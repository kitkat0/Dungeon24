#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AGRPRO

#include "Basic.hpp"

#include "AGRPRO_classes.hpp"
#include "AGRPRO_parameters.hpp"


namespace SDK
{

// Function AGRPRO.AGRAnimMasterComponent.AddTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::AddTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "AddTag");

	Params::AGRAnimMasterComponent_AddTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.AimTick
// (Final, Native, Public, BlueprintCallable)

void UAGRAnimMasterComponent::AimTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "AimTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ChangeAimOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAGR_AimOffsets                         InAimOffsetType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ChangeAimOffset(const EAGR_AimOffsets InAimOffsetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ChangeAimOffset");

	Params::AGRAnimMasterComponent_ChangeAimOffset Parms{};

	Parms.InAimOffsetType = InAimOffsetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ChangeRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAGR_RotationMethod                     InRotationMethod                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ChangeRotation(const EAGR_RotationMethod InRotationMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ChangeRotation");

	Params::AGRAnimMasterComponent_ChangeRotation Parms{};

	Parms.InRotationMethod = InRotationMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.NetMultiSetAimOffset
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FRotator                         InAimOffset                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::NetMultiSetAimOffset(const struct FRotator& InAimOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "NetMultiSetAimOffset");

	Params::AGRAnimMasterComponent_NetMultiSetAimOffset Parms{};

	Parms.InAimOffset = std::move(InAimOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.NetMultiSetLookAt
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                          LookAt                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::NetMultiSetLookAt(const struct FVector& LookAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "NetMultiSetLookAt");

	Params::AGRAnimMasterComponent_NetMultiSetLookAt Parms{};

	Parms.LookAt = std::move(LookAt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.OnRep_RotationMethod
// (Final, Native, Private)

void UAGRAnimMasterComponent::OnRep_RotationMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "OnRep_RotationMethod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.OnRep_RotationSpeed
// (Final, Native, Private)

void UAGRAnimMasterComponent::OnRep_RotationSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "OnRep_RotationSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.RemoveTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGRAnimMasterComponent::RemoveTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "RemoveTag");

	Params::AGRAnimMasterComponent_RemoveTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerChangeAimOffset
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EAGR_AimOffsets                         InAimOffsetType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerChangeAimOffset(const EAGR_AimOffsets InAimOffsetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerChangeAimOffset");

	Params::AGRAnimMasterComponent_ServerChangeAimOffset Parms{};

	Parms.InAimOffsetType = InAimOffsetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerChangeRotation
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EAGR_RotationMethod                     InRotationMethod                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerChangeRotation(const EAGR_RotationMethod InRotationMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerChangeRotation");

	Params::AGRAnimMasterComponent_ServerChangeRotation Parms{};

	Parms.InRotationMethod = InRotationMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerSetAimOffset
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// struct FRotator                         InAimOffset                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerSetAimOffset(const struct FRotator& InAimOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerSetAimOffset");

	Params::AGRAnimMasterComponent_ServerSetAimOffset Parms{};

	Parms.InAimOffset = std::move(InAimOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerSetBasePose
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FGameplayTag                     InBasePose                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerSetBasePose(const struct FGameplayTag& InBasePose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerSetBasePose");

	Params::AGRAnimMasterComponent_ServerSetBasePose Parms{};

	Parms.InBasePose = std::move(InBasePose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerSetLookAt
// (Final, Net, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// struct FVector                          LookAt                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerSetLookAt(const struct FVector& LookAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerSetLookAt");

	Params::AGRAnimMasterComponent_ServerSetLookAt Parms{};

	Parms.LookAt = std::move(LookAt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerSetOverlayPose
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FGameplayTag                     InOverlayPose                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerSetOverlayPose(const struct FGameplayTag& InOverlayPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerSetOverlayPose");

	Params::AGRAnimMasterComponent_ServerSetOverlayPose Parms{};

	Parms.InOverlayPose = std::move(InOverlayPose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerSetRotation
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EAGR_RotationMethod                     InRotationMethod                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRotationSpeed                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTurnStartAngle                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTurnStopTolerance                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerSetRotation(const EAGR_RotationMethod InRotationMethod, const float InRotationSpeed, const float InTurnStartAngle, const float InTurnStopTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerSetRotation");

	Params::AGRAnimMasterComponent_ServerSetRotation Parms{};

	Parms.InRotationMethod = InRotationMethod;
	Parms.InRotationSpeed = InRotationSpeed;
	Parms.InTurnStartAngle = InTurnStartAngle;
	Parms.InTurnStopTolerance = InTurnStopTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.ServerSetupAimOffset
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EAGR_AimOffsets                         InAimOffsetType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAGR_AimOffsetClamp                     InAimBehavior                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::ServerSetupAimOffset(const EAGR_AimOffsets InAimOffsetType, const EAGR_AimOffsetClamp InAimBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "ServerSetupAimOffset");

	Params::AGRAnimMasterComponent_ServerSetupAimOffset Parms{};

	Parms.InAimOffsetType = InAimOffsetType;
	Parms.InAimBehavior = InAimBehavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.SetupAimOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAGR_AimOffsets                         InAimOffsetType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAGR_AimOffsetClamp                     InAimBehavior                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAimClamp                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCameraBased                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InAimSocketName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InLookAtSocketName                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::SetupAimOffset(const EAGR_AimOffsets InAimOffsetType, const EAGR_AimOffsetClamp InAimBehavior, const float InAimClamp, const bool InCameraBased, const class FName InAimSocketName, const class FName InLookAtSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "SetupAimOffset");

	Params::AGRAnimMasterComponent_SetupAimOffset Parms{};

	Parms.InAimOffsetType = InAimOffsetType;
	Parms.InAimBehavior = InAimBehavior;
	Parms.InAimClamp = InAimClamp;
	Parms.InCameraBased = InCameraBased;
	Parms.InAimSocketName = InAimSocketName;
	Parms.InLookAtSocketName = InLookAtSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.SetupBasePose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InBasePose                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::SetupBasePose(const struct FGameplayTag& InBasePose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "SetupBasePose");

	Params::AGRAnimMasterComponent_SetupBasePose Parms{};

	Parms.InBasePose = std::move(InBasePose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.SetupFpp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInFirstPerson                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::SetupFpp(bool bInFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "SetupFpp");

	Params::AGRAnimMasterComponent_SetupFpp Parms{};

	Parms.bInFirstPerson = bInFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.SetupOverlayPose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InOverlayPose                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::SetupOverlayPose(const struct FGameplayTag& InOverlayPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "SetupOverlayPose");

	Params::AGRAnimMasterComponent_SetupOverlayPose Parms{};

	Parms.InOverlayPose = std::move(InOverlayPose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.SetupRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAGR_RotationMethod                     InRotationMethod                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRotationSpeed                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTurnStartAngle                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTurnStopTolerance                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::SetupRotation(const EAGR_RotationMethod InRotationMethod, const float InRotationSpeed, const float InTurnStartAngle, const float InTurnStopTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "SetupRotation");

	Params::AGRAnimMasterComponent_SetupRotation Parms{};

	Parms.InRotationMethod = InRotationMethod;
	Parms.InRotationSpeed = InRotationSpeed;
	Parms.InTurnStartAngle = InTurnStartAngle;
	Parms.InTurnStopTolerance = InTurnStopTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.TurnInPlaceTick
// (Final, Native, Public, BlueprintCallable)

void UAGRAnimMasterComponent::TurnInPlaceTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "TurnInPlaceTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.OnRep_BasePose
// (Final, Native, Private, Const)
// Parameters:
// struct FGameplayTag                     OldValue                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::OnRep_BasePose(const struct FGameplayTag& OldValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "OnRep_BasePose");

	Params::AGRAnimMasterComponent_OnRep_BasePose Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRAnimMasterComponent.OnRep_OverlayPose
// (Final, Native, Private, Const)
// Parameters:
// struct FGameplayTag                     OldValue                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGRAnimMasterComponent::OnRep_OverlayPose(const struct FGameplayTag& OldValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGRAnimMasterComponent", "OnRep_OverlayPose");

	Params::AGRAnimMasterComponent_OnRep_OverlayPose Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGRLibrary.K2_GetAnimationMaster
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAGRAnimMasterComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAGRAnimMasterComponent* UAGRLibrary::K2_GetAnimationMaster(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AGRLibrary", "K2_GetAnimationMaster");

	Params::AGRLibrary_K2_GetAnimationMaster Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGRLibrary.K2_GetCombatManager
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAGR_CombatManager*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAGR_CombatManager* UAGRLibrary::K2_GetCombatManager(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AGRLibrary", "K2_GetCombatManager");

	Params::AGRLibrary_K2_GetCombatManager Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGRLibrary.K2_GetEquipment
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAGR_EquipmentManager*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAGR_EquipmentManager* UAGRLibrary::K2_GetEquipment(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AGRLibrary", "K2_GetEquipment");

	Params::AGRLibrary_K2_GetEquipment Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGRLibrary.K2_GetInventory
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAGR_InventoryManager*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAGR_InventoryManager* UAGRLibrary::K2_GetInventory(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AGRLibrary", "K2_GetInventory");

	Params::AGRLibrary_K2_GetInventory Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGRLibrary.K2_GetItemComponent
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAGR_ItemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAGR_ItemComponent* UAGRLibrary::K2_GetItemComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AGRLibrary", "K2_GetItemComponent");

	Params::AGRLibrary_K2_GetItemComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGRLibrary.K2_GetSound
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAGR_SoundMaster*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAGR_SoundMaster* UAGRLibrary::K2_GetSound(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AGRLibrary", "K2_GetSound");

	Params::AGRLibrary_K2_GetSound Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_CombatManager.AddTraceMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InEnd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAGR_CombatColliderType                 CollisionHandling                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAGR_CombatManager::AddTraceMesh(class UPrimitiveComponent* Mesh, class FName InStart, class FName InEnd, const EAGR_CombatColliderType CollisionHandling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "AddTraceMesh");

	Params::AGR_CombatManager_AddTraceMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.InStart = InStart;
	Parms.InEnd = InEnd;
	Parms.CollisionHandling = CollisionHandling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_CombatManager.AddWeapopnTraceMesh
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InEnd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAGR_CombatColliderType                 CollisionHandling                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       StartOffset                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       EndOffset                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAGR_CombatManager::AddWeapopnTraceMesh(class UPrimitiveComponent* Mesh, class FName InStart, class FName InEnd, class FName AttachBoneName, const EAGR_CombatColliderType CollisionHandling, const struct FTransform& StartOffset, const struct FTransform& EndOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "AddWeapopnTraceMesh");

	Params::AGR_CombatManager_AddWeapopnTraceMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.InStart = InStart;
	Parms.InEnd = InEnd;
	Parms.AttachBoneName = AttachBoneName;
	Parms.CollisionHandling = CollisionHandling;
	Parms.StartOffset = std::move(StartOffset);
	Parms.EndOffset = std::move(EndOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_CombatManager.ClearAllMeshes
// (Final, Native, Public, BlueprintCallable)

void UAGR_CombatManager::ClearAllMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "ClearAllMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_CombatManager.EndTrace
// (Final, Native, Public, BlueprintCallable)

void UAGR_CombatManager::EndTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "EndTrace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_CombatManager.GetAllWeapons
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutWeapons                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAGR_CombatManager::GetAllWeapons(TArray<class AActor*>* OutWeapons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "GetAllWeapons");

	Params::AGR_CombatManager_GetAllWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeapons != nullptr)
		*OutWeapons = std::move(Parms.OutWeapons);
}


// Function AGRPRO.AGR_CombatManager.RefreshIgnoredActors
// (Final, Native, Public, BlueprintCallable)

void UAGR_CombatManager::RefreshIgnoredActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "RefreshIgnoredActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_CombatManager.RemoveTraceMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeyIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_CombatManager::RemoveTraceMesh(int32 KeyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "RemoveTraceMesh");

	Params::AGR_CombatManager_RemoveTraceMesh Parms{};

	Parms.KeyIndex = KeyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_CombatManager.SetupDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDebug                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_CombatManager::SetupDebug(const bool bInDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "SetupDebug");

	Params::AGR_CombatManager_SetupDebug Parms{};

	Parms.bInDebug = bInDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_CombatManager.StartTrace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InOnlyEffectiveStart                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InOnlyEffectiveEnd                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAGRAttackNotifyStateDataExtra   ExtraData                                              (Parm, NativeAccessSpecifierPublic)

void UAGR_CombatManager::StartTrace(const class UAnimSequenceBase* Animation, const class UAnimMontage* Montage, class FName InOnlyEffectiveStart, class FName InOnlyEffectiveEnd, float StartTime, const struct FAGRAttackNotifyStateDataExtra& ExtraData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_CombatManager", "StartTrace");

	Params::AGR_CombatManager_StartTrace Parms{};

	Parms.Animation = Animation;
	Parms.Montage = Montage;
	Parms.InOnlyEffectiveStart = InOnlyEffectiveStart;
	Parms.InOnlyEffectiveEnd = InOnlyEffectiveEnd;
	Parms.StartTime = StartTime;
	Parms.ExtraData = std::move(ExtraData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_EquipmentManager.EquipItemInSlot
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ItemActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OutPreviousItem                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OutNewItem                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_EquipmentManager::EquipItemInSlot(const class FName Slot, class AActor* ItemActor, class AActor** OutPreviousItem, class AActor** OutNewItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "EquipItemInSlot");

	Params::AGR_EquipmentManager_EquipItemInSlot Parms{};

	Parms.Slot = Slot;
	Parms.ItemActor = ItemActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPreviousItem != nullptr)
		*OutPreviousItem = Parms.OutPreviousItem;

	if (OutNewItem != nullptr)
		*OutNewItem = Parms.OutNewItem;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_EquipmentManager.GetAllItems
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutItems                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_EquipmentManager::GetAllItems(TArray<class AActor*>* OutItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "GetAllItems");

	Params::AGR_EquipmentManager_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItems != nullptr)
		*OutItems = std::move(Parms.OutItems);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_EquipmentManager.GetItemInSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OutItem                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_EquipmentManager::GetItemInSlot(const class FName Slot, class AActor** OutItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "GetItemInSlot");

	Params::AGR_EquipmentManager_GetItemInSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItem != nullptr)
		*OutItem = Parms.OutItem;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_EquipmentManager.GetShortcutReference
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_EquipmentManager::GetShortcutReference(const class FName Key, class AActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "GetShortcutReference");

	Params::AGR_EquipmentManager_GetShortcutReference Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_EquipmentManager.SaveShortcutReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_EquipmentManager::SaveShortcutReference(const class FName Key, class AActor* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "SaveShortcutReference");

	Params::AGR_EquipmentManager_SaveShortcutReference Parms{};

	Parms.Key = Key;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_EquipmentManager.SetupDefineSlots
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FEquipment>               InEquipmentList                                        (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAGR_EquipmentManager::SetupDefineSlots(const TArray<struct FEquipment>& InEquipmentList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "SetupDefineSlots");

	Params::AGR_EquipmentManager_SetupDefineSlots Parms{};

	Parms.InEquipmentList = std::move(InEquipmentList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_EquipmentManager.UnEquipByReference
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           ItemActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutNote                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_EquipmentManager::UnEquipByReference(class AActor* ItemActor, class FText* OutNote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "UnEquipByReference");

	Params::AGR_EquipmentManager_UnEquipByReference Parms{};

	Parms.ItemActor = ItemActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNote != nullptr)
		*OutNote = std::move(Parms.OutNote);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_EquipmentManager.UnEquipItemFromSlot
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OutItemUnequipped                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_EquipmentManager::UnEquipItemFromSlot(const class FName Slot, class AActor** OutItemUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_EquipmentManager", "UnEquipItemFromSlot");

	Params::AGR_EquipmentManager_UnEquipItemFromSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemUnequipped != nullptr)
		*OutItemUnequipped = Parms.OutItemUnequipped;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.AddItemsOfClass
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Param_Class                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutNote                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_InventoryManager::AddItemsOfClass(const TSubclassOf<class AActor> Param_Class, const int32 Quantity, class FText* OutNote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "AddItemsOfClass");

	Params::AGR_InventoryManager_AddItemsOfClass Parms{};

	Parms.Param_Class = Param_Class;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNote != nullptr)
		*OutNote = std::move(Parms.OutNote);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.AddItemToInventoryDirectly
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_InventoryManager::AddItemToInventoryDirectly(class AActor* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "AddItemToInventoryDirectly");

	Params::AGR_InventoryManager_AddItemToInventoryDirectly Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_InventoryManager.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UAGR_InventoryManager::GetAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "GetAllItems");

	Params::AGR_InventoryManager_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.GetAllItemsOfClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Param_Class                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutFilteredArray                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_InventoryManager::GetAllItemsOfClass(const TSubclassOf<class AActor> Param_Class, TArray<class AActor*>* OutFilteredArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "GetAllItemsOfClass");

	Params::AGR_InventoryManager_GetAllItemsOfClass Parms{};

	Parms.Param_Class = Param_Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFilteredArray != nullptr)
		*OutFilteredArray = std::move(Parms.OutFilteredArray);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.GetAllItemsOfTagSlotType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotTypeFilter                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutItemsWithTag                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_InventoryManager::GetAllItemsOfTagSlotType(const struct FGameplayTag& SlotTypeFilter, TArray<class AActor*>* OutItemsWithTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "GetAllItemsOfTagSlotType");

	Params::AGR_InventoryManager_GetAllItemsOfTagSlotType Parms{};

	Parms.SlotTypeFilter = std::move(SlotTypeFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemsWithTag != nullptr)
		*OutItemsWithTag = std::move(Parms.OutItemsWithTag);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.HasEnoughItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutNote                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_InventoryManager::HasEnoughItems(const TSubclassOf<class AActor> Item, const int32 Quantity, class FText* OutNote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "HasEnoughItems");

	Params::AGR_InventoryManager_HasEnoughItems Parms{};

	Parms.Item = Item;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNote != nullptr)
		*OutNote = std::move(Parms.OutNote);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.HasExactItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_InventoryManager::HasExactItem(class AActor* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "HasExactItem");

	Params::AGR_InventoryManager_HasExactItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_InventoryManager.OverwriteId
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            InInventoryId                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_InventoryManager::OverwriteId(const struct FGuid& InInventoryId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "OverwriteId");

	Params::AGR_InventoryManager_OverwriteId Parms{};

	Parms.InInventoryId = std::move(InInventoryId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_InventoryManager.RemoveItemsOfClass
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Param_Class                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutNote                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_InventoryManager::RemoveItemsOfClass(const TSubclassOf<class AActor> Param_Class, const int32 Quantity, class FText* OutNote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_InventoryManager", "RemoveItemsOfClass");

	Params::AGR_InventoryManager_RemoveItemsOfClass Parms{};

	Parms.Param_Class = Param_Class;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNote != nullptr)
		*OutNote = std::move(Parms.OutNote);

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_ItemComponent.DestroyItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UAGR_ItemComponent::DestroyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_ItemComponent", "DestroyItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_ItemComponent.DropItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UAGR_ItemComponent::DropItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_ItemComponent", "DropItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_ItemComponent.PickUpItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UAGR_InventoryManager*            InventoryPicking                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_ItemComponent::PickUpItem(class UAGR_InventoryManager* InventoryPicking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_ItemComponent", "PickUpItem");

	Params::AGR_ItemComponent_PickUpItem Parms{};

	Parms.InventoryPicking = InventoryPicking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_ItemComponent.SplitItems
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SplitSize                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_ItemComponent::SplitItems(const int32 SplitSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_ItemComponent", "SplitItems");

	Params::AGR_ItemComponent_SplitItems Parms{};

	Parms.SplitSize = SplitSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_ItemComponent.UseItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_ItemComponent::UseItem(class AActor* User, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_ItemComponent", "UseItem");

	Params::AGR_ItemComponent_UseItem Parms{};

	Parms.User = User;
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_SoundMaster.FootstepEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAudioComponent*                  Sound                                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   Particle                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_SoundMaster::FootstepEffect(const struct FHitResult& Hit, class UAudioComponent** Sound, class UNiagaraSystem** Particle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_SoundMaster", "FootstepEffect");

	Params::AGR_SoundMaster_FootstepEffect Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Sound != nullptr)
		*Sound = Parms.Sound;

	if (Particle != nullptr)
		*Particle = Parms.Particle;
}


// Function AGRPRO.AGR_SoundMaster.OverwritePickSurface
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPhysicalSurface                        InSurface                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        OutSurface                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAGR_SoundMaster::OverwritePickSurface(const EPhysicalSurface& InSurface, EPhysicalSurface* OutSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_SoundMaster", "OverwritePickSurface");

	Params::AGR_SoundMaster_OverwritePickSurface Parms{};

	Parms.InSurface = InSurface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSurface != nullptr)
		*OutSurface = Parms.OutSurface;
}


// Function AGRPRO.AGR_SoundMaster.TestAllFeetForCollision
// (Final, Native, Public, BlueprintCallable)

void UAGR_SoundMaster::TestAllFeetForCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_SoundMaster", "TestAllFeetForCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AGRPRO.AGR_SoundMaster.TryTraceFootstep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAGR_SoundMaster::TryTraceFootstep(const class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_SoundMaster", "TryTraceFootstep");

	Params::AGR_SoundMaster_TryTraceFootstep Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_SoundMaster.OverwriteCalcVolume
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAGR_SoundMaster::OverwriteCalcVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_SoundMaster", "OverwriteCalcVolume");

	Params::AGR_SoundMaster_OverwriteCalcVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.AGR_SoundMaster.OverwriteParticleScale
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAGR_SoundMaster::OverwriteParticleScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AGR_SoundMaster", "OverwriteParticleScale");

	Params::AGR_SoundMaster_OverwriteParticleScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AGRPRO.DA_AGR_FootstepConfig.GetSurfaceReaction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        InputParam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundCue*                        Sound                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   Particle                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDA_AGR_FootstepConfig::GetSurfaceReaction(EPhysicalSurface InputParam, class USoundCue** Sound, class UNiagaraSystem** Particle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DA_AGR_FootstepConfig", "GetSurfaceReaction");

	Params::DA_AGR_FootstepConfig_GetSurfaceReaction Parms{};

	Parms.InputParam = InputParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Sound != nullptr)
		*Sound = Parms.Sound;

	if (Particle != nullptr)
		*Particle = Parms.Particle;
}


// Function AGRPRO.DA_AGR_FootstepConfig.GetFootStepSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundAttenuation*                AttenuationRef                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencyRef                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDA_AGR_FootstepConfig::GetFootStepSettings(class USoundAttenuation** AttenuationRef, class USoundConcurrency** ConcurrencyRef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DA_AGR_FootstepConfig", "GetFootStepSettings");

	Params::DA_AGR_FootstepConfig_GetFootStepSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AttenuationRef != nullptr)
		*AttenuationRef = Parms.AttenuationRef;

	if (ConcurrencyRef != nullptr)
		*ConcurrencyRef = Parms.ConcurrencyRef;
}


// Function AGRPRO.DA_AGR_FootstepConfig.GetVelocityRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MinRange                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDA_AGR_FootstepConfig::GetVelocityRange(float* MinRange, float* MaxRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DA_AGR_FootstepConfig", "GetVelocityRange");

	Params::DA_AGR_FootstepConfig_GetVelocityRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MinRange != nullptr)
		*MinRange = Parms.MinRange;

	if (MaxRange != nullptr)
		*MaxRange = Parms.MaxRange;
}

}

