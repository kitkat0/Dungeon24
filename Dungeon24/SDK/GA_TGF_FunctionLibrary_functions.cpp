#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_TGF_FunctionLibrary

#include "Basic.hpp"

#include "GA_TGF_FunctionLibrary_classes.hpp"
#include "GA_TGF_FunctionLibrary_parameters.hpp"


namespace SDK
{

// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.CalculateOffsetAccordingToActor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Up                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Right                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BaseLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         BaseRot                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::CalculateOffsetAccordingToActor(double Forward, double Up, double Right, const struct FVector& BaseLocation, const struct FRotator& BaseRot, class UObject* __WorldContext, struct FVector* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "CalculateOffsetAccordingToActor");

	Params::GA_TGF_FunctionLibrary_C_CalculateOffsetAccordingToActor Parms{};

	Parms.Forward = Forward;
	Parms.Up = Up;
	Parms.Right = Right;
	Parms.BaseLocation = std::move(BaseLocation);
	Parms.BaseRot = std::move(BaseRot);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.CanBeTarget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::CanBeTarget(class AActor* InputActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "CanBeTarget");

	Params::GA_TGF_FunctionLibrary_C_CanBeTarget Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.CheckAbilityAdditionalCostValid
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<ETgfEquipSlot>                   CanUseAdditionalList                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IgnoreCheck                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ALyraCharacter*                   InActor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<ETgfEquipSlot>                   AllAdditionalList                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UTgfEquipmentManagerComponent*    EquipmentComponent                                     (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CostValid                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::CheckAbilityAdditionalCostValid(TArray<ETgfEquipSlot>& CanUseAdditionalList, bool IgnoreCheck, class ALyraCharacter* InActor, TArray<ETgfEquipSlot>& AllAdditionalList, class UObject* __WorldContext, class UTgfEquipmentManagerComponent** EquipmentComponent, bool* CostValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "CheckAbilityAdditionalCostValid");

	Params::GA_TGF_FunctionLibrary_C_CheckAbilityAdditionalCostValid Parms{};

	Parms.CanUseAdditionalList = std::move(CanUseAdditionalList);
	Parms.IgnoreCheck = IgnoreCheck;
	Parms.InActor = InActor;
	Parms.AllAdditionalList = std::move(AllAdditionalList);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	CanUseAdditionalList = std::move(Parms.CanUseAdditionalList);
	AllAdditionalList = std::move(Parms.AllAdditionalList);

	if (EquipmentComponent != nullptr)
		*EquipmentComponent = Parms.EquipmentComponent;

	if (CostValid != nullptr)
		*CostValid = Parms.CostValid;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.CheckCharacterStateValid
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            MustHaveTags                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FGameplayTagContainer            MustNotHaveTags                                        (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    DontCareCharacterState                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            RelevantTags                                           (Parm, OutParm)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::CheckCharacterStateValid(class ALyraCharacter* InputActor, const struct FGameplayTagContainer& MustHaveTags, const struct FGameplayTagContainer& MustNotHaveTags, bool DontCareCharacterState, class UObject* __WorldContext, struct FGameplayTagContainer* RelevantTags, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "CheckCharacterStateValid");

	Params::GA_TGF_FunctionLibrary_C_CheckCharacterStateValid Parms{};

	Parms.InputActor = InputActor;
	Parms.MustHaveTags = std::move(MustHaveTags);
	Parms.MustNotHaveTags = std::move(MustNotHaveTags);
	Parms.DontCareCharacterState = DontCareCharacterState;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (RelevantTags != nullptr)
		*RelevantTags = std::move(Parms.RelevantTags);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.CheckCrouch
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::CheckCrouch(class ALyraCharacter* InputActor, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "CheckCrouch");

	Params::GA_TGF_FunctionLibrary_C_CheckCrouch Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.Get Adjust Collision Spawn Pos
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          OriginalPos                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ALyraCharacter*                   Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  AdjustDelta                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          AdjustPos                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::Get_Adjust_Collision_Spawn_Pos(const struct FVector& OriginalPos, class ALyraCharacter* Instigator, double AdjustDelta, class UObject* __WorldContext, struct FVector* AdjustPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "Get Adjust Collision Spawn Pos");

	Params::GA_TGF_FunctionLibrary_C_Get_Adjust_Collision_Spawn_Pos Parms{};

	Parms.OriginalPos = std::move(OriginalPos);
	Parms.Instigator = Instigator;
	Parms.AdjustDelta = AdjustDelta;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AdjustPos != nullptr)
		*AdjustPos = std::move(Parms.AdjustPos);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.Get Spawn Projectile Rot
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          SpawnPos                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  LookDistance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  MinDistance                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShouldIgnoreWeapon                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_TGF_FunctionLibrary_C::Get_Spawn_Projectile_Rot(const struct FVector& SpawnPos, double LookDistance, class AActor* Instigator, double MinDistance, bool ShouldIgnoreWeapon, class UObject* __WorldContext, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "Get Spawn Projectile Rot");

	Params::GA_TGF_FunctionLibrary_C_Get_Spawn_Projectile_Rot Parms{};

	Parms.SpawnPos = std::move(SpawnPos);
	Parms.LookDistance = LookDistance;
	Parms.Instigator = Instigator;
	Parms.MinDistance = MinDistance;
	Parms.ShouldIgnoreWeapon = ShouldIgnoreWeapon;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.GetChargeSkillMethodFromComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraPlayerController*            InputController                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::GetChargeSkillMethodFromComponent(class ALyraPlayerController* InputController, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "GetChargeSkillMethodFromComponent");

	Params::GA_TGF_FunctionLibrary_C_GetChargeSkillMethodFromComponent Parms{};

	Parms.InputController = InputController;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.GetExplodeHitActors
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGameplayAbility*                 GameplayAbility                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bCheckExplodeBlock                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ExplodeCenter                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ExplodeRadius                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>                TraceType                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// ETraceTypeQuery                         TraceBlockChannel                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   Targets                                                (Parm, OutParm)

void UGA_TGF_FunctionLibrary_C::GetExplodeHitActors(class UGameplayAbility* GameplayAbility, bool bCheckExplodeBlock, const struct FVector& ExplodeCenter, double ExplodeRadius, TArray<EObjectTypeQuery>& TraceType, ETraceTypeQuery TraceBlockChannel, class UObject* __WorldContext, TArray<class AActor*>* Targets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "GetExplodeHitActors");

	Params::GA_TGF_FunctionLibrary_C_GetExplodeHitActors Parms{};

	Parms.GameplayAbility = GameplayAbility;
	Parms.bCheckExplodeBlock = bCheckExplodeBlock;
	Parms.ExplodeCenter = std::move(ExplodeCenter);
	Parms.ExplodeRadius = ExplodeRadius;
	Parms.TraceType = std::move(TraceType);
	Parms.TraceBlockChannel = TraceBlockChannel;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	TraceType = std::move(Parms.TraceType);

	if (Targets != nullptr)
		*Targets = std::move(Parms.Targets);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.GetMouseTargetingMethodFromComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraPlayerController*            InputController                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::GetMouseTargetingMethodFromComponent(class ALyraPlayerController* InputController, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "GetMouseTargetingMethodFromComponent");

	Params::GA_TGF_FunctionLibrary_C_GetMouseTargetingMethodFromComponent Parms{};

	Parms.InputController = InputController;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsActorInWaitingRoom
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsActorInWaitingRoom(class AActor* InputActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsActorInWaitingRoom");

	Params::GA_TGF_FunctionLibrary_C_IsActorInWaitingRoom Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsHitInteractorBattle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           CheckActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsHitInteractorBattle(class AActor* CheckActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsHitInteractorBattle");

	Params::GA_TGF_FunctionLibrary_C_IsHitInteractorBattle Parms{};

	Parms.CheckActor = CheckActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsHitInteractorEnvironment
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsHitInteractorEnvironment(const struct FHitResult& HitResult, class AActor* HitActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsHitInteractorEnvironment");

	Params::GA_TGF_FunctionLibrary_C_IsHitInteractorEnvironment Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.HitActor = HitActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsHomelandMatchType
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsHomelandMatchType(class AActor* InputActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsHomelandMatchType");

	Params::GA_TGF_FunctionLibrary_C_IsHomelandMatchType Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsInADS
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   InActor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsInADS(class ALyraCharacter* InActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsInADS");

	Params::GA_TGF_FunctionLibrary_C_IsInADS Parms{};

	Parms.InActor = InActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsPlayersSummon
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsPlayersSummon(class AActor* InputActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsPlayersSummon");

	Params::GA_TGF_FunctionLibrary_C_IsPlayersSummon Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.IsReboundEnvironment
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::IsReboundEnvironment(const struct FHitResult& HitResult, class AActor* HitActor, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "IsReboundEnvironment");

	Params::GA_TGF_FunctionLibrary_C_IsReboundEnvironment Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.HitActor = HitActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.MonsterAddThreat
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Monster                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ThreatTarget                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Threat                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::MonsterAddThreat(class AActor* Monster, class AActor* ThreatTarget, double Threat, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "MonsterAddThreat");

	Params::GA_TGF_FunctionLibrary_C_MonsterAddThreat Parms{};

	Parms.Monster = Monster;
	Parms.ThreatTarget = ThreatTarget;
	Parms.Threat = Threat;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.MonsterGetCurrentTarget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ResultActor                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::MonsterGetCurrentTarget(class ALyraCharacter* InputActor, class UObject* __WorldContext, class AActor** ResultActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "MonsterGetCurrentTarget");

	Params::GA_TGF_FunctionLibrary_C_MonsterGetCurrentTarget Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ResultActor != nullptr)
		*ResultActor = Parms.ResultActor;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.PrintDSMeshTick
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::PrintDSMeshTick(class ALyraCharacter* InputActor, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "PrintDSMeshTick");

	Params::GA_TGF_FunctionLibrary_C_PrintDSMeshTick Parms{};

	Parms.InputActor = InputActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.RemoveEquipBySlotWithCheck
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTgfEquipmentManagerComponent*    EquipComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// ETgfEquipSlot                           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::RemoveEquipBySlotWithCheck(class UTgfEquipmentManagerComponent* EquipComponent, ETgfEquipSlot Slot, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "RemoveEquipBySlotWithCheck");

	Params::GA_TGF_FunctionLibrary_C_RemoveEquipBySlotWithCheck Parms{};

	Parms.EquipComponent = EquipComponent;
	Parms.Slot = Slot;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.ResetAllAbilityInput
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraPlayerController*            LyraCtrl                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::ResetAllAbilityInput(class ALyraPlayerController* LyraCtrl, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "ResetAllAbilityInput");

	Params::GA_TGF_FunctionLibrary_C_ResetAllAbilityInput Parms{};

	Parms.LyraCtrl = LyraCtrl;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.SearchTarget
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   SrcActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  WithInAngle                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  SearchRadius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BoxHalfSize                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ResultActors                                           (Parm, OutParm)

void UGA_TGF_FunctionLibrary_C::SearchTarget(class ALyraCharacter* SrcActor, double WithInAngle, double SearchRadius, const struct FVector& BoxHalfSize, class UObject* __WorldContext, TArray<class AActor*>* ResultActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "SearchTarget");

	Params::GA_TGF_FunctionLibrary_C_SearchTarget Parms{};

	Parms.SrcActor = SrcActor;
	Parms.WithInAngle = WithInAngle;
	Parms.SearchRadius = SearchRadius;
	Parms.BoxHalfSize = std::move(BoxHalfSize);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ResultActors != nullptr)
		*ResultActors = std::move(Parms.ResultActors);
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.VerifyServerSpanwProjectilePos
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          CurViewPos                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxVerticalOffset                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxHorizontalOffset                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ALyraCharacter*                   Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bValid                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_FunctionLibrary_C::VerifyServerSpanwProjectilePos(const struct FVector& CurViewPos, double MaxVerticalOffset, double MaxHorizontalOffset, class ALyraCharacter* Target, class UObject* __WorldContext, bool* bValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GA_TGF_FunctionLibrary_C", "VerifyServerSpanwProjectilePos");

	Params::GA_TGF_FunctionLibrary_C_VerifyServerSpanwProjectilePos Parms{};

	Parms.CurViewPos = std::move(CurViewPos);
	Parms.MaxVerticalOffset = MaxVerticalOffset;
	Parms.MaxHorizontalOffset = MaxHorizontalOffset;
	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bValid != nullptr)
		*bValid = Parms.bValid;
}


// Function GA_TGF_FunctionLibrary.GA_TGF_FunctionLibrary_C.GetRandomGEWithHandler
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Targets                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     BuffTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            HighPriorityTags                                       (BlueprintVisible, BlueprintReadOnly, Parm)
// int32                                   Num                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bSucceed                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FTgfGameplayEffectHandleData>Res                                                    (Parm, OutParm, ContainsInstancedReference)

void UGA_TGF_FunctionLibrary_C::GetRandomGEWithHandler(TArray<class AActor*>& Targets, const struct FGameplayTag& BuffTag, const struct FGameplayTagContainer& HighPriorityTags, int32 Num, class UObject* __WorldContext, bool* bSucceed, TArray<struct FTgfGameplayEffectHandleData>* Res)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_FunctionLibrary_C", "GetRandomGEWithHandler");

	Params::GA_TGF_FunctionLibrary_C_GetRandomGEWithHandler Parms{};

	Parms.Targets = std::move(Targets);
	Parms.BuffTag = std::move(BuffTag);
	Parms.HighPriorityTags = std::move(HighPriorityTags);
	Parms.Num = Num;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	Targets = std::move(Parms.Targets);

	if (bSucceed != nullptr)
		*bSucceed = Parms.bSucceed;

	if (Res != nullptr)
		*Res = std::move(Parms.Res);
}

}

