#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_CollectableBase

#include "Basic.hpp"

#include "BP_CollectableBase_classes.hpp"
#include "BP_CollectableBase_parameters.hpp"


namespace SDK
{

// Function BP_CollectableBase.BP_CollectableBase_C.AddBeam
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::AddBeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "AddBeam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.AddMapHint
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::AddMapHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "AddMapHint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.BndEvt__BP_CollectableBase_ObjectNode_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_CollectableBase_C::BndEvt__BP_CollectableBase_ObjectNode_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "BndEvt__BP_CollectableBase_ObjectNode_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature");

	Params::BP_CollectableBase_C_BndEvt__BP_CollectableBase_ObjectNode_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.ConstructionScriptImp
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::ConstructionScriptImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "ConstructionScriptImp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.DestroyCollectableItem
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::DestroyCollectableItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "DestroyCollectableItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.DoLaunch
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::DoLaunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "DoLaunch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.ExecuteUbergraph_BP_CollectableBase
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::ExecuteUbergraph_BP_CollectableBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "ExecuteUbergraph_BP_CollectableBase");

	Params::BP_CollectableBase_C_ExecuteUbergraph_BP_CollectableBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.Get Item Id
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ItemId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::Get_Item_Id(int32* ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "Get Item Id");

	Params::BP_CollectableBase_C_Get_Item_Id Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemId != nullptr)
		*ItemId = Parms.ItemId;
}


// Function BP_CollectableBase.BP_CollectableBase_C.GetInteractionPromptText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerController*                Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             Key                                                    (Parm, OutParm)
// class FText                             Out_Text_Line_1                                        (Parm, OutParm)
// class FText                             Out_Text_Line_2                                        (Parm, OutParm)

void ABP_CollectableBase_C::GetInteractionPromptText(class APlayerController* Param_Instigator, class FText* Key, class FText* Out_Text_Line_1, class FText* Out_Text_Line_2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "GetInteractionPromptText");

	Params::BP_CollectableBase_C_GetInteractionPromptText Parms{};

	Parms.Param_Instigator = Param_Instigator;

	UObject::ProcessEvent(Func, &Parms);

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (Out_Text_Line_1 != nullptr)
		*Out_Text_Line_1 = std::move(Parms.Out_Text_Line_1);

	if (Out_Text_Line_2 != nullptr)
		*Out_Text_Line_2 = std::move(Parms.Out_Text_Line_2);
}


// Function BP_CollectableBase.BP_CollectableBase_C.IsPvpMatchType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    PVPMatchType                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::IsPvpMatchType(bool* PVPMatchType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "IsPvpMatchType");

	Params::BP_CollectableBase_C_IsPvpMatchType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PVPMatchType != nullptr)
		*PVPMatchType = Parms.PVPMatchType;
}


// Function BP_CollectableBase.BP_CollectableBase_C.LaunchCollectable
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_Impulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RotForce                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnableLight                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::LaunchCollectable(const struct FVector& Param_Impulse, double RotForce, bool EnableLight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "LaunchCollectable");

	Params::BP_CollectableBase_C_LaunchCollectable Parms{};

	Parms.Param_Impulse = std::move(Param_Impulse);
	Parms.RotForce = RotForce;
	Parms.EnableLight = EnableLight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.OnPickUpFail
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::OnPickUpFail(class APawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "OnPickUpFail");

	Params::BP_CollectableBase_C_OnPickUpFail Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.OnProjectileStop
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_CollectableBase_C::OnProjectileStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "OnProjectileStop");

	Params::BP_CollectableBase_C_OnProjectileStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.OnRep_FinalTransform
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::OnRep_FinalTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "OnRep_FinalTransform");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.Perform Interaction
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bSuccess                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::Perform_Interaction(class APawn* InteractingPawn, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "Perform Interaction");

	Params::BP_CollectableBase_C_Perform_Interaction Parms{};

	Parms.InteractingPawn = InteractingPawn;
	Parms.bSuccess = bSuccess;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.PerformInteraction on Server
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::PerformInteraction_on_Server(class APawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "PerformInteraction on Server");

	Params::BP_CollectableBase_C_PerformInteraction_on_Server Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.PlayProjectile
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::PlayProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "PlayProjectile");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_CollectableBase_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.RefreshScale
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NewScale                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::RefreshScale(const struct FVector& NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "RefreshScale");

	Params::BP_CollectableBase_C_RefreshScale Parms{};

	Parms.NewScale = std::move(NewScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.RemoveMapHint
// (BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::RemoveMapHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "RemoveMapHint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.Rotation__FinishedFunc
// (BlueprintEvent)

void ABP_CollectableBase_C::Rotation__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "Rotation__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.Rotation__UpdateFunc
// (BlueprintEvent)

void ABP_CollectableBase_C::Rotation__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "Rotation__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CollectableBase.BP_CollectableBase_C.SetCollectableObject
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      ObjectMesh                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UClass*                           InventoryItemDefinition                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::SetCollectableObject(class UStaticMesh* ObjectMesh, class UClass* InventoryItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "SetCollectableObject");

	Params::BP_CollectableBase_C_SetCollectableObject Parms{};

	Parms.ObjectMesh = ObjectMesh;
	Parms.InventoryItemDefinition = InventoryItemDefinition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.SetHighlightingRecursively
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Highlighting                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_CollectableBase_C::SetHighlightingRecursively(class AActor* Actor, bool Highlighting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "SetHighlightingRecursively");

	Params::BP_CollectableBase_C_SetHighlightingRecursively Parms{};

	Parms.Actor = Actor;
	Parms.Highlighting = Highlighting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CollectableBase.BP_CollectableBase_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_CollectableBase_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CollectableBase_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}

}

