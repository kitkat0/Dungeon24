#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GothicPack

#include "Basic.hpp"

#include "GothicPack_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class GothicPack.GothicPackBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UGothicPackBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GothicPackSampleFunction(float Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GothicPackBPLibrary">();
	}
	static class UGothicPackBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGothicPackBPLibrary>();
	}
};
static_assert(alignof(UGothicPackBPLibrary) == 0x000008, "Wrong alignment on UGothicPackBPLibrary");
static_assert(sizeof(UGothicPackBPLibrary) == 0x000028, "Wrong size on UGothicPackBPLibrary");

// Class GothicPack.ProceduralSpline
// 0x0060 (0x02F8 - 0x0298)
class AProceduralSpline : public AActor
{
public:
	class USplineComponent*                       MainSpline;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SceneRootComponent;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentLength;                                     // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectionLength;                                     // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplineEndPointDistance;                            // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplineBeginOffset;                                 // 0x02B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplineEndOffset;                                   // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SectionCountMax;                                   // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionEnabled                             CollisionEnable;                                   // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionType;                                     // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scaler;                                            // 0x02C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetBeforeAttachMesh;                            // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USplineMeshComponent*>           MeshComponents;                                    // 0x02E8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void PostConstruction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralSpline">();
	}
	static class AProceduralSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralSpline>();
	}
};
static_assert(alignof(AProceduralSpline) == 0x000008, "Wrong alignment on AProceduralSpline");
static_assert(sizeof(AProceduralSpline) == 0x0002F8, "Wrong size on AProceduralSpline");
static_assert(offsetof(AProceduralSpline, MainSpline) == 0x000298, "Member 'AProceduralSpline::MainSpline' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SceneRootComponent) == 0x0002A0, "Member 'AProceduralSpline::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SegmentLength) == 0x0002A8, "Member 'AProceduralSpline::SegmentLength' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SectionLength) == 0x0002AC, "Member 'AProceduralSpline::SectionLength' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SplineEndPointDistance) == 0x0002B0, "Member 'AProceduralSpline::SplineEndPointDistance' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SplineBeginOffset) == 0x0002B4, "Member 'AProceduralSpline::SplineBeginOffset' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SplineEndOffset) == 0x0002B8, "Member 'AProceduralSpline::SplineEndOffset' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, SectionCountMax) == 0x0002BC, "Member 'AProceduralSpline::SectionCountMax' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, CollisionEnable) == 0x0002C0, "Member 'AProceduralSpline::CollisionEnable' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, CollisionType) == 0x0002C1, "Member 'AProceduralSpline::CollisionType' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, Scaler) == 0x0002C8, "Member 'AProceduralSpline::Scaler' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, OffsetBeforeAttachMesh) == 0x0002E0, "Member 'AProceduralSpline::OffsetBeforeAttachMesh' has a wrong offset!");
static_assert(offsetof(AProceduralSpline, MeshComponents) == 0x0002E8, "Member 'AProceduralSpline::MeshComponents' has a wrong offset!");

// Class GothicPack.Railing
// 0x0098 (0x0390 - 0x02F8)
class ARailing final : public AProceduralSpline
{
public:
	class UStaticMesh*                            Selected_Newel;                                    // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Selected_Baluster;                                 // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Selected_Prop_StartAndEnd;                         // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Selected_Prop_Middle;                              // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NewelMaxScale;                                     // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRailingVariationParent>        PropVariation;                                     // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRailingVariationParent>        BalusterSectionVariation;                          // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRailingVariationParent>        NewelVariation;                                    // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         BalusterTopSelection;                              // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BalusterMiddleSelection;                           // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewelSelection;                                    // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddStartNewel;                                    // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartNewelScale;                                   // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddEndNewel;                                      // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EndNewelScale;                                     // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddProp;                                          // 0x036C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PropSelection;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropScale;                                         // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddMidNewel;                                      // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MiddleNewelGap;                                    // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMiddleNewel_AddProp;                              // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MiddleNewel_PropSelection;                         // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleNewel_PropGap;                               // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleNewel_PropScale;                             // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Railing">();
	}
	static class ARailing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARailing>();
	}
};
static_assert(alignof(ARailing) == 0x000008, "Wrong alignment on ARailing");
static_assert(sizeof(ARailing) == 0x000390, "Wrong size on ARailing");
static_assert(offsetof(ARailing, Selected_Newel) == 0x0002F8, "Member 'ARailing::Selected_Newel' has a wrong offset!");
static_assert(offsetof(ARailing, Selected_Baluster) == 0x000300, "Member 'ARailing::Selected_Baluster' has a wrong offset!");
static_assert(offsetof(ARailing, Selected_Prop_StartAndEnd) == 0x000308, "Member 'ARailing::Selected_Prop_StartAndEnd' has a wrong offset!");
static_assert(offsetof(ARailing, Selected_Prop_Middle) == 0x000310, "Member 'ARailing::Selected_Prop_Middle' has a wrong offset!");
static_assert(offsetof(ARailing, NewelMaxScale) == 0x000318, "Member 'ARailing::NewelMaxScale' has a wrong offset!");
static_assert(offsetof(ARailing, PropVariation) == 0x000320, "Member 'ARailing::PropVariation' has a wrong offset!");
static_assert(offsetof(ARailing, BalusterSectionVariation) == 0x000330, "Member 'ARailing::BalusterSectionVariation' has a wrong offset!");
static_assert(offsetof(ARailing, NewelVariation) == 0x000340, "Member 'ARailing::NewelVariation' has a wrong offset!");
static_assert(offsetof(ARailing, BalusterTopSelection) == 0x000350, "Member 'ARailing::BalusterTopSelection' has a wrong offset!");
static_assert(offsetof(ARailing, BalusterMiddleSelection) == 0x000354, "Member 'ARailing::BalusterMiddleSelection' has a wrong offset!");
static_assert(offsetof(ARailing, NewelSelection) == 0x000358, "Member 'ARailing::NewelSelection' has a wrong offset!");
static_assert(offsetof(ARailing, bAddStartNewel) == 0x00035C, "Member 'ARailing::bAddStartNewel' has a wrong offset!");
static_assert(offsetof(ARailing, StartNewelScale) == 0x000360, "Member 'ARailing::StartNewelScale' has a wrong offset!");
static_assert(offsetof(ARailing, bAddEndNewel) == 0x000364, "Member 'ARailing::bAddEndNewel' has a wrong offset!");
static_assert(offsetof(ARailing, EndNewelScale) == 0x000368, "Member 'ARailing::EndNewelScale' has a wrong offset!");
static_assert(offsetof(ARailing, bAddProp) == 0x00036C, "Member 'ARailing::bAddProp' has a wrong offset!");
static_assert(offsetof(ARailing, PropSelection) == 0x000370, "Member 'ARailing::PropSelection' has a wrong offset!");
static_assert(offsetof(ARailing, PropScale) == 0x000374, "Member 'ARailing::PropScale' has a wrong offset!");
static_assert(offsetof(ARailing, bAddMidNewel) == 0x000378, "Member 'ARailing::bAddMidNewel' has a wrong offset!");
static_assert(offsetof(ARailing, MiddleNewelGap) == 0x00037C, "Member 'ARailing::MiddleNewelGap' has a wrong offset!");
static_assert(offsetof(ARailing, bMiddleNewel_AddProp) == 0x000380, "Member 'ARailing::bMiddleNewel_AddProp' has a wrong offset!");
static_assert(offsetof(ARailing, MiddleNewel_PropSelection) == 0x000384, "Member 'ARailing::MiddleNewel_PropSelection' has a wrong offset!");
static_assert(offsetof(ARailing, MiddleNewel_PropGap) == 0x000388, "Member 'ARailing::MiddleNewel_PropGap' has a wrong offset!");
static_assert(offsetof(ARailing, MiddleNewel_PropScale) == 0x00038C, "Member 'ARailing::MiddleNewel_PropScale' has a wrong offset!");

// Class GothicPack.Sidewalk
// 0x0050 (0x0348 - 0x02F8)
class ASidewalk final : public AProceduralSpline
{
public:
	TArray<struct FSidewalkVariationParent>       SidewalkVariation_Wide;                            // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSidewalkVariationParent>       SidewalkVariation_Narrow;                          // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SidewalkTypeSelection;                             // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    Selected_MiddleSidewalk;                           // 0x0320(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Selected_StartSidewalk;                            // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Selected_EndSidewalk;                              // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SidewalkMiddlePartMaxCount;                        // 0x0340(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESidewalkSize                                 SidewalkSizeSelection;                             // 0x0344(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddStartSection;                                  // 0x0345(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddEndSection;                                    // 0x0346(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_347[0x1];                                      // 0x0347(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Sidewalk">();
	}
	static class ASidewalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASidewalk>();
	}
};
static_assert(alignof(ASidewalk) == 0x000008, "Wrong alignment on ASidewalk");
static_assert(sizeof(ASidewalk) == 0x000348, "Wrong size on ASidewalk");
static_assert(offsetof(ASidewalk, SidewalkVariation_Wide) == 0x0002F8, "Member 'ASidewalk::SidewalkVariation_Wide' has a wrong offset!");
static_assert(offsetof(ASidewalk, SidewalkVariation_Narrow) == 0x000308, "Member 'ASidewalk::SidewalkVariation_Narrow' has a wrong offset!");
static_assert(offsetof(ASidewalk, SidewalkTypeSelection) == 0x000318, "Member 'ASidewalk::SidewalkTypeSelection' has a wrong offset!");
static_assert(offsetof(ASidewalk, Selected_MiddleSidewalk) == 0x000320, "Member 'ASidewalk::Selected_MiddleSidewalk' has a wrong offset!");
static_assert(offsetof(ASidewalk, Selected_StartSidewalk) == 0x000330, "Member 'ASidewalk::Selected_StartSidewalk' has a wrong offset!");
static_assert(offsetof(ASidewalk, Selected_EndSidewalk) == 0x000338, "Member 'ASidewalk::Selected_EndSidewalk' has a wrong offset!");
static_assert(offsetof(ASidewalk, SidewalkMiddlePartMaxCount) == 0x000340, "Member 'ASidewalk::SidewalkMiddlePartMaxCount' has a wrong offset!");
static_assert(offsetof(ASidewalk, SidewalkSizeSelection) == 0x000344, "Member 'ASidewalk::SidewalkSizeSelection' has a wrong offset!");
static_assert(offsetof(ASidewalk, bAddStartSection) == 0x000345, "Member 'ASidewalk::bAddStartSection' has a wrong offset!");
static_assert(offsetof(ASidewalk, bAddEndSection) == 0x000346, "Member 'ASidewalk::bAddEndSection' has a wrong offset!");

// Class GothicPack.UniversalFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUniversalFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniversalFunctionLibrary">();
	}
	static class UUniversalFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniversalFunctionLibrary>();
	}
};
static_assert(alignof(UUniversalFunctionLibrary) == 0x000008, "Wrong alignment on UUniversalFunctionLibrary");
static_assert(sizeof(UUniversalFunctionLibrary) == 0x000028, "Wrong size on UUniversalFunctionLibrary");

// Class GothicPack.Wall
// 0x0070 (0x0368 - 0x02F8)
class AWall final : public AProceduralSpline
{
public:
	TArray<class UStaticMesh*>                    Wall_StaticMeshes;                                 // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Gate_Middle_StaticMesh;                            // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Gate_End_StaticMesh;                               // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Gate_Start_StaticMesh;                             // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Pillar_StaticMesh;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetBeforeAttachMesh_Wall;                       // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetBeforeAttachMesh_Gate;                       // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PillarMaxScale;                                    // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       TestSpline;                                        // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddStartGate;                                     // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddStartPillar;                                   // 0x0341(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_342[0x2];                                      // 0x0342(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartPillarScale;                                  // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddEndGate;                                       // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddEndPillar;                                     // 0x0349(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A[0x2];                                      // 0x034A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EndPillarScale;                                    // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddMiddleGate;                                    // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MiddleGateGap;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddMiddlePillar;                                  // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MiddlePillarGap;                                   // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddlePillarGapOffset;                             // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddlePillarAmount;                                // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wall">();
	}
	static class AWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWall>();
	}
};
static_assert(alignof(AWall) == 0x000008, "Wrong alignment on AWall");
static_assert(sizeof(AWall) == 0x000368, "Wrong size on AWall");
static_assert(offsetof(AWall, Wall_StaticMeshes) == 0x0002F8, "Member 'AWall::Wall_StaticMeshes' has a wrong offset!");
static_assert(offsetof(AWall, Gate_Middle_StaticMesh) == 0x000308, "Member 'AWall::Gate_Middle_StaticMesh' has a wrong offset!");
static_assert(offsetof(AWall, Gate_End_StaticMesh) == 0x000310, "Member 'AWall::Gate_End_StaticMesh' has a wrong offset!");
static_assert(offsetof(AWall, Gate_Start_StaticMesh) == 0x000318, "Member 'AWall::Gate_Start_StaticMesh' has a wrong offset!");
static_assert(offsetof(AWall, Pillar_StaticMesh) == 0x000320, "Member 'AWall::Pillar_StaticMesh' has a wrong offset!");
static_assert(offsetof(AWall, OffsetBeforeAttachMesh_Wall) == 0x000328, "Member 'AWall::OffsetBeforeAttachMesh_Wall' has a wrong offset!");
static_assert(offsetof(AWall, OffsetBeforeAttachMesh_Gate) == 0x00032C, "Member 'AWall::OffsetBeforeAttachMesh_Gate' has a wrong offset!");
static_assert(offsetof(AWall, PillarMaxScale) == 0x000330, "Member 'AWall::PillarMaxScale' has a wrong offset!");
static_assert(offsetof(AWall, TestSpline) == 0x000338, "Member 'AWall::TestSpline' has a wrong offset!");
static_assert(offsetof(AWall, bAddStartGate) == 0x000340, "Member 'AWall::bAddStartGate' has a wrong offset!");
static_assert(offsetof(AWall, bAddStartPillar) == 0x000341, "Member 'AWall::bAddStartPillar' has a wrong offset!");
static_assert(offsetof(AWall, StartPillarScale) == 0x000344, "Member 'AWall::StartPillarScale' has a wrong offset!");
static_assert(offsetof(AWall, bAddEndGate) == 0x000348, "Member 'AWall::bAddEndGate' has a wrong offset!");
static_assert(offsetof(AWall, bAddEndPillar) == 0x000349, "Member 'AWall::bAddEndPillar' has a wrong offset!");
static_assert(offsetof(AWall, EndPillarScale) == 0x00034C, "Member 'AWall::EndPillarScale' has a wrong offset!");
static_assert(offsetof(AWall, bAddMiddleGate) == 0x000350, "Member 'AWall::bAddMiddleGate' has a wrong offset!");
static_assert(offsetof(AWall, MiddleGateGap) == 0x000354, "Member 'AWall::MiddleGateGap' has a wrong offset!");
static_assert(offsetof(AWall, bAddMiddlePillar) == 0x000358, "Member 'AWall::bAddMiddlePillar' has a wrong offset!");
static_assert(offsetof(AWall, MiddlePillarGap) == 0x00035C, "Member 'AWall::MiddlePillarGap' has a wrong offset!");
static_assert(offsetof(AWall, MiddlePillarGapOffset) == 0x000360, "Member 'AWall::MiddlePillarGapOffset' has a wrong offset!");
static_assert(offsetof(AWall, MiddlePillarAmount) == 0x000364, "Member 'AWall::MiddlePillarAmount' has a wrong offset!");

}

