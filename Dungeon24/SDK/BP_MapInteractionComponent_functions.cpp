#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_MapInteractionComponent

#include "Basic.hpp"

#include "BP_MapInteractionComponent_classes.hpp"
#include "BP_MapInteractionComponent_parameters.hpp"


namespace SDK
{

// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.AddMapHint
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            InteractPawn                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          InteractObject                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ObjectLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::AddMapHint(class APawn* InteractPawn, class UObject* InteractObject, const struct FVector& ObjectLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "AddMapHint");

	Params::BP_MapInteractionComponent_C_AddMapHint Parms{};

	Parms.InteractPawn = InteractPawn;
	Parms.InteractObject = InteractObject;
	Parms.ObjectLocation = std::move(ObjectLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.BeginInteract
// (BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::BeginInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "BeginInteract");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.CheckInteractionDistanceOnClient
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_InteractableBase_C*           InteractableCandidate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_MapInteractionComponent_C::CheckInteractionDistanceOnClient(class ABP_InteractableBase_C* InteractableCandidate, class APawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "CheckInteractionDistanceOnClient");

	Params::BP_MapInteractionComponent_C_CheckInteractionDistanceOnClient Parms{};

	Parms.InteractableCandidate = InteractableCandidate;
	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.CheckInteractionDistanceOnServer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_InteractableBase_C*           InteractableCandidate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_MapInteractionComponent_C::CheckInteractionDistanceOnServer(class ABP_InteractableBase_C* InteractableCandidate, class APawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "CheckInteractionDistanceOnServer");

	Params::BP_MapInteractionComponent_C_CheckInteractionDistanceOnServer Parms{};

	Parms.InteractableCandidate = InteractableCandidate;
	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.CheckTargetLock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::CheckTargetLock(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "CheckTargetLock");

	Params::BP_MapInteractionComponent_C_CheckTargetLock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ChooseTraceResult
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               Hits                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FHitResult                       Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBP_MapInteractionComponent_C::ChooseTraceResult(TArray<struct FHitResult>& Hits, struct FHitResult* Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ChooseTraceResult");

	Params::BP_MapInteractionComponent_C_ChooseTraceResult Parms{};

	Parms.Hits = std::move(Hits);

	UObject::ProcessEvent(Func, &Parms);

	Hits = std::move(Parms.Hits);

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ClearCandidate
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::ClearCandidate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ClearCandidate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ClearCandidateFromServer
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::ClearCandidateFromServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ClearCandidateFromServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ClearLootCache
// (BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::ClearLootCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ClearLootCache");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.DisableInteractionOnServer
// (BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::DisableInteractionOnServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "DisableInteractionOnServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.EnableInteractionOnServer
// (BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::EnableInteractionOnServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "EnableInteractionOnServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.EndInteract
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Broken                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::EndInteract(bool Broken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "EndInteract");

	Params::BP_MapInteractionComponent_C_EndInteract Parms{};

	Parms.Broken = Broken;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.EndInteractOnServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Broken                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::EndInteractOnServer(bool Broken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "EndInteractOnServer");

	Params::BP_MapInteractionComponent_C_EndInteractOnServer Parms{};

	Parms.Broken = Broken;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ExecuteUbergraph_BP_MapInteractionComponent
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::ExecuteUbergraph_BP_MapInteractionComponent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ExecuteUbergraph_BP_MapInteractionComponent");

	Params::BP_MapInteractionComponent_C_ExecuteUbergraph_BP_MapInteractionComponent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.GetHitInteractable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class ABP_InteractableBase_C*           Interactable                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::GetHitInteractable(struct FHitResult& Hit, class ABP_InteractableBase_C** Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "GetHitInteractable");

	Params::BP_MapInteractionComponent_C_GetHitInteractable Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	Hit = std::move(Parms.Hit);

	if (Interactable != nullptr)
		*Interactable = Parms.Interactable;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.GetHitInteractableObject
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               Hits                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class ABP_InteractableBase_C*           Interactable_Object                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::GetHitInteractableObject(TArray<struct FHitResult>& Hits, class ABP_InteractableBase_C** Interactable_Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "GetHitInteractableObject");

	Params::BP_MapInteractionComponent_C_GetHitInteractableObject Parms{};

	Parms.Hits = std::move(Hits);

	UObject::ProcessEvent(Func, &Parms);

	Hits = std::move(Parms.Hits);

	if (Interactable_Object != nullptr)
		*Interactable_Object = Parms.Interactable_Object;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.GetInteractableLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_InteractableBase_C*           Interactable                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::GetInteractableLocation(class ABP_InteractableBase_C* Interactable, struct FVector* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "GetInteractableLocation");

	Params::BP_MapInteractionComponent_C_GetInteractableLocation Parms{};

	Parms.Interactable = Interactable;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.GetViewRay
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Start                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          End                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::GetViewRay(struct FVector* Start, struct FVector* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "GetViewRay");

	Params::BP_MapInteractionComponent_C_GetViewRay Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Start != nullptr)
		*Start = std::move(Parms.Start);

	if (End != nullptr)
		*End = std::move(Parms.End);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.HasTeleportScroll
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    HasScroll                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::HasTeleportScroll(class APawn* Pawn, bool* HasScroll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "HasTeleportScroll");

	Params::BP_MapInteractionComponent_C_HasTeleportScroll Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	if (HasScroll != nullptr)
		*HasScroll = Parms.HasScroll;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.InteractExtractDevice
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Begin                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_ExtractDevice_C*              Device                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::InteractExtractDevice(bool Begin, class ABP_ExtractDevice_C* Device)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "InteractExtractDevice");

	Params::BP_MapInteractionComponent_C_InteractExtractDevice Parms{};

	Parms.Begin = Begin;
	Parms.Device = Device;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OnBeginInteract__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_InteractableBase_C*           Interactable_Actor                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  EndTime                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::OnBeginInteract__DelegateSignature(class ABP_InteractableBase_C* Interactable_Actor, double StartTime, double EndTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OnBeginInteract__DelegateSignature");

	Params::BP_MapInteractionComponent_C_OnBeginInteract__DelegateSignature Parms{};

	Parms.Interactable_Actor = Interactable_Actor;
	Parms.StartTime = StartTime;
	Parms.EndTime = EndTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OnClearInteractable__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::OnClearInteractable__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OnClearInteractable__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OnEndInteract__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::OnEndInteract__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OnEndInteract__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OnRebirth__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::OnRebirth__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OnRebirth__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OnSetInteractable__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_InteractableBase_C*           Interactable_Actor                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::OnSetInteractable__DelegateSignature(class ABP_InteractableBase_C* Interactable_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OnSetInteractable__DelegateSignature");

	Params::BP_MapInteractionComponent_C_OnSetInteractable__DelegateSignature Parms{};

	Parms.Interactable_Actor = Interactable_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OpenInventoryInspector
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::OpenInventoryInspector(class ALyraCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OpenInventoryInspector");

	Params::BP_MapInteractionComponent_C_OpenInventoryInspector Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.OpenLootMenu
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULyraInventoryManagerComponent*   Inventory_Manager                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class ULyraEquipmentManagerComponent*   Equipment_Manager                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::OpenLootMenu(class ULyraInventoryManagerComponent* Inventory_Manager, class ULyraEquipmentManagerComponent* Equipment_Manager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "OpenLootMenu");

	Params::BP_MapInteractionComponent_C_OpenLootMenu Parms{};

	Parms.Inventory_Manager = Inventory_Manager;
	Parms.Equipment_Manager = Equipment_Manager;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.PromptTeleportScrollComsuption
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::PromptTeleportScrollComsuption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "PromptTeleportScrollComsuption");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.RebirthOnClient
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::RebirthOnClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "RebirthOnClient");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_MapInteractionComponent_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "ReceiveTick");

	Params::BP_MapInteractionComponent_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.RemoveMapHint
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          InteractObject                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::RemoveMapHint(class UObject* InteractObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "RemoveMapHint");

	Params::BP_MapInteractionComponent_C_RemoveMapHint Parms{};

	Parms.InteractObject = InteractObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.Spawn Collectable from Dropped Item Server
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULyraInventoryItemInstance*       Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    NeedDuplicate                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SpawnNumber                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DisperseRange                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ForwardDistance                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_CollectableBase_C*>    SpawnedActors                                          (Parm, OutParm)

void UBP_MapInteractionComponent_C::Spawn_Collectable_from_Dropped_Item_Server(class ULyraInventoryItemInstance* Item, bool NeedDuplicate, int32 SpawnNumber, double DisperseRange, double ForwardDistance, TArray<class ABP_CollectableBase_C*>* SpawnedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "Spawn Collectable from Dropped Item Server");

	Params::BP_MapInteractionComponent_C_Spawn_Collectable_from_Dropped_Item_Server Parms{};

	Parms.Item = Item;
	Parms.NeedDuplicate = NeedDuplicate;
	Parms.SpawnNumber = SpawnNumber;
	Parms.DisperseRange = DisperseRange;
	Parms.ForwardDistance = ForwardDistance;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnedActors != nullptr)
		*SpawnedActors = std::move(Parms.SpawnedActors);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.SpawnCollectableAndLaunch
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULyraInventoryItemInstance*       Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BornPos                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         BornRot                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         LaunchRot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RotForce                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnableLight                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::SpawnCollectableAndLaunch(class ULyraInventoryItemInstance* Item, const struct FVector& BornPos, const struct FRotator& BornRot, const struct FRotator& LaunchRot, double Force, double RotForce, bool EnableLight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "SpawnCollectableAndLaunch");

	Params::BP_MapInteractionComponent_C_SpawnCollectableAndLaunch Parms{};

	Parms.Item = Item;
	Parms.BornPos = std::move(BornPos);
	Parms.BornRot = std::move(BornRot);
	Parms.LaunchRot = std::move(LaunchRot);
	Parms.Force = Force;
	Parms.RotForce = RotForce;
	Parms.EnableLight = EnableLight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.SpawnCollectableFromDroppedItem
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ForwardDistance                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DisperseRange                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemFunctionLibrary_C*        ItemFuncComponent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::SpawnCollectableFromDroppedItem(class ULyraInventoryItemInstance* ItemInstance, double ForwardDistance, double DisperseRange, class UBP_ItemFunctionLibrary_C* ItemFuncComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "SpawnCollectableFromDroppedItem");

	Params::BP_MapInteractionComponent_C_SpawnCollectableFromDroppedItem Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.ForwardDistance = ForwardDistance;
	Parms.DisperseRange = DisperseRange;
	Parms.ItemFuncComponent = ItemFuncComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.SpawnOneCollectableObject
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UClass*                           ItemDefinition                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    NeedDuplicate                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AController*                      PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Stack                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DisperseRange                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ForwardDistance                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_CollectableBase_C*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class ABP_CollectableBase_C* UBP_MapInteractionComponent_C::SpawnOneCollectableObject(class ULyraInventoryItemInstance* ItemInstance, class UClass* ItemDefinition, bool NeedDuplicate, class AController* PlayerController, int32 Stack, double DisperseRange, double ForwardDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "SpawnOneCollectableObject");

	Params::BP_MapInteractionComponent_C_SpawnOneCollectableObject Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.ItemDefinition = ItemDefinition;
	Parms.NeedDuplicate = NeedDuplicate;
	Parms.PlayerController = PlayerController;
	Parms.Stack = Stack;
	Parms.DisperseRange = DisperseRange;
	Parms.ForwardDistance = ForwardDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.UpdateBeam
// (BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::UpdateBeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "UpdateBeam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.UpdateCandidate
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_InteractableBase_C*           InteractableCandidate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::UpdateCandidate(class ABP_InteractableBase_C* InteractableCandidate, class APawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "UpdateCandidate");

	Params::BP_MapInteractionComponent_C_UpdateCandidate Parms{};

	Parms.InteractableCandidate = InteractableCandidate;
	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.UpdateCandidateOnServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_InteractableBase_C*           InteractableCandidate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            InteractingPawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::UpdateCandidateOnServer(class ABP_InteractableBase_C* InteractableCandidate, class APawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "UpdateCandidateOnServer");

	Params::BP_MapInteractionComponent_C_UpdateCandidateOnServer Parms{};

	Parms.InteractableCandidate = InteractableCandidate;
	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.UpdateLootBeamOnServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULyraInventoryManagerComponent*   InventoryManager                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class ULyraEquipmentManagerComponent*   EquipmentManager                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_MapInteractionComponent_C::UpdateLootBeamOnServer(class ULyraInventoryManagerComponent* InventoryManager, class ULyraEquipmentManagerComponent* EquipmentManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "UpdateLootBeamOnServer");

	Params::BP_MapInteractionComponent_C_UpdateLootBeamOnServer Parms{};

	Parms.InventoryManager = InventoryManager;
	Parms.EquipmentManager = EquipmentManager;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MapInteractionComponent.BP_MapInteractionComponent_C.UpdateTargetLock
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_MapInteractionComponent_C::UpdateTargetLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MapInteractionComponent_C", "UpdateTargetLock");

	UObject::ProcessEvent(Func, nullptr);
}

}

