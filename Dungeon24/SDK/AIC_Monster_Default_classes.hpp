#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AIC_Monster_Default

#include "Basic.hpp"

#include "TGF_FAbilityTargetAlternateEntry_structs.hpp"
#include "Engine_structs.hpp"
#include "AIModule_structs.hpp"
#include "TGF_AIController_classes.hpp"
#include "TGF_FAbilitySelectorEntry_structs.hpp"
#include "LyraGame_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass AIC_Monster_Default.AIC_Monster_Default_C
// 0x0178 (0x0560 - 0x03E8)
class AAIC_Monster_Default_C final : public ATGF_AIController_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x03E8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UAIPerceptionComponent*                 AIPerception;                                      // 0x03F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 ActorPerceived;                                    // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FAIStimulus                            StimulusPerceived;                                 // 0x0408(0x0058)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	class FName                                   SpawnLocation;                                     // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   SpawnRotation;                                     // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        TickTime;                                          // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        TickDelta;                                         // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 ForceTargetable;                                   // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<struct FTGF_FAbilitySelectorEntry>     PriorAbilitySelector;                              // 0x0488(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class FName                                   AlertState;                                        // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AlertStateTime;                                    // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AlertLocation;                                     // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   Ability;                                           // 0x04B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AbilityActivateTime;                               // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AbilityTarget;                                     // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AbilityThreatTarget;                               // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           ThreatTargetTimer;                                 // 0x04D0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class FName                                   Retreat;                                           // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   RetreatIndex;                                      // 0x04E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   Flank;                                             // 0x04E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   InterruptAction;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   InterruptAbility;                                  // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   Stare;                                             // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<class UClass*, struct FTGF_FAbilityTargetAlternateEntry> AbilityTargetAlternateMap;                         // 0x0508(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	struct FTimerHandle                           CombatLeaveTimer;                                  // 0x0558(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)

public:
	void AbilityFilterBoss(bool* Result);
	void AbilityFilterEnemyBehind(TArray<int32>& Args, bool* Result);
	void AbilityFilterFriendlyCount(TArray<int32>& Args, bool* Result);
	void AbilityFilterHealthHigh(TArray<int32>& Args, bool* Result);
	void AbilityFilterHealthLow(TArray<int32>& Args, bool* Result);
	void AbilityFilterHostileCount(TArray<int32>& Args, bool* Result);
	void AbilityFilterNone(bool* Result);
	void AbilityFilterSummonsCount(TArray<int32>& Args, bool* Result);
	void AbilityFilterTags(TArray<int32>& Args, const struct FGameplayTagContainer& Param_Tags, bool* Result);
	void AbilityTargetFilterAlternately(class UClass* Param_Ability, TArray<class AActor*>& Targets);
	void AbilityTargetFilterCareer(TArray<class AActor*>& Targets, TArray<int32>& Args);
	void AbilityTargetFilterCareerPriority(TArray<class AActor*>& Targets, TArray<int32>& Args);
	void AbilityTargetFilterFriendly(TArray<class AActor*>& Targets);
	void AbilityTargetFilterFurthest(TArray<class AActor*>& Targets);
	void AbilityTargetFilterHealthHighest(TArray<class AActor*>& Targets);
	void AbilityTargetFilterHealthLowest(TArray<class AActor*>& Targets);
	void AbilityTargetFilterHostile(TArray<class AActor*>& Targets);
	void AbilityTargetFilterItemEquip(TArray<class AActor*>& Targets, TArray<int32>& Args);
	void AbilityTargetFilterNearest(TArray<class AActor*>& Targets);
	void AbilityTargetFilterNone(TArray<class AActor*>& Targets);
	void AbilityTargetFilterRace(TArray<class AActor*>& Targets, TArray<int32>& Args);
	void AbilityTargetFilterRange(TArray<class AActor*>& Targets, TArray<int32>& Args);
	void AbilityTargetFilterTags(TArray<class AActor*>& Targets, TArray<int32>& Args, const struct FGameplayTagContainer& Param_Tags);
	void AbilityTargetFilterThreatHighest(TArray<class AActor*>& Targets);
	void AbilityTargetFilterThreatLowest(TArray<class AActor*>& Targets);
	void AbilityTargetFilterThreats(TArray<class AActor*>& Targets);
	void AddPriorAbility(class UClass* Param_Ability, double Chance);
	void BndEvt__AC_Monster_Test_0_AIPerception_K2Node_ComponentBoundEvent_0_ActorPerceptionUpdatedDelegate__DelegateSignature(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void CalcDistance(class AActor* Target, double* Distance);
	void ClearAbility();
	void ClearAbilityInterval();
	void ClearAction();
	void ClearInterrupts();
	void ClearPriorAbilities();
	void ExecuteUbergraph_AIC_Monster_Default(int32 EntryPoint);
	void FilterAbilities(class UClass** Param_Ability, struct FTgfAIAbilityTarget* Param_AbilityTarget);
	void FilterAbility(class UClass* Param_Ability, bool* Result, struct FTgfAIAbilityTarget* Target);
	void FilterAbilityFromSelector(TArray<struct FTGF_FAbilitySelectorEntry>& AbilitySelector, class UClass** Param_Ability, struct FTgfAIAbilityTarget* Param_AbilityTarget);
	void FilterAbilitySelector(class ABP_Tgf_Monster_C* Monster, TArray<struct FTGF_FAbilitySelectorEntry>* Result);
	void FilterThreats();
	void GetAbility(class UClass** Result);
	void GetAbilityTarget(class AActor** Target);
	void GetHealth(class AActor* Actor, double* Result);
	void GetHealthPercent(class AActor* Actor, double* Result);
	void HasAction(bool* Result);
	void IsAbilityReady(class UClass* Param_Ability, bool* Ready);
	void IsActivatingAbility(bool* Result);
	void IsHostile(class AActor* Actor, bool* Result);
	void IsInCombat(bool* Result);
	void IsInCombatZone(const struct FVector& Location, bool* Result);
	void IsTargetable(class AActor* Actor, bool* Result);
	void OnDamageTaken(class AActor* Actor, const struct FGameplayTagContainer& InstigatorTags, const struct FGameplayTagContainer& TargetTags, float Damage, const struct FGameplayEffectSpec& Spec);
	void OnDeathStarted(class AActor* OwningActor);
	void OnEnterCombat();
	void OnLeaveCombat();
	void OnReady_6FF5A7C4444669FB1B1574B96598A394();
	void OnReady_7277D2FC41BAB0DB1537B390F56F14EC();
	void OnThreatTargetChanged(class AActor* Target);
	void PickAbility(bool* Result);
	void PickAbilityDirectly(class UClass* InAbility, bool* Result);
	void PickAction();
	void PostFilterAbility(class UClass* InAbility);
	void RangeQueryActors(double Range, TArray<class AActor*>* Actors);
	void ReceivePossess(class APawn* PossessedPawn);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveUnPossess(class APawn* UnpossessedPawn);
	void ReplicateAbilityTarget(class AActor* Actor);
	void SafeGetArg(TArray<int32>& Args, int32 Param_Index, bool PrintError, int32* Arg);
	void SetBlackboardBoolValue(class FName KeyName, bool Value);
	void SetFlank(bool Param_Flank);
	void SetFlee(bool Flee);
	void SetForceTargetable(class AActor* Actor);
	void SetInterruptAbility(bool Interrupt);
	void SetInterruptAction(bool Interrupt);
	void SetRetreat(bool Param_Retreat, int32 Param_RetreatIndex);
	void SetSensesEnabled(bool Enabled);
	void ShouldPauseCombatTimer(class ABP_Tgf_Monster_C* Monster, bool* Result);
	void StartCombatLeaveTimer();
	void StartThreatTargetTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"AIC_Monster_Default_C">();
	}
	static class AAIC_Monster_Default_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIC_Monster_Default_C>();
	}
};
static_assert(alignof(AAIC_Monster_Default_C) == 0x000008, "Wrong alignment on AAIC_Monster_Default_C");
static_assert(sizeof(AAIC_Monster_Default_C) == 0x000560, "Wrong size on AAIC_Monster_Default_C");
static_assert(offsetof(AAIC_Monster_Default_C, UberGraphFrame) == 0x0003E8, "Member 'AAIC_Monster_Default_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AIPerception) == 0x0003F0, "Member 'AAIC_Monster_Default_C::AIPerception' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, BehaviorTree) == 0x0003F8, "Member 'AAIC_Monster_Default_C::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, ActorPerceived) == 0x000400, "Member 'AAIC_Monster_Default_C::ActorPerceived' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, StimulusPerceived) == 0x000408, "Member 'AAIC_Monster_Default_C::StimulusPerceived' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, SpawnLocation) == 0x000460, "Member 'AAIC_Monster_Default_C::SpawnLocation' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, SpawnRotation) == 0x000468, "Member 'AAIC_Monster_Default_C::SpawnRotation' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, TickTime) == 0x000470, "Member 'AAIC_Monster_Default_C::TickTime' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, TickDelta) == 0x000478, "Member 'AAIC_Monster_Default_C::TickDelta' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, ForceTargetable) == 0x000480, "Member 'AAIC_Monster_Default_C::ForceTargetable' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, PriorAbilitySelector) == 0x000488, "Member 'AAIC_Monster_Default_C::PriorAbilitySelector' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AlertState) == 0x000498, "Member 'AAIC_Monster_Default_C::AlertState' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AlertStateTime) == 0x0004A0, "Member 'AAIC_Monster_Default_C::AlertStateTime' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AlertLocation) == 0x0004A8, "Member 'AAIC_Monster_Default_C::AlertLocation' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, Ability) == 0x0004B0, "Member 'AAIC_Monster_Default_C::Ability' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AbilityActivateTime) == 0x0004B8, "Member 'AAIC_Monster_Default_C::AbilityActivateTime' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AbilityTarget) == 0x0004C0, "Member 'AAIC_Monster_Default_C::AbilityTarget' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AbilityThreatTarget) == 0x0004C8, "Member 'AAIC_Monster_Default_C::AbilityThreatTarget' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, ThreatTargetTimer) == 0x0004D0, "Member 'AAIC_Monster_Default_C::ThreatTargetTimer' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, Retreat) == 0x0004D8, "Member 'AAIC_Monster_Default_C::Retreat' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, RetreatIndex) == 0x0004E0, "Member 'AAIC_Monster_Default_C::RetreatIndex' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, Flank) == 0x0004E8, "Member 'AAIC_Monster_Default_C::Flank' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, InterruptAction) == 0x0004F0, "Member 'AAIC_Monster_Default_C::InterruptAction' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, InterruptAbility) == 0x0004F8, "Member 'AAIC_Monster_Default_C::InterruptAbility' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, Stare) == 0x000500, "Member 'AAIC_Monster_Default_C::Stare' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, AbilityTargetAlternateMap) == 0x000508, "Member 'AAIC_Monster_Default_C::AbilityTargetAlternateMap' has a wrong offset!");
static_assert(offsetof(AAIC_Monster_Default_C, CombatLeaveTimer) == 0x000558, "Member 'AAIC_Monster_Default_C::CombatLeaveTimer' has a wrong offset!");

}

