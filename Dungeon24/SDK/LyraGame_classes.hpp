#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LyraGame

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "CommonGame_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "LyraGame_structs.hpp"
#include "Hotfix_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "CommonUI_classes.hpp"
#include "ModularGameplayActors_classes.hpp"
#include "InputCore_structs.hpp"
#include "AGRPRO_structs.hpp"
#include "AGRPRO_classes.hpp"
#include "AudioMixer_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "PhysicsCore_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameplayMessageRuntime_structs.hpp"
#include "ReplicationGraph_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "CommonInput_structs.hpp"
#include "GameSettings_classes.hpp"
#include "DeveloperSettings_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "GameFeatures_classes.hpp"
#include "CommonUser_structs.hpp"
#include "SignificanceManager_classes.hpp"
#include "Gauntlet_classes.hpp"


namespace SDK
{

// Class LyraGame.TgfAbilityCheats
// 0x0000 (0x0028 - 0x0028)
class UTgfAbilityCheats final : public UCheatManagerExtension
{
public:
	void AddAbilitySet(int32 AbilitySetId);
	void AddAttrValue(const class FString& AttrStr, float Value);
	void AddLooseGameplayTag(const class FString& TagName, int32 Nums, bool NeedReplicated, bool FoundTagInServer);
	void AttReady();
	void ClearAbilitySet();
	void GiveAbilitySet(const class FString& AssetName);
	void HPReady();
	void InjectInput(const class FString& InputStr);
	void MulAttrValue(const class FString& AttrStr, float Value);
	void Rebirth();
	void RebirthLocation(float X, float Y, float Z);
	void RemoveLooseGameplayTag(const class FString& TagName, int32 Nums, bool NeedReplicated, bool FoundTagInServer);
	void SetAttrValue(const class FString& AttrStr, float Value);
	void SetFirstLevel(float Value);
	void ShowAllTag();
	void ShowAllTagServer();
	void ToggleAuthIgnoreAbilitySystemCooldowns(bool Enabled);
	void ToggleAuthIgnoreAbilitySystemCosts(bool Enabled);
	void TriggerInput(const class FString& InputStr);
	void TriggerInputContinous(const class FString& InputStr);
	void UseOldHit(bool UseOld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityCheats">();
	}
	static class UTgfAbilityCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityCheats>();
	}
};
static_assert(alignof(UTgfAbilityCheats) == 0x000008, "Wrong alignment on UTgfAbilityCheats");
static_assert(sizeof(UTgfAbilityCheats) == 0x000028, "Wrong size on UTgfAbilityCheats");

// Class LyraGame.AbilityTask_WaitGameplayTagCountChanged
// 0x0010 (0x00B8 - 0x00A8)
class UAbilityTask_WaitGameplayTagCountChanged final : public UAbilityTask_WaitGameplayTag
{
public:
	FMulticastInlineDelegateProperty_             Changed;                                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitGameplayTagCountChanged* WaitGameplayTagCountChanged(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, class AActor* InOptionalExternalTarget, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayTagCountChanged">();
	}
	static class UAbilityTask_WaitGameplayTagCountChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagCountChanged>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayTagCountChanged) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayTagCountChanged");
static_assert(sizeof(UAbilityTask_WaitGameplayTagCountChanged) == 0x0000B8, "Wrong size on UAbilityTask_WaitGameplayTagCountChanged");
static_assert(offsetof(UAbilityTask_WaitGameplayTagCountChanged, Changed) == 0x0000A8, "Member 'UAbilityTask_WaitGameplayTagCountChanged::Changed' has a wrong offset!");

// Class LyraGame.TgfInteractorBattleComponent
// 0x0148 (0x01F0 - 0x00A8)
class UTgfInteractorBattleComponent final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDeathStarted;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeathFinished;                                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageTaken;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKillingTaken;                                    // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x00E8(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          EnableBattle;                                      // 0x01D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLootable;                                        // 0x01D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D2[0x2];                                      // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathTime;                                         // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalHP;                                           // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentHP;                                         // 0x01DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NeedReplicateDamage;                               // 0x01E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DontRebound;                                       // 0x01E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E2[0x2];                                      // 0x01E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathBeginTick;                                    // 0x01E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfDeathState                                DeathState;                                        // 0x01E8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastDamageEvent(class AActor* DamageInstigator, const struct FGameplayTagContainer& DamageInstigatorTags, float DamageValue);
	void MulticastDeathEvent(class AActor* DamageInstigator, class AActor* DamageTarget);
	void OnHit(class AActor* SrcActor, ETgfUseAttackType AttackType);
	void OnRep_DeathState(ETgfDeathState OldDeathState);
	void TriggerDeath();

	float GetCurrentHP() const;
	bool GetDeadOrDying() const;
	float GetTotalHP() const;
	bool IsDeadOrDying() const;
	bool IsEnableBattle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInteractorBattleComponent">();
	}
	static class UTgfInteractorBattleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInteractorBattleComponent>();
	}
};
static_assert(alignof(UTgfInteractorBattleComponent) == 0x000008, "Wrong alignment on UTgfInteractorBattleComponent");
static_assert(sizeof(UTgfInteractorBattleComponent) == 0x0001F0, "Wrong size on UTgfInteractorBattleComponent");
static_assert(offsetof(UTgfInteractorBattleComponent, OnDeathStarted) == 0x0000A8, "Member 'UTgfInteractorBattleComponent::OnDeathStarted' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, OnDeathFinished) == 0x0000B8, "Member 'UTgfInteractorBattleComponent::OnDeathFinished' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, OnDamageTaken) == 0x0000C8, "Member 'UTgfInteractorBattleComponent::OnDamageTaken' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, OnKillingTaken) == 0x0000D8, "Member 'UTgfInteractorBattleComponent::OnKillingTaken' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, HitResult) == 0x0000E8, "Member 'UTgfInteractorBattleComponent::HitResult' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, EnableBattle) == 0x0001D0, "Member 'UTgfInteractorBattleComponent::EnableBattle' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, IsLootable) == 0x0001D1, "Member 'UTgfInteractorBattleComponent::IsLootable' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, DeathTime) == 0x0001D4, "Member 'UTgfInteractorBattleComponent::DeathTime' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, TotalHP) == 0x0001D8, "Member 'UTgfInteractorBattleComponent::TotalHP' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, CurrentHP) == 0x0001DC, "Member 'UTgfInteractorBattleComponent::CurrentHP' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, NeedReplicateDamage) == 0x0001E0, "Member 'UTgfInteractorBattleComponent::NeedReplicateDamage' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, DontRebound) == 0x0001E1, "Member 'UTgfInteractorBattleComponent::DontRebound' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, DeathBeginTick) == 0x0001E4, "Member 'UTgfInteractorBattleComponent::DeathBeginTick' has a wrong offset!");
static_assert(offsetof(UTgfInteractorBattleComponent, DeathState) == 0x0001E8, "Member 'UTgfInteractorBattleComponent::DeathState' has a wrong offset!");

// Class LyraGame.LyraGameInstance
// 0x0000 (0x01D0 - 0x01D0)
class ULyraGameInstance : public UCommonGameInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameInstance">();
	}
	static class ULyraGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameInstance>();
	}
};
static_assert(alignof(ULyraGameInstance) == 0x000008, "Wrong alignment on ULyraGameInstance");
static_assert(sizeof(ULyraGameInstance) == 0x0001D0, "Wrong size on ULyraGameInstance");

// Class LyraGame.PlayerDistanceCheckerComponent
// 0x0030 (0x00D8 - 0x00A8)
class UPlayerDistanceCheckerComponent final : public UActorComponent
{
public:
	struct FVector2D                              TickIntervalRange;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DistanceThresholdSquared;                          // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Event_SomePlayerComesClose;                        // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bOneOff;                                           // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTickOnAuthority;                              // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDistanceCheckerComponent">();
	}
	static class UPlayerDistanceCheckerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDistanceCheckerComponent>();
	}
};
static_assert(alignof(UPlayerDistanceCheckerComponent) == 0x000008, "Wrong alignment on UPlayerDistanceCheckerComponent");
static_assert(sizeof(UPlayerDistanceCheckerComponent) == 0x0000D8, "Wrong size on UPlayerDistanceCheckerComponent");
static_assert(offsetof(UPlayerDistanceCheckerComponent, TickIntervalRange) == 0x0000A8, "Member 'UPlayerDistanceCheckerComponent::TickIntervalRange' has a wrong offset!");
static_assert(offsetof(UPlayerDistanceCheckerComponent, DistanceThresholdSquared) == 0x0000B8, "Member 'UPlayerDistanceCheckerComponent::DistanceThresholdSquared' has a wrong offset!");
static_assert(offsetof(UPlayerDistanceCheckerComponent, Event_SomePlayerComesClose) == 0x0000C0, "Member 'UPlayerDistanceCheckerComponent::Event_SomePlayerComesClose' has a wrong offset!");
static_assert(offsetof(UPlayerDistanceCheckerComponent, bOneOff) == 0x0000D0, "Member 'UPlayerDistanceCheckerComponent::bOneOff' has a wrong offset!");
static_assert(offsetof(UPlayerDistanceCheckerComponent, bOnlyTickOnAuthority) == 0x0000D1, "Member 'UPlayerDistanceCheckerComponent::bOnlyTickOnAuthority' has a wrong offset!");

// Class LyraGame.AbilityTask_GrantNearbyTarget
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_GrantNearbyTarget final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_GrantNearbyTarget">();
	}
	static class UAbilityTask_GrantNearbyTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_GrantNearbyTarget>();
	}
};
static_assert(alignof(UAbilityTask_GrantNearbyTarget) == 0x000008, "Wrong alignment on UAbilityTask_GrantNearbyTarget");
static_assert(sizeof(UAbilityTask_GrantNearbyTarget) == 0x0000A0, "Wrong size on UAbilityTask_GrantNearbyTarget");

// Class LyraGame.TgfInventoryDragDropOperation
// 0x0018 (0x00A8 - 0x0090)
class UTgfInventoryDragDropOperation : public UDragDropOperation
{
public:
	class UTgfInventoryItemWrapper*               DraggedItem;                                       // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfEquipSlot                                 FromEquipSlot;                                     // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTgfInventoryWrapper*                   FromContext;                                       // 0x00A0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryDragDropOperation">();
	}
	static class UTgfInventoryDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryDragDropOperation>();
	}
};
static_assert(alignof(UTgfInventoryDragDropOperation) == 0x000008, "Wrong alignment on UTgfInventoryDragDropOperation");
static_assert(sizeof(UTgfInventoryDragDropOperation) == 0x0000A8, "Wrong size on UTgfInventoryDragDropOperation");
static_assert(offsetof(UTgfInventoryDragDropOperation, DraggedItem) == 0x000090, "Member 'UTgfInventoryDragDropOperation::DraggedItem' has a wrong offset!");
static_assert(offsetof(UTgfInventoryDragDropOperation, FromEquipSlot) == 0x000098, "Member 'UTgfInventoryDragDropOperation::FromEquipSlot' has a wrong offset!");
static_assert(offsetof(UTgfInventoryDragDropOperation, FromContext) == 0x0000A0, "Member 'UTgfInventoryDragDropOperation::FromContext' has a wrong offset!");

// Class LyraGame.RayTracingAudioMainComponent
// 0x0068 (0x0110 - 0x00A8)
class URayTracingAudioMainComponent final : public UActorComponent
{
public:
	float                                         HeightOffset;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayLength;                                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameSpan;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x5C];                                      // 0x00B4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RayTracingAudioMainComponent">();
	}
	static class URayTracingAudioMainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URayTracingAudioMainComponent>();
	}
};
static_assert(alignof(URayTracingAudioMainComponent) == 0x000008, "Wrong alignment on URayTracingAudioMainComponent");
static_assert(sizeof(URayTracingAudioMainComponent) == 0x000110, "Wrong size on URayTracingAudioMainComponent");
static_assert(offsetof(URayTracingAudioMainComponent, HeightOffset) == 0x0000A8, "Member 'URayTracingAudioMainComponent::HeightOffset' has a wrong offset!");
static_assert(offsetof(URayTracingAudioMainComponent, RayLength) == 0x0000AC, "Member 'URayTracingAudioMainComponent::RayLength' has a wrong offset!");
static_assert(offsetof(URayTracingAudioMainComponent, FrameSpan) == 0x0000B0, "Member 'URayTracingAudioMainComponent::FrameSpan' has a wrong offset!");

// Class LyraGame.TgfCharacterCheats
// 0x0000 (0x0028 - 0x0028)
class UTgfCharacterCheats final : public UCheatManagerExtension
{
public:
	void ForceSpectate(bool ToSpectate);
	void HidePlayerNames(bool Hide);
	void NetTest();
	void PrintActorMapStat();
	void PrintCharacterName();
	void PrintCharaLocation();
	void ReinitCharaCareer(int32 CareerInt);
	void SetActorMapBounds(float AIBound, float TickBound);
	void SetCharaLocation(float X, float Y, float Z);
	void SetDisplayCareerAndRace(int32 CareerInt, int32 RaceInt);
	void SetFreeze(bool bFreeze);
	void SetMithrilCharacter(bool Value, int32 RemainingRebirthChance);
	void SetPlayerSceneTag(int32 Tag);
	void SetPlayMontageDelay(bool bOpenServerPlayDelay, float DelayTime, bool bOpenClientBehind, bool bOpenClientAhead, float ChaseMaxPing);
	void ShowTeamId();
	void SpawnActor(const class FString& ClassPath, float Distance);
	void SpawnMonster(const class FString& ClassPath, float Distance, int32 LootIndex, bool Dormant);
	void TestTryIncreaseAndCheckSecurityInvalidCount(int32 Reason);

	void AddSkin(int32 SkinType, int32 SkinId) const;
	void SetFaceConfig(const class FString& Param_Name, int32 Type) const;
	void SetGender(const int32 Gender) const;
	void SetPlayerName(const class FString& Param_Name) const;
	void SetRace(const int32 Race) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterCheats">();
	}
	static class UTgfCharacterCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterCheats>();
	}
};
static_assert(alignof(UTgfCharacterCheats) == 0x000008, "Wrong alignment on UTgfCharacterCheats");
static_assert(sizeof(UTgfCharacterCheats) == 0x000028, "Wrong size on UTgfCharacterCheats");

// Class LyraGame.AbilityTask_MonitorMove
// 0x0040 (0x00C0 - 0x0080)
class UAbilityTask_MonitorMove final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnExecutePeriodic;                                 // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeOut;                                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            CachedMovementComponent;                           // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_MonitorMove* MonitorMove(class UGameplayAbility* OwningAbility, class FName TaskName, bool bHasDuration, float Duration, float Period, bool bShouldExecuteAtFirst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_MonitorMove">();
	}
	static class UAbilityTask_MonitorMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_MonitorMove>();
	}
};
static_assert(alignof(UAbilityTask_MonitorMove) == 0x000008, "Wrong alignment on UAbilityTask_MonitorMove");
static_assert(sizeof(UAbilityTask_MonitorMove) == 0x0000C0, "Wrong size on UAbilityTask_MonitorMove");
static_assert(offsetof(UAbilityTask_MonitorMove, OnExecutePeriodic) == 0x000080, "Member 'UAbilityTask_MonitorMove::OnExecutePeriodic' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MonitorMove, OnTimeOut) == 0x000090, "Member 'UAbilityTask_MonitorMove::OnTimeOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MonitorMove, CachedMovementComponent) == 0x0000B8, "Member 'UAbilityTask_MonitorMove::CachedMovementComponent' has a wrong offset!");

// Class LyraGame.RoleDisplayAttributeUtility
// 0x0000 (0x0028 - 0x0028)
class URoleDisplayAttributeUtility final : public UObject
{
public:
	static float GetMaxHealth(class ULyraAbilitySystemComponent* AbilitySystem);
	static TArray<struct FRoleDisplayAttribute> SortRoleDisplayAttribute(const TArray<struct FRoleDisplayAttribute>& Attributes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleDisplayAttributeUtility">();
	}
	static class URoleDisplayAttributeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleDisplayAttributeUtility>();
	}
};
static_assert(alignof(URoleDisplayAttributeUtility) == 0x000008, "Wrong alignment on URoleDisplayAttributeUtility");
static_assert(sizeof(URoleDisplayAttributeUtility) == 0x000028, "Wrong size on URoleDisplayAttributeUtility");

// Class LyraGame.AbilityTask_StateChangeMonitor
// 0x0030 (0x00B0 - 0x0080)
class UAbilityTask_StateChangeMonitor final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnMonitorStateSatisfied;                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMonitorStateDissatisfied;                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_StateChangeMonitor* WaitMonitorStateChanged(class UGameplayAbility* OwningAbility, class FName TaskName, bool TriggerImmediately, int32 TriggerCounts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_StateChangeMonitor">();
	}
	static class UAbilityTask_StateChangeMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_StateChangeMonitor>();
	}
};
static_assert(alignof(UAbilityTask_StateChangeMonitor) == 0x000008, "Wrong alignment on UAbilityTask_StateChangeMonitor");
static_assert(sizeof(UAbilityTask_StateChangeMonitor) == 0x0000B0, "Wrong size on UAbilityTask_StateChangeMonitor");
static_assert(offsetof(UAbilityTask_StateChangeMonitor, OnMonitorStateSatisfied) == 0x000080, "Member 'UAbilityTask_StateChangeMonitor::OnMonitorStateSatisfied' has a wrong offset!");
static_assert(offsetof(UAbilityTask_StateChangeMonitor, OnMonitorStateDissatisfied) == 0x000090, "Member 'UAbilityTask_StateChangeMonitor::OnMonitorStateDissatisfied' has a wrong offset!");

// Class LyraGame.AsyncAtion_AppearanceDataListen
// 0x0020 (0x0050 - 0x0030)
class UAsyncAtion_AppearanceDataListen final : public UCancellableAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             EventOnAppearanceDataGet;                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAtion_AppearanceDataListen* RegisterAppearanceDataListen(class UObject* WorldContextObject, int64 RoleID);

	void HandleOnAppearanceDataGet(int64 InRoleID, class UObject* SlateBrush);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAtion_AppearanceDataListen">();
	}
	static class UAsyncAtion_AppearanceDataListen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAtion_AppearanceDataListen>();
	}
};
static_assert(alignof(UAsyncAtion_AppearanceDataListen) == 0x000008, "Wrong alignment on UAsyncAtion_AppearanceDataListen");
static_assert(sizeof(UAsyncAtion_AppearanceDataListen) == 0x000050, "Wrong size on UAsyncAtion_AppearanceDataListen");
static_assert(offsetof(UAsyncAtion_AppearanceDataListen, EventOnAppearanceDataGet) == 0x000030, "Member 'UAsyncAtion_AppearanceDataListen::EventOnAppearanceDataGet' has a wrong offset!");

// Class LyraGame.RuneSwordSkillHelperActor
// 0x00A0 (0x0338 - 0x0298)
class ARuneSwordSkillHelperActor : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           SocketNames;                                       // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   Skill2SocketName;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MagicNumber;                                       // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BaseBoneName;                                      // 0x02BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurveName;                                         // 0x02C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x1C];                                     // 0x02CC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESwordMasterSkillType, struct FSwordInsSet> SwordInsCache;                                     // 0x02E8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	class APawn* GetOwnerPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RuneSwordSkillHelperActor">();
	}
	static class ARuneSwordSkillHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARuneSwordSkillHelperActor>();
	}
};
static_assert(alignof(ARuneSwordSkillHelperActor) == 0x000008, "Wrong alignment on ARuneSwordSkillHelperActor");
static_assert(sizeof(ARuneSwordSkillHelperActor) == 0x000338, "Wrong size on ARuneSwordSkillHelperActor");
static_assert(offsetof(ARuneSwordSkillHelperActor, Mesh) == 0x000298, "Member 'ARuneSwordSkillHelperActor::Mesh' has a wrong offset!");
static_assert(offsetof(ARuneSwordSkillHelperActor, SocketNames) == 0x0002A0, "Member 'ARuneSwordSkillHelperActor::SocketNames' has a wrong offset!");
static_assert(offsetof(ARuneSwordSkillHelperActor, Skill2SocketName) == 0x0002B0, "Member 'ARuneSwordSkillHelperActor::Skill2SocketName' has a wrong offset!");
static_assert(offsetof(ARuneSwordSkillHelperActor, MagicNumber) == 0x0002B8, "Member 'ARuneSwordSkillHelperActor::MagicNumber' has a wrong offset!");
static_assert(offsetof(ARuneSwordSkillHelperActor, BaseBoneName) == 0x0002BC, "Member 'ARuneSwordSkillHelperActor::BaseBoneName' has a wrong offset!");
static_assert(offsetof(ARuneSwordSkillHelperActor, CurveName) == 0x0002C4, "Member 'ARuneSwordSkillHelperActor::CurveName' has a wrong offset!");
static_assert(offsetof(ARuneSwordSkillHelperActor, SwordInsCache) == 0x0002E8, "Member 'ARuneSwordSkillHelperActor::SwordInsCache' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_MontagePlayRate
// 0x0060 (0x0090 - 0x0030)
class UTgfAnimNotifyState_MontagePlayRate : public UAnimNotifyState
{
public:
	float                                         PlayRate;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class USkeletalMeshComponent*, float>    OldCachePlayRate;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bTriggerPlayRateManual;                            // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MontagePlayRateRevert(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;
	void MontagePlayRateTakeEffect(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_MontagePlayRate">();
	}
	static class UTgfAnimNotifyState_MontagePlayRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_MontagePlayRate>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_MontagePlayRate) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_MontagePlayRate");
static_assert(sizeof(UTgfAnimNotifyState_MontagePlayRate) == 0x000090, "Wrong size on UTgfAnimNotifyState_MontagePlayRate");
static_assert(offsetof(UTgfAnimNotifyState_MontagePlayRate, PlayRate) == 0x000030, "Member 'UTgfAnimNotifyState_MontagePlayRate::PlayRate' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_MontagePlayRate, OldCachePlayRate) == 0x000038, "Member 'UTgfAnimNotifyState_MontagePlayRate::OldCachePlayRate' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_MontagePlayRate, bTriggerPlayRateManual) == 0x000088, "Member 'UTgfAnimNotifyState_MontagePlayRate::bTriggerPlayRateManual' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_MontagePlayRateWithTags
// 0x0078 (0x0108 - 0x0090)
class UTgfAnimNotifyState_MontagePlayRateWithTags final : public UTgfAnimNotifyState_MontagePlayRate
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0090(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         MaxTime;                                           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x54];                                      // 0x00B4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_MontagePlayRateWithTags">();
	}
	static class UTgfAnimNotifyState_MontagePlayRateWithTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_MontagePlayRateWithTags>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_MontagePlayRateWithTags) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_MontagePlayRateWithTags");
static_assert(sizeof(UTgfAnimNotifyState_MontagePlayRateWithTags) == 0x000108, "Wrong size on UTgfAnimNotifyState_MontagePlayRateWithTags");
static_assert(offsetof(UTgfAnimNotifyState_MontagePlayRateWithTags, Tags) == 0x000090, "Member 'UTgfAnimNotifyState_MontagePlayRateWithTags::Tags' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_MontagePlayRateWithTags, MaxTime) == 0x0000B0, "Member 'UTgfAnimNotifyState_MontagePlayRateWithTags::MaxTime' has a wrong offset!");

// Class LyraGame.AbilityTask_TickMonitor
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_TickMonitor final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnMonitorSatisfied;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_TickMonitor* WaitMonitorSatisfied(class UGameplayAbility* OwningAbility, class FName TaskName, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_TickMonitor">();
	}
	static class UAbilityTask_TickMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_TickMonitor>();
	}
};
static_assert(alignof(UAbilityTask_TickMonitor) == 0x000008, "Wrong alignment on UAbilityTask_TickMonitor");
static_assert(sizeof(UAbilityTask_TickMonitor) == 0x0000A0, "Wrong size on UAbilityTask_TickMonitor");
static_assert(offsetof(UAbilityTask_TickMonitor, OnMonitorSatisfied) == 0x000080, "Member 'UAbilityTask_TickMonitor::OnMonitorSatisfied' has a wrong offset!");

// Class LyraGame.AbilityTask_WaitForInteractableTargets
// 0x0030 (0x00B0 - 0x0080)
class UAbilityTask_WaitForInteractableTargets : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             InteractableObjectsChanged;                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitForInteractableTargets">();
	}
	static class UAbilityTask_WaitForInteractableTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitForInteractableTargets>();
	}
};
static_assert(alignof(UAbilityTask_WaitForInteractableTargets) == 0x000008, "Wrong alignment on UAbilityTask_WaitForInteractableTargets");
static_assert(sizeof(UAbilityTask_WaitForInteractableTargets) == 0x0000B0, "Wrong size on UAbilityTask_WaitForInteractableTargets");
static_assert(offsetof(UAbilityTask_WaitForInteractableTargets, InteractableObjectsChanged) == 0x000080, "Member 'UAbilityTask_WaitForInteractableTargets::InteractableObjectsChanged' has a wrong offset!");

// Class LyraGame.TgfCameraFovSettingDataAsset
// 0x0008 (0x0038 - 0x0030)
class UTgfCameraFovSettingDataAsset final : public UPrimaryDataAsset
{
public:
	float                                         FieldOfView;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfViewAlt;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraFovSettingDataAsset">();
	}
	static class UTgfCameraFovSettingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraFovSettingDataAsset>();
	}
};
static_assert(alignof(UTgfCameraFovSettingDataAsset) == 0x000008, "Wrong alignment on UTgfCameraFovSettingDataAsset");
static_assert(sizeof(UTgfCameraFovSettingDataAsset) == 0x000038, "Wrong size on UTgfCameraFovSettingDataAsset");
static_assert(offsetof(UTgfCameraFovSettingDataAsset, FieldOfView) == 0x000030, "Member 'UTgfCameraFovSettingDataAsset::FieldOfView' has a wrong offset!");
static_assert(offsetof(UTgfCameraFovSettingDataAsset, FieldOfViewAlt) == 0x000034, "Member 'UTgfCameraFovSettingDataAsset::FieldOfViewAlt' has a wrong offset!");

// Class LyraGame.AbilityTask_WaitForInteractableTargets_ProjectileTrace
// 0x00E0 (0x0190 - 0x00B0)
class UAbilityTask_WaitForInteractableTargets_ProjectileTrace final : public UAbilityTask_WaitForInteractableTargets
{
public:
	struct FGameplayAbilityTargetingLocationInfo  StartLocation;                                     // 0x00B0(0x00A0)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x40];                                     // 0x0150(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitForInteractableTargets_ProjectileTrace* WaitForInteractableTargets_ProjectileTrace(class UGameplayAbility* OwningAbility, const struct FCollisionProfileName& TraceProfile, float InteractionScanRate, const struct FGameplayAbilityTargetingLocationInfo& Param_StartLocation, float ProjectileRadius, const struct FVector& LaunchVelocity, float MaxSimTime, ECollisionChannel TraceChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitForInteractableTargets_ProjectileTrace">();
	}
	static class UAbilityTask_WaitForInteractableTargets_ProjectileTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitForInteractableTargets_ProjectileTrace>();
	}
};
static_assert(alignof(UAbilityTask_WaitForInteractableTargets_ProjectileTrace) == 0x000010, "Wrong alignment on UAbilityTask_WaitForInteractableTargets_ProjectileTrace");
static_assert(sizeof(UAbilityTask_WaitForInteractableTargets_ProjectileTrace) == 0x000190, "Wrong size on UAbilityTask_WaitForInteractableTargets_ProjectileTrace");
static_assert(offsetof(UAbilityTask_WaitForInteractableTargets_ProjectileTrace, StartLocation) == 0x0000B0, "Member 'UAbilityTask_WaitForInteractableTargets_ProjectileTrace::StartLocation' has a wrong offset!");

// Class LyraGame.TgfGameWidgetBase
// 0x0018 (0x02B0 - 0x0298)
class UTgfGameWidgetBase : public UTickerUserWidget
{
public:
	class ALyraCharacter*                         CustomCharacter;                                   // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ALyraCharacter* GetGameWidgetCharacter();
	void SetCustomCharacter(class ALyraCharacter* InCharacter);

	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;
	class ALyraPlayerController* GetLyraPlayerController() const;
	class ULyraAbilitySystemComponent* GetSelfLyraAbilitySystemComponent() const;
	class UTgfEquipmentManagerComponent* GetTgfEquipmentManagerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameWidgetBase">();
	}
	static class UTgfGameWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameWidgetBase>();
	}
};
static_assert(alignof(UTgfGameWidgetBase) == 0x000008, "Wrong alignment on UTgfGameWidgetBase");
static_assert(sizeof(UTgfGameWidgetBase) == 0x0002B0, "Wrong size on UTgfGameWidgetBase");
static_assert(offsetof(UTgfGameWidgetBase, CustomCharacter) == 0x000298, "Member 'UTgfGameWidgetBase::CustomCharacter' has a wrong offset!");

// Class LyraGame.TgfDashBoardWidget
// 0x01A0 (0x0450 - 0x02B0)
class UTgfDashBoardWidget final : public UTgfGameWidgetBase
{
public:
	TMap<struct FActiveGameplayEffectHandle, class UUserWidget*> ActiveBuffWidget;                                  // 0x02B0(0x0050)(Edit, BlueprintVisible, ExportObject, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FString>      FailedTextMap;                                     // 0x0300(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FActorCareerRacePair, EHealthBarType> HealthBarConfig;                                   // 0x0350(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class ULyraAbilitySystemComponent*            OtherLyraASC;                                      // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachCarreer;                                    // 0x03A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayAbility>>   IgnoreFailedList;                                  // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x28];                                     // 0x03C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAbilitySystemComponent*            LyraASC;                                           // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfMagicAttributeSet*                  MagicAttributeSet;                                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x58];                                     // 0x03F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnApplyGECallback(class UAbilitySystemComponent* Target, const class UGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void BP_OnBuffAdd(class UTgfGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle, float RemainTime, float TotalTime, int32 StackCnt);
	void BP_OnCastFailed(const class UGameplayAbility* FailedGA, const struct FGameplayTag& Tag, const class FString& FailedText);
	void BP_OnGEDurationChange(const struct FActiveGameplayEffectHandle& GEHandle, float NewTime, float TotalTime, int32 StackCnt);
	void BP_OnGERemove(const struct FActiveGameplayEffectHandle& GEHandle);
	void BP_OnListenedTagChange(const struct FGameplayTag& Tag, int32 NewCnt);
	void BP_OnViewTargetChanged();
	void CheckExistGE();
	bool GetCareerAndRaceFromNecklace(ETgfActorCareer* OutCareer, ETgfActorRace* OutRace);
	float GetCurMagic();
	EHealthBarType GetHealthBarType(ETgfActorCareer Career, ETgfActorRace Race);
	float GetMaxMagicFinal();
	TArray<class UGameplayAbility*> GetTgfSkillGA(class ULyraAbilitySystemComponent* ASC, const TArray<struct FGameplayTag>& Tags);
	void ListenTagChanged(const struct FGameplayTagContainer& Container1, const struct FGameplayTagContainer& Container2);
	void OnChangeViewTarget(class AActor* NewViewTarget);
	void ResetListenedTags();
	void SetAttachCareer(bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfDashBoardWidget">();
	}
	static class UTgfDashBoardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfDashBoardWidget>();
	}
};
static_assert(alignof(UTgfDashBoardWidget) == 0x000008, "Wrong alignment on UTgfDashBoardWidget");
static_assert(sizeof(UTgfDashBoardWidget) == 0x000450, "Wrong size on UTgfDashBoardWidget");
static_assert(offsetof(UTgfDashBoardWidget, ActiveBuffWidget) == 0x0002B0, "Member 'UTgfDashBoardWidget::ActiveBuffWidget' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, FailedTextMap) == 0x000300, "Member 'UTgfDashBoardWidget::FailedTextMap' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, HealthBarConfig) == 0x000350, "Member 'UTgfDashBoardWidget::HealthBarConfig' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, OtherLyraASC) == 0x0003A0, "Member 'UTgfDashBoardWidget::OtherLyraASC' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, bAttachCarreer) == 0x0003A8, "Member 'UTgfDashBoardWidget::bAttachCarreer' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, IgnoreFailedList) == 0x0003B0, "Member 'UTgfDashBoardWidget::IgnoreFailedList' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, LyraASC) == 0x0003E8, "Member 'UTgfDashBoardWidget::LyraASC' has a wrong offset!");
static_assert(offsetof(UTgfDashBoardWidget, MagicAttributeSet) == 0x0003F0, "Member 'UTgfDashBoardWidget::MagicAttributeSet' has a wrong offset!");

// Class LyraGame.ActorMapComponent
// 0x0038 (0x00E0 - 0x00A8)
class UActorMapComponent final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTick;                                            // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          LastAIEnabled;                                     // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastActorDisabled;                                 // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActorClientDisabled;                               // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActorDSMeshEnabled;                                // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NextTick;                                          // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MoveNoiseEventEnabled;                             // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveNoiseEventInterval;                            // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateCharacterGravity(class AActor* LocalPawn, float DefaultGravity, float TargetGravity);
	void UpdateCharacterPlayerNameHeight(class AActor* LocalPawn, class UWidgetComponent* PlayNameComponent, class UCurveVector* LocationCurve);

	bool CheckInDistanceToLocalPlayer(float XYDis, float ZDis) const;
	class ALyraCharacter* GetLyraCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorMapComponent">();
	}
	static class UActorMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorMapComponent>();
	}
};
static_assert(alignof(UActorMapComponent) == 0x000008, "Wrong alignment on UActorMapComponent");
static_assert(sizeof(UActorMapComponent) == 0x0000E0, "Wrong size on UActorMapComponent");
static_assert(offsetof(UActorMapComponent, OnTick) == 0x0000A8, "Member 'UActorMapComponent::OnTick' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, LastAIEnabled) == 0x0000B8, "Member 'UActorMapComponent::LastAIEnabled' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, LastActorDisabled) == 0x0000BC, "Member 'UActorMapComponent::LastActorDisabled' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, ActorClientDisabled) == 0x0000C0, "Member 'UActorMapComponent::ActorClientDisabled' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, ActorDSMeshEnabled) == 0x0000C4, "Member 'UActorMapComponent::ActorDSMeshEnabled' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, NextTick) == 0x0000C8, "Member 'UActorMapComponent::NextTick' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, MoveNoiseEventEnabled) == 0x0000D0, "Member 'UActorMapComponent::MoveNoiseEventEnabled' has a wrong offset!");
static_assert(offsetof(UActorMapComponent, MoveNoiseEventInterval) == 0x0000D4, "Member 'UActorMapComponent::MoveNoiseEventInterval' has a wrong offset!");

// Class LyraGame.ActorMapSubsystem
// 0x0028 (0x0058 - 0x0030)
class UActorMapSubsystem final : public UWorldSubsystem
{
public:
	int32                                         MonsterAIEnableNum;                                // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterAITotalNum;                                 // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterTickEnableNum;                              // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterTickTotalNum;                               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MonsterActorMapAIBound;                            // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MonsterActorMapTickBound;                          // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ALyraCharacter*>                 HeroList;                                          // 0x0048(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddDeltaMonsterAINum(int32 Delta, int32 Total);
	void AddDeltaMonsterTickNum(int32 Delta, int32 Total);
	void AddHero(class ALyraCharacter* Hero);
	bool CheckCharacterEnabled(class ALyraCharacter* Character, float Bound);
	int32 GetCurrentHeroNum();
	void RemoveHero(class ALyraCharacter* Hero);
	void SetMonsterActorMapAIBound(float Bound);
	void SetMonsterActorMapTickBound(float Bound);

	float GetMonsterActorMapAIBound() const;
	float GetMonsterActorMapTickBound() const;
	int32 GetMonsterAIEnableNum() const;
	int32 GetMonsterAITotalNum() const;
	int32 GetMonsterTickEnableNum() const;
	int32 GetMonsterTickTotalNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorMapSubsystem">();
	}
	static class UActorMapSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorMapSubsystem>();
	}
};
static_assert(alignof(UActorMapSubsystem) == 0x000008, "Wrong alignment on UActorMapSubsystem");
static_assert(sizeof(UActorMapSubsystem) == 0x000058, "Wrong size on UActorMapSubsystem");
static_assert(offsetof(UActorMapSubsystem, MonsterAIEnableNum) == 0x000030, "Member 'UActorMapSubsystem::MonsterAIEnableNum' has a wrong offset!");
static_assert(offsetof(UActorMapSubsystem, MonsterAITotalNum) == 0x000034, "Member 'UActorMapSubsystem::MonsterAITotalNum' has a wrong offset!");
static_assert(offsetof(UActorMapSubsystem, MonsterTickEnableNum) == 0x000038, "Member 'UActorMapSubsystem::MonsterTickEnableNum' has a wrong offset!");
static_assert(offsetof(UActorMapSubsystem, MonsterTickTotalNum) == 0x00003C, "Member 'UActorMapSubsystem::MonsterTickTotalNum' has a wrong offset!");
static_assert(offsetof(UActorMapSubsystem, MonsterActorMapAIBound) == 0x000040, "Member 'UActorMapSubsystem::MonsterActorMapAIBound' has a wrong offset!");
static_assert(offsetof(UActorMapSubsystem, MonsterActorMapTickBound) == 0x000044, "Member 'UActorMapSubsystem::MonsterActorMapTickBound' has a wrong offset!");
static_assert(offsetof(UActorMapSubsystem, HeroList) == 0x000048, "Member 'UActorMapSubsystem::HeroList' has a wrong offset!");

// Class LyraGame.TgfCheckBox
// 0x0000 (0x0C80 - 0x0C80)
class UTgfCheckBox : public UCheckBox
{
public:
	void TgfOnCheckStateChanged(ECheckBoxState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCheckBox">();
	}
	static class UTgfCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCheckBox>();
	}
};
static_assert(alignof(UTgfCheckBox) == 0x000010, "Wrong alignment on UTgfCheckBox");
static_assert(sizeof(UTgfCheckBox) == 0x000C80, "Wrong size on UTgfCheckBox");

// Class LyraGame.AIBlueprintHelperExLibrary
// 0x0000 (0x0028 - 0x0028)
class UAIBlueprintHelperExLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetActorSimpleCollisionCylinderExtent(const class AActor* Actor);
	static float GetActorSimpleCollisionHalfHeight(const class AActor* Actor);
	static float GetActorSimpleCollisionRadius(const class AActor* Actor);
	static class UAISenseConfig* GetAISenseConfig(class AAIController* Controller, TSubclassOf<class UAISense> SenseClass);
	static float GetAISenseHearingRange(class AAIController* Controller);
	static float GetAISenseSightPeripheralVisionAngleDegrees(class AAIController* Controller);
	static float GetAISenseSightRadius(class AAIController* Controller);
	static void PauseLogic(class UBrainComponent* BrainComponent, const class FString& Reason);
	static void RefreshAIPerceptionStimuliSource(class UObject* WorldContextObject, TSubclassOf<class UAISense> Sense, class AActor* Target);
	static void ResumeLogic(class UBrainComponent* BrainComponent, const class FString& Reason);
	static void SetAISenseEnabled(class AAIController* Controller, TSubclassOf<class UAISense> SenseClass, bool bEnable);
	static void SetAISenseHearingRange(class AAIController* Controller, float Range);
	static void SetAISensesEnabled(class AAIController* Controller, bool bEnable);
	static void SetAISenseSightPeripheralVisionAngleDegrees(class AAIController* Controller, float Degrees);
	static void SetAISenseSightRadius(class AAIController* Controller, float Radius);
	static bool TestPathSync(class UObject* WorldContextObject, const struct FVector& PointA, const struct FVector& PointB, EPathExistanceQueryType PathQueryType, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool AllowPartialPaths);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIBlueprintHelperExLibrary">();
	}
	static class UAIBlueprintHelperExLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIBlueprintHelperExLibrary>();
	}
};
static_assert(alignof(UAIBlueprintHelperExLibrary) == 0x000008, "Wrong alignment on UAIBlueprintHelperExLibrary");
static_assert(sizeof(UAIBlueprintHelperExLibrary) == 0x000028, "Wrong size on UAIBlueprintHelperExLibrary");

// Class LyraGame.WaypointPath
// 0x0010 (0x0038 - 0x0028)
class UWaypointPath final : public UObject
{
public:
	TArray<struct FVector>                        Waypoints;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaypointPath">();
	}
	static class UWaypointPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaypointPath>();
	}
};
static_assert(alignof(UWaypointPath) == 0x000008, "Wrong alignment on UWaypointPath");
static_assert(sizeof(UWaypointPath) == 0x000038, "Wrong size on UWaypointPath");
static_assert(offsetof(UWaypointPath, Waypoints) == 0x000028, "Member 'UWaypointPath::Waypoints' has a wrong offset!");

// Class LyraGame.TgfEquipmentBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfEquipmentBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckFirstPerson(class AActor* Target);
	static void DealEquipAddCondAttr(class ALyraCharacter* Instigator, class ALyraCharacter* Target, TArray<struct FGameplayEffectSpec>* GESpecToApply);
	static void DealEquipRemoveCondAttr(class ALyraCharacter* Instigator, class ALyraCharacter* Target, TArray<struct FGameplayEffectSpec>* GESpecApplied);
	static void RestoreFOVConfig(class UMaterialInterface* OriginMat, class UMaterialInterface* ReplaceMat);
	static void SetAllFOVConfigForCharacter(class USkeletalMeshComponent* Mesh, bool bEnable);
	static void SetAlphaConfig(class UFXSystemComponent* FxComp, float Value);
	static void SetFOVConfig(class UFXSystemComponent* FxComp, bool Enabled);
	static void SetFOVConfigWithCheckBP(class AActor* Target, class UFXSystemComponent* FxComp);
	static void SetFOVMeshConfig(class UMeshComponent* MeshComp, bool Enabled);
	static void SetFOVMeshConfigWithCheckBP(class AActor* Target, class UMeshComponent* MeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentBlueprintLibrary">();
	}
	static class UTgfEquipmentBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentBlueprintLibrary>();
	}
};
static_assert(alignof(UTgfEquipmentBlueprintLibrary) == 0x000008, "Wrong alignment on UTgfEquipmentBlueprintLibrary");
static_assert(sizeof(UTgfEquipmentBlueprintLibrary) == 0x000028, "Wrong size on UTgfEquipmentBlueprintLibrary");

// Class LyraGame.AsyncAction_UntilItemReadyForPaint
// 0x0028 (0x0058 - 0x0030)
class UAsyncAction_UntilItemReadyForPaint final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_UntilItemReadyForPaint* UntilEquipmentReadyForPaint(class UObject* WorldContextObject, class UTgfEquipmentWrapper* Equipment);
	static class UAsyncAction_UntilItemReadyForPaint* UntilInventoryItemReadyForPaint(class UObject* WorldContextObject, class UTgfInventoryItemWrapper* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_UntilItemReadyForPaint">();
	}
	static class UAsyncAction_UntilItemReadyForPaint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_UntilItemReadyForPaint>();
	}
};
static_assert(alignof(UAsyncAction_UntilItemReadyForPaint) == 0x000008, "Wrong alignment on UAsyncAction_UntilItemReadyForPaint");
static_assert(sizeof(UAsyncAction_UntilItemReadyForPaint) == 0x000058, "Wrong size on UAsyncAction_UntilItemReadyForPaint");
static_assert(offsetof(UAsyncAction_UntilItemReadyForPaint, OnReady) == 0x000030, "Member 'UAsyncAction_UntilItemReadyForPaint::OnReady' has a wrong offset!");

// Class LyraGame.AsyncAction_InventoryItemRightClickOverride
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_InventoryItemRightClickOverride final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnTrigger;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_InventoryItemRightClickOverride* Create(class UObject* WorldContextObject, class UTgfInventoryWrapper* InventoryContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_InventoryItemRightClickOverride">();
	}
	static class UAsyncAction_InventoryItemRightClickOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_InventoryItemRightClickOverride>();
	}
};
static_assert(alignof(UAsyncAction_InventoryItemRightClickOverride) == 0x000008, "Wrong alignment on UAsyncAction_InventoryItemRightClickOverride");
static_assert(sizeof(UAsyncAction_InventoryItemRightClickOverride) == 0x000050, "Wrong size on UAsyncAction_InventoryItemRightClickOverride");
static_assert(offsetof(UAsyncAction_InventoryItemRightClickOverride, OnTrigger) == 0x000030, "Member 'UAsyncAction_InventoryItemRightClickOverride::OnTrigger' has a wrong offset!");

// Class LyraGame.TgfBlueprintableObject
// 0x0000 (0x0028 - 0x0028)
class UTgfBlueprintableObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBlueprintableObject">();
	}
	static class UTgfBlueprintableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBlueprintableObject>();
	}
};
static_assert(alignof(UTgfBlueprintableObject) == 0x000008, "Wrong alignment on UTgfBlueprintableObject");
static_assert(sizeof(UTgfBlueprintableObject) == 0x000028, "Wrong size on UTgfBlueprintableObject");

// Class LyraGame.TgfInventoryRoleWrapper
// 0x0008 (0x0030 - 0x0028)
class UTgfInventoryRoleWrapper : public UTgfBlueprintableObject
{
public:
	class ALyraCharacter*                         Character;                                         // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetMaxHealth();
	float GetRoleAttributeValue(EnRoleDisplayAttribueID Type_id);
	void GetTalentOfFirstLevelAttribute(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, const struct FGameplayAttribute& ConditionalAttr, TArray<struct FTgfCareerTalentCfgItem>* Configs);
	void GetTalentsOfAttribute(EnRoleDisplayAttribueID Type_id, TArray<int32>* Talents, TArray<int32>* OpenedTalents);

	class ALyraCharacter* GetOwningCharacter() const;
	class UTgfGameplayAbility* GetSkillE() const;
	class UTgfGameplayAbility* GetSkillQ() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryRoleWrapper">();
	}
	static class UTgfInventoryRoleWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryRoleWrapper>();
	}
};
static_assert(alignof(UTgfInventoryRoleWrapper) == 0x000008, "Wrong alignment on UTgfInventoryRoleWrapper");
static_assert(sizeof(UTgfInventoryRoleWrapper) == 0x000030, "Wrong size on UTgfInventoryRoleWrapper");
static_assert(offsetof(UTgfInventoryRoleWrapper, Character) == 0x000028, "Member 'UTgfInventoryRoleWrapper::Character' has a wrong offset!");

// Class LyraGame.AsyncAction_InventoryItemLeftClickOverride
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_InventoryItemLeftClickOverride final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnTrigger;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_InventoryItemLeftClickOverride* Create(class UObject* WorldContextObject, class UTgfInventoryWrapper* InventoryContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_InventoryItemLeftClickOverride">();
	}
	static class UAsyncAction_InventoryItemLeftClickOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_InventoryItemLeftClickOverride>();
	}
};
static_assert(alignof(UAsyncAction_InventoryItemLeftClickOverride) == 0x000008, "Wrong alignment on UAsyncAction_InventoryItemLeftClickOverride");
static_assert(sizeof(UAsyncAction_InventoryItemLeftClickOverride) == 0x000050, "Wrong size on UAsyncAction_InventoryItemLeftClickOverride");
static_assert(offsetof(UAsyncAction_InventoryItemLeftClickOverride, OnTrigger) == 0x000030, "Member 'UAsyncAction_InventoryItemLeftClickOverride::OnTrigger' has a wrong offset!");

// Class LyraGame.AudioObstacleDetectionComponent
// 0x0160 (0x0208 - 0x00A8)
class UAudioObstacleDetectionComponent final : public UActorComponent
{
public:
	bool                                          EnableComponent;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FrameInterval;                                     // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DetectionDistanceThreshold;                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TracingRowNumber;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TracingColumnNumber;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TracingCellInterval;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DiffractionImageOcclusion;                         // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        WeightValue;                                       // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoopMode;                                          // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDebug;                                       // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x126];                                     // 0x00E2(0x0126)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetOneShotObstructionAndOcclusion(class UAkComponent* SpeakerComponent, const class AActor* IgnoredActor);

	void OneShotDiffractionDetection();
	void OnListenerActorChange(class AActor* InActor);
	void SetDiffractionSoundPoints(class UAkComponent* SpeakerComponent);
	void SetOcclusion(const class UAkComponent* SpeakerComponent);
	void ShowDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioObstacleDetectionComponent">();
	}
	static class UAudioObstacleDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioObstacleDetectionComponent>();
	}
};
static_assert(alignof(UAudioObstacleDetectionComponent) == 0x000008, "Wrong alignment on UAudioObstacleDetectionComponent");
static_assert(sizeof(UAudioObstacleDetectionComponent) == 0x000208, "Wrong size on UAudioObstacleDetectionComponent");
static_assert(offsetof(UAudioObstacleDetectionComponent, EnableComponent) == 0x0000A8, "Member 'UAudioObstacleDetectionComponent::EnableComponent' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, FrameInterval) == 0x0000AC, "Member 'UAudioObstacleDetectionComponent::FrameInterval' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, HeightOffset) == 0x0000B0, "Member 'UAudioObstacleDetectionComponent::HeightOffset' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, DetectionDistanceThreshold) == 0x0000B8, "Member 'UAudioObstacleDetectionComponent::DetectionDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, TracingRowNumber) == 0x0000C0, "Member 'UAudioObstacleDetectionComponent::TracingRowNumber' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, TracingColumnNumber) == 0x0000C4, "Member 'UAudioObstacleDetectionComponent::TracingColumnNumber' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, TracingCellInterval) == 0x0000C8, "Member 'UAudioObstacleDetectionComponent::TracingCellInterval' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, DiffractionImageOcclusion) == 0x0000D0, "Member 'UAudioObstacleDetectionComponent::DiffractionImageOcclusion' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, WeightValue) == 0x0000D8, "Member 'UAudioObstacleDetectionComponent::WeightValue' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, LoopMode) == 0x0000E0, "Member 'UAudioObstacleDetectionComponent::LoopMode' has a wrong offset!");
static_assert(offsetof(UAudioObstacleDetectionComponent, EnableDebug) == 0x0000E1, "Member 'UAudioObstacleDetectionComponent::EnableDebug' has a wrong offset!");

// Class LyraGame.TgfFaceDataAsset
// 0x0020 (0x0050 - 0x0030)
class UTgfFaceDataAsset : public UPrimaryDataAsset
{
public:
	TArray<struct FTgfFaceConfig>                 FaceConfigs;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTgfSkinConfig>                 SkinConfigs;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFaceDataAsset">();
	}
	static class UTgfFaceDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFaceDataAsset>();
	}
};
static_assert(alignof(UTgfFaceDataAsset) == 0x000008, "Wrong alignment on UTgfFaceDataAsset");
static_assert(sizeof(UTgfFaceDataAsset) == 0x000050, "Wrong size on UTgfFaceDataAsset");
static_assert(offsetof(UTgfFaceDataAsset, FaceConfigs) == 0x000030, "Member 'UTgfFaceDataAsset::FaceConfigs' has a wrong offset!");
static_assert(offsetof(UTgfFaceDataAsset, SkinConfigs) == 0x000040, "Member 'UTgfFaceDataAsset::SkinConfigs' has a wrong offset!");

// Class LyraGame.AudioRoomShapeAsset
// 0x0010 (0x0040 - 0x0030)
class UAudioRoomShapeAsset final : public UDataAsset
{
public:
	int32                                         TotalAverageNum;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestorePlaneThreshold;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerPlaneThreshold;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageDifferenceThreshold;                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioRoomShapeAsset">();
	}
	static class UAudioRoomShapeAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioRoomShapeAsset>();
	}
};
static_assert(alignof(UAudioRoomShapeAsset) == 0x000008, "Wrong alignment on UAudioRoomShapeAsset");
static_assert(sizeof(UAudioRoomShapeAsset) == 0x000040, "Wrong size on UAudioRoomShapeAsset");
static_assert(offsetof(UAudioRoomShapeAsset, TotalAverageNum) == 0x000030, "Member 'UAudioRoomShapeAsset::TotalAverageNum' has a wrong offset!");
static_assert(offsetof(UAudioRoomShapeAsset, RestorePlaneThreshold) == 0x000034, "Member 'UAudioRoomShapeAsset::RestorePlaneThreshold' has a wrong offset!");
static_assert(offsetof(UAudioRoomShapeAsset, TriggerPlaneThreshold) == 0x000038, "Member 'UAudioRoomShapeAsset::TriggerPlaneThreshold' has a wrong offset!");
static_assert(offsetof(UAudioRoomShapeAsset, AverageDifferenceThreshold) == 0x00003C, "Member 'UAudioRoomShapeAsset::AverageDifferenceThreshold' has a wrong offset!");

// Class LyraGame.AudioRoomShapeComponent
// 0x0180 (0x0228 - 0x00A8)
class UAudioRoomShapeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x180];                                     // 0x00A8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioRoomShapeComponent">();
	}
	static class UAudioRoomShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioRoomShapeComponent>();
	}
};
static_assert(alignof(UAudioRoomShapeComponent) == 0x000008, "Wrong alignment on UAudioRoomShapeComponent");
static_assert(sizeof(UAudioRoomShapeComponent) == 0x000228, "Wrong size on UAudioRoomShapeComponent");

// Class LyraGame.TgfCursorPayloadFunctions
// 0x0000 (0x0028 - 0x0028)
class UTgfCursorPayloadFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void DiscardCursorPayload();
	static struct FEventReply InstigateCursorPayload(const struct FPointerEvent& MouseEvent, class UDragDropOperation* DragDropOperation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCursorPayloadFunctions">();
	}
	static class UTgfCursorPayloadFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCursorPayloadFunctions>();
	}
};
static_assert(alignof(UTgfCursorPayloadFunctions) == 0x000008, "Wrong alignment on UTgfCursorPayloadFunctions");
static_assert(sizeof(UTgfCursorPayloadFunctions) == 0x000028, "Wrong size on UTgfCursorPayloadFunctions");

// Class LyraGame.BattleDsBpFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UBattleDsBpFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void FillOssLogPlayerInteraction(class ALyraCharacter* InCharacter, const class FString& InTargetName, const struct FVector& InLocation, int32 ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDsBpFuncLibrary">();
	}
	static class UBattleDsBpFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDsBpFuncLibrary>();
	}
};
static_assert(alignof(UBattleDsBpFuncLibrary) == 0x000008, "Wrong alignment on UBattleDsBpFuncLibrary");
static_assert(sizeof(UBattleDsBpFuncLibrary) == 0x000028, "Wrong size on UBattleDsBpFuncLibrary");

// Class LyraGame.BattleDsUtility
// 0x0320 (0x0350 - 0x0030)
class UBattleDsUtility final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x298];                                     // 0x0030(0x0298)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             RoomReadyDelegate;                                 // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameStateOptionArgsInitDelegate;                   // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             WaitingRoomLeaveDelegate;                          // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerLoginSuccessDelegate;                        // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerWaitingRoomLogoutDelegate;                   // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerDisconnectEvent;                             // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x28];                                     // 0x0328(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameOver();
	int32 GetCurrentUserCount();
	void GetFlawlessTrialLevelArgs(bool* _Flawless, int32* _WinningStreak, bool* _bRewardsAvailable);
	void GetHomelandLevelArgs(int64* _LastMoonEyeInteractionTimeStamp, int64* _CurrentCycleTimeStamp, int64* _CycleLength);
	int32 GetTotalUserCount();
	float GetWaitingRoomTimeout();
	bool HasNextFloor();
	int32 InitGameMap(int32 Map_id, int32 Game_timeout, bool IsIndependentMapMode);
	void InitPlayerGameData(class APlayerState* PlayerState);
	bool IsOptionArgsInit();
	bool IsPlayerGameOver(class APlayerState* PlayerState);
	bool IsRoomReady();
	void OnMapFinish();
	const TArray<int32> OptionArgs();
	void PlayerDeadPlayerState(class APlayerState* PlayerState, bool bSmallBackpackActive);
	void PlayerUseItem(class APlayerState* PlayerState, int32 ItemId, int32 Count);
	void PVPGameWinTeam(int32 Faction_id);
	void PVPGameWinTeamRound(int32 Round_id, int32 Faction_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDsUtility">();
	}
	static class UBattleDsUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDsUtility>();
	}
};
static_assert(alignof(UBattleDsUtility) == 0x000008, "Wrong alignment on UBattleDsUtility");
static_assert(sizeof(UBattleDsUtility) == 0x000350, "Wrong size on UBattleDsUtility");
static_assert(offsetof(UBattleDsUtility, RoomReadyDelegate) == 0x0002C8, "Member 'UBattleDsUtility::RoomReadyDelegate' has a wrong offset!");
static_assert(offsetof(UBattleDsUtility, GameStateOptionArgsInitDelegate) == 0x0002D8, "Member 'UBattleDsUtility::GameStateOptionArgsInitDelegate' has a wrong offset!");
static_assert(offsetof(UBattleDsUtility, WaitingRoomLeaveDelegate) == 0x0002E8, "Member 'UBattleDsUtility::WaitingRoomLeaveDelegate' has a wrong offset!");
static_assert(offsetof(UBattleDsUtility, PlayerLoginSuccessDelegate) == 0x0002F8, "Member 'UBattleDsUtility::PlayerLoginSuccessDelegate' has a wrong offset!");
static_assert(offsetof(UBattleDsUtility, PlayerWaitingRoomLogoutDelegate) == 0x000308, "Member 'UBattleDsUtility::PlayerWaitingRoomLogoutDelegate' has a wrong offset!");
static_assert(offsetof(UBattleDsUtility, PlayerDisconnectEvent) == 0x000318, "Member 'UBattleDsUtility::PlayerDisconnectEvent' has a wrong offset!");

// Class LyraGame.LyraGameplayAbility
// 0x02B0 (0x0688 - 0x03D8)
class ULyraGameplayAbility : public UGameplayAbility
{
public:
	bool                                          bIsActiveAbility;                                  // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ListStatisticID;                                   // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTgfSkillCastMontageSet                CastMontageSet;                                    // 0x03F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTgfSkillCastPhaseMontageSet>   PhaseCastMontageList;                              // 0x0410(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CosmeticTags;                                      // 0x0420(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UObject*                                ActivateSourceObject;                              // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELyraAbilityActivationPolicy                  ActivationPolicy;                                  // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELyraAbilityActivationGroup                   ActivationGroup;                                   // 0x0449(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44A[0x6];                                      // 0x044A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      ActivationBlockTagQuery;                           // 0x0450(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      SourceBlockTagQuery;                               // 0x0498(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      TargetBlockTagQuery;                               // 0x04E0(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          IgnoreServerTagRequirements;                       // 0x0528(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_529[0x7];                                      // 0x0529(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActivateAbilityEventTags;                          // 0x0530(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EndAbilityEventTags;                               // 0x0550(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CancelAbilityEventTags;                            // 0x0570(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CommitAbilityEventTags;                            // 0x0590(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class ULyraAbilityCost*>               AdditionalCosts;                                   // 0x05B0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CustomMissTag;                                     // 0x05C0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class FText>        FailureTagToUserFacingMessages;                    // 0x05C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAnimMontage*> FailureTagToAnimMontage;                           // 0x0618(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bLogCancelation;                                   // 0x0668(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_669[0x17];                                     // 0x0669(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bActivateFromEventFirst;                           // 0x0680(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_681[0x7];                                      // 0x0681(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToASCTarget(class UAbilitySystemComponent* Target, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks);
	bool ChangeActivationGroup(ELyraAbilityActivationGroup NewGroup);
	void ClearCameraMode();
	void ClearCameraModeFromServer();
	struct FActiveGameplayEffectHandle K2_ApplyGameplayEffectSpecToASCTarget(const struct FGameplayEffectSpecHandle& EffectSpecHandle, class UAbilitySystemComponent* Target);
	void K2_OnAbilityAdded();
	void K2_OnAbilityRemoved();
	void K2_OnPawnAvatarSet();
	void OnCameraModeDelayTimeFinish();
	bool PickBestCastSkillMontage(const struct FGameplayTagContainer& CosmeticTag, ETgfMontageEntryType EntryType, class UAnimMontage** FindMontage, class FName* SectionName);
	bool PickBestCastSkillMontage_FilteredWithTag(const struct FGameplayTagContainer& CosmeticTag, const struct FGameplayTag& FilterTag, ETgfMontageEntryType EntryType, class UAnimMontage** FindMontage, class FName* SectionName);
	void ReceiveInputPressed(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilityActivationInfo& ActivationInfo);
	void ReceiveInputReleased(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilityActivationInfo& ActivationInfo);
	void RemoveGameplayEffectFromOwnerExcludedAssetTags(const struct FGameplayTagContainer& ExcludedTags, int32 StacksToRemove);
	void SetAutoRecoverCameraMode(TSubclassOf<class ULyraCameraMode> CameraMode, float DelayTime);
	void SetCameraMode(TSubclassOf<class ULyraCameraMode> CameraMode);
	void SetCameraModeFromServer(TSubclassOf<class ULyraCameraMode> CameraMode);

	bool CanChangeActivationGroup(ELyraAbilityActivationGroup NewGroup) const;
	class AController* GetControllerFromActorInfo() const;
	class ULyraHeroComponent* GetHeroComponentFromActorInfo() const;
	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponentFromActorInfo() const;
	class ALyraCharacter* GetLyraCharacterFromActorInfo() const;
	class ALyraPlayerController* GetLyraPlayerControllerFromActorInfo() const;
	void ScriptOnAbilityFailedToActivate(const struct FGameplayTagContainer& FailedReason) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayAbility">();
	}
	static class ULyraGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayAbility>();
	}
};
static_assert(alignof(ULyraGameplayAbility) == 0x000008, "Wrong alignment on ULyraGameplayAbility");
static_assert(sizeof(ULyraGameplayAbility) == 0x000688, "Wrong size on ULyraGameplayAbility");
static_assert(offsetof(ULyraGameplayAbility, bIsActiveAbility) == 0x0003D8, "Member 'ULyraGameplayAbility::bIsActiveAbility' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, ListStatisticID) == 0x0003E0, "Member 'ULyraGameplayAbility::ListStatisticID' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, CastMontageSet) == 0x0003F0, "Member 'ULyraGameplayAbility::CastMontageSet' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, PhaseCastMontageList) == 0x000410, "Member 'ULyraGameplayAbility::PhaseCastMontageList' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, CosmeticTags) == 0x000420, "Member 'ULyraGameplayAbility::CosmeticTags' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, ActivateSourceObject) == 0x000440, "Member 'ULyraGameplayAbility::ActivateSourceObject' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, ActivationPolicy) == 0x000448, "Member 'ULyraGameplayAbility::ActivationPolicy' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, ActivationGroup) == 0x000449, "Member 'ULyraGameplayAbility::ActivationGroup' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, ActivationBlockTagQuery) == 0x000450, "Member 'ULyraGameplayAbility::ActivationBlockTagQuery' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, SourceBlockTagQuery) == 0x000498, "Member 'ULyraGameplayAbility::SourceBlockTagQuery' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, TargetBlockTagQuery) == 0x0004E0, "Member 'ULyraGameplayAbility::TargetBlockTagQuery' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, IgnoreServerTagRequirements) == 0x000528, "Member 'ULyraGameplayAbility::IgnoreServerTagRequirements' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, ActivateAbilityEventTags) == 0x000530, "Member 'ULyraGameplayAbility::ActivateAbilityEventTags' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, EndAbilityEventTags) == 0x000550, "Member 'ULyraGameplayAbility::EndAbilityEventTags' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, CancelAbilityEventTags) == 0x000570, "Member 'ULyraGameplayAbility::CancelAbilityEventTags' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, CommitAbilityEventTags) == 0x000590, "Member 'ULyraGameplayAbility::CommitAbilityEventTags' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, AdditionalCosts) == 0x0005B0, "Member 'ULyraGameplayAbility::AdditionalCosts' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, CustomMissTag) == 0x0005C0, "Member 'ULyraGameplayAbility::CustomMissTag' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, FailureTagToUserFacingMessages) == 0x0005C8, "Member 'ULyraGameplayAbility::FailureTagToUserFacingMessages' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, FailureTagToAnimMontage) == 0x000618, "Member 'ULyraGameplayAbility::FailureTagToAnimMontage' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, bLogCancelation) == 0x000668, "Member 'ULyraGameplayAbility::bLogCancelation' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility, bActivateFromEventFirst) == 0x000680, "Member 'ULyraGameplayAbility::bActivateFromEventFirst' has a wrong offset!");

// Class LyraGame.TgfGameplayAbility
// 0x02F8 (0x0980 - 0x0688)
class UTgfGameplayAbility : public ULyraGameplayAbility
{
public:
	uint8                                         Pad_688[0x4];                                      // 0x0688(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GameplayAbilityId;                                 // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTgfAIAbilityRule*                      AIAbilityRule;                                     // 0x0690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAGRTraceData                          LeftHandWeaponTrace;                               // 0x06A0(0x0140)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAGRTraceData                          RightHandWeaponTrace;                              // 0x07E0(0x0140)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAGRTraceData>                  PlayerBodyTrace;                                   // 0x0920(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          UseSkillCooldownScaleRate;                         // 0x0930(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreNoActiveAbilityBuffStateCheck;               // 0x0931(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreWeaponHand;                                  // 0x0932(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_933[0x5];                                      // 0x0933(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfSubLevelChargeConfig>       MultiLevelCharge;                                  // 0x0938(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTimerHandle>                   MultiLevelChargeHandle;                            // 0x0948(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_958[0x8];                                      // 0x0958(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableActiveCDCheck;                               // 0x0960(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableActiveCDUpdate;                              // 0x0961(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_962[0x2];                                      // 0x0962(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreActiveCD;                                       // 0x0964(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostActiveCD;                                      // 0x0968(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96C[0x4];                                      // 0x096C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfAbilityPostActiveCD>        RelatedAbilityPostActiveCDs;                       // 0x0970(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void ApplyAOEGameplayEffect(TArray<class AActor*>& Actors, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 MaxNum, ELyraTeamComparison TeamRestrict, TArray<class ALyraCharacter*>* AppliedActors, const struct FTgfApplyAOEExtraParam& ExtraParams);
	struct FActiveGameplayEffectHandle ApplyGameplayEffectToOwnerWithTags(const struct FGameplayTagContainer& Tags, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks);
	TArray<struct FActiveGameplayEffectHandle> ApplyGameplayEffectToTargetWithTags(const struct FGameplayTagContainer& Tags, const struct FGameplayAbilityTargetDataHandle& Target, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks);
	void ApplyGameplayEffectWithTags(const struct FGameplayTagContainer& Tags, const TDelegate<void()>& Callback);
	bool CheckAbilityTaskMonitorSatisfied();
	bool CheckValidFromInputTag(const struct FGameplayTag& InputTag);
	bool CommitSubAbilityCost(float& OutMagicCost, const class UGameplayEffect* CostGE, const struct FGameplayAttribute& CostAttribute, bool IgnoreCostCheck);
	bool DisperseActiveBuff(TArray<class AActor*>& Actors, const struct FGameplayTag& Tag, const struct FGameplayTagContainer& HighPriorityTags, int32 Num);
	void GetCollectableActors(TArray<struct FTgfCollectableActorInfo>* OutActorInfos, class AActor* SourceActor, float Radius, float CheckAngle, ETraceTypeQuery TraceChannel, bool bIgnoreBlock);
	struct FGameplayTag GetCooldownTag();
	float GetCooldownTimeDuration();
	class UTgfSkillWidgetBase* GetSkillWidget(bool bIgnoreTagCheck);
	class UGameplayAbility* GetSpecGA();
	bool K2_CheckValidFromInputTag(const struct FGameplayTag& InputTag);
	struct FGameplayEffectContextHandle MakeEffectContextSimple();
	bool MatchCoolDownTagBySpecHandle(const struct FGameplayEffectSpecHandle& SpecHandle);
	void PostEndAbility(class UGameplayAbility* ActivatedAbility);
	void RegisterEndAbilityCallback();

	bool CheckAdditionCooldownTags(const struct FGameplayTagContainer& AdditionalTags) const;
	bool CheckEquipmentInstanceRestrict(const class UObject* SourceObject, const class UGameplayAbility* AbilityInstance) const;
	bool CheckEquipmentInstanceValid(const class UObject* TargetObject) const;
	bool CheckSubAbilityCost(const class UGameplayEffect* CostGE, struct FGameplayTag* FailedTag) const;
	const class ULyraEquipmentInstance* GetAnotherEquipmentInstance() const;
	const class ULyraEquipmentInstance* GetSourceEquipmentInstance() const;
	ETgfWeaponHandType GetWeaponHandType() const;
	bool HasTalentTag(const struct FGameplayTag& TagToCheck) const;
	bool IsCharacterStateValid() const;
	bool IsCurrentActive() const;
	bool IsUsingWeapon(ETgfEquipSubType EquipSubType) const;
	class UGameplayEffect* K2_GetCooldownGameplayEffect() const;
	bool K2_PostCheckCooldown(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, bool CheckResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility">();
	}
	static class UTgfGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility>();
	}
};
static_assert(alignof(UTgfGameplayAbility) == 0x000010, "Wrong alignment on UTgfGameplayAbility");
static_assert(sizeof(UTgfGameplayAbility) == 0x000980, "Wrong size on UTgfGameplayAbility");
static_assert(offsetof(UTgfGameplayAbility, GameplayAbilityId) == 0x00068C, "Member 'UTgfGameplayAbility::GameplayAbilityId' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, AIAbilityRule) == 0x000690, "Member 'UTgfGameplayAbility::AIAbilityRule' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, LeftHandWeaponTrace) == 0x0006A0, "Member 'UTgfGameplayAbility::LeftHandWeaponTrace' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, RightHandWeaponTrace) == 0x0007E0, "Member 'UTgfGameplayAbility::RightHandWeaponTrace' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, PlayerBodyTrace) == 0x000920, "Member 'UTgfGameplayAbility::PlayerBodyTrace' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, UseSkillCooldownScaleRate) == 0x000930, "Member 'UTgfGameplayAbility::UseSkillCooldownScaleRate' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, IgnoreNoActiveAbilityBuffStateCheck) == 0x000931, "Member 'UTgfGameplayAbility::IgnoreNoActiveAbilityBuffStateCheck' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, IgnoreWeaponHand) == 0x000932, "Member 'UTgfGameplayAbility::IgnoreWeaponHand' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, MultiLevelCharge) == 0x000938, "Member 'UTgfGameplayAbility::MultiLevelCharge' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, MultiLevelChargeHandle) == 0x000948, "Member 'UTgfGameplayAbility::MultiLevelChargeHandle' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, EnableActiveCDCheck) == 0x000960, "Member 'UTgfGameplayAbility::EnableActiveCDCheck' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, EnableActiveCDUpdate) == 0x000961, "Member 'UTgfGameplayAbility::EnableActiveCDUpdate' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, PreActiveCD) == 0x000964, "Member 'UTgfGameplayAbility::PreActiveCD' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, PostActiveCD) == 0x000968, "Member 'UTgfGameplayAbility::PostActiveCD' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility, RelatedAbilityPostActiveCDs) == 0x000970, "Member 'UTgfGameplayAbility::RelatedAbilityPostActiveCDs' has a wrong offset!");

// Class LyraGame.BattleUtility
// 0x0000 (0x0028 - 0x0028)
class UBattleUtility final : public UObject
{
public:
	static void AddItem(class UTgfInventoryManagerComponent* Component, int32 ItemId, int32 Nums, const class FString& ClassName);
	static TArray<class UTgfInventoryItemInstance*> CreateItemInstanceForLobby(class AActor* Owner, int32 ItemId, int32 ItemCnt, const class FString& ClassName);
	static ETgfEquipSubType GetEquipSubtype(class ULyraInventoryItemInstance* ItemInstance);
	static ETgfWeaponEquipType GetEquipType(class ULyraInventoryItemInstance* ItemInstance);
	static bool GetMatchedCareers(ETgfEquipSubType EquipType, TArray<ETgfActorCareer>* ActorCareer);
	static void GetTalentOfFirstLevelAttribute(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, const struct FGameplayAttribute& ConditionalAttr, TArray<struct FTgfCareerTalentCfgItem>* Configs);
	static bool GetTalentOfGameplayTag(const TArray<struct FTgfCareerTalentCfgItem>& Talents, const struct FGameplayTag& TagToCheck, struct FTgfCareerTalentCfgItem* OutTalent);
	static void GetTalents(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, TArray<struct FTgfCareerTalentCfgItem>* Configs);
	static void GetTalentsWithOrder(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, TArray<struct FTgfCareerTalentCfgItem>* Configs);
	static class UExcelLoaderTgfConfigExcelConstConfig* GetUExcelLoaderTgfConfigExcelConstConfig();
	static bool IsEquipMatchLeftWeapon(TSubclassOf<class UTgfInventoryItemDefinition> Main_weapon, ETgfEquipSubType Left_type);
	static TArray<class UTgfInventoryItemInstance*> Loot(class AActor* Owner, const class FString& SourceName, const class FString& UserKey, const TArray<class APlayerState*>& PlayerStates, class APlayerState* LootPlayerState, const class FString& ClassName, int32 LootType);
	static bool MatchCareer(ETgfEquipSubType EquipType, ETgfActorCareer ActorCareer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleUtility">();
	}
	static class UBattleUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleUtility>();
	}
};
static_assert(alignof(UBattleUtility) == 0x000008, "Wrong alignment on UBattleUtility");
static_assert(sizeof(UBattleUtility) == 0x000028, "Wrong size on UBattleUtility");

// Class LyraGame.BTDecorator_TimeLimitEx
// 0x0028 (0x0098 - 0x0070)
class UBTDecorator_TimeLimitEx final : public UBTDecorator_TimeLimit
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_TimeLimitEx">();
	}
	static class UBTDecorator_TimeLimitEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_TimeLimitEx>();
	}
};
static_assert(alignof(UBTDecorator_TimeLimitEx) == 0x000008, "Wrong alignment on UBTDecorator_TimeLimitEx");
static_assert(sizeof(UBTDecorator_TimeLimitEx) == 0x000098, "Wrong size on UBTDecorator_TimeLimitEx");
static_assert(offsetof(UBTDecorator_TimeLimitEx, BlackboardKey) == 0x000070, "Member 'UBTDecorator_TimeLimitEx::BlackboardKey' has a wrong offset!");

// Class LyraGame.TgfReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0240 (0x0290 - 0x0050)
class UTgfReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x220];                                     // 0x0050(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastPawn;                                          // 0x0270(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAlwaysRelevantActorInfo>       PastRelevantActors;                                // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UTgfReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UTgfReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UTgfReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UTgfReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000290, "Wrong size on UTgfReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UTgfReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000270, "Member 'UTgfReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");
static_assert(offsetof(UTgfReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x000278, "Member 'UTgfReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class LyraGame.BTTask_BlackboardObserve
// 0x0010 (0x00B8 - 0x00A8)
class UBTTask_BlackboardObserve : public UBTTask_BlueprintBase
{
public:
	FMulticastInlineDelegateProperty_             OnBlackboardValueChanged;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void RegisterObserve(uint8 KeyID);
	void UnregisterObserve();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_BlackboardObserve">();
	}
	static class UBTTask_BlackboardObserve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_BlackboardObserve>();
	}
};
static_assert(alignof(UBTTask_BlackboardObserve) == 0x000008, "Wrong alignment on UBTTask_BlackboardObserve");
static_assert(sizeof(UBTTask_BlackboardObserve) == 0x0000B8, "Wrong size on UBTTask_BlackboardObserve");
static_assert(offsetof(UBTTask_BlackboardObserve, OnBlackboardValueChanged) == 0x0000A8, "Member 'UBTTask_BlackboardObserve::OnBlackboardValueChanged' has a wrong offset!");

// Class LyraGame.CharacterSelectionComponent
// 0x0020 (0x00C8 - 0x00A8)
class UCharacterSelectionComponent : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCustomnTraceStartPos();
	void ClearFilterCallback();
	void SetCustomnTraceStartPos(TDelegate<void()> InGetTraceStartPosDelegate);
	void SetFilterCallback(TDelegate<void(class AActor* Actor)> InOnShouldActorSelected);

	struct FVector GetTraceStartPos(const class AController* Controller) const;
	bool IsActorValid(const class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectionComponent">();
	}
	static class UCharacterSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectionComponent>();
	}
};
static_assert(alignof(UCharacterSelectionComponent) == 0x000008, "Wrong alignment on UCharacterSelectionComponent");
static_assert(sizeof(UCharacterSelectionComponent) == 0x0000C8, "Wrong size on UCharacterSelectionComponent");

// Class LyraGame.TgfComboBoxString
// 0x0000 (0x1630 - 0x1630)
class UTgfComboBoxString final : public UComboBoxString
{
public:
	void TgfOnOpening();
	void TgfOnSelectionChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfComboBoxString">();
	}
	static class UTgfComboBoxString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfComboBoxString>();
	}
};
static_assert(alignof(UTgfComboBoxString) == 0x000010, "Wrong alignment on UTgfComboBoxString");
static_assert(sizeof(UTgfComboBoxString) == 0x001630, "Wrong size on UTgfComboBoxString");

// Class LyraGame.CrashSightService
// 0x0020 (0x0050 - 0x0030)
class UCrashSightService final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrashSightService">();
	}
	static class UCrashSightService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrashSightService>();
	}
};
static_assert(alignof(UCrashSightService) == 0x000008, "Wrong alignment on UCrashSightService");
static_assert(sizeof(UCrashSightService) == 0x000050, "Wrong size on UCrashSightService");

// Class LyraGame.DataUtility
// 0x0140 (0x0170 - 0x0030)
class UDataUtility final : public UEngineSubsystem
{
public:
	TMap<int32, TSubclassOf<class UTgfInventoryItemDefinition>> UeItemSourceData_;                                 // 0x0030(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int32, TSubclassOf<class UTgfEquipmentDefinition>> UeEquipSourceData_;                                // 0x0080(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int32, class ULyraAbilitySet*>           UeAbilitySetSourceData_;                           // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, class UItemSkinSet*>              UeItemSkinSetSourceData_;                          // 0x0120(0x0050)(NativeAccessSpecifierPrivate)

public:
	static const class ULyraInventoryItemFragment* FindFragmentByClass(TSubclassOf<class ULyraInventoryItemDefinition> Item_class, TSubclassOf<class ULyraInventoryItemFragment> Fragment_class);
	static TSubclassOf<class ULyraInventoryItemDefinition> GetBestFitDefinition(TSubclassOf<class ULyraInventoryItemDefinition> SourceDef, int32 SkinId);
	static class UObject* GetClassDefaultObject(class UClass* Param_Class);
	static class UDataUtility* GetDataUtilityInstance();
	static struct FVector GetFacadeItemPosOffset(int32 Type_id);
	static class FString GetFacadeItemRotator(int32 Type_id);
	static struct FVector GetFacadeItemScale(int32 Type_id);
	static struct FTgfItemHeadFrameDefinition GetHeadFrameDefinition(int32 SkinId);
	static TSubclassOf<class ULyraInventoryItemDefinition> GetPreviewSkinDefinition(TSubclassOf<class ULyraInventoryItemDefinition> SourceDef, int32 SkinId);
	static TSubclassOf<class ULyraInventoryItemDefinition> GetSkinDefinition(TSubclassOf<class ULyraInventoryItemDefinition> SourceDef, int32 SkinId);
	static bool IsFacadeItem(int32 Type_id);
	static bool IsGearGemInstItem(int32 Type_id);
	static bool IsRoleItem(int32 Type_id);
	static bool IsSkinItem(int32 Type_id);
	static bool IsVirtualItem(int32 Type_id);

	const class ULyraAbilitySet* GetAbilitySetClass(int32 Type);
	TSubclassOf<class UTgfEquipmentDefinition> GetEquipClass(int32 EquipId);
	TSubclassOf<class UTgfInventoryItemDefinition> GetItemClass(int32 ItemId);
	const class UItemSkinSet* GetItemSkinSetClass(int32 SkinId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataUtility">();
	}
	static class UDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataUtility>();
	}
};
static_assert(alignof(UDataUtility) == 0x000008, "Wrong alignment on UDataUtility");
static_assert(sizeof(UDataUtility) == 0x000170, "Wrong size on UDataUtility");
static_assert(offsetof(UDataUtility, UeItemSourceData_) == 0x000030, "Member 'UDataUtility::UeItemSourceData_' has a wrong offset!");
static_assert(offsetof(UDataUtility, UeEquipSourceData_) == 0x000080, "Member 'UDataUtility::UeEquipSourceData_' has a wrong offset!");
static_assert(offsetof(UDataUtility, UeAbilitySetSourceData_) == 0x0000D0, "Member 'UDataUtility::UeAbilitySetSourceData_' has a wrong offset!");
static_assert(offsetof(UDataUtility, UeItemSkinSetSourceData_) == 0x000120, "Member 'UDataUtility::UeItemSkinSetSourceData_' has a wrong offset!");

// Class LyraGame.GameFeatureAction_WorldActionBase
// 0x0050 (0x0078 - 0x0028)
class UGameFeatureAction_WorldActionBase : public UGameFeatureAction
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_WorldActionBase">();
	}
	static class UGameFeatureAction_WorldActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_WorldActionBase>();
	}
};
static_assert(alignof(UGameFeatureAction_WorldActionBase) == 0x000008, "Wrong alignment on UGameFeatureAction_WorldActionBase");
static_assert(sizeof(UGameFeatureAction_WorldActionBase) == 0x000078, "Wrong size on UGameFeatureAction_WorldActionBase");

// Class LyraGame.LyraAttributeSet
// 0x0000 (0x0030 - 0x0030)
class ULyraAttributeSet : public UAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAttributeSet">();
	}
	static class ULyraAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAttributeSet>();
	}
};
static_assert(alignof(ULyraAttributeSet) == 0x000008, "Wrong alignment on ULyraAttributeSet");
static_assert(sizeof(ULyraAttributeSet) == 0x000030, "Wrong size on ULyraAttributeSet");

// Class LyraGame.TgfSoulEnergyAttributeSet
// 0x0080 (0x00B0 - 0x0030)
class UTgfSoulEnergyAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 CurSoulEnergy;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SoulEnergyOnHit;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SoulEnergyOnKill;                                  // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SoulEnergyOnHurt;                                  // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SoulEnergyGenerateRate;                            // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxSoulEnergyBase;                                 // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxSoulEnergyPercent;                              // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SoulEnergyDeltaValue;                              // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_CurSoulEnergy(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxSoulEnergyBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxSoulEnergyPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_SoulEnergyGenerateRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_SoulEnergyOnHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_SoulEnergyOnHurt(const struct FGameplayAttributeData& OldValue);
	void OnRep_SoulEnergyOnKill(const struct FGameplayAttributeData& OldValue);

	float GetMaxSoulEnergyFinal() const;
	bool IsFullSEP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSoulEnergyAttributeSet">();
	}
	static class UTgfSoulEnergyAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSoulEnergyAttributeSet>();
	}
};
static_assert(alignof(UTgfSoulEnergyAttributeSet) == 0x000008, "Wrong alignment on UTgfSoulEnergyAttributeSet");
static_assert(sizeof(UTgfSoulEnergyAttributeSet) == 0x0000B0, "Wrong size on UTgfSoulEnergyAttributeSet");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, CurSoulEnergy) == 0x000030, "Member 'UTgfSoulEnergyAttributeSet::CurSoulEnergy' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, SoulEnergyOnHit) == 0x000040, "Member 'UTgfSoulEnergyAttributeSet::SoulEnergyOnHit' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, SoulEnergyOnKill) == 0x000050, "Member 'UTgfSoulEnergyAttributeSet::SoulEnergyOnKill' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, SoulEnergyOnHurt) == 0x000060, "Member 'UTgfSoulEnergyAttributeSet::SoulEnergyOnHurt' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, SoulEnergyGenerateRate) == 0x000070, "Member 'UTgfSoulEnergyAttributeSet::SoulEnergyGenerateRate' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, MaxSoulEnergyBase) == 0x000080, "Member 'UTgfSoulEnergyAttributeSet::MaxSoulEnergyBase' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, MaxSoulEnergyPercent) == 0x000090, "Member 'UTgfSoulEnergyAttributeSet::MaxSoulEnergyPercent' has a wrong offset!");
static_assert(offsetof(UTgfSoulEnergyAttributeSet, SoulEnergyDeltaValue) == 0x0000A0, "Member 'UTgfSoulEnergyAttributeSet::SoulEnergyDeltaValue' has a wrong offset!");

// Class LyraGame.DeathZone
// 0x00B0 (0x0348 - 0x0298)
class ADeathZone : public AActor
{
public:
	TArray<struct FDeathZoneDisc>                 Discs;                                             // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PotentialPortalPlacements;                         // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PotentialTeleportScrollPlacements;                 // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x50];                                     // 0x02C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpawnedPortals                        SpawnedPortals;                                    // 0x0318(0x0030)(NativeAccessSpecifierPublic)

public:
	void BroadCastSpawnPortalMessage(int32 BluePortalSpawned, int32 RedPortalSpawned, int32 ShadowPortalSpawned);
	void Generate(TArray<struct FDeathZoneDiscRuntimeInstance>* OutDiscs);
	struct FSpawnedPortalsInfo GetSpawnPortalInfo();
	void PickPortalPlacementsWithinRange(int32 NumPortals, const struct FVector& CircleOrigin, float CircleRadius, TArray<struct FVector>* PotentialPlacements, TArray<bool>* bPortalVisited, TArray<struct FPortalSpawnInfo>* OutPortalInfos, const TArray<float>& SpawnTime, EPortalType PortalType);
	void PickPortalPlacementsWithinRangeWithProbability(int32 NumPortals, const struct FVector& CircleOrigin, float CircleRadius, TArray<struct FVector>* PotentialPlacements, TArray<bool>* bPortalVisited, TArray<struct FPortalSpawnInfo>* OutPortalInfos, const TArray<struct FPortalSpawnConfig>& SpawnTime, EPortalType PortalType);
	void PickPortalPlacementsWithinRangeWithSpawnConfigs(int32 NumPortals, const struct FVector& CircleOrigin, float CircleRadius, TArray<struct FVector>* PotentialPlacements, TArray<bool>* bPortalVisited, TArray<struct FPortalSpawnInfo>* OutPortalInfos, const TArray<struct FPortalSpawnConfig>& SpawnConfigs);
	class AActor* SpawnOnePortalOrScroll(EPortalType Type, const struct FTransform& Transform, TSubclassOf<class AActor> PortalClass);
	void SpawnPortalAndScrolls(struct FDeathZoneDiscRuntimeInstance& CurrentDisc, double CurrentTimeDuration);

	TArray<struct FVector> GetAllPortalLocations(EPortalType PortalType) const;
	int32 GetAvailablePortalNums(EPortalType PortalType) const;
	const struct FDeathZoneDisc GetDiscDefinitionByIndex(int32 Param_Index) const;
	struct FVector2D RandomPointInCircle(const struct FVector2D& Center, float Radius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathZone">();
	}
	static class ADeathZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathZone>();
	}
};
static_assert(alignof(ADeathZone) == 0x000008, "Wrong alignment on ADeathZone");
static_assert(sizeof(ADeathZone) == 0x000348, "Wrong size on ADeathZone");
static_assert(offsetof(ADeathZone, Discs) == 0x000298, "Member 'ADeathZone::Discs' has a wrong offset!");
static_assert(offsetof(ADeathZone, PotentialPortalPlacements) == 0x0002A8, "Member 'ADeathZone::PotentialPortalPlacements' has a wrong offset!");
static_assert(offsetof(ADeathZone, PotentialTeleportScrollPlacements) == 0x0002B8, "Member 'ADeathZone::PotentialTeleportScrollPlacements' has a wrong offset!");
static_assert(offsetof(ADeathZone, SpawnedPortals) == 0x000318, "Member 'ADeathZone::SpawnedPortals' has a wrong offset!");

// Class LyraGame.DeathZoneVisuals
// 0x0008 (0x02A0 - 0x0298)
class ADeathZoneVisuals : public AActor
{
public:
	class UStaticMeshComponent*                   CylinderMeshComponent;                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathZoneVisuals">();
	}
	static class ADeathZoneVisuals* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathZoneVisuals>();
	}
};
static_assert(alignof(ADeathZoneVisuals) == 0x000008, "Wrong alignment on ADeathZoneVisuals");
static_assert(sizeof(ADeathZoneVisuals) == 0x0002A0, "Wrong size on ADeathZoneVisuals");
static_assert(offsetof(ADeathZoneVisuals, CylinderMeshComponent) == 0x000298, "Member 'ADeathZoneVisuals::CylinderMeshComponent' has a wrong offset!");

// Class LyraGame.TgfGameplayAbility_MontageCamera
// 0x0008 (0x0690 - 0x0688)
class UTgfGameplayAbility_MontageCamera : public ULyraGameplayAbility
{
public:
	TSubclassOf<class ULyraCameraMode>            CameraMode;                                        // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDeactivateEventReceived(const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility_MontageCamera">();
	}
	static class UTgfGameplayAbility_MontageCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility_MontageCamera>();
	}
};
static_assert(alignof(UTgfGameplayAbility_MontageCamera) == 0x000008, "Wrong alignment on UTgfGameplayAbility_MontageCamera");
static_assert(sizeof(UTgfGameplayAbility_MontageCamera) == 0x000690, "Wrong size on UTgfGameplayAbility_MontageCamera");
static_assert(offsetof(UTgfGameplayAbility_MontageCamera, CameraMode) == 0x000688, "Member 'UTgfGameplayAbility_MontageCamera::CameraMode' has a wrong offset!");

// Class LyraGame.DssdkSubsystem
// 0x0000 (0x0030 - 0x0030)
class UDssdkSubsystem : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DssdkSubsystem">();
	}
	static class UDssdkSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDssdkSubsystem>();
	}
};
static_assert(alignof(UDssdkSubsystem) == 0x000008, "Wrong alignment on UDssdkSubsystem");
static_assert(sizeof(UDssdkSubsystem) == 0x000030, "Wrong size on UDssdkSubsystem");

// Class LyraGame.AsyncAction_ExperienceReady
// 0x0018 (0x0048 - 0x0030)
class UAsyncAction_ExperienceReady final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_ExperienceReady* WaitForExperienceReady(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_ExperienceReady">();
	}
	static class UAsyncAction_ExperienceReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_ExperienceReady>();
	}
};
static_assert(alignof(UAsyncAction_ExperienceReady) == 0x000008, "Wrong alignment on UAsyncAction_ExperienceReady");
static_assert(sizeof(UAsyncAction_ExperienceReady) == 0x000048, "Wrong size on UAsyncAction_ExperienceReady");
static_assert(offsetof(UAsyncAction_ExperienceReady, OnReady) == 0x000030, "Member 'UAsyncAction_ExperienceReady::OnReady' has a wrong offset!");

// Class LyraGame.DSSDK
// 0x0040 (0x0070 - 0x0030)
class UDSSDK final : public UDssdkSubsystem
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DSSDK">();
	}
	static class UDSSDK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDSSDK>();
	}
};
static_assert(alignof(UDSSDK) == 0x000008, "Wrong alignment on UDSSDK");
static_assert(sizeof(UDSSDK) == 0x000070, "Wrong size on UDSSDK");

// Class LyraGame.GameFeatureAction_AddInputConfig
// 0x0060 (0x00D8 - 0x0078)
class UGameFeatureAction_AddInputConfig final : public UGameFeatureAction_WorldActionBase
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMappableConfigPair>            InputConfigs;                                      // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddInputConfig">();
	}
	static class UGameFeatureAction_AddInputConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddInputConfig>();
	}
};
static_assert(alignof(UGameFeatureAction_AddInputConfig) == 0x000008, "Wrong alignment on UGameFeatureAction_AddInputConfig");
static_assert(sizeof(UGameFeatureAction_AddInputConfig) == 0x0000D8, "Wrong size on UGameFeatureAction_AddInputConfig");
static_assert(offsetof(UGameFeatureAction_AddInputConfig, InputConfigs) == 0x0000C8, "Member 'UGameFeatureAction_AddInputConfig::InputConfigs' has a wrong offset!");

// Class LyraGame.IndicatorWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class IIndicatorWidgetInterface final : public IInterface
{
public:
	void BindIndicator(class UIndicatorDescriptor* Indicator);
	void UnbindIndicator(const class UIndicatorDescriptor* Indicator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorWidgetInterface">();
	}
	static class IIndicatorWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IIndicatorWidgetInterface>();
	}
};
static_assert(alignof(IIndicatorWidgetInterface) == 0x000008, "Wrong alignment on IIndicatorWidgetInterface");
static_assert(sizeof(IIndicatorWidgetInterface) == 0x000028, "Wrong size on IIndicatorWidgetInterface");

// Class LyraGame.InteractableTarget
// 0x0000 (0x0028 - 0x0028)
class IInteractableTarget final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableTarget">();
	}
	static class IInteractableTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractableTarget>();
	}
};
static_assert(alignof(IInteractableTarget) == 0x000008, "Wrong alignment on IInteractableTarget");
static_assert(sizeof(IInteractableTarget) == 0x000028, "Wrong size on IInteractableTarget");

// Class LyraGame.TgfEnviromentEquipmentSubsystem
// 0x0010 (0x0040 - 0x0030)
class UTgfEnviromentEquipmentSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InsertToTorchArray(class AActor* TorchActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEnviromentEquipmentSubsystem">();
	}
	static class UTgfEnviromentEquipmentSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEnviromentEquipmentSubsystem>();
	}
};
static_assert(alignof(UTgfEnviromentEquipmentSubsystem) == 0x000008, "Wrong alignment on UTgfEnviromentEquipmentSubsystem");
static_assert(sizeof(UTgfEnviromentEquipmentSubsystem) == 0x000040, "Wrong size on UTgfEnviromentEquipmentSubsystem");

// Class LyraGame.InteractionInstigator
// 0x0000 (0x0028 - 0x0028)
class IInteractionInstigator final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionInstigator">();
	}
	static class IInteractionInstigator* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionInstigator>();
	}
};
static_assert(alignof(IInteractionInstigator) == 0x000008, "Wrong alignment on IInteractionInstigator");
static_assert(sizeof(IInteractionInstigator) == 0x000028, "Wrong size on IInteractionInstigator");

// Class LyraGame.LyraNumberPopComponent
// 0x0000 (0x00A8 - 0x00A8)
class ULyraNumberPopComponent : public UControllerComponent
{
public:
	void AddNumberPop(const struct FLyraNumberPopRequest& NewRequest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraNumberPopComponent">();
	}
	static class ULyraNumberPopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraNumberPopComponent>();
	}
};
static_assert(alignof(ULyraNumberPopComponent) == 0x000008, "Wrong alignment on ULyraNumberPopComponent");
static_assert(sizeof(ULyraNumberPopComponent) == 0x0000A8, "Wrong size on ULyraNumberPopComponent");

// Class LyraGame.LyraNumberPopComponent_NiagaraText
// 0x0020 (0x00C8 - 0x00A8)
class ULyraNumberPopComponent_NiagaraText final : public ULyraNumberPopComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraDamagePopStyleNiagara*             Style;                                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComp;                                       // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraNumberPopComponent_NiagaraText">();
	}
	static class ULyraNumberPopComponent_NiagaraText* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraNumberPopComponent_NiagaraText>();
	}
};
static_assert(alignof(ULyraNumberPopComponent_NiagaraText) == 0x000008, "Wrong alignment on ULyraNumberPopComponent_NiagaraText");
static_assert(sizeof(ULyraNumberPopComponent_NiagaraText) == 0x0000C8, "Wrong size on ULyraNumberPopComponent_NiagaraText");
static_assert(offsetof(ULyraNumberPopComponent_NiagaraText, Style) == 0x0000B8, "Member 'ULyraNumberPopComponent_NiagaraText::Style' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_NiagaraText, NiagaraComp) == 0x0000C0, "Member 'ULyraNumberPopComponent_NiagaraText::NiagaraComp' has a wrong offset!");

// Class LyraGame.InGameTaskFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UInGameTaskFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool InGameReportClientTaskProgressValue(ETGFInGameRookieTaskType RookieTaskType, int64 Value);
	static bool InGameReportClientTaskProgressValueWithCharacterParam(ETGFInGameRookieTaskType RookieTaskType, int64 Value, class ALyraCharacter* InCharacter);
	static bool InGameReportDeathTask(class AActor* Killer, class AActor* Death);
	static bool InGameReportInteractorTask(bool bIsLootable, class AActor* Destroyer, class AActor* InteractorTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameTaskFunctionLibrary">();
	}
	static class UInGameTaskFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameTaskFunctionLibrary>();
	}
};
static_assert(alignof(UInGameTaskFunctionLibrary) == 0x000008, "Wrong alignment on UInGameTaskFunctionLibrary");
static_assert(sizeof(UInGameTaskFunctionLibrary) == 0x000028, "Wrong size on UInGameTaskFunctionLibrary");

// Class LyraGame.TgfInteractorEventComponent
// 0x0010 (0x00B8 - 0x00A8)
class UTgfInteractorEventComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInteractorEventComponent">();
	}
	static class UTgfInteractorEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInteractorEventComponent>();
	}
};
static_assert(alignof(UTgfInteractorEventComponent) == 0x000008, "Wrong alignment on UTgfInteractorEventComponent");
static_assert(sizeof(UTgfInteractorEventComponent) == 0x0000B8, "Wrong size on UTgfInteractorEventComponent");

// Class LyraGame.LyraInventoryItemFragment
// 0x0000 (0x0028 - 0x0028)
class ULyraInventoryItemFragment : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInventoryItemFragment">();
	}
	static class ULyraInventoryItemFragment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInventoryItemFragment>();
	}
};
static_assert(alignof(ULyraInventoryItemFragment) == 0x000008, "Wrong alignment on ULyraInventoryItemFragment");
static_assert(sizeof(ULyraInventoryItemFragment) == 0x000028, "Wrong size on ULyraInventoryItemFragment");

// Class LyraGame.InventoryFragment_InventoryIcon
// 0x01D8 (0x0200 - 0x0028)
class UInventoryFragment_InventoryIcon final : public ULyraInventoryItemFragment
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0030(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            TipsBrush;                                         // 0x0100(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UseDescription;                                    // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfEquipQuality                              DisplayQuality;                                    // 0x01F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0xF];                                      // 0x01F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_InventoryIcon">();
	}
	static class UInventoryFragment_InventoryIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_InventoryIcon>();
	}
};
static_assert(alignof(UInventoryFragment_InventoryIcon) == 0x000010, "Wrong alignment on UInventoryFragment_InventoryIcon");
static_assert(sizeof(UInventoryFragment_InventoryIcon) == 0x000200, "Wrong size on UInventoryFragment_InventoryIcon");
static_assert(offsetof(UInventoryFragment_InventoryIcon, Brush) == 0x000030, "Member 'UInventoryFragment_InventoryIcon::Brush' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_InventoryIcon, TipsBrush) == 0x000100, "Member 'UInventoryFragment_InventoryIcon::TipsBrush' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_InventoryIcon, Description) == 0x0001D0, "Member 'UInventoryFragment_InventoryIcon::Description' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_InventoryIcon, UseDescription) == 0x0001E0, "Member 'UInventoryFragment_InventoryIcon::UseDescription' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_InventoryIcon, DisplayQuality) == 0x0001F0, "Member 'UInventoryFragment_InventoryIcon::DisplayQuality' has a wrong offset!");

// Class LyraGame.TgfGameplayEventAsyncAction
// 0x0028 (0x0058 - 0x0030)
class UTgfGameplayEventAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfGameplayEventAsyncAction* WaitForGameplayEventToCharaOrInteractor(const class UObject* WorldContext, class AActor* Actor, const struct FGameplayTag& Tag);

	void EventReceivedDelegate__DelegateSignature(const struct FGameplayTag& ReceivedTag, const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayEventAsyncAction">();
	}
	static class UTgfGameplayEventAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayEventAsyncAction>();
	}
};
static_assert(alignof(UTgfGameplayEventAsyncAction) == 0x000008, "Wrong alignment on UTgfGameplayEventAsyncAction");
static_assert(sizeof(UTgfGameplayEventAsyncAction) == 0x000058, "Wrong size on UTgfGameplayEventAsyncAction");
static_assert(offsetof(UTgfGameplayEventAsyncAction, EventReceived) == 0x000030, "Member 'UTgfGameplayEventAsyncAction::EventReceived' has a wrong offset!");

// Class LyraGame.InventoryFragment_ItemGA
// 0x0008 (0x0030 - 0x0028)
class UInventoryFragment_ItemGA final : public ULyraInventoryItemFragment
{
public:
	TSubclassOf<class UTgfGameplayAbility>        RelateGAClass;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_ItemGA">();
	}
	static class UInventoryFragment_ItemGA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_ItemGA>();
	}
};
static_assert(alignof(UInventoryFragment_ItemGA) == 0x000008, "Wrong alignment on UInventoryFragment_ItemGA");
static_assert(sizeof(UInventoryFragment_ItemGA) == 0x000030, "Wrong size on UInventoryFragment_ItemGA");
static_assert(offsetof(UInventoryFragment_ItemGA, RelateGAClass) == 0x000028, "Member 'UInventoryFragment_ItemGA::RelateGAClass' has a wrong offset!");

// Class LyraGame.InventoryFragment_PickupMesh
// 0x0040 (0x0068 - 0x0028)
class UInventoryFragment_PickupMesh final : public ULyraInventoryItemFragment
{
public:
	struct FSoftObjectPath                        StaticMesh;                                        // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATgfStaticInteraction>      CollectableClass;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PickupTriggerBoxScale;                             // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_PickupMesh">();
	}
	static class UInventoryFragment_PickupMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_PickupMesh>();
	}
};
static_assert(alignof(UInventoryFragment_PickupMesh) == 0x000008, "Wrong alignment on UInventoryFragment_PickupMesh");
static_assert(sizeof(UInventoryFragment_PickupMesh) == 0x000068, "Wrong size on UInventoryFragment_PickupMesh");
static_assert(offsetof(UInventoryFragment_PickupMesh, StaticMesh) == 0x000028, "Member 'UInventoryFragment_PickupMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_PickupMesh, CollectableClass) == 0x000048, "Member 'UInventoryFragment_PickupMesh::CollectableClass' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_PickupMesh, PickupTriggerBoxScale) == 0x000050, "Member 'UInventoryFragment_PickupMesh::PickupTriggerBoxScale' has a wrong offset!");

// Class LyraGame.LyraInventoryItemDefinition
// 0x0028 (0x0050 - 0x0028)
class ULyraInventoryItemDefinition : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class ULyraInventoryItemFragment*>     Fragments;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInventoryItemDefinition">();
	}
	static class ULyraInventoryItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInventoryItemDefinition>();
	}
};
static_assert(alignof(ULyraInventoryItemDefinition) == 0x000008, "Wrong alignment on ULyraInventoryItemDefinition");
static_assert(sizeof(ULyraInventoryItemDefinition) == 0x000050, "Wrong size on ULyraInventoryItemDefinition");
static_assert(offsetof(ULyraInventoryItemDefinition, DisplayName) == 0x000028, "Member 'ULyraInventoryItemDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(ULyraInventoryItemDefinition, Fragments) == 0x000040, "Member 'ULyraInventoryItemDefinition::Fragments' has a wrong offset!");

// Class LyraGame.InventoryFragment_Sound
// 0x0040 (0x0068 - 0x0028)
class UInventoryFragment_Sound final : public ULyraInventoryItemFragment
{
public:
	class UAkAudioEvent*                          DragSound;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DropSound;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PickupSound;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DiscardSound;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          HitSound;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EquipSound;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          UnequipSound;                                      // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         AnimNotifySwitch;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_Sound">();
	}
	static class UInventoryFragment_Sound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_Sound>();
	}
};
static_assert(alignof(UInventoryFragment_Sound) == 0x000008, "Wrong alignment on UInventoryFragment_Sound");
static_assert(sizeof(UInventoryFragment_Sound) == 0x000068, "Wrong size on UInventoryFragment_Sound");
static_assert(offsetof(UInventoryFragment_Sound, DragSound) == 0x000028, "Member 'UInventoryFragment_Sound::DragSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, DropSound) == 0x000030, "Member 'UInventoryFragment_Sound::DropSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, PickupSound) == 0x000038, "Member 'UInventoryFragment_Sound::PickupSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, DiscardSound) == 0x000040, "Member 'UInventoryFragment_Sound::DiscardSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, HitSound) == 0x000048, "Member 'UInventoryFragment_Sound::HitSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, EquipSound) == 0x000050, "Member 'UInventoryFragment_Sound::EquipSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, UnequipSound) == 0x000058, "Member 'UInventoryFragment_Sound::UnequipSound' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_Sound, AnimNotifySwitch) == 0x000060, "Member 'UInventoryFragment_Sound::AnimNotifySwitch' has a wrong offset!");

// Class LyraGame.InventoryMenuConfig
// 0x0000 (0x0030 - 0x0030)
class UInventoryMenuConfig final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryMenuConfig">();
	}
	static class UInventoryMenuConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryMenuConfig>();
	}
};
static_assert(alignof(UInventoryMenuConfig) == 0x000008, "Wrong alignment on UInventoryMenuConfig");
static_assert(sizeof(UInventoryMenuConfig) == 0x000030, "Wrong size on UInventoryMenuConfig");

// Class LyraGame.LyraEquipmentInstance
// 0x00A8 (0x00D0 - 0x0028)
class ULyraEquipmentInstance : public UObject
{
public:
	TSubclassOf<class ULyraEquipmentDefinition>   EquipDef;                                          // 0x0028(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULyraEquipmentDefinition>   SkinDef;                                           // 0x0030(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraInventoryItemInstance*             InventoryInstance;                                 // 0x0038(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLyraAbilitySet_GrantedHandles         GrantedHandles;                                    // 0x0040(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ULyraAbilitySystemComponent*            OwnerABS;                                          // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfEquipAttrParseType                        AttrParseType;                                     // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnEquipped();
	void K2_OnUnequipped();
	void OnRep_Instance();

	TSubclassOf<class ULyraEquipmentDefinition> GetEquipDef(bool NeedSkined) const;
	int32 GetEquipId() const;
	ETgfEquipSubType GetEquipSubtype() const;
	ETgfWeaponEquipType GetEquipType() const;
	class ULyraInventoryItemInstance* GetInventory() const;
	class ULyraAbilitySystemComponent* GetOwnerAbilitySystem() const;
	class APawn* GetPawn() const;
	class APawn* GetTypedPawn(TSubclassOf<class APawn> PawnType) const;
	bool IsEquipped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraEquipmentInstance">();
	}
	static class ULyraEquipmentInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraEquipmentInstance>();
	}
};
static_assert(alignof(ULyraEquipmentInstance) == 0x000008, "Wrong alignment on ULyraEquipmentInstance");
static_assert(sizeof(ULyraEquipmentInstance) == 0x0000D0, "Wrong size on ULyraEquipmentInstance");
static_assert(offsetof(ULyraEquipmentInstance, EquipDef) == 0x000028, "Member 'ULyraEquipmentInstance::EquipDef' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentInstance, SkinDef) == 0x000030, "Member 'ULyraEquipmentInstance::SkinDef' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentInstance, InventoryInstance) == 0x000038, "Member 'ULyraEquipmentInstance::InventoryInstance' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentInstance, GrantedHandles) == 0x000040, "Member 'ULyraEquipmentInstance::GrantedHandles' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentInstance, OwnerABS) == 0x0000C0, "Member 'ULyraEquipmentInstance::OwnerABS' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentInstance, AttrParseType) == 0x0000C8, "Member 'ULyraEquipmentInstance::AttrParseType' has a wrong offset!");

// Class LyraGame.ItemFunctionLibrary
// 0x0018 (0x00C0 - 0x00A8)
class UItemFunctionLibrary : public UGameFrameworkComponent
{
public:
	float                                         DefaultVaildDis;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALyraCharacter*                         StealTarget;                                       // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StealValidDistance;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemDefinitionToEquipmentWithSlot(TSubclassOf<class ULyraInventoryItemDefinition> ItemDefinition, class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot Slot);
	bool CheckDistance(const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList, float Distance);
	void DiscardItem(const struct FTgfInventoryOperationItemSource& Source, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	void DropItem(const struct FTgfInventoryOperationItemSource& Source, class ALyraCharacter* Character, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	bool DropItemToWorld(class ULyraInventoryItemInstance* Item, const class ALyraCharacter* Character);
	void ExchangeEquipsWithSlots(class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot Slot1, ETgfEquipSlot Slot2, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	void ExchangeItemsToInventory(const TArray<struct FTgfInventoryOperationItemSource>& Source, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	void ExchangeItemToEquipmentFromLoot(const struct FTgfInventoryOperationItemSource& Source, class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot TargetSlot, class UTgfInventoryManagerComponent* TargetInventoryComp, class UTgfInventoryManagerComponent* SourceInventoryComp, class UTgfEquipmentManagerComponent* SourceEquipmentComp, const struct FIntPoint& FromPoint, ETgfEquipSlot FromEquipSlot);
	void ExchangeItemToEquipmentWithSlot(const struct FTgfInventoryOperationItemSource& Source, class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot Slot, class UTgfEquipmentManagerComponent* SourceEquipmentComp, class UTgfInventoryManagerComponent* SourceInventoryComp, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	void ExchangeItemToInventory(const struct FTgfInventoryOperationItemSource& Source, class UTgfInventoryManagerComponent* TargetInventoryComp, ELyraInventoryType InventoryType, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	bool FindItemInCompList(class ULyraInventoryItemInstance* ItemInstance, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	void GetAllCompList(const TArray<class ALyraCharacter*>& CharacterList, const TArray<class ATgfStaticInteraction*>& InteractorList, TArray<class UTgfInventoryManagerComponent*>* InventoryCompList, TArray<class UTgfEquipmentManagerComponent*>* EquipmentCompList);
	struct FTgfInventoryLootState GetInventoryLootState();
	float GetLootVaildDistance();
	void MergeGemToItem(class UTgfInventoryItemInstance* Item, class UTgfInventoryItemInstance* GemItem, class ULyraAbilitySystemComponent* OwnerABS, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList, ETgfEquipAttrParseType AttrParseType, class ULyraEquipmentInstance* Equipment);
	void MergeItemInstance(class ULyraInventoryItemInstance* TargetItemInstance, const struct FTgfInventoryOperationItemSource& Source, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList);
	void MoveAnotherCharacterEquipmentAndInventoryToSelf(class AActor* Target, bool bClearEquipped);
	bool PickUpItem(TSubclassOf<class UTgfInventoryItemDefinition> ItemDefinition, class ULyraInventoryItemInstance* ItemInstance);
	void RemoveSelfAllPvPItems();
	void SetStealTarget(class ALyraCharacter* Target);
	void StealItemSimple();
	void StealItemSimpleResultNotifyClient(bool Success, const class FString& ReasonTxt);

	bool CanRemoveEquipment(class ULyraEquipmentInstance* EquipmentInstance, const class UTgfEquipmentManagerComponent* EquipmentManager, class FText* OutFailReason) const;
	bool CanRemoveItemFromEquipmentList(class ULyraInventoryItemInstance* ItemInstance, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentManagers, class FText* OutFailReason) const;
	ETgfEquipSlot FindBestEquipSlotForItem(class ULyraInventoryItemInstance* ItemInstance, const class UTgfEquipmentManagerComponent* EquipmentManager, bool bUseAutoFillConfig) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemFunctionLibrary">();
	}
	static class UItemFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemFunctionLibrary>();
	}
};
static_assert(alignof(UItemFunctionLibrary) == 0x000008, "Wrong alignment on UItemFunctionLibrary");
static_assert(sizeof(UItemFunctionLibrary) == 0x0000C0, "Wrong size on UItemFunctionLibrary");
static_assert(offsetof(UItemFunctionLibrary, DefaultVaildDis) == 0x0000A8, "Member 'UItemFunctionLibrary::DefaultVaildDis' has a wrong offset!");
static_assert(offsetof(UItemFunctionLibrary, StealTarget) == 0x0000B0, "Member 'UItemFunctionLibrary::StealTarget' has a wrong offset!");
static_assert(offsetof(UItemFunctionLibrary, StealValidDistance) == 0x0000B8, "Member 'UItemFunctionLibrary::StealValidDistance' has a wrong offset!");

// Class LyraGame.ItemSkinSet
// 0x00C0 (0x00F0 - 0x0030)
class UItemSkinSet final : public UDataAsset
{
public:
	ETgfSkinSlot                                  SlotType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfSkinCategory                              SlotCategory;                                      // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkinId;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTgfItemDefinitionQualitySelectionSet> QualityDefinitionRules;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfItemDefinitionSelectionSet> SpecificDefinitionRules;                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ULyraInventoryItemDefinition> DefaultDefinition;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTgfItemEffectDefinition               KillEffectDefinition;                              // 0x0060(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FTgfItemHeadFrameDefinition            HeadFrameDefinition;                               // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSkinSet">();
	}
	static class UItemSkinSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSkinSet>();
	}
};
static_assert(alignof(UItemSkinSet) == 0x000010, "Wrong alignment on UItemSkinSet");
static_assert(sizeof(UItemSkinSet) == 0x0000F0, "Wrong size on UItemSkinSet");
static_assert(offsetof(UItemSkinSet, SlotType) == 0x000030, "Member 'UItemSkinSet::SlotType' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, SlotCategory) == 0x000031, "Member 'UItemSkinSet::SlotCategory' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, SkinId) == 0x000034, "Member 'UItemSkinSet::SkinId' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, QualityDefinitionRules) == 0x000038, "Member 'UItemSkinSet::QualityDefinitionRules' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, SpecificDefinitionRules) == 0x000048, "Member 'UItemSkinSet::SpecificDefinitionRules' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, DefaultDefinition) == 0x000058, "Member 'UItemSkinSet::DefaultDefinition' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, KillEffectDefinition) == 0x000060, "Member 'UItemSkinSet::KillEffectDefinition' has a wrong offset!");
static_assert(offsetof(UItemSkinSet, HeadFrameDefinition) == 0x0000E0, "Member 'UItemSkinSet::HeadFrameDefinition' has a wrong offset!");

// Class LyraGame.LyraInventoryManagerComponent
// 0x0130 (0x01D8 - 0x00A8)
class ULyraInventoryManagerComponent : public UGameFrameworkComponent
{
public:
	struct FLyraInventoryList                     InventoryList;                                     // 0x00A8(0x0130)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class ULyraInventoryItemInstance* StaticCreateInstance(class AActor* Owner, TSubclassOf<class ULyraInventoryItemDefinition> ItemClass, int32 StackCount, TSubclassOf<class ULyraInventoryItemInstance> InstanceType);

	void AddItemDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType, int32 NumToAdd);
	void AddItemDefinitionAuth(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType, int32 NumToAdd);
	void AddItemInstance(class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType);
	void AddItemInstanceAuth(class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType);
	void AddItemInstanceWithAutoStack(class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType);
	void ClearAllInventory();
	void OnRep_InventoryList();
	void RemoveItemByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume);
	void RemoveItemByDefinitionAuth(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume);
	void RemoveItemInstance(class ULyraInventoryItemInstance* ItemInstance);
	void UpdateItemInstance(class ULyraInventoryItemInstance* ItemInstance);

	bool CanAddItemDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType, int32 StackCount) const;
	bool CanAddItemInstance(class ULyraInventoryItemInstance* Instance, ELyraInventoryType LyraInventoryType) const;
	bool CanAddItemInstances(const TArray<class ULyraInventoryItemInstance*>& AddInstances, ELyraInventoryType LyraInventoryType) const;
	class ULyraInventoryItemInstance* CreateInstance(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass, int32 StackCount) const;
	class ULyraInventoryItemInstance* FindFirstItemByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef) const;
	const TArray<struct FLyraInventoryEntry> GetAllEntries() const;
	TArray<class ULyraInventoryItemInstance*> GetAllItems() const;
	int32 GetAllSize() const;
	int32 GetEntryIndexByItemInstance(class ULyraInventoryItemInstance* ItemInstance) const;
	class ULyraInventoryItemInstance* GetItemByIndex(int32 Param_Index) const;
	int32 GetTotalItemCountByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef) const;
	bool HasEmptyInventory(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass, struct FIntPoint* Position, ELyraInventoryType InventoryType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInventoryManagerComponent">();
	}
	static class ULyraInventoryManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInventoryManagerComponent>();
	}
};
static_assert(alignof(ULyraInventoryManagerComponent) == 0x000008, "Wrong alignment on ULyraInventoryManagerComponent");
static_assert(sizeof(ULyraInventoryManagerComponent) == 0x0001D8, "Wrong size on ULyraInventoryManagerComponent");
static_assert(offsetof(ULyraInventoryManagerComponent, InventoryList) == 0x0000A8, "Member 'ULyraInventoryManagerComponent::InventoryList' has a wrong offset!");

// Class LyraGame.LyraAbilityCost
// 0x0010 (0x0038 - 0x0028)
class ULyraAbilityCost : public UObject
{
public:
	struct FGameplayTag                           FailedTag;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyApplyCostOnHit;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilityCost">();
	}
	static class ULyraAbilityCost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilityCost>();
	}
};
static_assert(alignof(ULyraAbilityCost) == 0x000008, "Wrong alignment on ULyraAbilityCost");
static_assert(sizeof(ULyraAbilityCost) == 0x000038, "Wrong size on ULyraAbilityCost");
static_assert(offsetof(ULyraAbilityCost, FailedTag) == 0x000028, "Member 'ULyraAbilityCost::FailedTag' has a wrong offset!");
static_assert(offsetof(ULyraAbilityCost, bOnlyApplyCostOnHit) == 0x000030, "Member 'ULyraAbilityCost::bOnlyApplyCostOnHit' has a wrong offset!");

// Class LyraGame.LyraActionWidget
// 0x0000 (0x0450 - 0x0450)
class ULyraActionWidget final : public UCommonActionWidget
{
public:
	class UInputAction*                           AssociatedInputAction;                             // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraActionWidget">();
	}
	static class ULyraActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraActionWidget>();
	}
};
static_assert(alignof(ULyraActionWidget) == 0x000010, "Wrong alignment on ULyraActionWidget");
static_assert(sizeof(ULyraActionWidget) == 0x000450, "Wrong size on ULyraActionWidget");
static_assert(offsetof(ULyraActionWidget, AssociatedInputAction) == 0x000448, "Member 'ULyraActionWidget::AssociatedInputAction' has a wrong offset!");

// Class LyraGame.TgfInGameServiceComponent
// 0x0020 (0x00C8 - 0x00A8)
class UTgfInGameServiceComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsGameServerLogin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInGameServiceComponent">();
	}
	static class UTgfInGameServiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInGameServiceComponent>();
	}
};
static_assert(alignof(UTgfInGameServiceComponent) == 0x000008, "Wrong alignment on UTgfInGameServiceComponent");
static_assert(sizeof(UTgfInGameServiceComponent) == 0x0000C8, "Wrong size on UTgfInGameServiceComponent");

// Class LyraGame.LyraAIController
// 0x0028 (0x03E8 - 0x03C0)
class ALyraAIController : public AModularAIController
{
public:
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         MyTeamID;                                          // 0x03D8(0x0001)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAIControllerData*                  Data;                                              // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetDebugInfoString();
	void OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAIController">();
	}
	static class ALyraAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraAIController>();
	}
};
static_assert(alignof(ALyraAIController) == 0x000008, "Wrong alignment on ALyraAIController");
static_assert(sizeof(ALyraAIController) == 0x0003E8, "Wrong size on ALyraAIController");
static_assert(offsetof(ALyraAIController, OnTeamChangedDelegate) == 0x0003C8, "Member 'ALyraAIController::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ALyraAIController, MyTeamID) == 0x0003D8, "Member 'ALyraAIController::MyTeamID' has a wrong offset!");
static_assert(offsetof(ALyraAIController, Data) == 0x0003E0, "Member 'ALyraAIController::Data' has a wrong offset!");

// Class LyraGame.LyraAIControllerData
// 0x0000 (0x0028 - 0x0028)
class ULyraAIControllerData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAIControllerData">();
	}
	static class ULyraAIControllerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAIControllerData>();
	}
};
static_assert(alignof(ULyraAIControllerData) == 0x000008, "Wrong alignment on ULyraAIControllerData");
static_assert(sizeof(ULyraAIControllerData) == 0x000028, "Wrong size on ULyraAIControllerData");

// Class LyraGame.TgfEquipmentWrapper
// 0x0008 (0x0030 - 0x0028)
class UTgfEquipmentWrapper : public UTgfBlueprintableObject
{
public:
	class UTgfInventoryItemWrapper*               Item;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TSubclassOf<class UTgfEquipmentDefinition> GetEquipmentDefinition(bool bIsSkin) const;
	const class UTgfEquipmentDefinition* GetEquipmentDefinitionObject(bool bIsSkin) const;
	ETgfEquipSubType GetEquipSubtype() const;
	TSubclassOf<class UTgfInventoryItemDefinition> GetItemDefinition(bool bIsSkin) const;
	const class UTgfInventoryItemDefinition* GetItemDefinitionObject(bool bIsSkin) const;
	ETgfWeaponEquipType GetWeaponEquipType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentWrapper">();
	}
	static class UTgfEquipmentWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentWrapper>();
	}
};
static_assert(alignof(UTgfEquipmentWrapper) == 0x000008, "Wrong alignment on UTgfEquipmentWrapper");
static_assert(sizeof(UTgfEquipmentWrapper) == 0x000030, "Wrong size on UTgfEquipmentWrapper");
static_assert(offsetof(UTgfEquipmentWrapper, Item) == 0x000028, "Member 'UTgfEquipmentWrapper::Item' has a wrong offset!");

// Class LyraGame.LyraCameraAssistInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraCameraAssistInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraAssistInterface">();
	}
	static class ILyraCameraAssistInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraCameraAssistInterface>();
	}
};
static_assert(alignof(ILyraCameraAssistInterface) == 0x000008, "Wrong alignment on ILyraCameraAssistInterface");
static_assert(sizeof(ILyraCameraAssistInterface) == 0x000028, "Wrong size on ILyraCameraAssistInterface");

// Class LyraGame.LyraCameraMode
// 0x00E8 (0x0110 - 0x0028)
class ULyraCameraMode : public UObject
{
public:
	bool                                          FieldOfViewOverride;                               // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CameraTypeTag;                                     // 0x002C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x54];                                      // 0x0034(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldOfView;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FieldOfViewAlt;                                    // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMin;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMax;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTime;                                         // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELyraCameraModeBlendFunction                  BlendFunction;                                     // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExponent;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULyraCameraMode>            NextBlendingCameraMode;                            // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendingTimeOfNextCameraMode;                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUseThirdPersonMesh;                          // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverBlendWeight;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsAddedToCharacterWhenBlendOut;                  // 0x00C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsAddedToCharacterWhenActive;                    // 0x00E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bResetInterpolation : 1;                           // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraMode">();
	}
	static class ULyraCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraMode>();
	}
};
static_assert(alignof(ULyraCameraMode) == 0x000008, "Wrong alignment on ULyraCameraMode");
static_assert(sizeof(ULyraCameraMode) == 0x000110, "Wrong size on ULyraCameraMode");
static_assert(offsetof(ULyraCameraMode, FieldOfViewOverride) == 0x000028, "Member 'ULyraCameraMode::FieldOfViewOverride' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, CameraTypeTag) == 0x00002C, "Member 'ULyraCameraMode::CameraTypeTag' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, FieldOfView) == 0x000088, "Member 'ULyraCameraMode::FieldOfView' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, FieldOfViewAlt) == 0x00008C, "Member 'ULyraCameraMode::FieldOfViewAlt' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, ViewPitchMin) == 0x000090, "Member 'ULyraCameraMode::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, ViewPitchMax) == 0x000094, "Member 'ULyraCameraMode::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, BlendTime) == 0x000098, "Member 'ULyraCameraMode::BlendTime' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, BlendFunction) == 0x00009C, "Member 'ULyraCameraMode::BlendFunction' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, BlendExponent) == 0x0000A0, "Member 'ULyraCameraMode::BlendExponent' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, NextBlendingCameraMode) == 0x0000A8, "Member 'ULyraCameraMode::NextBlendingCameraMode' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, BlendingTimeOfNextCameraMode) == 0x0000B0, "Member 'ULyraCameraMode::BlendingTimeOfNextCameraMode' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, bForceUseThirdPersonMesh) == 0x0000B4, "Member 'ULyraCameraMode::bForceUseThirdPersonMesh' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, RecoverBlendWeight) == 0x0000B8, "Member 'ULyraCameraMode::RecoverBlendWeight' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, TagsAddedToCharacterWhenBlendOut) == 0x0000C0, "Member 'ULyraCameraMode::TagsAddedToCharacterWhenBlendOut' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode, TagsAddedToCharacterWhenActive) == 0x0000E0, "Member 'ULyraCameraMode::TagsAddedToCharacterWhenActive' has a wrong offset!");

// Class LyraGame.LyraGameplayCueManager
// 0x0130 (0x0440 - 0x0310)
class ULyraGameplayCueManager : public UGameplayCueManager
{
public:
	TSet<TSubclassOf<class UObject>>              PreloadedCues;                                     // 0x0310(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x50];                                     // 0x0360(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UObject>>              AlwaysLoadedCues;                                  // 0x03B0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x40];                                     // 0x0400(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayCueManager">();
	}
	static class ULyraGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayCueManager>();
	}
};
static_assert(alignof(ULyraGameplayCueManager) == 0x000008, "Wrong alignment on ULyraGameplayCueManager");
static_assert(sizeof(ULyraGameplayCueManager) == 0x000440, "Wrong size on ULyraGameplayCueManager");
static_assert(offsetof(ULyraGameplayCueManager, PreloadedCues) == 0x000310, "Member 'ULyraGameplayCueManager::PreloadedCues' has a wrong offset!");
static_assert(offsetof(ULyraGameplayCueManager, AlwaysLoadedCues) == 0x0003B0, "Member 'ULyraGameplayCueManager::AlwaysLoadedCues' has a wrong offset!");

// Class LyraGame.LyraCameraMode_FixedPerspective
// 0x0050 (0x0160 - 0x0110)
class ULyraCameraMode_FixedPerspective : public ULyraCameraMode
{
public:
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraMode_FixedPerspective">();
	}
	static class ULyraCameraMode_FixedPerspective* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraMode_FixedPerspective>();
	}
};
static_assert(alignof(ULyraCameraMode_FixedPerspective) == 0x000008, "Wrong alignment on ULyraCameraMode_FixedPerspective");
static_assert(sizeof(ULyraCameraMode_FixedPerspective) == 0x000160, "Wrong size on ULyraCameraMode_FixedPerspective");

// Class LyraGame.LyraCameraMode_DetachFromFollowing
// 0x0008 (0x0168 - 0x0160)
class ULyraCameraMode_DetachFromFollowing final : public ULyraCameraMode_FixedPerspective
{
public:
	float                                         FixedPitch;                                        // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraMode_DetachFromFollowing">();
	}
	static class ULyraCameraMode_DetachFromFollowing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraMode_DetachFromFollowing>();
	}
};
static_assert(alignof(ULyraCameraMode_DetachFromFollowing) == 0x000008, "Wrong alignment on ULyraCameraMode_DetachFromFollowing");
static_assert(sizeof(ULyraCameraMode_DetachFromFollowing) == 0x000168, "Wrong size on ULyraCameraMode_DetachFromFollowing");
static_assert(offsetof(ULyraCameraMode_DetachFromFollowing, FixedPitch) == 0x000160, "Member 'ULyraCameraMode_DetachFromFollowing::FixedPitch' has a wrong offset!");

// Class LyraGame.TgfPawnMaterialManagerComponent
// 0x0108 (0x01B0 - 0x00A8)
class UTgfPawnMaterialManagerComponent : public UPawnComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMaterialChanged;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UMeshComponent*, struct FUTgfPawnMaterialCache> MainMeshMaterials;                                 // 0x00B8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      AlternatedOverlayMaterial;                         // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      AlternateMaterial;                                 // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               AlternateMaterialDynamic;                          // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      PetrifactionOverlayMat;                            // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               PetrifactionOverlayMatDynamic;                     // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfCharaMatStateType                         StateType;                                         // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StoneActorPosition;                                // 0x0138(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x60];                                     // 0x0150(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BatchSetMainMeshScalarParameterValue(class FName ParameterName, float AlternateValue);
	void BatchSetMainMeshVectorParameterValue(class FName ParameterName, const struct FVector& AlternateValue);
	void OnMaterialUpdatedAfter(ETgfCharaMatStateType NewStateType, ETgfCharaMatStateType OldStateType);
	void OnMaterialUpdatedBefore(ETgfCharaMatStateType NewStateType, ETgfCharaMatStateType OldStateType);
	void RevertOverlayMaterial();
	void RevertToOriginalSkin();
	void SwitchToDynamicMaterials();
	void SwitchToSpecificSkin();
	void SwitchToSpecifiedOverlayMaterial(ETgfPawnOverlayMaterialType MIType);
	void UpdateMaterialState(ETgfCharaMatStateType Type);

	bool ContainsMaterialState(ETgfCharaMatStateType Type) const;
	struct FGameplayTag FindTagByStateType(ETgfCharaMatStateType Type) const;
	ETgfCharaMatStateType GetStateType() const;
	ETgfCharaMatStateType GetStateTypeByTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfPawnMaterialManagerComponent">();
	}
	static class UTgfPawnMaterialManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfPawnMaterialManagerComponent>();
	}
};
static_assert(alignof(UTgfPawnMaterialManagerComponent) == 0x000008, "Wrong alignment on UTgfPawnMaterialManagerComponent");
static_assert(sizeof(UTgfPawnMaterialManagerComponent) == 0x0001B0, "Wrong size on UTgfPawnMaterialManagerComponent");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, OnMaterialChanged) == 0x0000A8, "Member 'UTgfPawnMaterialManagerComponent::OnMaterialChanged' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, MainMeshMaterials) == 0x0000B8, "Member 'UTgfPawnMaterialManagerComponent::MainMeshMaterials' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, AlternatedOverlayMaterial) == 0x000108, "Member 'UTgfPawnMaterialManagerComponent::AlternatedOverlayMaterial' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, AlternateMaterial) == 0x000110, "Member 'UTgfPawnMaterialManagerComponent::AlternateMaterial' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, AlternateMaterialDynamic) == 0x000118, "Member 'UTgfPawnMaterialManagerComponent::AlternateMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, PetrifactionOverlayMat) == 0x000120, "Member 'UTgfPawnMaterialManagerComponent::PetrifactionOverlayMat' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, PetrifactionOverlayMatDynamic) == 0x000128, "Member 'UTgfPawnMaterialManagerComponent::PetrifactionOverlayMatDynamic' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, StateType) == 0x000130, "Member 'UTgfPawnMaterialManagerComponent::StateType' has a wrong offset!");
static_assert(offsetof(UTgfPawnMaterialManagerComponent, StoneActorPosition) == 0x000138, "Member 'UTgfPawnMaterialManagerComponent::StoneActorPosition' has a wrong offset!");

// Class LyraGame.TgfCharacterMaterialManagerComponent
// 0x01A8 (0x0358 - 0x01B0)
class UTgfCharacterMaterialManagerComponent : public UTgfPawnMaterialManagerComponent
{
public:
	TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache> SubMeshesMaterials;                                // 0x01B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache> SubMeshesCloakingMaterials;                        // 0x0200(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache> EquipmentMaterials;                                // 0x0250(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache> EquipmentCloakingMaterials;                        // 0x02A0(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      CharacterFadeOutMat;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CharacterFadeOutMatDynamic;                        // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      CharacterFriendCloakingMat;                        // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CharacterFriendCloakingMatDynamic;                 // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      CharacterEnemyCloakingMat;                         // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CharacterEnemyCloakingMatDynamic;                  // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      InvincibleOverlayMat;                              // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               InvincibleOverlayMatDynamic;                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfCharacterMaterialCloakType                CloakType;                                         // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMaterialEnum                        MaterialType;                                      // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              ActiveNiagaraSystermComps;                         // 0x0338(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UPointLightComponent*>           ActivePointLightComps;                             // 0x0348(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void BatchSetScalarParameterValue(class FName ParameterName, float AlternateValue, TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache>& AvatarAlternateMaterials, TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache>& EquipmentAlternateMaterials);
	void BatchSetVectorParameterValue(class FName ParameterName, const struct FVector& AlternateValue, TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache>& AvatarAlternateMaterials, TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache>& EquipmentAlternateMaterials);
	void CreateAndSetCharacterDynamicMaterials();
	void RemoveOverlayMaterial();
	void SetAllNiagaraAndLightNewActiveOnWeapons(bool CheckValue);
	void SetCloakType(ETgfCharacterMaterialCloakType NewType);
	void SwitchSkin(class UMaterialInstance* SkinMat);
	void SwitchToCloakingSkin();
	void SwitchToFadeOutSkin();
	void UpdateCloakLerpValue(float LerpValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterMaterialManagerComponent">();
	}
	static class UTgfCharacterMaterialManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterMaterialManagerComponent>();
	}
};
static_assert(alignof(UTgfCharacterMaterialManagerComponent) == 0x000008, "Wrong alignment on UTgfCharacterMaterialManagerComponent");
static_assert(sizeof(UTgfCharacterMaterialManagerComponent) == 0x000358, "Wrong size on UTgfCharacterMaterialManagerComponent");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, SubMeshesMaterials) == 0x0001B0, "Member 'UTgfCharacterMaterialManagerComponent::SubMeshesMaterials' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, SubMeshesCloakingMaterials) == 0x000200, "Member 'UTgfCharacterMaterialManagerComponent::SubMeshesCloakingMaterials' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, EquipmentMaterials) == 0x000250, "Member 'UTgfCharacterMaterialManagerComponent::EquipmentMaterials' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, EquipmentCloakingMaterials) == 0x0002A0, "Member 'UTgfCharacterMaterialManagerComponent::EquipmentCloakingMaterials' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CharacterFadeOutMat) == 0x0002F0, "Member 'UTgfCharacterMaterialManagerComponent::CharacterFadeOutMat' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CharacterFadeOutMatDynamic) == 0x0002F8, "Member 'UTgfCharacterMaterialManagerComponent::CharacterFadeOutMatDynamic' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CharacterFriendCloakingMat) == 0x000300, "Member 'UTgfCharacterMaterialManagerComponent::CharacterFriendCloakingMat' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CharacterFriendCloakingMatDynamic) == 0x000308, "Member 'UTgfCharacterMaterialManagerComponent::CharacterFriendCloakingMatDynamic' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CharacterEnemyCloakingMat) == 0x000310, "Member 'UTgfCharacterMaterialManagerComponent::CharacterEnemyCloakingMat' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CharacterEnemyCloakingMatDynamic) == 0x000318, "Member 'UTgfCharacterMaterialManagerComponent::CharacterEnemyCloakingMatDynamic' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, InvincibleOverlayMat) == 0x000320, "Member 'UTgfCharacterMaterialManagerComponent::InvincibleOverlayMat' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, InvincibleOverlayMatDynamic) == 0x000328, "Member 'UTgfCharacterMaterialManagerComponent::InvincibleOverlayMatDynamic' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, CloakType) == 0x000330, "Member 'UTgfCharacterMaterialManagerComponent::CloakType' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, MaterialType) == 0x000331, "Member 'UTgfCharacterMaterialManagerComponent::MaterialType' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, ActiveNiagaraSystermComps) == 0x000338, "Member 'UTgfCharacterMaterialManagerComponent::ActiveNiagaraSystermComps' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMaterialManagerComponent, ActivePointLightComps) == 0x000348, "Member 'UTgfCharacterMaterialManagerComponent::ActivePointLightComps' has a wrong offset!");

// Class LyraGame.LyraCameraMode_ThirdPerson
// 0x0238 (0x0348 - 0x0110)
class ULyraCameraMode_ThirdPerson : public ULyraCameraMode
{
public:
	class UCurveVector*                           TargetOffsetCurve;                                 // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRuntimeFloatCurves;                            // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     TargetOffsetX;                                     // 0x0120(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     TargetOffsetY;                                     // 0x01A8(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     TargetOffsetZ;                                     // 0x0230(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CrouchOffsetBlendMultiplier;                       // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PenetrationBlendInTime;                            // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendOutTime;                           // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventPenetration;                               // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoPredictiveAvoidance;                            // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0x2];                                      // 0x02C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionPushOutDistance;                          // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReportPenetrationPercent;                          // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraPenetrationAvoidanceFeeler> PenetrationAvoidanceFeelers;                       // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AimLineToDesiredPosBlockedPct;                     // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         DebugActorsHitDuringCameraPenetration;             // 0x02E8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x50];                                     // 0x02F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraMode_ThirdPerson">();
	}
	static class ULyraCameraMode_ThirdPerson* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraMode_ThirdPerson>();
	}
};
static_assert(alignof(ULyraCameraMode_ThirdPerson) == 0x000008, "Wrong alignment on ULyraCameraMode_ThirdPerson");
static_assert(sizeof(ULyraCameraMode_ThirdPerson) == 0x000348, "Wrong size on ULyraCameraMode_ThirdPerson");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, TargetOffsetCurve) == 0x000110, "Member 'ULyraCameraMode_ThirdPerson::TargetOffsetCurve' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, bUseRuntimeFloatCurves) == 0x000118, "Member 'ULyraCameraMode_ThirdPerson::bUseRuntimeFloatCurves' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, TargetOffsetX) == 0x000120, "Member 'ULyraCameraMode_ThirdPerson::TargetOffsetX' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, TargetOffsetY) == 0x0001A8, "Member 'ULyraCameraMode_ThirdPerson::TargetOffsetY' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, TargetOffsetZ) == 0x000230, "Member 'ULyraCameraMode_ThirdPerson::TargetOffsetZ' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, CrouchOffsetBlendMultiplier) == 0x0002B8, "Member 'ULyraCameraMode_ThirdPerson::CrouchOffsetBlendMultiplier' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, PenetrationBlendInTime) == 0x0002BC, "Member 'ULyraCameraMode_ThirdPerson::PenetrationBlendInTime' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, PenetrationBlendOutTime) == 0x0002C0, "Member 'ULyraCameraMode_ThirdPerson::PenetrationBlendOutTime' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, bPreventPenetration) == 0x0002C4, "Member 'ULyraCameraMode_ThirdPerson::bPreventPenetration' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, bDoPredictiveAvoidance) == 0x0002C5, "Member 'ULyraCameraMode_ThirdPerson::bDoPredictiveAvoidance' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, CollisionPushOutDistance) == 0x0002C8, "Member 'ULyraCameraMode_ThirdPerson::CollisionPushOutDistance' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, ReportPenetrationPercent) == 0x0002CC, "Member 'ULyraCameraMode_ThirdPerson::ReportPenetrationPercent' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, PenetrationAvoidanceFeelers) == 0x0002D0, "Member 'ULyraCameraMode_ThirdPerson::PenetrationAvoidanceFeelers' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, AimLineToDesiredPosBlockedPct) == 0x0002E0, "Member 'ULyraCameraMode_ThirdPerson::AimLineToDesiredPosBlockedPct' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_ThirdPerson, DebugActorsHitDuringCameraPenetration) == 0x0002E8, "Member 'ULyraCameraMode_ThirdPerson::DebugActorsHitDuringCameraPenetration' has a wrong offset!");

// Class LyraGame.LyraCameraMode_FirstPerson
// 0x0040 (0x0388 - 0x0348)
class ULyraCameraMode_FirstPerson : public ULyraCameraMode_ThirdPerson
{
public:
	class FName                                   CameraBone;                                        // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoneCameraRotation;                            // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BoneToCameraRotation;                              // 0x0358(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InitFirstPersonCameraOffset;                       // 0x0370(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraMode_FirstPerson">();
	}
	static class ULyraCameraMode_FirstPerson* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraMode_FirstPerson>();
	}
};
static_assert(alignof(ULyraCameraMode_FirstPerson) == 0x000008, "Wrong alignment on ULyraCameraMode_FirstPerson");
static_assert(sizeof(ULyraCameraMode_FirstPerson) == 0x000388, "Wrong size on ULyraCameraMode_FirstPerson");
static_assert(offsetof(ULyraCameraMode_FirstPerson, CameraBone) == 0x000348, "Member 'ULyraCameraMode_FirstPerson::CameraBone' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_FirstPerson, bUseBoneCameraRotation) == 0x000350, "Member 'ULyraCameraMode_FirstPerson::bUseBoneCameraRotation' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_FirstPerson, BoneToCameraRotation) == 0x000358, "Member 'ULyraCameraMode_FirstPerson::BoneToCameraRotation' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_FirstPerson, InitFirstPersonCameraOffset) == 0x000370, "Member 'ULyraCameraMode_FirstPerson::InitFirstPersonCameraOffset' has a wrong offset!");

// Class LyraGame.TgfInventoryItemWrapper
// 0x0020 (0x0048 - 0x0028)
class UTgfInventoryItemWrapper : public UTgfBlueprintableObject
{
public:
	struct FIntPoint                              InventoryPosition;                                 // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAffixDisplayUpdated;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FIntPoint                              InventorySize;                                     // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetCorruptionId();
	int32 GetDurabilityPoint();
	int32 GetMaxDurabilityPoint();
	void GetOwners(TArray<struct FTgfPlayerIDKey>* Owners);
	int32 GetPolishingCount();
	int32 GetSkinId();
	bool HasDurabilityPoint();
	bool IsHeirloom();
	bool IsMyHeirloom(class AActor* SelfActor);
	bool IsSameItem(class UTgfInventoryItemWrapper* AnotherItem);
	bool IsTargetInventory(class AActor* Owner);
	bool IsTeammateInventory(class AActor* ViewCharacter);
	void OnAffixDisplayDataUpdate();
	void SpawnEquipmentActorsWithAttachTarget(class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors, bool bAttachToLeft, bool NeedSkin);

	bool CanDivide() const;
	const class ULyraInventoryItemFragment* FindFragmentByClass(TSubclassOf<class ULyraInventoryItemFragment> FragmentClass, bool bIsSkin) const;
	void GetAffixDisplayConfig(TArray<struct FAffixDisplayConfig>* Base, TArray<struct FAffixDisplayConfig>* Main, TArray<struct FAffixDisplayConfig>* Top, TArray<struct FAffixDisplayConfig>* Gem, TArray<struct FAffixDisplayConfig>* GearSet) const;
	TSubclassOf<class UTgfEquipmentDefinition> GetEquipmentDefinition(bool bIsSkin) const;
	const class UTgfEquipmentDefinition* GetEquipmentDefinitionObject(bool bIsSkin) const;
	ETgfEquipSubType GetEquipSubtype() const;
	int32 GetExpireTimepoint() const;
	class UTGFProtoTgfDItemGem* GetGemData() const;
	int32 GetGuid() const;
	const class UAnimSequenceBase* GetIdleAnimation(class UTgfInventoryItemWrapper* OffhandItem, const struct FGameplayTagContainer& WithTags, bool* bIsRightIdle) const;
	TSubclassOf<class UTgfInventoryItemDefinition> GetItemDefinition(bool bIsSkin) const;
	const class UTgfInventoryItemDefinition* GetItemDefinitionObject(bool bIsSkin) const;
	struct FIntPoint GetItemSize() const;
	int32 GetStackCount() const;
	int32 GetTypeId() const;
	ETgfWeaponEquipType GetWeaponEquipType() const;
	bool IsTheSameAs(class UTgfInventoryItemWrapper* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper">();
	}
	static class UTgfInventoryItemWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper");
static_assert(sizeof(UTgfInventoryItemWrapper) == 0x000048, "Wrong size on UTgfInventoryItemWrapper");
static_assert(offsetof(UTgfInventoryItemWrapper, InventoryPosition) == 0x000028, "Member 'UTgfInventoryItemWrapper::InventoryPosition' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper, OnAffixDisplayUpdated) == 0x000030, "Member 'UTgfInventoryItemWrapper::OnAffixDisplayUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper, InventorySize) == 0x000040, "Member 'UTgfInventoryItemWrapper::InventorySize' has a wrong offset!");

// Class LyraGame.TgfCameraMode_ThirdPersonFree
// 0x0058 (0x03A0 - 0x0348)
class UTgfCameraMode_ThirdPersonFree : public ULyraCameraMode_ThirdPerson
{
public:
	bool                                          bUseFreePerspective;                               // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBlendingCurve;                                 // 0x0349(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           LocationBlendingOffset;                            // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraBone;                                        // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBoneCameraRotation;                            // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BoneToCameraRotation;                              // 0x0368(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveVector*                           TargetRotationOffsetCurve;                         // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseControlledPitchCurve;                          // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PitchOffsetCurve;                                  // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraMode_ThirdPersonFree">();
	}
	static class UTgfCameraMode_ThirdPersonFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraMode_ThirdPersonFree>();
	}
};
static_assert(alignof(UTgfCameraMode_ThirdPersonFree) == 0x000008, "Wrong alignment on UTgfCameraMode_ThirdPersonFree");
static_assert(sizeof(UTgfCameraMode_ThirdPersonFree) == 0x0003A0, "Wrong size on UTgfCameraMode_ThirdPersonFree");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, bUseFreePerspective) == 0x000348, "Member 'UTgfCameraMode_ThirdPersonFree::bUseFreePerspective' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, bUseBlendingCurve) == 0x000349, "Member 'UTgfCameraMode_ThirdPersonFree::bUseBlendingCurve' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, LocationBlendingOffset) == 0x000350, "Member 'UTgfCameraMode_ThirdPersonFree::LocationBlendingOffset' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, CameraBone) == 0x000358, "Member 'UTgfCameraMode_ThirdPersonFree::CameraBone' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, bUseBoneCameraRotation) == 0x000360, "Member 'UTgfCameraMode_ThirdPersonFree::bUseBoneCameraRotation' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, BoneToCameraRotation) == 0x000368, "Member 'UTgfCameraMode_ThirdPersonFree::BoneToCameraRotation' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, TargetRotationOffsetCurve) == 0x000380, "Member 'UTgfCameraMode_ThirdPersonFree::TargetRotationOffsetCurve' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, bUseControlledPitchCurve) == 0x000388, "Member 'UTgfCameraMode_ThirdPersonFree::bUseControlledPitchCurve' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_ThirdPersonFree, PitchOffsetCurve) == 0x000390, "Member 'UTgfCameraMode_ThirdPersonFree::PitchOffsetCurve' has a wrong offset!");

// Class LyraGame.LyraCameraMode_Spectator
// 0x0020 (0x03C0 - 0x03A0)
class ULyraCameraMode_Spectator final : public UTgfCameraMode_ThirdPersonFree
{
public:
	float                                         DistanceFilterThreshold;                           // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceUpdateThreshold;                              // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraMode_Spectator">();
	}
	static class ULyraCameraMode_Spectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraMode_Spectator>();
	}
};
static_assert(alignof(ULyraCameraMode_Spectator) == 0x000008, "Wrong alignment on ULyraCameraMode_Spectator");
static_assert(sizeof(ULyraCameraMode_Spectator) == 0x0003C0, "Wrong size on ULyraCameraMode_Spectator");
static_assert(offsetof(ULyraCameraMode_Spectator, DistanceFilterThreshold) == 0x0003A0, "Member 'ULyraCameraMode_Spectator::DistanceFilterThreshold' has a wrong offset!");
static_assert(offsetof(ULyraCameraMode_Spectator, ForceUpdateThreshold) == 0x0003A4, "Member 'ULyraCameraMode_Spectator::ForceUpdateThreshold' has a wrong offset!");

// Class LyraGame.TgfCheatComponent
// 0x0080 (0x0128 - 0x00A8)
class UTgfCheatComponent final : public UGameFrameworkComponent
{
public:
	struct FLyraAbilitySet_GrantedHandles         GrantedHandles;                                    // 0x00A8(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void ActivateAllEscapeDevices(class UWorld* World);
	void AddBlockingLootSlot(class UTgfEquipmentManagerComponent* EquipmentComponent, int32 Slot);
	void AddGearsetLevel(class UTgfEquipmentManagerComponent* EquipmentComponent, int32 GearsetId, int32 DeltaLevel);
	void AddItemDefinition(class UTgfInventoryManagerComponent* InventoryComponent, TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToAdd);
	void AddLooseGameplayTag(class ULyraAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& GameplayTag, int32 Nums, bool NeedReplicated);
	void AddLooseGameplayTagWithFString(class ULyraAbilitySystemComponent* AbilitySystemComponent, const class FString& TagName, int32 Nums, bool NeedReplicated);
	void AddLootItem(class UTgfInventoryManagerComponent* InventoryComponent, int32 ItemId, int32 Nums);
	void AddPlayerBots(int32 AddCnt);
	void ClearAbility(class ULyraAbilitySystemComponent* AbilitySystemComponent);
	void ClearAllGearsetLevel(class UTgfEquipmentManagerComponent* EquipmentComponent);
	void ClientSetPlayMontagePlay(bool bOpenServerPlayDelay, float DelayTime, bool bOpenClientBehind, bool bOpenClientAhead, float ChaseMaxPing);
	void ClientShowPortalLocations(const TArray<struct FVector>& Locations);
	void DealAttrValue(class ULyraAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& GPAttr, float Value, EGameplayModOp ModOp);
	void DsQuitGame(class APlayerState* PlayerState, int32 Type);
	void EndCurrentPhase(class UWorld* World);
	void ForceGC(bool FullPurge);
	void FreezeSelf(class ALyraCharacter* Character, bool bFreeze);
	void GiveAbility(class ULyraAbilitySystemComponent* AbilitySystemComponent, const class FString& AssetName);
	void MultiWorldTravel(const class FString& MapPath);
	void PrintActorMapLog(int32 ActorNum, int32 AIEnableNum, int32 AITotalNum, int32 TickEnableNum, int32 TickTotalNum, float AIBound, float TickBound);
	void PrintActorMapRPC();
	void RebirthSelf(class ALyraCharacter* LyraCharacter, class ULyraAbilitySystemComponent* AbilitySystemComponent);
	void RecoverAmmo(class AActor* InActor);
	void ReinitCharaCareer(class ALyraCharacter* Character, ETgfActorCareer Career);
	void RemoveItemByDefinition(class UTgfInventoryManagerComponent* InventoryComponent, TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToRemove);
	void RemoveLooseGameplayTag(class ULyraAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& GameplayTag, int32 Nums, bool NeedReplicated);
	void RemoveLooseGameplayTagWithFString(class ULyraAbilitySystemComponent* AbilitySystemComponent, const class FString& TagName, int32 Nums, bool NeedReplicated);
	void RemovePlayerBots(int32 RemoveCnt);
	void ResizeInventory(class UTgfInventoryManagerComponent* InventoryComponent, const struct FIntPoint& Size, ELyraInventoryType InventoryType);
	void ServerSetPlayMontagePlay(bool bOpenServerPlayDelay, float DelayTime, bool bOpenClientBehind, bool bOpenClientAhead, float ChaseMaxPing);
	void SetActorMapBounds(float AIBound, float TickBound);
	void SetDeathZoneEnabled(class UWorld* World, int32 Enabled);
	void SetMithrilCharacter(class ALyraCharacter* Character, bool Value, int32 Level, int32 RemainingRebirthChance);
	void SetPlayerSceneTag(class ALyraCharacter* Character, int32 Tag);
	void ShowAllTagServer();
	void ShowGoblinThief();
	void ShowPortalLocations(int32 PortalType);
	void SpawnActor(TSubclassOf<class AActor> Param_Class, const struct FVector& Position);
	void SpawnAllEscapeDevices(class UWorld* World);
	void SpawnAllPortalsAndScrolls();
	void SpawnMonster(TSubclassOf<class ALyraCharacter> Param_Class, const struct FVector& Position, int32 LootIndex, bool Dormant);
	void SpawnOnePortal(int32 PortalType, const struct FVector& Location);
	void TeleportChara(class APawn* Pawn, const struct FVector& Location, const struct FRotator& Rotation);
	void ToggleIgnoreAbilitySystemArg(int32 Type, bool Enabled);
	void TryIncreaseAndCheckSecurityInvalidCount(class ALyraPlayerController* PC, int32 Reason);
	void WaitingRoomCountdown(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCheatComponent">();
	}
	static class UTgfCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCheatComponent>();
	}
};
static_assert(alignof(UTgfCheatComponent) == 0x000008, "Wrong alignment on UTgfCheatComponent");
static_assert(sizeof(UTgfCheatComponent) == 0x000128, "Wrong size on UTgfCheatComponent");
static_assert(offsetof(UTgfCheatComponent, GrantedHandles) == 0x0000A8, "Member 'UTgfCheatComponent::GrantedHandles' has a wrong offset!");

// Class LyraGame.LyraCameraModifier_RotationAdjust
// 0x0008 (0x0050 - 0x0048)
class ULyraCameraModifier_RotationAdjust final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraModifier_RotationAdjust">();
	}
	static class ULyraCameraModifier_RotationAdjust* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraModifier_RotationAdjust>();
	}
};
static_assert(alignof(ULyraCameraModifier_RotationAdjust) == 0x000008, "Wrong alignment on ULyraCameraModifier_RotationAdjust");
static_assert(sizeof(ULyraCameraModifier_RotationAdjust) == 0x000050, "Wrong size on ULyraCameraModifier_RotationAdjust");

// Class LyraGame.LyraContextEffectsInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraContextEffectsInterface final : public IInterface
{
public:
	void AnimMotionEffect(const class FName bone, const struct FGameplayTag& MotionEffect, class USceneComponent* StaticMeshComponent, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const class UAnimSequenceBase* AnimationSequence, const bool bHitSuccess, const struct FHitResult& HitResult, const struct FGameplayTagContainer& Contexts, const struct FVector& VFXScale, float AudioVolume, float AudioPitch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraContextEffectsInterface">();
	}
	static class ILyraContextEffectsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraContextEffectsInterface>();
	}
};
static_assert(alignof(ILyraContextEffectsInterface) == 0x000008, "Wrong alignment on ILyraContextEffectsInterface");
static_assert(sizeof(ILyraContextEffectsInterface) == 0x000028, "Wrong size on ILyraContextEffectsInterface");

// Class LyraGame.TgfHeadCosmeticDataAsset
// 0x0150 (0x0180 - 0x0030)
class UTgfHeadCosmeticDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<struct FTgfPresetAppearanceTemplate>   AppearanceTemplate;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMeshConfig>                 FaceMeshContainer;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMeshConfig>                 HairMeshContainer;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMeshConfig>                 BeardMeshContainer;                                // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfTextureConfig>              TatooTextureContainer;                             // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfColorConfig>                HairColorContainer;                                // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfColorConfig>                SkinColorContainer;                                // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMaterialConfig>             SkinMaterialContainer;                             // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMaterialConfig>             SkinMaterialContainer_FP;                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfColorConfig>                TatooColorContainer;                               // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfColorConfig>                EyeColorContainer;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfTextureConfig>              ScarTextureContainer;                              // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfTextureConfig>              ScarNormalMapContainer;                            // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfTextureConfig>              MakeupTextureContainer;                            // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfColorConfig>                MakeupColorContainer;                              // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfConfigParamConfig>          ColorConfigContainer;                              // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ETgfActorGender, struct FTgfGenderConfig> MapGenderAsset;                                    // 0x0130(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static struct FTgfHeadResConfig UpdateHeadResConfigWithTemplateID(int32 InTemplateID, const struct FTgfHeadResConfig& InHeadResConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfHeadCosmeticDataAsset">();
	}
	static class UTgfHeadCosmeticDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfHeadCosmeticDataAsset>();
	}
};
static_assert(alignof(UTgfHeadCosmeticDataAsset) == 0x000008, "Wrong alignment on UTgfHeadCosmeticDataAsset");
static_assert(sizeof(UTgfHeadCosmeticDataAsset) == 0x000180, "Wrong size on UTgfHeadCosmeticDataAsset");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, AppearanceTemplate) == 0x000030, "Member 'UTgfHeadCosmeticDataAsset::AppearanceTemplate' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, FaceMeshContainer) == 0x000040, "Member 'UTgfHeadCosmeticDataAsset::FaceMeshContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, HairMeshContainer) == 0x000050, "Member 'UTgfHeadCosmeticDataAsset::HairMeshContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, BeardMeshContainer) == 0x000060, "Member 'UTgfHeadCosmeticDataAsset::BeardMeshContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, TatooTextureContainer) == 0x000070, "Member 'UTgfHeadCosmeticDataAsset::TatooTextureContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, HairColorContainer) == 0x000080, "Member 'UTgfHeadCosmeticDataAsset::HairColorContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, SkinColorContainer) == 0x000090, "Member 'UTgfHeadCosmeticDataAsset::SkinColorContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, SkinMaterialContainer) == 0x0000A0, "Member 'UTgfHeadCosmeticDataAsset::SkinMaterialContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, SkinMaterialContainer_FP) == 0x0000B0, "Member 'UTgfHeadCosmeticDataAsset::SkinMaterialContainer_FP' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, TatooColorContainer) == 0x0000C0, "Member 'UTgfHeadCosmeticDataAsset::TatooColorContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, EyeColorContainer) == 0x0000D0, "Member 'UTgfHeadCosmeticDataAsset::EyeColorContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, ScarTextureContainer) == 0x0000E0, "Member 'UTgfHeadCosmeticDataAsset::ScarTextureContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, ScarNormalMapContainer) == 0x0000F0, "Member 'UTgfHeadCosmeticDataAsset::ScarNormalMapContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, MakeupTextureContainer) == 0x000100, "Member 'UTgfHeadCosmeticDataAsset::MakeupTextureContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, MakeupColorContainer) == 0x000110, "Member 'UTgfHeadCosmeticDataAsset::MakeupColorContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, ColorConfigContainer) == 0x000120, "Member 'UTgfHeadCosmeticDataAsset::ColorConfigContainer' has a wrong offset!");
static_assert(offsetof(UTgfHeadCosmeticDataAsset, MapGenderAsset) == 0x000130, "Member 'UTgfHeadCosmeticDataAsset::MapGenderAsset' has a wrong offset!");

// Class LyraGame.LyraDamagePopStyleNiagara
// 0x0010 (0x0040 - 0x0030)
class ULyraDamagePopStyleNiagara final : public UDataAsset
{
public:
	class FName                                   NiagaraArrayName;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TextNiagara;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDamagePopStyleNiagara">();
	}
	static class ULyraDamagePopStyleNiagara* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraDamagePopStyleNiagara>();
	}
};
static_assert(alignof(ULyraDamagePopStyleNiagara) == 0x000008, "Wrong alignment on ULyraDamagePopStyleNiagara");
static_assert(sizeof(ULyraDamagePopStyleNiagara) == 0x000040, "Wrong size on ULyraDamagePopStyleNiagara");
static_assert(offsetof(ULyraDamagePopStyleNiagara, NiagaraArrayName) == 0x000030, "Member 'ULyraDamagePopStyleNiagara::NiagaraArrayName' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyleNiagara, TextNiagara) == 0x000038, "Member 'ULyraDamagePopStyleNiagara::TextNiagara' has a wrong offset!");

// Class LyraGame.LyraWeaponBase
// 0x0118 (0x03B0 - 0x0298)
class ALyraWeaponBase : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTgfEquipmentInstance*                  EquipmentInstance;                                 // 0x02B8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponAttachSocket                    EquipSocket;                                       // 0x02C0(0x0070)(Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAttachSocket                    UnequipSocket;                                     // 0x0330(0x0070)(Net, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachParent;                                      // 0x03A0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMaterialDynamicModify;                      // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Held;                                              // 0x03A9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnFOVConfigChanged();
	void K2_OnWeaponVisibleChanged(bool Visiblity);
	void OnRep_Held(bool OldHeld);
	void ReceiveOnHeld();
	void ReceiveOnSpawn();
	void ReceiveOnUnHeld();
	void SetEquipmentInstance(class UTgfEquipmentInstance* Instance);

	class UTgfEquipmentInstance* GetEquipmentInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponBase">();
	}
	static class ALyraWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraWeaponBase>();
	}
};
static_assert(alignof(ALyraWeaponBase) == 0x000010, "Wrong alignment on ALyraWeaponBase");
static_assert(sizeof(ALyraWeaponBase) == 0x0003B0, "Wrong size on ALyraWeaponBase");
static_assert(offsetof(ALyraWeaponBase, EquipmentInstance) == 0x0002B8, "Member 'ALyraWeaponBase::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(ALyraWeaponBase, EquipSocket) == 0x0002C0, "Member 'ALyraWeaponBase::EquipSocket' has a wrong offset!");
static_assert(offsetof(ALyraWeaponBase, UnequipSocket) == 0x000330, "Member 'ALyraWeaponBase::UnequipSocket' has a wrong offset!");
static_assert(offsetof(ALyraWeaponBase, AttachParent) == 0x0003A0, "Member 'ALyraWeaponBase::AttachParent' has a wrong offset!");
static_assert(offsetof(ALyraWeaponBase, bEnableMaterialDynamicModify) == 0x0003A8, "Member 'ALyraWeaponBase::bEnableMaterialDynamicModify' has a wrong offset!");
static_assert(offsetof(ALyraWeaponBase, Held) == 0x0003A9, "Member 'ALyraWeaponBase::Held' has a wrong offset!");

// Class LyraGame.TGFCombatZoneComponent
// 0x0018 (0x00C0 - 0x00A8)
class UTGFCombatZoneComponent final : public UGameFrameworkComponent
{
public:
	class AActor*                                 CombatZone;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize();
	bool IsInside(const struct FVector& InPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCombatZoneComponent">();
	}
	static class UTGFCombatZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCombatZoneComponent>();
	}
};
static_assert(alignof(UTGFCombatZoneComponent) == 0x000008, "Wrong alignment on UTGFCombatZoneComponent");
static_assert(sizeof(UTGFCombatZoneComponent) == 0x0000C0, "Wrong size on UTGFCombatZoneComponent");
static_assert(offsetof(UTGFCombatZoneComponent, CombatZone) == 0x0000A8, "Member 'UTGFCombatZoneComponent::CombatZone' has a wrong offset!");

// Class LyraGame.MinimapReferencer
// 0x0038 (0x02D0 - 0x0298)
class AMinimapReferencer final : public AActor
{
public:
	class UTexture2D*                             FullMapTexture;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               MapBounds;                                         // 0x02A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapViewportSize;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapReferencer">();
	}
	static class AMinimapReferencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMinimapReferencer>();
	}
};
static_assert(alignof(AMinimapReferencer) == 0x000010, "Wrong alignment on AMinimapReferencer");
static_assert(sizeof(AMinimapReferencer) == 0x0002D0, "Wrong size on AMinimapReferencer");
static_assert(offsetof(AMinimapReferencer, FullMapTexture) == 0x000298, "Member 'AMinimapReferencer::FullMapTexture' has a wrong offset!");
static_assert(offsetof(AMinimapReferencer, MapBounds) == 0x0002A0, "Member 'AMinimapReferencer::MapBounds' has a wrong offset!");
static_assert(offsetof(AMinimapReferencer, MinimapViewportSize) == 0x0002C0, "Member 'AMinimapReferencer::MinimapViewportSize' has a wrong offset!");

// Class LyraGame.LyraTeamAgentInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraTeamAgentInterface final : public IGenericTeamAgentInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamAgentInterface">();
	}
	static class ILyraTeamAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraTeamAgentInterface>();
	}
};
static_assert(alignof(ILyraTeamAgentInterface) == 0x000008, "Wrong alignment on ILyraTeamAgentInterface");
static_assert(sizeof(ILyraTeamAgentInterface) == 0x000028, "Wrong size on ILyraTeamAgentInterface");

// Class LyraGame.TgfAbilityCost_Equipment
// 0x0038 (0x0070 - 0x0038)
class UTgfAbilityCost_Equipment final : public ULyraAbilityCost
{
public:
	struct FScalableFloat                         Quantity;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ULyraInventoryItemDefinition> ItemDefinition;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSpecSlot;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfWeaponChangeSlot                          SpecSlot;                                          // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSwitchSlot;                                 // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityCost_Equipment">();
	}
	static class UTgfAbilityCost_Equipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityCost_Equipment>();
	}
};
static_assert(alignof(UTgfAbilityCost_Equipment) == 0x000008, "Wrong alignment on UTgfAbilityCost_Equipment");
static_assert(sizeof(UTgfAbilityCost_Equipment) == 0x000070, "Wrong size on UTgfAbilityCost_Equipment");
static_assert(offsetof(UTgfAbilityCost_Equipment, Quantity) == 0x000038, "Member 'UTgfAbilityCost_Equipment::Quantity' has a wrong offset!");
static_assert(offsetof(UTgfAbilityCost_Equipment, ItemDefinition) == 0x000060, "Member 'UTgfAbilityCost_Equipment::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UTgfAbilityCost_Equipment, bUseSpecSlot) == 0x000068, "Member 'UTgfAbilityCost_Equipment::bUseSpecSlot' has a wrong offset!");
static_assert(offsetof(UTgfAbilityCost_Equipment, SpecSlot) == 0x000069, "Member 'UTgfAbilityCost_Equipment::SpecSlot' has a wrong offset!");
static_assert(offsetof(UTgfAbilityCost_Equipment, bIgnoreSwitchSlot) == 0x00006A, "Member 'UTgfAbilityCost_Equipment::bIgnoreSwitchSlot' has a wrong offset!");

// Class LyraGame.TgfAbilityCost_WeaponAmmo
// 0x0030 (0x0068 - 0x0038)
class UTgfAbilityCost_WeaponAmmo final : public ULyraAbilityCost
{
public:
	struct FScalableFloat                         Quantity;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ETgfWeaponHandType                            HandType;                                          // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityCost_WeaponAmmo">();
	}
	static class UTgfAbilityCost_WeaponAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityCost_WeaponAmmo>();
	}
};
static_assert(alignof(UTgfAbilityCost_WeaponAmmo) == 0x000008, "Wrong alignment on UTgfAbilityCost_WeaponAmmo");
static_assert(sizeof(UTgfAbilityCost_WeaponAmmo) == 0x000068, "Wrong size on UTgfAbilityCost_WeaponAmmo");
static_assert(offsetof(UTgfAbilityCost_WeaponAmmo, Quantity) == 0x000038, "Member 'UTgfAbilityCost_WeaponAmmo::Quantity' has a wrong offset!");
static_assert(offsetof(UTgfAbilityCost_WeaponAmmo, HandType) == 0x000060, "Member 'UTgfAbilityCost_WeaponAmmo::HandType' has a wrong offset!");

// Class LyraGame.LyraSignificanceManager
// 0x0000 (0x0140 - 0x0140)
class ULyraSignificanceManager final : public USignificanceManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSignificanceManager">();
	}
	static class ULyraSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSignificanceManager>();
	}
};
static_assert(alignof(ULyraSignificanceManager) == 0x000008, "Wrong alignment on ULyraSignificanceManager");
static_assert(sizeof(ULyraSignificanceManager) == 0x000140, "Wrong size on ULyraSignificanceManager");

// Class LyraGame.TgfAbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromPassiveMoveInfo(const struct FTgfGameplayAbilityTargetingPassiveMoveInfo& PassiveMoveInfo);
	static void AddFullWeaponAmmo(class AActor* InActor, bool Right);
	static void AddGameplayEffectContextSourceObject(const struct FGameplayEffectContextHandle& GECH, class UObject* Object);
	static void AddItemByDef(class AActor* Target, TSubclassOf<class UTgfInventoryItemDefinition> ItemDef, int32 Num, const class FString& ClassName);
	static void AddWeaponAmmoByCountWithoutCostItem(class AActor* InActor, bool Right, int32 AddCount);
	static void AfterApplyGEWithSpec(class AActor* Instigator, class AActor* Target, TArray<struct FGameplayEffectSpec>* GESpecApplied);
	static bool AmmoAutoRecoverByInstance(class AActor* InActor, class UTgfInventoryItemInstance* Instance);
	static void AmmoAutoRecoverBySlot(class AActor* InActor, ETgfWeaponChangeSlot ChangeSlot);
	static bool AmmoClearByInstance(class AActor* InActor, class UTgfInventoryItemInstance* Instance);
	static void ApplyAOEWithGA(class AActor* Source, TArray<class AActor*>& Targets, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 MaxNum, ELyraTeamComparison TeamRestrict, TArray<class ALyraCharacter*>* AppliedActors, class UGameplayAbility* SourceGA, const struct FTgfApplyAOEExtraParam& ExtraParams);
	static void ApplyGE(class AActor* Instigator, class AActor* Target, class UAbilitySystemComponent* ASCInstigator, class UAbilitySystemComponent* ASCHitActor, const struct FGameplayEffectContextHandle& GECH, const TArray<TSubclassOf<class UGameplayEffect>>& GEs, float DamageRate, float WeaponAttack);
	static bool ApplyHitValueAndInterrupt(float HitValue, const struct FGameplayEffectContextHandle& InEffectContext, TSubclassOf<class UGameplayEffect> InterruptGEClass, class UAbilitySystemComponent* Src, class UAbilitySystemComponent* Trg, bool TargetIsPlayer, bool CanCauseInterrupt, float Level);
	static void AutoFillAdditionalWeaponSlot(class ALyraCharacter* LyraCharacter, ETgfEquipSubType WeaponType);
	static void BeforeApplyGEWithSpec(class AActor* Instigator, class AActor* Target, TArray<struct FGameplayEffectSpec>* GESpecToApply);
	static float CalcHitValue(class AActor* SrcActor, class AActor* TrgActor, ETgfUseAttackType AttackType, bool Guarded, float OverrideAtk, float OverrideDef);
	static bool CanBeTarget(class AActor* InputActor);
	static bool CapsuleTraceMultiWithHeightLimit(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, float HalfHeight, float NotHigherThanCenter, float NotLowerThanCenter, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CheckCanReload(class AActor* InActor, bool Right);
	static bool CheckGuardedProjectile(class AActor* HitActor, struct FHitResult& HitResult);
	static bool CheckHasAbility(class AActor* Actor, TSubclassOf<class UGameplayAbility> InAbilityClass);
	static bool CheckNeedSnap(class UAnimMontage* Montage);
	static bool CheckNeedTriggerReload(class AActor* InActor, bool Right);
	static bool CheckVisibilityToLocalPlayer(class AActor* TargetActor, const struct FGameplayTag& VisibleTag);
	static bool ConsumeItemByWeaponInHand(class AActor* InActor, bool Right, int32 Num);
	static bool DisperseActiveBuff(TArray<class AActor*>& Actors, const struct FGameplayTag& Tag, const struct FGameplayTagContainer& HighPriorityTags, int32 Num);
	static void DoFullReload(class AActor* InActor);
	static void DropAllAdditionalInventoryItem(class AActor* Target, TArray<class ULyraInventoryItemInstance*>* Items);
	static void EffectContextAddExtraParam(const struct FGameplayEffectContextHandle& InEffectContext, const struct FTgfGameplayEffectExtraParam& InExtraParam, bool bReset);
	static void EffectContextAddInstigator(const struct FGameplayEffectContextHandle& EffectContext, class AActor* InInstigator, class AActor* InEffectCauser);
	static const class UGameplayAbility* EffectContextGetAbility(const struct FGameplayEffectContextHandle& EffectContext);
	static const class UGameplayAbility* EffectContextGetAbilityInstance(const struct FGameplayEffectContextHandle& EffectContext);
	static float EffectContextGetCriticalRandomValue(const struct FGameplayEffectContextHandle& InEffectContext);
	static const struct FTgfGameplayEffectExtraParam EffectContextGetExtraParam(const struct FGameplayEffectContextHandle& InEffectContext);
	static float EffectContextGetHitValue(const struct FGameplayEffectContextHandle& InEffectContext);
	static float EffectContextGetNormalWeight(const struct FGameplayEffectContextHandle& InEffectContext);
	static float EffectContextGetTangentWeight(const struct FGameplayEffectContextHandle& InEffectContext);
	static bool EffectContextHasExtraParam(const struct FGameplayEffectContextHandle& InEffectContext);
	static void EffectContextSetCriticalRandomValue(const struct FGameplayEffectContextHandle& InEffectContext, float InValue);
	static void EffectContextSetDirectionWeight(const struct FGameplayEffectContextHandle& InEffectContext, float InNormalWeight, float InTangentWeight);
	static void EffectContextSetHitValue(const struct FGameplayEffectContextHandle& InEffectContext, float InHitValue);
	static void EffectContextSetSourceAbility(const struct FGameplayEffectContextHandle& EffectContext, const class UGameplayAbility* GameplayAbility);
	static class AActor* FindBackStabActor(class AActor* SrcActor, const struct FVector& ViewForward, const struct FVector& ViewPos, float BackDegree, float HDegree, float VDegree, float Radius);
	static class UActorComponent* FindDefaultComponentByClass(const TSubclassOf<class AActor> InActorClass, const TSubclassOf<class UActorComponent> InComponentClass);
	static struct FVector FindProperGroundPos(const class UObject* WorldContextObject, const struct FVector& NowPos, float CheckDepth);
	static bool GetActiveGameplayEffectHandleByClass(class AActor* Target, TSubclassOf<class UTgfGameplayEffect> GEClass, struct FActiveGameplayEffectHandle* OutHandle);
	static void GetAllMatchingTags(class ULyraAbilitySystemComponent* ASC, const struct FGameplayTagContainer& TagsToMatch, struct FGameplayTagContainer* MatchResult);
	static int32 GetAmmoItemCount(class AActor* InActor, bool Right);
	static int32 GetAmmoItemCountBySlot(class AActor* InActor, ETgfEquipSlot Slot);
	static TSubclassOf<class ATgfProjectileBase> GetAnimDriveProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult);
	static float GetAttackRate(class AActor* SrcActor, float DefaultRate);
	static float GetAttackWeight(class AActor* SrcActor, ETgfUseAttackType AttackType);
	static class FString GetConsoleVariableSourceByName(const class FString& VariableName);
	static class APlayerController* GetControllerFromGameplayCueParameters(const struct FGameplayCueParameters& Parameters);
	static float GetCoolDownCountDuration(class AActor* SrcActor, float DefaultDuration);
	static bool GetCurrentCharacterState(class ALyraCharacter* InActor, struct FGameplayTag* CharacterStateTag);
	static class ULyraEquipmentInstance* GetCurrentHandEquipInstance(class AActor* InActor, bool Right);
	static ETgfEquipSlot GetCurrentHandEquipSlot(class AActor* InActor, bool Right);
	static const class UTgfWeaponDefinition* GetCurrentWeaponDefinition(class AActor* InActor, bool Right, int32 IgnoreIndex);
	static class AActor* GetCurrentWeaponFirstActor(class AActor* InActor, bool Right);
	static bool GetDamageSourceDir(float* OutAngle, const struct FGameplayEffectContextHandle& EffectContext, class AActor* Instigator, class AActor* Target);
	static float GetDefendValue(class AActor* SrcActor, bool Guarded);
	static ETgfEquipQuality GetDisplayQualityByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex);
	static class USkeletalMesh* GetEquipSkeletalMesh(class ULyraEquipmentInstance* EquipInstance);
	static class ULyraInventoryItemInstance* GetInventoryItemInstanceByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex);
	static float GetMontageRate(class AActor* SrcActor, ETgfMontageRateType RateType, float DefaultRate);
	static float GetMoveActorNotifyDuration(class UAnimMontage* Montage);
	static TSubclassOf<class ATgfProjectileBase> GetNoHitProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult);
	static TSubclassOf<class ATgfProjectileBase> GetNormalProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult);
	static float GetSharedDPH(float DPH, int32 ActualNum, float MinSharedNum, float MinDPHRate);
	static float GetSnapNotifyDuration(class UAnimMontage* Montage);
	static TSubclassOf<class ATgfProjectileBase> GetTaggedProjectile(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, const struct FGameplayTag& ProjectileTag, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult);
	static const struct FTgfGameplayAbilityTargetData_PassiveMove GetTargetDataPassiveMoveInfo(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Param_Index);
	static TSubclassOf<class ATgfProjectileBase> GetTrackProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult);
	static float GetVulnerFactorRawValue(class AActor* SrcActor, const struct FGameplayTagContainer& TagContainer);
	static EWeaponAmmoType GetWeaponAmmoType(class AActor* InActor, bool Right);
	static float GetWeaponAttack(class AActor* SrcActor, ETgfUseAttackType AttackType);
	static int32 GetWeaponCurAmmo(class AActor* InActor, bool Right);
	static int32 GetWeaponCurAmmoBySlot(class AActor* InActor, ETgfEquipSlot Slot);
	static const class UTgfWeaponDefinition* GetWeaponDefinitionByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex);
	static class UTgfInventoryItemInstance* GetWeaponInventoryItemInstance(class AActor* InActor, bool Right);
	static int32 GetWeaponMaxAmmo(class AActor* InActor, bool Right);
	static int32 GetWeaponMaxAmmoBySlot(class AActor* InActor, ETgfEquipSlot Slot);
	static bool HasAllMatchingGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags);
	static bool HasAnyMatchingGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags);
	static bool IsAbilityFromCurrentHand(class AActor* InActor, class UTgfGameplayAbility* Ability, bool Right);
	static bool IsCharacterState(class ALyraCharacter* InActor, const struct FGameplayTag& CharacterStateTag);
	static bool IsCritical(class UAbilitySystemComponent* SrcABS, class UAbilitySystemComponent* TrgABS, float CriticalRandom);
	static bool IsEquipLocked(const class UTgfEquipmentManagerComponent* EquipmentManager, const class ULyraEquipmentInstance* EquipIns);
	static bool IsHPFull(class AActor* TargetActor);
	static bool IsInstigatorSummonSourceLocallyControlled(const struct FGameplayCueParameters& Parameters);
	static bool IsNaturalEnergyEmpty(class AActor* TargetActor);
	static bool IsNormalCharacterState(class ALyraCharacter* InActor);
	static bool IsSoulEnergyFull(class AActor* TargetActor);
	static bool IsWhichHandWeapon(class AActor* InActor, bool Right);
	static ETgfWeaponChangeSlot IterateAvailableSlot(const class UTgfEquipmentManagerComponent* EquipmentManager, int32 Step, const TArray<ETgfWeaponChangeSlot>& SlotList);
	static struct FGameplayEffectSpecHandle MakeGESpecHandle(TSubclassOf<class UGameplayEffect> GameplayEffectDef, const struct FGameplayEffectContextHandle& GECH, float InLevel);
	static void RecoverAllSlotWeaponAmmoWithoutCostItem(class AActor* InActor);
	static void RecoverSlotWeaponAmmoWithoutCostItem(class AActor* InActor, ETgfWeaponChangeSlot ChangeSlot);
	static void ReturnMagicCost(TSubclassOf<class UGameplayEffect> ReturnMagicGEClass, class UAbilitySystemComponent* Src, float CostValue, const struct FGameplayEffectContextHandle& EffectContext, int32 Level);
	static void SendClearAdditionalInventoryEvent(class ALyraCharacter* Character, bool bNeedDrop);
	static void SendCommonGameEvent(const struct FGameplayTag& InstigatorEvent, const struct FGameplayTag& TargetEvent, class AActor* Instigator, class AActor* Target, const TArray<struct FGameplayEffectSpec>& GESpecToApply);
	static void SendGameplayEventToCharaOrInteract(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	static bool ShouldHitValueInterrupt(const class UObject* WorldContextObject, float HitValue, bool CanCauseInterrupt, bool TargetIsPlayer, bool HasDefence, bool HasCharging, bool HasUninterruptible);
	static void TestRootMotion(class ALyraCharacter* InActor, const struct FVector& TargetLocation, float Duration);
	static void UseWeaponAmmo(class AActor* InActor, int32 UseCount, bool Right);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilitySystemBlueprintLibrary">();
	}
	static class UTgfAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UTgfAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UTgfAbilitySystemBlueprintLibrary");
static_assert(sizeof(UTgfAbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UTgfAbilitySystemBlueprintLibrary");

// Class LyraGame.TgfAbilityTask_WaitGameplayEvent
// 0x0098 (0x0118 - 0x0080)
class UTgfAbilityTask_WaitGameplayEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x28];                                      // 0x0090(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x58];                                      // 0x00C0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfAbilityTask_WaitGameplayEvent* WaitGameplayEventWithTime(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& EventTags, class AActor* Param_OptionalExternalTarget, bool OnlyTriggerOnce, bool OnlyMatchExact);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityTask_WaitGameplayEvent">();
	}
	static class UTgfAbilityTask_WaitGameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityTask_WaitGameplayEvent>();
	}
};
static_assert(alignof(UTgfAbilityTask_WaitGameplayEvent) == 0x000008, "Wrong alignment on UTgfAbilityTask_WaitGameplayEvent");
static_assert(sizeof(UTgfAbilityTask_WaitGameplayEvent) == 0x000118, "Wrong size on UTgfAbilityTask_WaitGameplayEvent");
static_assert(offsetof(UTgfAbilityTask_WaitGameplayEvent, EventReceived) == 0x000080, "Member 'UTgfAbilityTask_WaitGameplayEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_WaitGameplayEvent, OptionalExternalTarget) == 0x0000B8, "Member 'UTgfAbilityTask_WaitGameplayEvent::OptionalExternalTarget' has a wrong offset!");

// Class LyraGame.LyraDevelopmentStatics
// 0x0000 (0x0028 - 0x0028)
class ULyraDevelopmentStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CanPlayerBotsAttack();
	static void ForceGarbageCollection();
	static bool ShouldLoadCosmeticBackgrounds();
	static bool ShouldSkipDirectlyToGameplay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDevelopmentStatics">();
	}
	static class ULyraDevelopmentStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraDevelopmentStatics>();
	}
};
static_assert(alignof(ULyraDevelopmentStatics) == 0x000008, "Wrong alignment on ULyraDevelopmentStatics");
static_assert(sizeof(ULyraDevelopmentStatics) == 0x000028, "Wrong size on ULyraDevelopmentStatics");

// Class LyraGame.TgfAbilityTask_WaitMoving
// 0x0070 (0x00F0 - 0x0080)
class UTgfAbilityTask_WaitMoving final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnMoving;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfAbilityTask_WaitMoving* WaitMoving(class UGameplayAbility* OwningAbility, const struct FMovingCheckParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityTask_WaitMoving">();
	}
	static class UTgfAbilityTask_WaitMoving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityTask_WaitMoving>();
	}
};
static_assert(alignof(UTgfAbilityTask_WaitMoving) == 0x000008, "Wrong alignment on UTgfAbilityTask_WaitMoving");
static_assert(sizeof(UTgfAbilityTask_WaitMoving) == 0x0000F0, "Wrong size on UTgfAbilityTask_WaitMoving");
static_assert(offsetof(UTgfAbilityTask_WaitMoving, OnMoving) == 0x000080, "Member 'UTgfAbilityTask_WaitMoving::OnMoving' has a wrong offset!");

// Class LyraGame.TgfActorCustomDepthStencilManagerComponent
// 0x0030 (0x00D8 - 0x00A8)
class UTgfActorCustomDepthStencilManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StencilSubtypeValues;                              // 0x00B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCustomStencilTypeAndValue(ETgfStencilTypeBaseValue StencilType, bool bSet, int32 Subtype, class UPrimitiveComponent* TargetMesh, bool Recursively);
	void SetCustomStencilValue(ETgfStencilRef StencilValue, bool bSet, class UPrimitiveComponent* TargetMesh);
	void SetCustomStencilValueByRealValue(class UPrimitiveComponent* TargetMesh, int32 Value);
	int32 SetStencilSubtypeValue(ETgfStencilTypeBaseValue StencilType, int32 Value, bool bSet);

	int32 GetCurrentStencilValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfActorCustomDepthStencilManagerComponent">();
	}
	static class UTgfActorCustomDepthStencilManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfActorCustomDepthStencilManagerComponent>();
	}
};
static_assert(alignof(UTgfActorCustomDepthStencilManagerComponent) == 0x000008, "Wrong alignment on UTgfActorCustomDepthStencilManagerComponent");
static_assert(sizeof(UTgfActorCustomDepthStencilManagerComponent) == 0x0000D8, "Wrong size on UTgfActorCustomDepthStencilManagerComponent");
static_assert(offsetof(UTgfActorCustomDepthStencilManagerComponent, StencilSubtypeValues) == 0x0000B0, "Member 'UTgfActorCustomDepthStencilManagerComponent::StencilSubtypeValues' has a wrong offset!");

// Class LyraGame.AsyncAction_ObserveTeamColors
// 0x0030 (0x0060 - 0x0030)
class UAsyncAction_ObserveTeamColors final : public UCancellableAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_ObserveTeamColors* ObserveTeamColors(class UObject* TeamAgent);

	void OnDisplayAssetChanged(const class ULyraTeamDisplayAsset* DisplayAsset);
	void OnWatchedAgentChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_ObserveTeamColors">();
	}
	static class UAsyncAction_ObserveTeamColors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_ObserveTeamColors>();
	}
};
static_assert(alignof(UAsyncAction_ObserveTeamColors) == 0x000008, "Wrong alignment on UAsyncAction_ObserveTeamColors");
static_assert(sizeof(UAsyncAction_ObserveTeamColors) == 0x000060, "Wrong size on UAsyncAction_ObserveTeamColors");
static_assert(offsetof(UAsyncAction_ObserveTeamColors, OnTeamChanged) == 0x000030, "Member 'UAsyncAction_ObserveTeamColors::OnTeamChanged' has a wrong offset!");

// Class LyraGame.TgfAIAbilityRule
// 0x0040 (0x0070 - 0x0030)
class UTgfAIAbilityRule final : public UDataAsset
{
public:
	ETgfAIAbilityFilterOp                         FilterOp;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfAIAbilityFilter>            Filters;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETgfAIAbilityTargetType                       TargetType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfAIAbilityTargetFilter>      TargetFilters;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActivateRange;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateAngleRange;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InterruptOnTargetLost;                             // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAIAbilityRule">();
	}
	static class UTgfAIAbilityRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAIAbilityRule>();
	}
};
static_assert(alignof(UTgfAIAbilityRule) == 0x000008, "Wrong alignment on UTgfAIAbilityRule");
static_assert(sizeof(UTgfAIAbilityRule) == 0x000070, "Wrong size on UTgfAIAbilityRule");
static_assert(offsetof(UTgfAIAbilityRule, FilterOp) == 0x000030, "Member 'UTgfAIAbilityRule::FilterOp' has a wrong offset!");
static_assert(offsetof(UTgfAIAbilityRule, Filters) == 0x000038, "Member 'UTgfAIAbilityRule::Filters' has a wrong offset!");
static_assert(offsetof(UTgfAIAbilityRule, TargetType) == 0x000048, "Member 'UTgfAIAbilityRule::TargetType' has a wrong offset!");
static_assert(offsetof(UTgfAIAbilityRule, TargetFilters) == 0x000050, "Member 'UTgfAIAbilityRule::TargetFilters' has a wrong offset!");
static_assert(offsetof(UTgfAIAbilityRule, ActivateRange) == 0x000060, "Member 'UTgfAIAbilityRule::ActivateRange' has a wrong offset!");
static_assert(offsetof(UTgfAIAbilityRule, ActivateAngleRange) == 0x000064, "Member 'UTgfAIAbilityRule::ActivateAngleRange' has a wrong offset!");
static_assert(offsetof(UTgfAIAbilityRule, InterruptOnTargetLost) == 0x000068, "Member 'UTgfAIAbilityRule::InterruptOnTargetLost' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_AnimAttrValue
// 0x0008 (0x0038 - 0x0030)
class UTgfAnimNotifyState_AnimAttrValue final : public UAnimNotifyState
{
public:
	float                                         Value;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfAnimAttrValueType                         Type;                                              // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_AnimAttrValue">();
	}
	static class UTgfAnimNotifyState_AnimAttrValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_AnimAttrValue>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_AnimAttrValue) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_AnimAttrValue");
static_assert(sizeof(UTgfAnimNotifyState_AnimAttrValue) == 0x000038, "Wrong size on UTgfAnimNotifyState_AnimAttrValue");
static_assert(offsetof(UTgfAnimNotifyState_AnimAttrValue, Value) == 0x000030, "Member 'UTgfAnimNotifyState_AnimAttrValue::Value' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_AnimAttrValue, Type) == 0x000034, "Member 'UTgfAnimNotifyState_AnimAttrValue::Type' has a wrong offset!");

// Class LyraGame.LyraTeamSubsystem
// 0x0088 (0x00B8 - 0x0030)
class ULyraTeamSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerSetTeamId;                                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamAllSelfQuit;                                 // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, struct FLyraTeamTrackingInfo>     TeamMap;                                           // 0x0050(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTeamTagStack(int32 TeamId, const struct FGameplayTag& Tag, int32 StackCount);
	class ULyraTeamDisplayAsset* GetEffectiveTeamDisplayAsset(int32 TeamId, class UObject* ViewerTeamAgent);
	class ALyraPlayerController* GetOwnPlayer();
	TArray<class ALyraPlayerState*> GetPlayersInTeam(int32 TeamId);
	TArray<class ALyraPlayerState*> GetPlayerStatesWithSameTeam(class AActor* Target);
	TArray<class ALyraPlayerState*> GetPlayersWithSameTeam(class AActor* Target);
	class ULyraTeamDisplayAsset* GetTeamDisplayAsset(int32 TeamId, int32 ViewerTeamId);
	TArray<class ALyraPlayerState*> GetTeamMembers(int32 TeamId);
	void RemoveTeamTagStack(int32 TeamId, const struct FGameplayTag& Tag, int32 StackCount);

	ELyraTeamComparison CompareTeams(const class UObject* A, const class UObject* B, int32* TeamIdA, int32* TeamIdB) const;
	bool DoesTeamExist(int32 TeamId) const;
	void FindTeamFromActor(const class UObject* TestActor, bool* bIsPartOfTeam, int32* TeamId) const;
	TArray<int32> GetTeamIDs() const;
	int32 GetTeamTagStackCount(int32 TeamId, const struct FGameplayTag& Tag) const;
	bool TeamHasTag(int32 TeamId, const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamSubsystem">();
	}
	static class ULyraTeamSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTeamSubsystem>();
	}
};
static_assert(alignof(ULyraTeamSubsystem) == 0x000008, "Wrong alignment on ULyraTeamSubsystem");
static_assert(sizeof(ULyraTeamSubsystem) == 0x0000B8, "Wrong size on ULyraTeamSubsystem");
static_assert(offsetof(ULyraTeamSubsystem, OnPlayerSetTeamId) == 0x000030, "Member 'ULyraTeamSubsystem::OnPlayerSetTeamId' has a wrong offset!");
static_assert(offsetof(ULyraTeamSubsystem, OnTeamAllSelfQuit) == 0x000040, "Member 'ULyraTeamSubsystem::OnTeamAllSelfQuit' has a wrong offset!");
static_assert(offsetof(ULyraTeamSubsystem, TeamMap) == 0x000050, "Member 'ULyraTeamSubsystem::TeamMap' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_Attack
// 0x0008 (0x0070 - 0x0068)
class UTgfAnimNotifyState_Attack final : public UAGR_Attack_NotifyState
{
public:
	bool                                          RightHandWeaponTakeEffect;                         // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LeftHandWeaponTakeEffect;                          // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_Attack">();
	}
	static class UTgfAnimNotifyState_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_Attack>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_Attack) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_Attack");
static_assert(sizeof(UTgfAnimNotifyState_Attack) == 0x000070, "Wrong size on UTgfAnimNotifyState_Attack");
static_assert(offsetof(UTgfAnimNotifyState_Attack, RightHandWeaponTakeEffect) == 0x000068, "Member 'UTgfAnimNotifyState_Attack::RightHandWeaponTakeEffect' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_Attack, LeftHandWeaponTakeEffect) == 0x000069, "Member 'UTgfAnimNotifyState_Attack::LeftHandWeaponTakeEffect' has a wrong offset!");

// Class LyraGame.TgfAnimNotify_DrinkBlood
// 0x0008 (0x0038 - 0x0030)
class UTgfAnimNotify_DrinkBlood final : public UAnimNotifyState
{
public:
	bool                                          bResetLiquidHeight;                                // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotify_DrinkBlood">();
	}
	static class UTgfAnimNotify_DrinkBlood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotify_DrinkBlood>();
	}
};
static_assert(alignof(UTgfAnimNotify_DrinkBlood) == 0x000008, "Wrong alignment on UTgfAnimNotify_DrinkBlood");
static_assert(sizeof(UTgfAnimNotify_DrinkBlood) == 0x000038, "Wrong size on UTgfAnimNotify_DrinkBlood");
static_assert(offsetof(UTgfAnimNotify_DrinkBlood, bResetLiquidHeight) == 0x000030, "Member 'UTgfAnimNotify_DrinkBlood::bResetLiquidHeight' has a wrong offset!");

// Class LyraGame.LyraTeamCreationComponent
// 0x0060 (0x0108 - 0x00A8)
class ULyraTeamCreationComponent final : public UGameStateComponent
{
public:
	TMap<uint8, class ULyraTeamDisplayAsset*>     TeamsToCreate;                                     // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class ALyraTeamPublicInfo>        PublicTeamInfoClass;                               // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALyraTeamPrivateInfo>       PrivateTeamInfoClass;                              // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamCreationComponent">();
	}
	static class ULyraTeamCreationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTeamCreationComponent>();
	}
};
static_assert(alignof(ULyraTeamCreationComponent) == 0x000008, "Wrong alignment on ULyraTeamCreationComponent");
static_assert(sizeof(ULyraTeamCreationComponent) == 0x000108, "Wrong size on ULyraTeamCreationComponent");
static_assert(offsetof(ULyraTeamCreationComponent, TeamsToCreate) == 0x0000A8, "Member 'ULyraTeamCreationComponent::TeamsToCreate' has a wrong offset!");
static_assert(offsetof(ULyraTeamCreationComponent, PublicTeamInfoClass) == 0x0000F8, "Member 'ULyraTeamCreationComponent::PublicTeamInfoClass' has a wrong offset!");
static_assert(offsetof(ULyraTeamCreationComponent, PrivateTeamInfoClass) == 0x000100, "Member 'ULyraTeamCreationComponent::PrivateTeamInfoClass' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_GameAbilityCameraMode
// 0x0068 (0x0098 - 0x0030)
class UTgfAnimNotifyState_GameAbilityCameraMode final : public UAnimNotifyState
{
public:
	TSubclassOf<class ULyraCameraMode>            CameraModeClass;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayAbility>>   AbilitiesApplied;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class USkeletalMeshComponent*, struct FGameplayAbilitySpecHandle> AbilitySpecHandles;                                // 0x0048(0x0050)(BlueprintReadOnly, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_GameAbilityCameraMode">();
	}
	static class UTgfAnimNotifyState_GameAbilityCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_GameAbilityCameraMode>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_GameAbilityCameraMode) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_GameAbilityCameraMode");
static_assert(sizeof(UTgfAnimNotifyState_GameAbilityCameraMode) == 0x000098, "Wrong size on UTgfAnimNotifyState_GameAbilityCameraMode");
static_assert(offsetof(UTgfAnimNotifyState_GameAbilityCameraMode, CameraModeClass) == 0x000030, "Member 'UTgfAnimNotifyState_GameAbilityCameraMode::CameraModeClass' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_GameAbilityCameraMode, AbilitiesApplied) == 0x000038, "Member 'UTgfAnimNotifyState_GameAbilityCameraMode::AbilitiesApplied' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_GameAbilityCameraMode, AbilitySpecHandles) == 0x000048, "Member 'UTgfAnimNotifyState_GameAbilityCameraMode::AbilitySpecHandles' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_GameplayTag
// 0x0028 (0x0058 - 0x0030)
class UTgfAnimNotifyState_GameplayTag : public UAnimNotifyState
{
public:
	bool                                          bReplicated;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	bool NeedDealTag(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_GameplayTag">();
	}
	static class UTgfAnimNotifyState_GameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_GameplayTag>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_GameplayTag) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_GameplayTag");
static_assert(sizeof(UTgfAnimNotifyState_GameplayTag) == 0x000058, "Wrong size on UTgfAnimNotifyState_GameplayTag");
static_assert(offsetof(UTgfAnimNotifyState_GameplayTag, bReplicated) == 0x000030, "Member 'UTgfAnimNotifyState_GameplayTag::bReplicated' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_GameplayTag, Tags) == 0x000038, "Member 'UTgfAnimNotifyState_GameplayTag::Tags' has a wrong offset!");

// Class LyraGame.LyraAssetManager
// 0x0138 (0x0620 - 0x04E8)
class ULyraAssetManager : public UAssetManager
{
public:
	TSoftObjectPtr<class ULyraGameData>           LyraGameDataPath;                                  // 0x04E8(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UObject>, class UPrimaryDataAsset*> GameDataMap;                                       // 0x0518(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ULyraPawnData>           DefaultPawnData;                                   // 0x0568(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x10];                                     // 0x0598(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          LoadedAssets;                                      // 0x05A8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x28];                                     // 0x05F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAssetManager">();
	}
	static class ULyraAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAssetManager>();
	}
};
static_assert(alignof(ULyraAssetManager) == 0x000008, "Wrong alignment on ULyraAssetManager");
static_assert(sizeof(ULyraAssetManager) == 0x000620, "Wrong size on ULyraAssetManager");
static_assert(offsetof(ULyraAssetManager, LyraGameDataPath) == 0x0004E8, "Member 'ULyraAssetManager::LyraGameDataPath' has a wrong offset!");
static_assert(offsetof(ULyraAssetManager, GameDataMap) == 0x000518, "Member 'ULyraAssetManager::GameDataMap' has a wrong offset!");
static_assert(offsetof(ULyraAssetManager, DefaultPawnData) == 0x000568, "Member 'ULyraAssetManager::DefaultPawnData' has a wrong offset!");
static_assert(offsetof(ULyraAssetManager, LoadedAssets) == 0x0005A8, "Member 'ULyraAssetManager::LoadedAssets' has a wrong offset!");

// Class LyraGame.TgfAssetManager
// 0x01B0 (0x07D0 - 0x0620)
class UTgfAssetManager final : public ULyraAssetManager
{
public:
	TSoftObjectPtr<class UTgfBattleCalculationDataAsset> BattleCalculationData;                             // 0x0620(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfBattleEleResistanceDataAsset> BattleElementResistanceData;                       // 0x0650(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfInventoryDataAsset>  InventoryData;                                     // 0x0680(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfEquipmentDataAsset>  EquipmentData;                                     // 0x06B0(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfAttributeConstDataAsset> AttributeConstData;                                // 0x06E0(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfInputDataAsset>      InputData;                                         // 0x0710(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfHeadCosmeticDataAsset> HeadCosmeticData;                                  // 0x0740(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfCharacterAvatarDataAsset> CharacterAvatarData;                               // 0x0770(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTgfFirstLevelAttrDataAsset> FirstLevelAttrData;                                // 0x07A0(0x0030)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAssetManager">();
	}
	static class UTgfAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAssetManager>();
	}
};
static_assert(alignof(UTgfAssetManager) == 0x000008, "Wrong alignment on UTgfAssetManager");
static_assert(sizeof(UTgfAssetManager) == 0x0007D0, "Wrong size on UTgfAssetManager");
static_assert(offsetof(UTgfAssetManager, BattleCalculationData) == 0x000620, "Member 'UTgfAssetManager::BattleCalculationData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, BattleElementResistanceData) == 0x000650, "Member 'UTgfAssetManager::BattleElementResistanceData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, InventoryData) == 0x000680, "Member 'UTgfAssetManager::InventoryData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, EquipmentData) == 0x0006B0, "Member 'UTgfAssetManager::EquipmentData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, AttributeConstData) == 0x0006E0, "Member 'UTgfAssetManager::AttributeConstData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, InputData) == 0x000710, "Member 'UTgfAssetManager::InputData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, HeadCosmeticData) == 0x000740, "Member 'UTgfAssetManager::HeadCosmeticData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, CharacterAvatarData) == 0x000770, "Member 'UTgfAssetManager::CharacterAvatarData' has a wrong offset!");
static_assert(offsetof(UTgfAssetManager, FirstLevelAttrData) == 0x0007A0, "Member 'UTgfAssetManager::FirstLevelAttrData' has a wrong offset!");

// Class LyraGame.LyraTeamInfoBase
// 0x0170 (0x0408 - 0x0298)
class ALyraTeamInfoBase : public AInfo
{
public:
	struct FGameplayTagStackContainer             TeamTags;                                          // 0x0298(0x0168)(Net, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TeamId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamInfoBase">();
	}
	static class ALyraTeamInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraTeamInfoBase>();
	}
};
static_assert(alignof(ALyraTeamInfoBase) == 0x000008, "Wrong alignment on ALyraTeamInfoBase");
static_assert(sizeof(ALyraTeamInfoBase) == 0x000408, "Wrong size on ALyraTeamInfoBase");
static_assert(offsetof(ALyraTeamInfoBase, TeamTags) == 0x000298, "Member 'ALyraTeamInfoBase::TeamTags' has a wrong offset!");
static_assert(offsetof(ALyraTeamInfoBase, TeamId) == 0x000400, "Member 'ALyraTeamInfoBase::TeamId' has a wrong offset!");

// Class LyraGame.LyraTeamPublicInfo
// 0x0008 (0x0410 - 0x0408)
class ALyraTeamPublicInfo final : public ALyraTeamInfoBase
{
public:
	class ULyraTeamDisplayAsset*                  TeamDisplayAsset;                                  // 0x0408(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_TeamDisplayAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamPublicInfo">();
	}
	static class ALyraTeamPublicInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraTeamPublicInfo>();
	}
};
static_assert(alignof(ALyraTeamPublicInfo) == 0x000008, "Wrong alignment on ALyraTeamPublicInfo");
static_assert(sizeof(ALyraTeamPublicInfo) == 0x000410, "Wrong size on ALyraTeamPublicInfo");
static_assert(offsetof(ALyraTeamPublicInfo, TeamDisplayAsset) == 0x000408, "Member 'ALyraTeamPublicInfo::TeamDisplayAsset' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_MoveActor
// 0x0038 (0x0068 - 0x0030)
class UTgfAnimNotifyState_MoveActor final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTgfMoveActorConfig                    MoveActorConfig;                                   // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_MoveActor">();
	}
	static class UTgfAnimNotifyState_MoveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_MoveActor>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_MoveActor) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_MoveActor");
static_assert(sizeof(UTgfAnimNotifyState_MoveActor) == 0x000068, "Wrong size on UTgfAnimNotifyState_MoveActor");
static_assert(offsetof(UTgfAnimNotifyState_MoveActor, MoveActorConfig) == 0x000038, "Member 'UTgfAnimNotifyState_MoveActor::MoveActorConfig' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_MovingInterrupt
// 0x0058 (0x0088 - 0x0030)
class UTgfAnimNotifyState_MovingInterrupt final : public UAnimNotifyState
{
public:
	bool                                          bTick;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMontageBlendOutSetting;                        // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomBlendOutTime;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class USkeletalMeshComponent*, bool>     HasStopped;                                        // 0x0038(0x0050)(BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_MovingInterrupt">();
	}
	static class UTgfAnimNotifyState_MovingInterrupt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_MovingInterrupt>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_MovingInterrupt) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_MovingInterrupt");
static_assert(sizeof(UTgfAnimNotifyState_MovingInterrupt) == 0x000088, "Wrong size on UTgfAnimNotifyState_MovingInterrupt");
static_assert(offsetof(UTgfAnimNotifyState_MovingInterrupt, bTick) == 0x000030, "Member 'UTgfAnimNotifyState_MovingInterrupt::bTick' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_MovingInterrupt, bUseMontageBlendOutSetting) == 0x000031, "Member 'UTgfAnimNotifyState_MovingInterrupt::bUseMontageBlendOutSetting' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_MovingInterrupt, CustomBlendOutTime) == 0x000034, "Member 'UTgfAnimNotifyState_MovingInterrupt::CustomBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_MovingInterrupt, HasStopped) == 0x000038, "Member 'UTgfAnimNotifyState_MovingInterrupt::HasStopped' has a wrong offset!");

// Class LyraGame.LyraTabListWidgetBase
// 0x0088 (0x0430 - 0x03A8)
class ULyraTabListWidgetBase final : public UCommonTabListWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnTabContentCreated;                               // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x18];                                     // 0x03B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLyraTabDescriptor>             PreregisteredTabInfoArray;                         // 0x03D0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FLyraTabDescriptor>  PendingTabLabelInfoMap;                            // 0x03E0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool GetPreregisteredTabInfo(const class FName TabNameID, struct FLyraTabDescriptor* OutTabInfo);
	int32 GetVisibleTabCount();
	bool IsTabVisible(class FName TabId);
	void OnTabContentCreated__DelegateSignature(class FName TabId, class UCommonUserWidget* TabWidget);
	bool RegisterDynamicTab(const struct FLyraTabDescriptor& TabDescriptor);
	void SetPreregisteredTabInfoLock(const class FName TabNameID, bool IsLock);
	void SetTabHiddenState(class FName TabNameID, bool bHidden);

	bool IsFirstTabActive() const;
	bool IsLastTabActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTabListWidgetBase">();
	}
	static class ULyraTabListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTabListWidgetBase>();
	}
};
static_assert(alignof(ULyraTabListWidgetBase) == 0x000008, "Wrong alignment on ULyraTabListWidgetBase");
static_assert(sizeof(ULyraTabListWidgetBase) == 0x000430, "Wrong size on ULyraTabListWidgetBase");
static_assert(offsetof(ULyraTabListWidgetBase, OnTabContentCreated) == 0x0003A8, "Member 'ULyraTabListWidgetBase::OnTabContentCreated' has a wrong offset!");
static_assert(offsetof(ULyraTabListWidgetBase, PreregisteredTabInfoArray) == 0x0003D0, "Member 'ULyraTabListWidgetBase::PreregisteredTabInfoArray' has a wrong offset!");
static_assert(offsetof(ULyraTabListWidgetBase, PendingTabLabelInfoMap) == 0x0003E0, "Member 'ULyraTabListWidgetBase::PendingTabLabelInfoMap' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_NiagaraEffect_Common
// 0x00E0 (0x0110 - 0x0030)
class UTgfAnimNotifyState_NiagaraEffect_Common final : public UAnimNotifyState
{
public:
	class FString                                 DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTgfLineEffectStartConfig              StartConfig;                                       // 0x0040(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTgfLineEffectEndConfig                EndConfig;                                         // 0x0098(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCastShadow : 1;                                   // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class USkeletalMeshComponent*, class UNiagaraComponent*> SpawnedNiagara;                                    // 0x00C0(0x0050)(ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_NiagaraEffect_Common">();
	}
	static class UTgfAnimNotifyState_NiagaraEffect_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_NiagaraEffect_Common>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_NiagaraEffect_Common) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_NiagaraEffect_Common");
static_assert(sizeof(UTgfAnimNotifyState_NiagaraEffect_Common) == 0x000110, "Wrong size on UTgfAnimNotifyState_NiagaraEffect_Common");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Common, DisplayName) == 0x000030, "Member 'UTgfAnimNotifyState_NiagaraEffect_Common::DisplayName' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Common, StartConfig) == 0x000040, "Member 'UTgfAnimNotifyState_NiagaraEffect_Common::StartConfig' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Common, EndConfig) == 0x000098, "Member 'UTgfAnimNotifyState_NiagaraEffect_Common::EndConfig' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Common, NiagaraSystem) == 0x0000B0, "Member 'UTgfAnimNotifyState_NiagaraEffect_Common::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Common, SpawnedNiagara) == 0x0000C0, "Member 'UTgfAnimNotifyState_NiagaraEffect_Common::SpawnedNiagara' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_NiagaraEffect_ScreenTrail
// 0x0010 (0x0040 - 0x0030)
class UTgfAnimNotifyState_NiagaraEffect_ScreenTrail final : public UAnimNotifyState
{
public:
	class UNiagaraSystem*                         SpecialEffect;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationAngle;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_NiagaraEffect_ScreenTrail">();
	}
	static class UTgfAnimNotifyState_NiagaraEffect_ScreenTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_NiagaraEffect_ScreenTrail>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_NiagaraEffect_ScreenTrail) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_NiagaraEffect_ScreenTrail");
static_assert(sizeof(UTgfAnimNotifyState_NiagaraEffect_ScreenTrail) == 0x000040, "Wrong size on UTgfAnimNotifyState_NiagaraEffect_ScreenTrail");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_ScreenTrail, SpecialEffect) == 0x000030, "Member 'UTgfAnimNotifyState_NiagaraEffect_ScreenTrail::SpecialEffect' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_ScreenTrail, RotationAngle) == 0x000038, "Member 'UTgfAnimNotifyState_NiagaraEffect_ScreenTrail::RotationAngle' has a wrong offset!");

// Class LyraGame.MaterialProgressBar
// 0x00B0 (0x0370 - 0x02C0)
class UMaterialProgressBar final : public UCommonUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnFillAnimationFinished;                           // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bOverrideDefaultColorA;                            // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CachedColorA;                                      // 0x02D4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultColorB;                            // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CachedColorB;                                      // 0x02E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultColorBackground;                   // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CachedColorBackground;                             // 0x02FC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultSegments;                          // 0x030C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Segments;                                          // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultSegmentEdge;                       // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SegmentEdge;                                       // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultFillEdgeSoftness;                  // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FillEdgeSoftness;                                  // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultGlowEdge;                          // 0x0324(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlowEdge;                                          // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultGlowSoftness;                      // 0x032C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlowSoftness;                                      // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultOutlineScale;                      // 0x0334(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutlineScale;                                      // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseStroke;                                        // 0x033C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33D[0x3];                                      // 0x033D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     StrokeMaterial;                                    // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     NoStrokeMaterial;                                  // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_Bar;                                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       BoundAnim_FillBar;                                 // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CachedMID;                                         // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimateProgressFromCurrent(float End, float AnimSpeed);
	void AnimateProgressFromStart(float Start, float End, float AnimSpeed);
	void OnFillAnimationFinished__DelegateSignature();
	void SetColorA(const struct FLinearColor& ColorA);
	void SetColorB(const struct FLinearColor& ColorB);
	void SetColorBackground(const struct FLinearColor& ColorBackground);
	void SetProgress(float Progress);
	void SetStartProgress(float StartProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialProgressBar">();
	}
	static class UMaterialProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialProgressBar>();
	}
};
static_assert(alignof(UMaterialProgressBar) == 0x000008, "Wrong alignment on UMaterialProgressBar");
static_assert(sizeof(UMaterialProgressBar) == 0x000370, "Wrong size on UMaterialProgressBar");
static_assert(offsetof(UMaterialProgressBar, OnFillAnimationFinished) == 0x0002C0, "Member 'UMaterialProgressBar::OnFillAnimationFinished' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultColorA) == 0x0002D0, "Member 'UMaterialProgressBar::bOverrideDefaultColorA' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedColorA) == 0x0002D4, "Member 'UMaterialProgressBar::CachedColorA' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultColorB) == 0x0002E4, "Member 'UMaterialProgressBar::bOverrideDefaultColorB' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedColorB) == 0x0002E8, "Member 'UMaterialProgressBar::CachedColorB' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultColorBackground) == 0x0002F8, "Member 'UMaterialProgressBar::bOverrideDefaultColorBackground' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedColorBackground) == 0x0002FC, "Member 'UMaterialProgressBar::CachedColorBackground' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultSegments) == 0x00030C, "Member 'UMaterialProgressBar::bOverrideDefaultSegments' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, Segments) == 0x000310, "Member 'UMaterialProgressBar::Segments' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultSegmentEdge) == 0x000314, "Member 'UMaterialProgressBar::bOverrideDefaultSegmentEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, SegmentEdge) == 0x000318, "Member 'UMaterialProgressBar::SegmentEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultFillEdgeSoftness) == 0x00031C, "Member 'UMaterialProgressBar::bOverrideDefaultFillEdgeSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, FillEdgeSoftness) == 0x000320, "Member 'UMaterialProgressBar::FillEdgeSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultGlowEdge) == 0x000324, "Member 'UMaterialProgressBar::bOverrideDefaultGlowEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, GlowEdge) == 0x000328, "Member 'UMaterialProgressBar::GlowEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultGlowSoftness) == 0x00032C, "Member 'UMaterialProgressBar::bOverrideDefaultGlowSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, GlowSoftness) == 0x000330, "Member 'UMaterialProgressBar::GlowSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultOutlineScale) == 0x000334, "Member 'UMaterialProgressBar::bOverrideDefaultOutlineScale' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, OutlineScale) == 0x000338, "Member 'UMaterialProgressBar::OutlineScale' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bUseStroke) == 0x00033C, "Member 'UMaterialProgressBar::bUseStroke' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, StrokeMaterial) == 0x000340, "Member 'UMaterialProgressBar::StrokeMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, NoStrokeMaterial) == 0x000348, "Member 'UMaterialProgressBar::NoStrokeMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, Image_Bar) == 0x000350, "Member 'UMaterialProgressBar::Image_Bar' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, BoundAnim_FillBar) == 0x000358, "Member 'UMaterialProgressBar::BoundAnim_FillBar' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedMID) == 0x000360, "Member 'UMaterialProgressBar::CachedMID' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_NiagaraEffect_Sword
// 0x0098 (0x00C8 - 0x0030)
class UTgfAnimNotifyState_NiagaraEffect_Sword final : public UAnimNotifyState
{
public:
	TMap<class USkeletalMeshComponent*, struct FFXContainer> SpawnedEffects;                                    // 0x0030(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         Template;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfWeaponHandType                            RestrictWeapon;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_NiagaraEffect_Sword">();
	}
	static class UTgfAnimNotifyState_NiagaraEffect_Sword* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_NiagaraEffect_Sword>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_NiagaraEffect_Sword) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_NiagaraEffect_Sword");
static_assert(sizeof(UTgfAnimNotifyState_NiagaraEffect_Sword) == 0x0000C8, "Wrong size on UTgfAnimNotifyState_NiagaraEffect_Sword");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Sword, SpawnedEffects) == 0x000030, "Member 'UTgfAnimNotifyState_NiagaraEffect_Sword::SpawnedEffects' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Sword, Template) == 0x000080, "Member 'UTgfAnimNotifyState_NiagaraEffect_Sword::Template' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Sword, SocketName) == 0x000088, "Member 'UTgfAnimNotifyState_NiagaraEffect_Sword::SocketName' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Sword, RestrictWeapon) == 0x000090, "Member 'UTgfAnimNotifyState_NiagaraEffect_Sword::RestrictWeapon' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Sword, LocationOffset) == 0x000098, "Member 'UTgfAnimNotifyState_NiagaraEffect_Sword::LocationOffset' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_NiagaraEffect_Sword, RotationOffset) == 0x0000B0, "Member 'UTgfAnimNotifyState_NiagaraEffect_Sword::RotationOffset' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_SetWeaponMaterialParam
// 0x0070 (0x00A0 - 0x0030)
class UTgfAnimNotifyState_SetWeaponMaterialParam final : public UAnimNotifyState
{
public:
	class UCurveFloat*                            ParamCurve;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParamName;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfWeaponHandType                            HandType;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinReachEndTime;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreSetDefaultOnReachEnd;                        // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class USkeletalMeshComponent*, float>    ElapsedTimes;                                      // 0x0050(0x0050)(BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_SetWeaponMaterialParam">();
	}
	static class UTgfAnimNotifyState_SetWeaponMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_SetWeaponMaterialParam>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_SetWeaponMaterialParam) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_SetWeaponMaterialParam");
static_assert(sizeof(UTgfAnimNotifyState_SetWeaponMaterialParam) == 0x0000A0, "Wrong size on UTgfAnimNotifyState_SetWeaponMaterialParam");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, ParamCurve) == 0x000030, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::ParamCurve' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, ParamName) == 0x000038, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::ParamName' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, HandType) == 0x000040, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::HandType' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, DefaultValue) == 0x000044, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::DefaultValue' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, MinReachEndTime) == 0x000048, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::MinReachEndTime' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, IgnoreSetDefaultOnReachEnd) == 0x00004C, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::IgnoreSetDefaultOnReachEnd' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_SetWeaponMaterialParam, ElapsedTimes) == 0x000050, "Member 'UTgfAnimNotifyState_SetWeaponMaterialParam::ElapsedTimes' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_SnapToTarget
// 0x0008 (0x0038 - 0x0030)
class UTgfAnimNotifyState_SnapToTarget final : public UAnimNotifyState
{
public:
	class FName                                   NotifyName;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_SnapToTarget">();
	}
	static class UTgfAnimNotifyState_SnapToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_SnapToTarget>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_SnapToTarget) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_SnapToTarget");
static_assert(sizeof(UTgfAnimNotifyState_SnapToTarget) == 0x000038, "Wrong size on UTgfAnimNotifyState_SnapToTarget");
static_assert(offsetof(UTgfAnimNotifyState_SnapToTarget, NotifyName) == 0x000030, "Member 'UTgfAnimNotifyState_SnapToTarget::NotifyName' has a wrong offset!");

// Class LyraGame.TgfAnimNotifyState_WeaponMaterialParameter
// 0x0060 (0x0090 - 0x0030)
class UTgfAnimNotifyState_WeaponMaterialParameter final : public UAnimNotifyState
{
public:
	class FName                                   ParameterName;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfWeaponHandType                            HandType;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x57];                                      // 0x0039(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ElapsedTime(class USkeletalMeshComponent* MeshComp, float Default) const;
	float TotalTime(class USkeletalMeshComponent* MeshComp, float Default) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotifyState_WeaponMaterialParameter">();
	}
	static class UTgfAnimNotifyState_WeaponMaterialParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotifyState_WeaponMaterialParameter>();
	}
};
static_assert(alignof(UTgfAnimNotifyState_WeaponMaterialParameter) == 0x000008, "Wrong alignment on UTgfAnimNotifyState_WeaponMaterialParameter");
static_assert(sizeof(UTgfAnimNotifyState_WeaponMaterialParameter) == 0x000090, "Wrong size on UTgfAnimNotifyState_WeaponMaterialParameter");
static_assert(offsetof(UTgfAnimNotifyState_WeaponMaterialParameter, ParameterName) == 0x000030, "Member 'UTgfAnimNotifyState_WeaponMaterialParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotifyState_WeaponMaterialParameter, HandType) == 0x000038, "Member 'UTgfAnimNotifyState_WeaponMaterialParameter::HandType' has a wrong offset!");

// Class LyraGame.LyraButtonBase
// 0x0020 (0x1530 - 0x1510)
class ULyraButtonBase : public UCommonButtonBase
{
public:
	uint8                                         bOverride_ButtonText : 1;                          // 0x1510(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1511[0x7];                                     // 0x1511(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonText;                                        // 0x1518(0x0018)(Edit, NativeAccessSpecifierPrivate)

public:
	void SetButtonText(const class FText& InText);
	void UpdateButtonStyle();
	void UpdateButtonText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraButtonBase">();
	}
	static class ULyraButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraButtonBase>();
	}
};
static_assert(alignof(ULyraButtonBase) == 0x000010, "Wrong alignment on ULyraButtonBase");
static_assert(sizeof(ULyraButtonBase) == 0x001530, "Wrong size on ULyraButtonBase");
static_assert(offsetof(ULyraButtonBase, ButtonText) == 0x001518, "Member 'ULyraButtonBase::ButtonText' has a wrong offset!");

// Class LyraGame.LyraTabButtonBase
// 0x0140 (0x1670 - 0x1530)
class ULyraTabButtonBase final : public ULyraButtonBase
{
public:
	uint8                                         Pad_1530[0x10];                                    // 0x1530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLyraTabDescriptor                     TabDescriptor;                                     // 0x1540(0x0110)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCommonLazyImage*                       LazyImage_Icon;                                    // 0x1650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 IconHover;                                         // 0x1658(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 IconNormal;                                        // 0x1660(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 IconHighlight;                                     // 0x1668(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetTabLabelInfo_Implementation(const struct FLyraTabDescriptor& TabLabelInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTabButtonBase">();
	}
	static class ULyraTabButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTabButtonBase>();
	}
};
static_assert(alignof(ULyraTabButtonBase) == 0x000010, "Wrong alignment on ULyraTabButtonBase");
static_assert(sizeof(ULyraTabButtonBase) == 0x001670, "Wrong size on ULyraTabButtonBase");
static_assert(offsetof(ULyraTabButtonBase, TabDescriptor) == 0x001540, "Member 'ULyraTabButtonBase::TabDescriptor' has a wrong offset!");
static_assert(offsetof(ULyraTabButtonBase, LazyImage_Icon) == 0x001650, "Member 'ULyraTabButtonBase::LazyImage_Icon' has a wrong offset!");
static_assert(offsetof(ULyraTabButtonBase, IconHover) == 0x001658, "Member 'ULyraTabButtonBase::IconHover' has a wrong offset!");
static_assert(offsetof(ULyraTabButtonBase, IconNormal) == 0x001660, "Member 'ULyraTabButtonBase::IconNormal' has a wrong offset!");
static_assert(offsetof(ULyraTabButtonBase, IconHighlight) == 0x001668, "Member 'ULyraTabButtonBase::IconHighlight' has a wrong offset!");

// Class LyraGame.TgfAnimNotify_ResetAGR
// 0x0038 (0x0070 - 0x0038)
class UTgfAnimNotify_ResetAGR final : public UAnimNotify
{
public:
	class FName                                   OnlyEffectiveStart;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnlyEffectiveEnd;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAGRAttackNotifyStateDataExtra         ExtraData;                                         // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotify_ResetAGR">();
	}
	static class UTgfAnimNotify_ResetAGR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotify_ResetAGR>();
	}
};
static_assert(alignof(UTgfAnimNotify_ResetAGR) == 0x000008, "Wrong alignment on UTgfAnimNotify_ResetAGR");
static_assert(sizeof(UTgfAnimNotify_ResetAGR) == 0x000070, "Wrong size on UTgfAnimNotify_ResetAGR");
static_assert(offsetof(UTgfAnimNotify_ResetAGR, OnlyEffectiveStart) == 0x000038, "Member 'UTgfAnimNotify_ResetAGR::OnlyEffectiveStart' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotify_ResetAGR, OnlyEffectiveEnd) == 0x000040, "Member 'UTgfAnimNotify_ResetAGR::OnlyEffectiveEnd' has a wrong offset!");
static_assert(offsetof(UTgfAnimNotify_ResetAGR, ExtraData) == 0x000048, "Member 'UTgfAnimNotify_ResetAGR::ExtraData' has a wrong offset!");

// Class LyraGame.TgfAnimNotify_SnapToTarget
// 0x0008 (0x0040 - 0x0038)
class UTgfAnimNotify_SnapToTarget final : public UAnimNotify
{
public:
	TSubclassOf<class UGameplayAbility>           AbilityToTrigger;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAnimNotify_SnapToTarget">();
	}
	static class UTgfAnimNotify_SnapToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAnimNotify_SnapToTarget>();
	}
};
static_assert(alignof(UTgfAnimNotify_SnapToTarget) == 0x000008, "Wrong alignment on UTgfAnimNotify_SnapToTarget");
static_assert(sizeof(UTgfAnimNotify_SnapToTarget) == 0x000040, "Wrong size on UTgfAnimNotify_SnapToTarget");
static_assert(offsetof(UTgfAnimNotify_SnapToTarget, AbilityToTrigger) == 0x000038, "Member 'UTgfAnimNotify_SnapToTarget::AbilityToTrigger' has a wrong offset!");

// Class LyraGame.LyraEquipmentDefinition
// 0x0030 (0x0058 - 0x0028)
class ULyraEquipmentDefinition : public UObject
{
public:
	TSubclassOf<class ULyraEquipmentInstance>     InstanceType;                                      // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULyraAbilitySet*>                AbilitySetsToGrant;                                // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bVisibleWhenUnequip;                               // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLyraEquipmentActorToSpawn>     ActorsToSpawn;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraEquipmentDefinition">();
	}
	static class ULyraEquipmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraEquipmentDefinition>();
	}
};
static_assert(alignof(ULyraEquipmentDefinition) == 0x000008, "Wrong alignment on ULyraEquipmentDefinition");
static_assert(sizeof(ULyraEquipmentDefinition) == 0x000058, "Wrong size on ULyraEquipmentDefinition");
static_assert(offsetof(ULyraEquipmentDefinition, InstanceType) == 0x000028, "Member 'ULyraEquipmentDefinition::InstanceType' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentDefinition, AbilitySetsToGrant) == 0x000030, "Member 'ULyraEquipmentDefinition::AbilitySetsToGrant' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentDefinition, bVisibleWhenUnequip) == 0x000040, "Member 'ULyraEquipmentDefinition::bVisibleWhenUnequip' has a wrong offset!");
static_assert(offsetof(ULyraEquipmentDefinition, ActorsToSpawn) == 0x000048, "Member 'ULyraEquipmentDefinition::ActorsToSpawn' has a wrong offset!");

// Class LyraGame.TgfEquipmentDefinition
// 0x0008 (0x0060 - 0x0058)
class UTgfEquipmentDefinition : public ULyraEquipmentDefinition
{
public:
	int32                                         EquipDefId;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfEquipSubType                              EquipSubType;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentDefinition">();
	}
	static class UTgfEquipmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentDefinition>();
	}
};
static_assert(alignof(UTgfEquipmentDefinition) == 0x000008, "Wrong alignment on UTgfEquipmentDefinition");
static_assert(sizeof(UTgfEquipmentDefinition) == 0x000060, "Wrong size on UTgfEquipmentDefinition");
static_assert(offsetof(UTgfEquipmentDefinition, EquipDefId) == 0x000058, "Member 'UTgfEquipmentDefinition::EquipDefId' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentDefinition, EquipSubType) == 0x00005C, "Member 'UTgfEquipmentDefinition::EquipSubType' has a wrong offset!");

// Class LyraGame.TgfArmorDefinition
// 0x0010 (0x0070 - 0x0060)
class UTgfArmorDefinition : public UTgfEquipmentDefinition
{
public:
	TArray<struct FTgfCharaPartChangeConfig>      ChangePartConfigs;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfArmorDefinition">();
	}
	static class UTgfArmorDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfArmorDefinition>();
	}
};
static_assert(alignof(UTgfArmorDefinition) == 0x000008, "Wrong alignment on UTgfArmorDefinition");
static_assert(sizeof(UTgfArmorDefinition) == 0x000070, "Wrong size on UTgfArmorDefinition");
static_assert(offsetof(UTgfArmorDefinition, ChangePartConfigs) == 0x000060, "Member 'UTgfArmorDefinition::ChangePartConfigs' has a wrong offset!");

// Class LyraGame.LyraListView
// 0x0010 (0x0C30 - 0x0C20)
class ULyraListView final : public UCommonListView
{
public:
	TArray<class ULyraWidgetFactory*>             FactoryRules;                                      // 0x0C20(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraListView">();
	}
	static class ULyraListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraListView>();
	}
};
static_assert(alignof(ULyraListView) == 0x000010, "Wrong alignment on ULyraListView");
static_assert(sizeof(ULyraListView) == 0x000C30, "Wrong size on ULyraListView");
static_assert(offsetof(ULyraListView, FactoryRules) == 0x000C20, "Member 'ULyraListView::FactoryRules' has a wrong offset!");

// Class LyraGame.TgfEquipmentInstance
// 0x0018 (0x00E8 - 0x00D0)
class UTgfEquipmentInstance : public ULyraEquipmentInstance
{
public:
	TArray<class AActor*>                         SpawnedActors;                                     // 0x00D0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          WeaponVisible;                                     // 0x00E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecLoosePointOnDeath();
	void K2_OnSpawnedActors();
	void K2_OnWeaponVisibleChanged(bool Visiblity);
	void ModifiedDurabilityPoint(int32 DeltaPoint);
	void OnRep_SpawnedActors();
	void OnRep_WeaponVisible();
	int32 RemoveGameplayEffectWithSourceObjectAndTags(const struct FGameplayTagContainer& TagContainer, bool CheckAnotherWeapon);
	void SetWeaponVisible(bool Value);
	void SpawnEquipmentActorsWithAttachTarget(class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors);

	int32 GetDurabilityPoint() const;
	TArray<class AActor*> GetSpawnedActors() const;
	bool GetWeaponVisible() const;
	bool HasDurabilityPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentInstance">();
	}
	static class UTgfEquipmentInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentInstance>();
	}
};
static_assert(alignof(UTgfEquipmentInstance) == 0x000008, "Wrong alignment on UTgfEquipmentInstance");
static_assert(sizeof(UTgfEquipmentInstance) == 0x0000E8, "Wrong size on UTgfEquipmentInstance");
static_assert(offsetof(UTgfEquipmentInstance, SpawnedActors) == 0x0000D0, "Member 'UTgfEquipmentInstance::SpawnedActors' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentInstance, WeaponVisible) == 0x0000E0, "Member 'UTgfEquipmentInstance::WeaponVisible' has a wrong offset!");

// Class LyraGame.TgfArmorInstance
// 0x0000 (0x00E8 - 0x00E8)
class UTgfArmorInstance : public UTgfEquipmentInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfArmorInstance">();
	}
	static class UTgfArmorInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfArmorInstance>();
	}
};
static_assert(alignof(UTgfArmorInstance) == 0x000008, "Wrong alignment on UTgfArmorInstance");
static_assert(sizeof(UTgfArmorInstance) == 0x0000E8, "Wrong size on UTgfArmorInstance");

// Class LyraGame.TgfAttachedAnimInstance
// 0x0040 (0x0390 - 0x0350)
class UTgfAttachedAnimInstance : public UAnimInstance
{
public:
	struct FGameplayTagBlueprintPropertyMap       TagMaps;                                           // 0x0348(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bJumping;                                          // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFalling;                                          // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnGround;                                         // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeath;                                            // 0x036B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeathFinished;                                    // 0x036C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundDistance;                                    // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLyraLocalContolled;                               // 0x038C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInited;                                           // 0x038D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bThisIsParent;                                     // 0x038E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38F[0x1];                                      // 0x038F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimInstance* GetAttachedParentAnimInstance();

	class ACharacter* GetAttachedParentCharacter() const;
	bool IsOnDedicatedServer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAttachedAnimInstance">();
	}
	static class UTgfAttachedAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAttachedAnimInstance>();
	}
};
static_assert(alignof(UTgfAttachedAnimInstance) == 0x000010, "Wrong alignment on UTgfAttachedAnimInstance");
static_assert(sizeof(UTgfAttachedAnimInstance) == 0x000390, "Wrong size on UTgfAttachedAnimInstance");
static_assert(offsetof(UTgfAttachedAnimInstance, TagMaps) == 0x000348, "Member 'UTgfAttachedAnimInstance::TagMaps' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bJumping) == 0x000368, "Member 'UTgfAttachedAnimInstance::bJumping' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bFalling) == 0x000369, "Member 'UTgfAttachedAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bOnGround) == 0x00036A, "Member 'UTgfAttachedAnimInstance::bOnGround' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bDeath) == 0x00036B, "Member 'UTgfAttachedAnimInstance::bDeath' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bDeathFinished) == 0x00036C, "Member 'UTgfAttachedAnimInstance::bDeathFinished' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, Velocity) == 0x000370, "Member 'UTgfAttachedAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, GroundDistance) == 0x000388, "Member 'UTgfAttachedAnimInstance::GroundDistance' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bLyraLocalContolled) == 0x00038C, "Member 'UTgfAttachedAnimInstance::bLyraLocalContolled' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bInited) == 0x00038D, "Member 'UTgfAttachedAnimInstance::bInited' has a wrong offset!");
static_assert(offsetof(UTgfAttachedAnimInstance, bThisIsParent) == 0x00038E, "Member 'UTgfAttachedAnimInstance::bThisIsParent' has a wrong offset!");

// Class LyraGame.TgfAttributeConstDataAsset
// 0x0030 (0x0060 - 0x0030)
class UTgfAttributeConstDataAsset final : public UPrimaryDataAsset
{
public:
	class FName                                   CommonCurveGroupName;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchMaxSpeedRate;                                // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageConstPing;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageChaseMaxPing;                               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayMontageServerDelay;                           // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseMontageWhenClientAhead;                      // 0x0045(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChaseMontageWhenClientBehind;                     // 0x0046(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MontageChaseDeltaPingThreshold;                    // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorMapAIBound;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorMapTickBound;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickLowTime;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickHighTime;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingEstimateTimeOut;                               // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAttributeConstDataAsset">();
	}
	static class UTgfAttributeConstDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAttributeConstDataAsset>();
	}
};
static_assert(alignof(UTgfAttributeConstDataAsset) == 0x000008, "Wrong alignment on UTgfAttributeConstDataAsset");
static_assert(sizeof(UTgfAttributeConstDataAsset) == 0x000060, "Wrong size on UTgfAttributeConstDataAsset");
static_assert(offsetof(UTgfAttributeConstDataAsset, CommonCurveGroupName) == 0x000030, "Member 'UTgfAttributeConstDataAsset::CommonCurveGroupName' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, CrouchMaxSpeedRate) == 0x000038, "Member 'UTgfAttributeConstDataAsset::CrouchMaxSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, MontageConstPing) == 0x00003C, "Member 'UTgfAttributeConstDataAsset::MontageConstPing' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, MontageChaseMaxPing) == 0x000040, "Member 'UTgfAttributeConstDataAsset::MontageChaseMaxPing' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, bPlayMontageServerDelay) == 0x000044, "Member 'UTgfAttributeConstDataAsset::bPlayMontageServerDelay' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, bPauseMontageWhenClientAhead) == 0x000045, "Member 'UTgfAttributeConstDataAsset::bPauseMontageWhenClientAhead' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, bChaseMontageWhenClientBehind) == 0x000046, "Member 'UTgfAttributeConstDataAsset::bChaseMontageWhenClientBehind' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, MontageChaseDeltaPingThreshold) == 0x000048, "Member 'UTgfAttributeConstDataAsset::MontageChaseDeltaPingThreshold' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, ActorMapAIBound) == 0x00004C, "Member 'UTgfAttributeConstDataAsset::ActorMapAIBound' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, ActorMapTickBound) == 0x000050, "Member 'UTgfAttributeConstDataAsset::ActorMapTickBound' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, TickLowTime) == 0x000054, "Member 'UTgfAttributeConstDataAsset::TickLowTime' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, TickHighTime) == 0x000058, "Member 'UTgfAttributeConstDataAsset::TickHighTime' has a wrong offset!");
static_assert(offsetof(UTgfAttributeConstDataAsset, PingEstimateTimeOut) == 0x00005C, "Member 'UTgfAttributeConstDataAsset::PingEstimateTimeOut' has a wrong offset!");

// Class LyraGame.LyraSimulatedInputWidget
// 0x0038 (0x02F8 - 0x02C0)
class ULyraSimulatedInputWidget : public UCommonUserWidget
{
public:
	class UInputAction*                           AssociatedAction;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   FallbackBindingKey;                                // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushSimulatedInput();
	void InputKeyValue(const struct FVector& Value);
	void InputKeyValue2D(const struct FVector2D& Value);

	const class UInputAction* GetAssociatedAction() const;
	class UEnhancedInputLocalPlayerSubsystem* GetEnhancedInputSubsystem() const;
	struct FKey GetSimulatedKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSimulatedInputWidget">();
	}
	static class ULyraSimulatedInputWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSimulatedInputWidget>();
	}
};
static_assert(alignof(ULyraSimulatedInputWidget) == 0x000008, "Wrong alignment on ULyraSimulatedInputWidget");
static_assert(sizeof(ULyraSimulatedInputWidget) == 0x0002F8, "Wrong size on ULyraSimulatedInputWidget");
static_assert(offsetof(ULyraSimulatedInputWidget, AssociatedAction) == 0x0002C0, "Member 'ULyraSimulatedInputWidget::AssociatedAction' has a wrong offset!");
static_assert(offsetof(ULyraSimulatedInputWidget, FallbackBindingKey) == 0x0002C8, "Member 'ULyraSimulatedInputWidget::FallbackBindingKey' has a wrong offset!");

// Class LyraGame.TgfAuraManagerComponent
// 0x0018 (0x00C0 - 0x00A8)
class UTgfAuraManagerComponent final : public UGameFrameworkComponent
{
public:
	TArray<struct FTgfGameplayAuraSpec>           ActiveGameplayAuraSpecs;                           // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTgfActiveGameplayAuraHandle AddGameplayAura(TSubclassOf<class UTgfGameplayAura> AuraClass);
	struct FTgfActiveGameplayAuraHandle AddGameplayAuraWithSourceCharacter(TSubclassOf<class UTgfGameplayAura> AuraClass, class AActor* Source);
	class UTgfGameplayAura* GetActiveAuraByClass(TSubclassOf<class UTgfGameplayAura> AuraClass);
	void HandleInstigatorDeath(class AActor* OwningActor);
	void HandleInstigatorEscape(class APawn* OwingPawn, bool bWaiting);
	void HandleInstigatorRebirth(class AActor* OwningActor);
	void RemoveGameplayAura(class UTgfGameplayAura* GameplayAura);
	void RemoveGameplayAuraByHandle(const struct FTgfActiveGameplayAuraHandle& Handle);
	void RemoveGameplayAuraBySourceAura(TSubclassOf<class UTgfGameplayAura> AuraClass, int32 StacksToRemove);
	void RemoveGameplayAuraWithAppliedTags(const struct FGameplayTagContainer& Tags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAuraManagerComponent">();
	}
	static class UTgfAuraManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAuraManagerComponent>();
	}
};
static_assert(alignof(UTgfAuraManagerComponent) == 0x000008, "Wrong alignment on UTgfAuraManagerComponent");
static_assert(sizeof(UTgfAuraManagerComponent) == 0x0000C0, "Wrong size on UTgfAuraManagerComponent");
static_assert(offsetof(UTgfAuraManagerComponent, ActiveGameplayAuraSpecs) == 0x0000A8, "Member 'UTgfAuraManagerComponent::ActiveGameplayAuraSpecs' has a wrong offset!");

// Class LyraGame.LyraTaggedActor
// 0x0048 (0x02E0 - 0x0298)
class ALyraTaggedActor : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  StaticGameplayTags;                                // 0x02A0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AuthorityTag;                                      // 0x02C0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	bool IsAttachedFirstPersonCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTaggedActor">();
	}
	static class ALyraTaggedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraTaggedActor>();
	}
};
static_assert(alignof(ALyraTaggedActor) == 0x000008, "Wrong alignment on ALyraTaggedActor");
static_assert(sizeof(ALyraTaggedActor) == 0x0002E0, "Wrong size on ALyraTaggedActor");
static_assert(offsetof(ALyraTaggedActor, StaticGameplayTags) == 0x0002A0, "Member 'ALyraTaggedActor::StaticGameplayTags' has a wrong offset!");
static_assert(offsetof(ALyraTaggedActor, AuthorityTag) == 0x0002C0, "Member 'ALyraTaggedActor::AuthorityTag' has a wrong offset!");

// Class LyraGame.IndicatorLayer
// 0x00E0 (0x0230 - 0x0150)
class UIndicatorLayer final : public UWidget
{
public:
	struct FSlateBrush                            ArrowBrush;                                        // 0x0150(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorLayer">();
	}
	static class UIndicatorLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIndicatorLayer>();
	}
};
static_assert(alignof(UIndicatorLayer) == 0x000010, "Wrong alignment on UIndicatorLayer");
static_assert(sizeof(UIndicatorLayer) == 0x000230, "Wrong size on UIndicatorLayer");
static_assert(offsetof(UIndicatorLayer, ArrowBrush) == 0x000150, "Member 'UIndicatorLayer::ArrowBrush' has a wrong offset!");

// Class LyraGame.TgfAvatarActor
// 0x04A0 (0x0780 - 0x02E0)
class ATgfAvatarActor : public ALyraTaggedActor
{
public:
	bool                                          ForceLockedThirdPerson;                            // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         SubMeshes;                                         // 0x02F8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x138];                                    // 0x0308(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTgfAvatarMeshSelectionSet             AvatarMeshSet;                                     // 0x0440(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USkeleton*                              AvatarSkeleton;                                    // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x2D0];                                    // 0x04A8(0x02D0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLobbyActor;                                       // 0x0778(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ForceUseBaseMesh;                                  // 0x0779(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77A[0x2];                                      // 0x077A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsActive;                                          // 0x077C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsMainAvatar;                                      // 0x077D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77E[0x2];                                      // 0x077E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMesh* BuildAvatarMeshForExternalUse(const struct FGameplayTagContainer& CosmeticTags, TArray<class USkeletalMesh*>* OutMeshesToAppend);
	void ClearAllAttachmentActors();
	void ClearAllSkin();
	void ClearAvatarSkinMesh();
	void DisableSubMeshClothSimulation(bool bDisable);
	void ForceThirdPerson(bool bThirdPerson);
	void GetAllAttachmentActors(TArray<class AActor*>* OutSpawnedActors);
	TArray<int32> GetAllSkinIDs();
	ETgfActorGender GetAvatarGender();
	ETgfActorRace GetAvatarRace();
	struct FTgfHeadResConfig GetFaceConfig();
	void GetInventoryAvatar(class ATgfAvatarActor* InventoryAvatar);
	bool GetIsActive();
	bool GetIsMainAvatar();
	void OnUpdateAvatarDataMesh(ETgfActorGender Gender, ETgfActorRace Race);
	void RemoveSkinMeshIDs(ETgfSkinSlot Slot, int32 SkinId);
	void SetActive(bool Active);
	void SetAllSkinIdMeshIdsAndHelmetVisible(const TArray<int32>& SkinIds, bool HelmetVisible);
	void SetAnimTick(EVisibilityBasedAnimTickOption Option);
	void SetAvatarGender(ETgfActorGender Data);
	void SetAvatarRace(ETgfActorRace Data);
	bool SetAvatarSkinMesh(const TArray<struct FTgfCharaPartChangeConfig>& InAttachmentMeshParts);
	void SetEquipmentAttachment(const TArray<struct FTgfCharaPartSpawnActor>& SpawnActorsInfo);
	void SetFaceConfig(const struct FTgfHeadResConfig& Data);
	void SetIsMainAvatar(bool Value);
	void SetLobbyActor(bool Value);
	bool SetOverrideAvatarMesh(const TArray<struct FTgfCharaPartChangeConfig>& InOverrideMeshParts);
	bool SetSkinMeshForce(int32 Type_id, bool IgnoreTypeCheck, ETgfSkinSlot SlotAlternative, TSubclassOf<class ULyraInventoryItemDefinition> Definition);
	void SwitchSkin(class UMaterialInterface* SkinMat);
	void ToggleBaseMeshForBodyPart(ETgfCharaPart Part, bool bBaseMeshVisible);
	void ToggleSubMeshPostProcessBlueprint();
	void UpdateMesh();
	void UpdateMeshMorphTarget(class FName MorphName, float Weight);
	void UpdatePhysics();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAvatarActor">();
	}
	static class ATgfAvatarActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfAvatarActor>();
	}
};
static_assert(alignof(ATgfAvatarActor) == 0x000008, "Wrong alignment on ATgfAvatarActor");
static_assert(sizeof(ATgfAvatarActor) == 0x000780, "Wrong size on ATgfAvatarActor");
static_assert(offsetof(ATgfAvatarActor, ForceLockedThirdPerson) == 0x0002E0, "Member 'ATgfAvatarActor::ForceLockedThirdPerson' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, Mesh) == 0x0002E8, "Member 'ATgfAvatarActor::Mesh' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, CapsuleComponent) == 0x0002F0, "Member 'ATgfAvatarActor::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, SubMeshes) == 0x0002F8, "Member 'ATgfAvatarActor::SubMeshes' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, AvatarMeshSet) == 0x000440, "Member 'ATgfAvatarActor::AvatarMeshSet' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, AvatarSkeleton) == 0x0004A0, "Member 'ATgfAvatarActor::AvatarSkeleton' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, bLobbyActor) == 0x000778, "Member 'ATgfAvatarActor::bLobbyActor' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, ForceUseBaseMesh) == 0x000779, "Member 'ATgfAvatarActor::ForceUseBaseMesh' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, IsActive) == 0x00077C, "Member 'ATgfAvatarActor::IsActive' has a wrong offset!");
static_assert(offsetof(ATgfAvatarActor, IsMainAvatar) == 0x00077D, "Member 'ATgfAvatarActor::IsMainAvatar' has a wrong offset!");

// Class LyraGame.TgfAvatarHelperComponent
// 0x0060 (0x0108 - 0x00A8)
class UTgfAvatarHelperComponent final : public UActorComponent
{
public:
	struct FTgfHeadResConfig                      AvatarHeadConfig;                                  // 0x00A8(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	ETgfActorGender                               AvatarGender;                                      // 0x00D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfCharaPartChangeConfig>      MeshParts;                                         // 0x00E0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FTgfCharaPartSpawnActor>        SpawnActorsInfo;                                   // 0x00F0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              LinkedAnimLayerClass;                              // 0x0100(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CopyDataFromAvatar(class ATgfAvatarActor* Avatar);
	void OnRep_AvatarGender();
	void OnRep_AvatarHeadConfig();
	void OnRep_LinkAnimLayer();
	void OnRep_MeshParts();

	void CopyDataToAvatar(class ATgfAvatarActor* Avatar) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAvatarHelperComponent">();
	}
	static class UTgfAvatarHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAvatarHelperComponent>();
	}
};
static_assert(alignof(UTgfAvatarHelperComponent) == 0x000008, "Wrong alignment on UTgfAvatarHelperComponent");
static_assert(sizeof(UTgfAvatarHelperComponent) == 0x000108, "Wrong size on UTgfAvatarHelperComponent");
static_assert(offsetof(UTgfAvatarHelperComponent, AvatarHeadConfig) == 0x0000A8, "Member 'UTgfAvatarHelperComponent::AvatarHeadConfig' has a wrong offset!");
static_assert(offsetof(UTgfAvatarHelperComponent, AvatarGender) == 0x0000D8, "Member 'UTgfAvatarHelperComponent::AvatarGender' has a wrong offset!");
static_assert(offsetof(UTgfAvatarHelperComponent, MeshParts) == 0x0000E0, "Member 'UTgfAvatarHelperComponent::MeshParts' has a wrong offset!");
static_assert(offsetof(UTgfAvatarHelperComponent, SpawnActorsInfo) == 0x0000F0, "Member 'UTgfAvatarHelperComponent::SpawnActorsInfo' has a wrong offset!");
static_assert(offsetof(UTgfAvatarHelperComponent, LinkedAnimLayerClass) == 0x000100, "Member 'UTgfAvatarHelperComponent::LinkedAnimLayerClass' has a wrong offset!");

// Class LyraGame.LyraControllerDisconnectedScreen
// 0x0008 (0x03F0 - 0x03E8)
class ULyraControllerDisconnectedScreen final : public UCommonActivatableWidget
{
public:
	class UHorizontalBox*                         HBox_SwitchUser;                                   // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraControllerDisconnectedScreen">();
	}
	static class ULyraControllerDisconnectedScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraControllerDisconnectedScreen>();
	}
};
static_assert(alignof(ULyraControllerDisconnectedScreen) == 0x000008, "Wrong alignment on ULyraControllerDisconnectedScreen");
static_assert(sizeof(ULyraControllerDisconnectedScreen) == 0x0003F0, "Wrong size on ULyraControllerDisconnectedScreen");
static_assert(offsetof(ULyraControllerDisconnectedScreen, HBox_SwitchUser) == 0x0003E8, "Member 'ULyraControllerDisconnectedScreen::HBox_SwitchUser' has a wrong offset!");

// Class LyraGame.TgfBaseExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfBaseExecution : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBaseExecution">();
	}
	static class UTgfBaseExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBaseExecution>();
	}
};
static_assert(alignof(UTgfBaseExecution) == 0x000008, "Wrong alignment on UTgfBaseExecution");
static_assert(sizeof(UTgfBaseExecution) == 0x000070, "Wrong size on UTgfBaseExecution");

// Class LyraGame.TgfBaseModMagnitudeCalculation
// 0x0000 (0x0040 - 0x0040)
class UTgfBaseModMagnitudeCalculation : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBaseModMagnitudeCalculation">();
	}
	static class UTgfBaseModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBaseModMagnitudeCalculation>();
	}
};
static_assert(alignof(UTgfBaseModMagnitudeCalculation) == 0x000008, "Wrong alignment on UTgfBaseModMagnitudeCalculation");
static_assert(sizeof(UTgfBaseModMagnitudeCalculation) == 0x000040, "Wrong size on UTgfBaseModMagnitudeCalculation");

// Class LyraGame.LyraHUD
// 0x0000 (0x0388 - 0x0388)
class ALyraHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHUD">();
	}
	static class ALyraHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraHUD>();
	}
};
static_assert(alignof(ALyraHUD) == 0x000008, "Wrong alignment on ALyraHUD");
static_assert(sizeof(ALyraHUD) == 0x000388, "Wrong size on ALyraHUD");

// Class LyraGame.TgfBattleCalculationDataAsset
// 0x0038 (0x0068 - 0x0030)
class UTgfBattleCalculationDataAsset final : public UPrimaryDataAsset
{
public:
	float                                         DefendConstructionNumerator;                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefendConstructionDenominator;                     // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostDamageMutiplierLowerBound;                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostDamageMutiplierUpperBound;                    // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefendMultiplierLowerBound;                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefendMultiplierUpperBound;                        // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResistanceMultiplierLowerBound;                    // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResistanceMultiplierUpperBound;                    // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VulnerMultiplierLowerBound;                        // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VulnerMultiplierUpperBound;                        // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HurtInterruptBound;                                // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendlyDamageReduction;                           // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillCooldownScaleRateMin;                         // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBattleCalculationDataAsset">();
	}
	static class UTgfBattleCalculationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBattleCalculationDataAsset>();
	}
};
static_assert(alignof(UTgfBattleCalculationDataAsset) == 0x000008, "Wrong alignment on UTgfBattleCalculationDataAsset");
static_assert(sizeof(UTgfBattleCalculationDataAsset) == 0x000068, "Wrong size on UTgfBattleCalculationDataAsset");
static_assert(offsetof(UTgfBattleCalculationDataAsset, DefendConstructionNumerator) == 0x000030, "Member 'UTgfBattleCalculationDataAsset::DefendConstructionNumerator' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, DefendConstructionDenominator) == 0x000034, "Member 'UTgfBattleCalculationDataAsset::DefendConstructionDenominator' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, BoostDamageMutiplierLowerBound) == 0x000038, "Member 'UTgfBattleCalculationDataAsset::BoostDamageMutiplierLowerBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, BoostDamageMutiplierUpperBound) == 0x00003C, "Member 'UTgfBattleCalculationDataAsset::BoostDamageMutiplierUpperBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, DefendMultiplierLowerBound) == 0x000040, "Member 'UTgfBattleCalculationDataAsset::DefendMultiplierLowerBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, DefendMultiplierUpperBound) == 0x000044, "Member 'UTgfBattleCalculationDataAsset::DefendMultiplierUpperBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, ResistanceMultiplierLowerBound) == 0x000048, "Member 'UTgfBattleCalculationDataAsset::ResistanceMultiplierLowerBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, ResistanceMultiplierUpperBound) == 0x00004C, "Member 'UTgfBattleCalculationDataAsset::ResistanceMultiplierUpperBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, VulnerMultiplierLowerBound) == 0x000050, "Member 'UTgfBattleCalculationDataAsset::VulnerMultiplierLowerBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, VulnerMultiplierUpperBound) == 0x000054, "Member 'UTgfBattleCalculationDataAsset::VulnerMultiplierUpperBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, HurtInterruptBound) == 0x000058, "Member 'UTgfBattleCalculationDataAsset::HurtInterruptBound' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, FriendlyDamageReduction) == 0x00005C, "Member 'UTgfBattleCalculationDataAsset::FriendlyDamageReduction' has a wrong offset!");
static_assert(offsetof(UTgfBattleCalculationDataAsset, SkillCooldownScaleRateMin) == 0x000060, "Member 'UTgfBattleCalculationDataAsset::SkillCooldownScaleRateMin' has a wrong offset!");

// Class LyraGame.TgfBattleEleResistanceDataAsset
// 0x0018 (0x0048 - 0x0030)
class UTgfBattleEleResistanceDataAsset final : public UPrimaryDataAsset
{
public:
	float                                         DefaultElementResistance;                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfBattleEleResistanceItem>    DeltaResistanceList;                               // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	float GetConfigElementResistanceRate(ETgfBattleElement AttackElement, ETgfBattleElement DefendElement) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBattleEleResistanceDataAsset">();
	}
	static class UTgfBattleEleResistanceDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBattleEleResistanceDataAsset>();
	}
};
static_assert(alignof(UTgfBattleEleResistanceDataAsset) == 0x000008, "Wrong alignment on UTgfBattleEleResistanceDataAsset");
static_assert(sizeof(UTgfBattleEleResistanceDataAsset) == 0x000048, "Wrong size on UTgfBattleEleResistanceDataAsset");
static_assert(offsetof(UTgfBattleEleResistanceDataAsset, DefaultElementResistance) == 0x000030, "Member 'UTgfBattleEleResistanceDataAsset::DefaultElementResistance' has a wrong offset!");
static_assert(offsetof(UTgfBattleEleResistanceDataAsset, DeltaResistanceList) == 0x000038, "Member 'UTgfBattleEleResistanceDataAsset::DeltaResistanceList' has a wrong offset!");

// Class LyraGame.CircumferenceMarkerWidget
// 0x0110 (0x0260 - 0x0150)
class UCircumferenceMarkerWidget final : public UWidget
{
public:
	TArray<struct FCircumferenceMarkerEntry>      MarkerList;                                        // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0xC];                                      // 0x0164(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MarkerImage;                                       // 0x0170(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bReticleCornerOutsideSpreadRadius : 1;             // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_241[0x1F];                                     // 0x0241(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRadius(float InRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CircumferenceMarkerWidget">();
	}
	static class UCircumferenceMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCircumferenceMarkerWidget>();
	}
};
static_assert(alignof(UCircumferenceMarkerWidget) == 0x000010, "Wrong alignment on UCircumferenceMarkerWidget");
static_assert(sizeof(UCircumferenceMarkerWidget) == 0x000260, "Wrong size on UCircumferenceMarkerWidget");
static_assert(offsetof(UCircumferenceMarkerWidget, MarkerList) == 0x000150, "Member 'UCircumferenceMarkerWidget::MarkerList' has a wrong offset!");
static_assert(offsetof(UCircumferenceMarkerWidget, Radius) == 0x000160, "Member 'UCircumferenceMarkerWidget::Radius' has a wrong offset!");
static_assert(offsetof(UCircumferenceMarkerWidget, MarkerImage) == 0x000170, "Member 'UCircumferenceMarkerWidget::MarkerImage' has a wrong offset!");

// Class LyraGame.EnumUtils
// 0x0000 (0x0028 - 0x0028)
class UEnumUtils final : public UBlueprintFunctionLibrary
{
public:
	static ETgfEquipSlot GetAnotherSlot(ETgfEquipSlot Slot);
	static bool IsAdditionalWeapon(ETgfEquipSlot Slot);
	static bool IsBossMonster(ETgfActorType Type);
	static bool IsBotPlayer(ETgfActorType Type);
	static bool IsCurrentWeapon(ETgfEquipSlot Slot, ETgfWeaponChangeSlot ChangeSlot);
	static bool IsEliteMonster(ETgfActorType Type);
	static bool IsLeftHandWeapon(ETgfEquipSlot Slot);
	static bool IsMatchSlot(ETgfEquipSlot Slot, ETgfWeaponEquipType EquipType, bool CanEquipDouble);
	static bool IsMonster(ETgfActorType Type);
	static bool IsPlayer(ETgfActorType Type);
	static bool IsRightHandWeapon(ETgfEquipSlot Slot, bool NeedConsumable);
	static bool IsSummonActor(ETgfActorType Type);
	static bool IsWeapon(ETgfEquipSlot Slot, bool OnlyBase);
	static bool IsWeaponChangeSlot(ETgfWeaponChangeSlot ChangeSlot);
	static bool NeedLeftHand(ETgfWeaponEquipType Type);
	static bool NeedRightHand(ETgfWeaponEquipType Type);
	static int32 Parse3ValIntFromFloat(float Value);
	static ETgfUseAttackType ParseAttackTypeFromFloat(float Value);
	static struct FGameplayTag ParseBattleElementTagFromEnum(ETgfBattleElement BattleElement);
	static bool ParseBoolFromFloat(float Value);
	static struct FGameplayTag ParseDamageBattleElementTagFromEnum(ETgfBattleElement BattleElement);
	static ETgfBattleElement ParseElementFromFloat(float Value);
	static ETgfEquipSlot ParseLeftHandWeaponSlot(ETgfWeaponChangeSlot Slot);
	static ETgfEquipSlot ParseRightHandWeaponSlot(ETgfWeaponChangeSlot Slot);
	static ETgfWeaponChangeSlot ParseWeaponSlot(ETgfEquipSlot Slot);
	static ETgfEquipSlot ParseWeaponSlotToEquipSlotExtra(ETgfWeaponChangeSlot Slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnumUtils">();
	}
	static class UEnumUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnumUtils>();
	}
};
static_assert(alignof(UEnumUtils) == 0x000008, "Wrong alignment on UEnumUtils");
static_assert(sizeof(UEnumUtils) == 0x000028, "Wrong size on UEnumUtils");

// Class LyraGame.LyraTaggedWidget
// 0x0028 (0x02E8 - 0x02C0)
class ULyraTaggedWidget final : public UCommonUserWidget
{
public:
	struct FGameplayTagContainer                  HiddenByTags;                                      // 0x02C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESlateVisibility                              ShownVisibility;                                   // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              HiddenVisibility;                                  // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTaggedWidget">();
	}
	static class ULyraTaggedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTaggedWidget>();
	}
};
static_assert(alignof(ULyraTaggedWidget) == 0x000008, "Wrong alignment on ULyraTaggedWidget");
static_assert(sizeof(ULyraTaggedWidget) == 0x0002E8, "Wrong size on ULyraTaggedWidget");
static_assert(offsetof(ULyraTaggedWidget, HiddenByTags) == 0x0002C0, "Member 'ULyraTaggedWidget::HiddenByTags' has a wrong offset!");
static_assert(offsetof(ULyraTaggedWidget, ShownVisibility) == 0x0002E0, "Member 'ULyraTaggedWidget::ShownVisibility' has a wrong offset!");
static_assert(offsetof(ULyraTaggedWidget, HiddenVisibility) == 0x0002E1, "Member 'ULyraTaggedWidget::HiddenVisibility' has a wrong offset!");

// Class LyraGame.TgfBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyDisplayGamma();
	static float BlendFloat(float CurValue, float TargetValue, float DeltaTime, float TotalTime, struct FBlendingUtilParamsCache& CachedParams);
	static bool BoxOverlapActorsWithRot(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FQuat& Rot, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool BoxOverlapComponentsWithRot(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, const struct FQuat& Rot, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static float CalcItemScreenSizeByViewTarget(const struct FVector& ViewPos, const struct FVector& ItemPos, const struct FVector& ItemExtent, class AActor* InViewTarget);
	static bool CheckCurrentWeaponSlotType(class ALyraCharacter* Character, ETgfWeaponChangeSlot Slot);
	static float ClassicSpeedDamping(float Current, float DeltaTime, struct FSpeedDampingParams& DampingParams);
	static void DestroyChildActor(class AActor* Parent, TSubclassOf<class AActor> ChildType);
	static float EvaluateCurve(const struct FRuntimeFloatCurve& Curve, float Value);
	static float EvaluateCurveMapping(const struct FRuntimeFloatCurve& Curve, float Time, float MappingDuration, float DefaultValue);
	static bool FindUnoccupiedLocationForSpawn(const class AActor* WorldContext, TSubclassOf<class AActor> ActorClass, const struct FVector& TestLocation, const struct FRotator& TestRotation, struct FVector* PlaceLocation);
	static void ForceDefaultGamma();
	static TArray<class UClass*> GetAllBluePrintClassesOfPath(class FName Path, bool IncludingSubPath);
	static float GetAngleBetweenTwoVectors(const struct FVector& Lhs, const struct FVector& Rhs, bool Signed);
	static float GetAngleBetweenTwoVectors2D(const struct FVector& Lhs, const struct FVector& Rhs, bool Signed);
	static EAnimConfigDirection8 GetAngleDirection8(const float Angle);
	static EAnimConfigDirection8 GetAngleDirection8_WithThreshold(const float Angle, const float BackThreshold, const float HorizThreshold, const float FrontThreshold);
	static void GetAttachNiagaraComponents(class AActor* Target, TArray<class UNiagaraComponent*>* NiagaraSystems);
	static struct FRotator GetCharacterControlledRotation(class ACharacter* Character);
	static struct FVector GetCurrentAcceleration(const class UCharacterMovementComponent* MovementComponent);
	static class FString GetDebugName(const class AActor* Actor);
	static float GetDeltaTimeInMilliseconds(const struct FDateTime& EndTime, const struct FDateTime& StartTime);
	static const class UTgfEquipmentDefinition* GetEquipmentDefinition(int32 TypeId);
	static class AActor* GetLocalViewTarget(class UObject* WorldContext);
	static void GetMeshComponentsBound(class AActor* InActor, struct FVector* Origin, struct FVector* BoxExtent, bool bIncludeFromChildActors, bool bOnlyCollidingComponents);
	static void GetPlayMontageDelayInfo(float* DelayTime, const bool& bCheck, float DefaultInvalidValue);
	static const struct FTgfRaceAvatarBodyModifyData GetRaceAvatarData(ETgfActorRace Race, float* HeightOffset);
	static bool GetSpawnOffsetPos(TArray<struct FVector>* OutOffsetPos, const class AActor* SrcActor, const TArray<struct FVector>& SpawnOffset, const int32 SpawnNum, const struct FVector& SourceOffset);
	static void GetUniqueHitResultsByActor(const TArray<struct FHitResult>& InHits, TArray<struct FHitResult>* OutHits);
	static float GetVectorDirection(const struct FVector& Lhs, const struct FVector& Rhs);
	static class FString GetWorldNameOfSpecificLevel(class ULevel* InLevel);
	static bool IsActorCloser(const class AActor* ActorA, const class AActor* ActorB, const struct FVector& Pos);
	static bool IsCharacterAttrGreater(const class AActor* ActorA, const class AActor* ActorB, const struct FGameplayAttribute& Attribute);
	static bool IsCharacterCloser(const class AActor* ActorA, const class AActor* ActorB, const struct FVector& Pos);
	static bool IsCharacterHealthRatioHigher(const class AActor* ActorA, const class AActor* ActorB);
	static bool IsCharacterRight(const class AActor* ActorA, const class AActor* ActorB, const struct FVector& CenterPos, const struct FVector& Forward);
	static bool IsDevelopmentBuild();
	static bool IsOnDedicatedServer(class UObject* WorldContext);
	static bool IsPendingKillPending(const class AActor* Actor);
	static bool IsRunningInPIE();
	static bool IsValid(const struct FGameplayTagContainer& TagContainer);
	static struct FAxis MakeAxis(ETgfAxisName Axis);
	static struct FVector MakeVectorFromAxis(ETgfAxisName Axis);
	static void PreparePhysicalMaterials(const class UTgfObjectListDataAsset* ObjectListDataAsset);
	static void RequestRoleAppearanceTexture(int64 RoleID, const struct FTgfAvatarBuildConfig& InAppearanceConfig, bool NeedQueueFirst, const struct FVector2D& ImgSize);
	static void ReregisterActor(class AActor* InActor);
	static void ResetBlendFloat(struct FBlendingUtilParamsCache& CachedParams);
	static void SetActorCustomStencilValue(class AActor* TargetActor, ETgfStencilRef StencilValue, bool bSet, class UPrimitiveComponent* TargetMesh);
	static void SetCharacterWeaponMaterialParameter_Float(class ACharacter* Character, class FName Param_Name, float Value, ETgfWeaponHandType Hand);
	static void SetCustomStencilValueSingleBit(class UPrimitiveComponent* Mesh, ETgfStencilRef StencilValue, bool bSet);
	static void SetWorldPhysicsSimulationEnabled(class AActor* Actor, bool Enabled);
	static TArray<class AActor*> SortActorsByAngle(TArray<class AActor*>& Actors, const struct FVector& CenterPos, const struct FVector& Forward, bool bIsReverse);
	static TArray<class AActor*> SortActorsByAttribute(TArray<class AActor*>& Actors, const struct FGameplayAttribute& Attribute, bool bIsReverse);
	static TArray<class AActor*> SortActorsByDistance(TArray<class AActor*>& Actors, const struct FVector& Pos, bool bIsReverse);
	static TArray<class AActor*> SortActorsByHealthRatio(TArray<class AActor*>& Actors, bool bIsReverse);
	static void SpawnDecalFromAbility(class AActor* Instigator, const struct FVector& SpawnCenter, float SpawnRadius, const TArray<EObjectTypeQuery>& ObjectTypes, const TArray<EPhysicalSurface>& SurfaceTypes, const struct FGameplayEffectContextHandle& GECH, const struct FGameplayTag& GameplayCueTag);
	static void SpawnEquipmentActorsWithAttachTarget(int32 Type_id, class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors, bool bAttachToLeft);
	static float SpringFloatBlendAssist(float Current, float Target, struct FFloatSpringState& State);
	static float SpringFloatSpeed(struct FFloatSpringState& State);
	static void StopAllMontage(class UAnimInstance* AnimInstance, float BlendOutTime);
	static void TGFEasilyGetItemById(int32 SkinId, TArray<TSubclassOf<class AActor>>* OutEquipment, TArray<class USkeletalMesh*>* OutSkinParts, struct FRotator* OutRotatar);
	static void ToggleActorTick(class AActor* InActor, bool ShouldTick, bool ShouldAffectComps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBlueprintFunctionLibrary">();
	}
	static class UTgfBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTgfBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTgfBlueprintFunctionLibrary");
static_assert(sizeof(UTgfBlueprintFunctionLibrary) == 0x000028, "Wrong size on UTgfBlueprintFunctionLibrary");

// Class LyraGame.TgfBPCheatsBase
// 0x0000 (0x0028 - 0x0028)
class UTgfBPCheatsBase final : public UCheatManagerExtension
{
public:
	bool CheatEnabled() const;
	class ULyraAbilitySystemComponent* GetAbilitySystemComponent() const;
	class ALyraCharacter* GetCharacter() const;
	class UTgfCheatComponent* GetTgfCheatComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBPCheatsBase">();
	}
	static class UTgfBPCheatsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBPCheatsBase>();
	}
};
static_assert(alignof(UTgfBPCheatsBase) == 0x000008, "Wrong alignment on UTgfBPCheatsBase");
static_assert(sizeof(UTgfBPCheatsBase) == 0x000028, "Wrong size on UTgfBPCheatsBase");

// Class LyraGame.LyraIndicatorManagerComponent
// 0x0040 (0x00E8 - 0x00A8)
class ULyraIndicatorManagerComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UIndicatorDescriptor*>           Indicators;                                        // 0x00D8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void AddIndicator(class UIndicatorDescriptor* IndicatorDescriptor);
	void RemoveIndicator(class UIndicatorDescriptor* IndicatorDescriptor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraIndicatorManagerComponent">();
	}
	static class ULyraIndicatorManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraIndicatorManagerComponent>();
	}
};
static_assert(alignof(ULyraIndicatorManagerComponent) == 0x000008, "Wrong alignment on ULyraIndicatorManagerComponent");
static_assert(sizeof(ULyraIndicatorManagerComponent) == 0x0000E8, "Wrong size on ULyraIndicatorManagerComponent");
static_assert(offsetof(ULyraIndicatorManagerComponent, Indicators) == 0x0000D8, "Member 'ULyraIndicatorManagerComponent::Indicators' has a wrong offset!");

// Class LyraGame.TgfButton
// 0x0000 (0x05F0 - 0x05F0)
class UTgfButton : public UButton
{
public:
	void TgfOnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfButton">();
	}
	static class UTgfButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfButton>();
	}
};
static_assert(alignof(UTgfButton) == 0x000010, "Wrong alignment on UTgfButton");
static_assert(sizeof(UTgfButton) == 0x0005F0, "Wrong size on UTgfButton");

// Class LyraGame.TgfButtonInternalBase
// 0x0000 (0x0660 - 0x0660)
class UTgfButtonInternalBase final : public UCommonButtonInternalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfButtonInternalBase">();
	}
	static class UTgfButtonInternalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfButtonInternalBase>();
	}
};
static_assert(alignof(UTgfButtonInternalBase) == 0x000010, "Wrong alignment on UTgfButtonInternalBase");
static_assert(sizeof(UTgfButtonInternalBase) == 0x000660, "Wrong size on UTgfButtonInternalBase");

// Class LyraGame.LyraUIManagerSubsystem
// 0x0030 (0x0098 - 0x0068)
class ULyraUIManagerSubsystem final : public UGameUIManagerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPreLoadMapDelegate;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostLoadMapDelegate;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUIManagerSubsystem">();
	}
	static class ULyraUIManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUIManagerSubsystem>();
	}
};
static_assert(alignof(ULyraUIManagerSubsystem) == 0x000008, "Wrong alignment on ULyraUIManagerSubsystem");
static_assert(sizeof(ULyraUIManagerSubsystem) == 0x000098, "Wrong size on ULyraUIManagerSubsystem");
static_assert(offsetof(ULyraUIManagerSubsystem, OnPreLoadMapDelegate) == 0x000068, "Member 'ULyraUIManagerSubsystem::OnPreLoadMapDelegate' has a wrong offset!");
static_assert(offsetof(ULyraUIManagerSubsystem, OnPostLoadMapDelegate) == 0x000078, "Member 'ULyraUIManagerSubsystem::OnPostLoadMapDelegate' has a wrong offset!");

// Class LyraGame.TgfButtonBase
// 0x0010 (0x1520 - 0x1510)
class UTgfButtonBase : public UCommonButtonBase
{
public:
	bool                                          bNotClickable;                                     // 0x1510(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1511[0xF];                                     // 0x1511(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfButtonBase">();
	}
	static class UTgfButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfButtonBase>();
	}
};
static_assert(alignof(UTgfButtonBase) == 0x000010, "Wrong alignment on UTgfButtonBase");
static_assert(sizeof(UTgfButtonBase) == 0x001520, "Wrong size on UTgfButtonBase");
static_assert(offsetof(UTgfButtonBase, bNotClickable) == 0x001510, "Member 'UTgfButtonBase::bNotClickable' has a wrong offset!");

// Class LyraGame.TgfButtonStyle
// 0x0040 (0x07F0 - 0x07B0)
class UTgfButtonStyle : public UCommonButtonStyle
{
public:
	bool                                          bTextless;                                         // 0x07B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverlay;                                       // 0x07B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B2[0x6];                                      // 0x07B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OverlayMask;                                       // 0x07B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HoverOverlayColor;                                 // 0x07D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E8[0x8];                                      // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfButtonStyle">();
	}
	static class UTgfButtonStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfButtonStyle>();
	}
};
static_assert(alignof(UTgfButtonStyle) == 0x000010, "Wrong alignment on UTgfButtonStyle");
static_assert(sizeof(UTgfButtonStyle) == 0x0007F0, "Wrong size on UTgfButtonStyle");
static_assert(offsetof(UTgfButtonStyle, bTextless) == 0x0007B0, "Member 'UTgfButtonStyle::bTextless' has a wrong offset!");
static_assert(offsetof(UTgfButtonStyle, bUseOverlay) == 0x0007B1, "Member 'UTgfButtonStyle::bUseOverlay' has a wrong offset!");
static_assert(offsetof(UTgfButtonStyle, OverlayMask) == 0x0007B8, "Member 'UTgfButtonStyle::OverlayMask' has a wrong offset!");
static_assert(offsetof(UTgfButtonStyle, HoverOverlayColor) == 0x0007D8, "Member 'UTgfButtonStyle::HoverOverlayColor' has a wrong offset!");

// Class LyraGame.TgfCameraActor
// 0x0010 (0x09B0 - 0x09A0)
class ATgfCameraActor final : public ACameraActor
{
public:
	struct FGameplayTag                           CameraTag;                                         // 0x09A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A8[0x8];                                      // 0x09A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraActor">();
	}
	static class ATgfCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfCameraActor>();
	}
};
static_assert(alignof(ATgfCameraActor) == 0x000010, "Wrong alignment on ATgfCameraActor");
static_assert(sizeof(ATgfCameraActor) == 0x0009B0, "Wrong size on ATgfCameraActor");
static_assert(offsetof(ATgfCameraActor, CameraTag) == 0x0009A0, "Member 'ATgfCameraActor::CameraTag' has a wrong offset!");

// Class LyraGame.LyraReticleWidgetBase
// 0x0010 (0x02D0 - 0x02C0)
class ULyraReticleWidgetBase final : public UCommonUserWidget
{
public:
	class ULyraWeaponInstance*                    WeaponInstance;                                    // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraInventoryItemInstance*             InventoryInstance;                                 // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeFromWeapon(class ULyraWeaponInstance* InWeapon);
	void OnWeaponInitialized();

	float ComputeMaxScreenspaceSpreadRadius() const;
	float ComputeSpreadAngle() const;
	bool HasFirstShotAccuracy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraReticleWidgetBase">();
	}
	static class ULyraReticleWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraReticleWidgetBase>();
	}
};
static_assert(alignof(ULyraReticleWidgetBase) == 0x000008, "Wrong alignment on ULyraReticleWidgetBase");
static_assert(sizeof(ULyraReticleWidgetBase) == 0x0002D0, "Wrong size on ULyraReticleWidgetBase");
static_assert(offsetof(ULyraReticleWidgetBase, WeaponInstance) == 0x0002C0, "Member 'ULyraReticleWidgetBase::WeaponInstance' has a wrong offset!");
static_assert(offsetof(ULyraReticleWidgetBase, InventoryInstance) == 0x0002C8, "Member 'ULyraReticleWidgetBase::InventoryInstance' has a wrong offset!");

// Class LyraGame.TgfCameraControlWidget
// 0x0018 (0x02D8 - 0x02C0)
class UTgfCameraControlWidget final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraControlWidget">();
	}
	static class UTgfCameraControlWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraControlWidget>();
	}
};
static_assert(alignof(UTgfCameraControlWidget) == 0x000008, "Wrong alignment on UTgfCameraControlWidget");
static_assert(sizeof(UTgfCameraControlWidget) == 0x0002D8, "Wrong size on UTgfCameraControlWidget");

// Class LyraGame.LyraPerfStatContainerBase
// 0x0008 (0x02C8 - 0x02C0)
class ULyraPerfStatContainerBase final : public UCommonUserWidget
{
public:
	ELyraStatDisplayMode                          StatDisplayModeFilter;                             // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateVisibilityOfChildren();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerfStatContainerBase">();
	}
	static class ULyraPerfStatContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerfStatContainerBase>();
	}
};
static_assert(alignof(ULyraPerfStatContainerBase) == 0x000008, "Wrong alignment on ULyraPerfStatContainerBase");
static_assert(sizeof(ULyraPerfStatContainerBase) == 0x0002C8, "Wrong size on ULyraPerfStatContainerBase");
static_assert(offsetof(ULyraPerfStatContainerBase, StatDisplayModeFilter) == 0x0002C0, "Member 'ULyraPerfStatContainerBase::StatDisplayModeFilter' has a wrong offset!");

// Class LyraGame.TgfCameraMode_FirstPerson
// 0x0000 (0x0110 - 0x0110)
class UTgfCameraMode_FirstPerson final : public ULyraCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraMode_FirstPerson">();
	}
	static class UTgfCameraMode_FirstPerson* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraMode_FirstPerson>();
	}
};
static_assert(alignof(UTgfCameraMode_FirstPerson) == 0x000008, "Wrong alignment on UTgfCameraMode_FirstPerson");
static_assert(sizeof(UTgfCameraMode_FirstPerson) == 0x000110, "Wrong size on UTgfCameraMode_FirstPerson");

// Class LyraGame.TgfCameraMode_Montage
// 0x00A8 (0x03F0 - 0x0348)
class UTgfCameraMode_Montage : public ULyraCameraMode_ThirdPerson
{
public:
	class FName                                   BaseBone;                                          // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               BoneToCameraRotation;                              // 0x0350(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   RotationX_CurveName;                               // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RotationY_CurveName;                               // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RotationZ_CurveName;                               // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationX_CurveName;                               // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationY_CurveName;                               // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationZ_CurveName;                               // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MotionBlendTime;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MotionBlendCurve;                                  // 0x03A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x48];                                     // 0x03A8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraMode_Montage">();
	}
	static class UTgfCameraMode_Montage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraMode_Montage>();
	}
};
static_assert(alignof(UTgfCameraMode_Montage) == 0x000008, "Wrong alignment on UTgfCameraMode_Montage");
static_assert(sizeof(UTgfCameraMode_Montage) == 0x0003F0, "Wrong size on UTgfCameraMode_Montage");
static_assert(offsetof(UTgfCameraMode_Montage, BaseBone) == 0x000348, "Member 'UTgfCameraMode_Montage::BaseBone' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, BoneToCameraRotation) == 0x000350, "Member 'UTgfCameraMode_Montage::BoneToCameraRotation' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, RotationX_CurveName) == 0x000368, "Member 'UTgfCameraMode_Montage::RotationX_CurveName' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, RotationY_CurveName) == 0x000370, "Member 'UTgfCameraMode_Montage::RotationY_CurveName' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, RotationZ_CurveName) == 0x000378, "Member 'UTgfCameraMode_Montage::RotationZ_CurveName' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, LocationX_CurveName) == 0x000380, "Member 'UTgfCameraMode_Montage::LocationX_CurveName' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, LocationY_CurveName) == 0x000388, "Member 'UTgfCameraMode_Montage::LocationY_CurveName' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, LocationZ_CurveName) == 0x000390, "Member 'UTgfCameraMode_Montage::LocationZ_CurveName' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, MotionBlendTime) == 0x000398, "Member 'UTgfCameraMode_Montage::MotionBlendTime' has a wrong offset!");
static_assert(offsetof(UTgfCameraMode_Montage, MotionBlendCurve) == 0x0003A0, "Member 'UTgfCameraMode_Montage::MotionBlendCurve' has a wrong offset!");

// Class LyraGame.LyraDamageLogDebuggerComponent
// 0x0080 (0x0128 - 0x00A8)
class ULyraDamageLogDebuggerComponent final : public UActorComponent
{
public:
	double                                        SecondsBetweenDamageBeforeLogging;                 // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x78];                                      // 0x00B0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDamageLogDebuggerComponent">();
	}
	static class ULyraDamageLogDebuggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraDamageLogDebuggerComponent>();
	}
};
static_assert(alignof(ULyraDamageLogDebuggerComponent) == 0x000008, "Wrong alignment on ULyraDamageLogDebuggerComponent");
static_assert(sizeof(ULyraDamageLogDebuggerComponent) == 0x000128, "Wrong size on ULyraDamageLogDebuggerComponent");
static_assert(offsetof(ULyraDamageLogDebuggerComponent, SecondsBetweenDamageBeforeLogging) == 0x0000A8, "Member 'ULyraDamageLogDebuggerComponent::SecondsBetweenDamageBeforeLogging' has a wrong offset!");

// Class LyraGame.TgfCameraMode_SpectateActor
// 0x0000 (0x03A0 - 0x03A0)
class UTgfCameraMode_SpectateActor final : public UTgfCameraMode_ThirdPersonFree
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraMode_SpectateActor">();
	}
	static class UTgfCameraMode_SpectateActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraMode_SpectateActor>();
	}
};
static_assert(alignof(UTgfCameraMode_SpectateActor) == 0x000008, "Wrong alignment on UTgfCameraMode_SpectateActor");
static_assert(sizeof(UTgfCameraMode_SpectateActor) == 0x0003A0, "Wrong size on UTgfCameraMode_SpectateActor");

// Class LyraGame.TgfCameraPostProcessBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfCameraPostProcessBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FWeightedBlendables DeletePostProcessMaterial(class UCameraComponent* CameraComponent, class UMaterialInterface* Material);
	static struct FWeightedBlendables InsertPostProcessMaterial(class UCameraComponent* CameroComponent, class UMaterialInterface* Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraPostProcessBlueprintLibrary">();
	}
	static class UTgfCameraPostProcessBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraPostProcessBlueprintLibrary>();
	}
};
static_assert(alignof(UTgfCameraPostProcessBlueprintLibrary) == 0x000008, "Wrong alignment on UTgfCameraPostProcessBlueprintLibrary");
static_assert(sizeof(UTgfCameraPostProcessBlueprintLibrary) == 0x000028, "Wrong size on UTgfCameraPostProcessBlueprintLibrary");

// Class LyraGame.TgfCameraShake_Moving
// 0x01B0 (0x02A0 - 0x00F0)
class UTgfCameraShake_Moving : public UCameraShakeBase
{
public:
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ShakeScaleCurve;                                   // 0x0108(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     ShakeAmplitudeScaleCurve;                          // 0x0190(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     ShakeFrequencyScaleCurve;                          // 0x0218(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCameraShake_Moving">();
	}
	static class UTgfCameraShake_Moving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCameraShake_Moving>();
	}
};
static_assert(alignof(UTgfCameraShake_Moving) == 0x000010, "Wrong alignment on UTgfCameraShake_Moving");
static_assert(sizeof(UTgfCameraShake_Moving) == 0x0002A0, "Wrong size on UTgfCameraShake_Moving");
static_assert(offsetof(UTgfCameraShake_Moving, ShakeScaleCurve) == 0x000108, "Member 'UTgfCameraShake_Moving::ShakeScaleCurve' has a wrong offset!");
static_assert(offsetof(UTgfCameraShake_Moving, ShakeAmplitudeScaleCurve) == 0x000190, "Member 'UTgfCameraShake_Moving::ShakeAmplitudeScaleCurve' has a wrong offset!");
static_assert(offsetof(UTgfCameraShake_Moving, ShakeFrequencyScaleCurve) == 0x000218, "Member 'UTgfCameraShake_Moving::ShakeFrequencyScaleCurve' has a wrong offset!");

// Class LyraGame.HitReactAnimConfig
// 0x0060 (0x0090 - 0x0030)
class UHitReactAnimConfig final : public UDataAsset
{
public:
	TArray<struct FAnimTagPair>                   Animations;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EAnimConfigDirection, struct FAnimTagPairSet> DefaultAnimations;                                 // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactAnimConfig">();
	}
	static class UHitReactAnimConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactAnimConfig>();
	}
};
static_assert(alignof(UHitReactAnimConfig) == 0x000008, "Wrong alignment on UHitReactAnimConfig");
static_assert(sizeof(UHitReactAnimConfig) == 0x000090, "Wrong size on UHitReactAnimConfig");
static_assert(offsetof(UHitReactAnimConfig, Animations) == 0x000030, "Member 'UHitReactAnimConfig::Animations' has a wrong offset!");
static_assert(offsetof(UHitReactAnimConfig, DefaultAnimations) == 0x000040, "Member 'UHitReactAnimConfig::DefaultAnimations' has a wrong offset!");

// Class LyraGame.PhysicalAssetConfig
// 0x0060 (0x0090 - 0x0030)
class UPhysicalAssetConfig final : public UDataAsset
{
public:
	TMap<ETgfCharaPart, struct FPhysicsBodyContainer> PartToBodyNames;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsBodyContainer>          BodyNamesToTags;                                   // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalAssetConfig">();
	}
	static class UPhysicalAssetConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalAssetConfig>();
	}
};
static_assert(alignof(UPhysicalAssetConfig) == 0x000008, "Wrong alignment on UPhysicalAssetConfig");
static_assert(sizeof(UPhysicalAssetConfig) == 0x000090, "Wrong size on UPhysicalAssetConfig");
static_assert(offsetof(UPhysicalAssetConfig, PartToBodyNames) == 0x000030, "Member 'UPhysicalAssetConfig::PartToBodyNames' has a wrong offset!");
static_assert(offsetof(UPhysicalAssetConfig, BodyNamesToTags) == 0x000080, "Member 'UPhysicalAssetConfig::BodyNamesToTags' has a wrong offset!");

// Class LyraGame.MonsterBrokenArmHelperActor
// 0x0008 (0x02A0 - 0x0298)
class AMonsterBrokenArmHelperActor final : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BrokenArmL();
	void BrokenArmR();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBrokenArmHelperActor">();
	}
	static class AMonsterBrokenArmHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterBrokenArmHelperActor>();
	}
};
static_assert(alignof(AMonsterBrokenArmHelperActor) == 0x000008, "Wrong alignment on AMonsterBrokenArmHelperActor");
static_assert(sizeof(AMonsterBrokenArmHelperActor) == 0x0002A0, "Wrong size on AMonsterBrokenArmHelperActor");
static_assert(offsetof(AMonsterBrokenArmHelperActor, Mesh) == 0x000298, "Member 'AMonsterBrokenArmHelperActor::Mesh' has a wrong offset!");

// Class LyraGame.TgfReticleWidgetBase
// 0x0018 (0x02D8 - 0x02C0)
class UTgfReticleWidgetBase : public UCommonUserWidget
{
public:
	ETgfEquipSubType                              SecondaryWeaponType;                               // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTgfEquipmentInstance*                  WeaponInstance;                                    // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraInventoryItemInstance*             InventoryInstance;                                 // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeFromWeapon(class UTgfEquipmentInstance* InWeapon);
	void OnWeaponInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfReticleWidgetBase">();
	}
	static class UTgfReticleWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfReticleWidgetBase>();
	}
};
static_assert(alignof(UTgfReticleWidgetBase) == 0x000008, "Wrong alignment on UTgfReticleWidgetBase");
static_assert(sizeof(UTgfReticleWidgetBase) == 0x0002D8, "Wrong size on UTgfReticleWidgetBase");
static_assert(offsetof(UTgfReticleWidgetBase, SecondaryWeaponType) == 0x0002C0, "Member 'UTgfReticleWidgetBase::SecondaryWeaponType' has a wrong offset!");
static_assert(offsetof(UTgfReticleWidgetBase, WeaponInstance) == 0x0002C8, "Member 'UTgfReticleWidgetBase::WeaponInstance' has a wrong offset!");
static_assert(offsetof(UTgfReticleWidgetBase, InventoryInstance) == 0x0002D0, "Member 'UTgfReticleWidgetBase::InventoryInstance' has a wrong offset!");

// Class LyraGame.TgfCharacterAnimationHelperComponent
// 0x0138 (0x01E0 - 0x00A8)
class UTgfCharacterAnimationHelperComponent final : public UPawnComponent
{
public:
	class UHitReactAnimConfig*                    HeavyHitConfig;                                    // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactAnimConfig*                    NormalHitConfig;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeScale;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasCameraShake;                                    // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalAssetConfig*                   PhysicalPartsConfig;                               // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARuneSwordSkillHelperActor> RuneSwordSkillHelperActorClass;                    // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTimeDilationConfig>            TimeDilationConfigList;                            // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TimeDilationDuration;                              // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasTimeDilation;                                   // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimSequenceBase>       ActiveHitMontage;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTgfGameplayTagABPConfig>       ABPConfigs;                                        // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MimicActor;                                        // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARuneSwordSkillHelperActor*             HelperActor;                                       // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x50];                                     // 0x0138(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMimicArg                              MimicArg;                                          // 0x0188(0x0038)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         CrouchTimer;                                       // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMonsterBrokenArmHelperActor> BrokenArmMeshActor;                                // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTgfVisibleCheck                       VisibleCheckConfig;                                // 0x01D0(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTimeDilationConfig(float Duration, float Rate);
	void AttachProjectileSword(TSubclassOf<class AActor> SwordTemplate, const struct FProjectileActorSpawnParams& Params_0, const struct FProjectileInitParams& ProjectileParams);
	void AttachSword(TSubclassOf<class AActor> SwordTemplate, class AActor* SwordIns);
	void CrouchMeshTickEnable(float DelayTime);
	void DestroySword(int32 SwordIndex, bool bHidden);
	void EndMimic(const struct FGameplayTagContainer& TagsToRemove);
	const struct FGameplayTagContainer GetTagFromBoneName(class FName BoneName);
	void HelperActorPlayMontage(class UAnimMontage* Montage);
	void HelperActorStopMontage(class UAnimMontage* Montage, float BlendOutTime);
	void HelperActorStopMontageByGroup(class FName GroupName, float BlendOutTime);
	void InitHelperActor();
	void OnBrokenArm(bool bArmL, bool bAttach);
	void OnGameplayTagChange(const struct FGameplayTag& Tag, int32 NewCount);
	void OnRep_MimicArg(const struct FMimicArg& OldMimicArg);
	void RangedWeaponAction(ERangedWeaponActionType Action, float PlayRate);
	void ReleaseHelperActor();
	void RemoveTimeDilationConfig(float Duration, float Rate);
	void SetTimeDilationTimer();
	class ATgfProjectileBase* SpawnProjectile(TSubclassOf<class AActor> ActorTemplate, const struct FProjectileActorSpawnParams& Params_0, const struct FProjectileInitParams& ProjectileParams);
	void StartHelperActor(ESwordMasterSkillType Skill);
	void StartMimic(TSubclassOf<class AActor> MimicTargetActorTemplate, const struct FGameplayTagContainer& TagsToAdd, bool bIgnoreCollision);
	void TryChangePhysicalMaterial(ETgfCharaPart Part, class UPhysicalMaterial* Material);
	void TryPlayCurEquipmentSingleAnimation(TSubclassOf<class AActor> EquipClass, class UAnimSequenceBase* Sequence, float PlayRate, bool bLooping);
	void UpdateTimeDilationRate();
	void WaitToReleaseActor(float Time);

	const class UAnimSequenceBase* GetHitReactAnimation(const struct FGameplayTagContainer& Tags, class ALyraCharacter* Character, bool bHeavyHit, EAnimConfigDirection HitDirection) const;
	struct FTransform GetSocketTransform(int32 SwordIndex) const;
	struct FTransform GetSocketTransformExtra() const;
	float GetTimeDilationRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterAnimationHelperComponent">();
	}
	static class UTgfCharacterAnimationHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterAnimationHelperComponent>();
	}
};
static_assert(alignof(UTgfCharacterAnimationHelperComponent) == 0x000008, "Wrong alignment on UTgfCharacterAnimationHelperComponent");
static_assert(sizeof(UTgfCharacterAnimationHelperComponent) == 0x0001E0, "Wrong size on UTgfCharacterAnimationHelperComponent");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, HeavyHitConfig) == 0x0000A8, "Member 'UTgfCharacterAnimationHelperComponent::HeavyHitConfig' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, NormalHitConfig) == 0x0000B0, "Member 'UTgfCharacterAnimationHelperComponent::NormalHitConfig' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, CameraShakeClass) == 0x0000B8, "Member 'UTgfCharacterAnimationHelperComponent::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, CameraShakeScale) == 0x0000C0, "Member 'UTgfCharacterAnimationHelperComponent::CameraShakeScale' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, HasCameraShake) == 0x0000C4, "Member 'UTgfCharacterAnimationHelperComponent::HasCameraShake' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, PhysicalPartsConfig) == 0x0000C8, "Member 'UTgfCharacterAnimationHelperComponent::PhysicalPartsConfig' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, RuneSwordSkillHelperActorClass) == 0x0000D0, "Member 'UTgfCharacterAnimationHelperComponent::RuneSwordSkillHelperActorClass' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, TimeDilationConfigList) == 0x0000D8, "Member 'UTgfCharacterAnimationHelperComponent::TimeDilationConfigList' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, TimeDilationDuration) == 0x0000E8, "Member 'UTgfCharacterAnimationHelperComponent::TimeDilationDuration' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, HasTimeDilation) == 0x0000EC, "Member 'UTgfCharacterAnimationHelperComponent::HasTimeDilation' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, ActiveHitMontage) == 0x0000F0, "Member 'UTgfCharacterAnimationHelperComponent::ActiveHitMontage' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, ABPConfigs) == 0x0000F8, "Member 'UTgfCharacterAnimationHelperComponent::ABPConfigs' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, MimicActor) == 0x000128, "Member 'UTgfCharacterAnimationHelperComponent::MimicActor' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, HelperActor) == 0x000130, "Member 'UTgfCharacterAnimationHelperComponent::HelperActor' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, MimicArg) == 0x000188, "Member 'UTgfCharacterAnimationHelperComponent::MimicArg' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, CrouchTimer) == 0x0001C0, "Member 'UTgfCharacterAnimationHelperComponent::CrouchTimer' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, BrokenArmMeshActor) == 0x0001C8, "Member 'UTgfCharacterAnimationHelperComponent::BrokenArmMeshActor' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAnimationHelperComponent, VisibleCheckConfig) == 0x0001D0, "Member 'UTgfCharacterAnimationHelperComponent::VisibleCheckConfig' has a wrong offset!");

// Class LyraGame.TgfCharacterAvatarComponent
// 0x0038 (0x00E0 - 0x00A8)
class UTgfCharacterAvatarComponent final : public UActorComponent
{
public:
	struct FTgfHeadResConfig                      FaceConfig;                                        // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ShowHelmet;                                        // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Avatar();
	void SetFaceConfigServerOnly(const class FString& Part, int32 Param_Index);
	void SetShowHelmet(bool Val);
	void ToggleHelmetVisible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterAvatarComponent">();
	}
	static class UTgfCharacterAvatarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterAvatarComponent>();
	}
};
static_assert(alignof(UTgfCharacterAvatarComponent) == 0x000008, "Wrong alignment on UTgfCharacterAvatarComponent");
static_assert(sizeof(UTgfCharacterAvatarComponent) == 0x0000E0, "Wrong size on UTgfCharacterAvatarComponent");
static_assert(offsetof(UTgfCharacterAvatarComponent, FaceConfig) == 0x0000A8, "Member 'UTgfCharacterAvatarComponent::FaceConfig' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAvatarComponent, ShowHelmet) == 0x0000D8, "Member 'UTgfCharacterAvatarComponent::ShowHelmet' has a wrong offset!");

// Class LyraGame.TgfCharacterAvatarDataAsset
// 0x0178 (0x01A8 - 0x0030)
class UTgfCharacterAvatarDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<struct FTgfRaceAvatarDataPair>         RaceAvatarData;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTgfRaceAvatarBodyModifyData           DefaultRaceData;                                   // 0x0040(0x0168)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterAvatarDataAsset">();
	}
	static class UTgfCharacterAvatarDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterAvatarDataAsset>();
	}
};
static_assert(alignof(UTgfCharacterAvatarDataAsset) == 0x000008, "Wrong alignment on UTgfCharacterAvatarDataAsset");
static_assert(sizeof(UTgfCharacterAvatarDataAsset) == 0x0001A8, "Wrong size on UTgfCharacterAvatarDataAsset");
static_assert(offsetof(UTgfCharacterAvatarDataAsset, RaceAvatarData) == 0x000030, "Member 'UTgfCharacterAvatarDataAsset::RaceAvatarData' has a wrong offset!");
static_assert(offsetof(UTgfCharacterAvatarDataAsset, DefaultRaceData) == 0x000040, "Member 'UTgfCharacterAvatarDataAsset::DefaultRaceData' has a wrong offset!");

// Class LyraGame.TgfCharacterMovementExtensionComponent
// 0x0030 (0x00D8 - 0x00A8)
class UTgfCharacterMovementExtensionComponent final : public UPawnComponent
{
public:
	class ACharacter*                             CharacterOwner;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveActorBlockedCheckDist;                         // 0x00B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnorePawnCollision : 1;                          // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_B4_1 : 7;                                   // 0x00B4(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_B5[0xB];                                       // 0x00B5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsPantherState : 1;                               // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfMovementMonitorConfig>      MovementMonitorConfigList;                         // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UTgfCharacterMovementExtensionComponent* FindCharacterMovementExtensionComponent(const class AActor* Actor);

	bool AddMovementMonitor(const struct FTgfMovementMonitorConfig& NewMonitorConfig, bool CheckUnique);
	void ClientEndFloating();
	void ClientStartFloating();
	void EndFloating();
	void ForceResetMovementMonitor(const struct FGameplayTag& MovementMonitorTag, bool bNeedResetTriggerTime);
	void ForceTriggerMovementMonitor(const struct FGameplayTag& MovementMonitorTag);
	void MoveActorBlockedOnLocal(const struct FVector& ClientPos, const class AActor* BlockedActor);
	void OnRep_IgnorePawnCollision();
	void OnRep_IsPantherState();
	void OnSelectedSnapTargetLocal(const class AActor* TargetActor);
	void OnSelectedSnapTargetServer(const class AActor* TargetActor);
	void RemoveMovementMonitor(const struct FGameplayTag& MovementMonitorTag);
	bool ServerCheckSnapTargetValid(class AActor* TargetActor, const struct FTgfSnapQueryConfig& SnapQueryConfig);
	void SetIgnorePawnCollision(bool bEnabled);
	void StartFloating();
	void TransToNormal();
	void TransToPanther();
	class AActor* TryGetSnapTargetLocal(const struct FTgfSnapQueryConfig& SnapQueryConfig);
	bool TryingTeleportToFitPos();

	class ACharacter* GetCharacterOwner() const;
	bool GetIsPantherState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterMovementExtensionComponent">();
	}
	static class UTgfCharacterMovementExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterMovementExtensionComponent>();
	}
};
static_assert(alignof(UTgfCharacterMovementExtensionComponent) == 0x000008, "Wrong alignment on UTgfCharacterMovementExtensionComponent");
static_assert(sizeof(UTgfCharacterMovementExtensionComponent) == 0x0000D8, "Wrong size on UTgfCharacterMovementExtensionComponent");
static_assert(offsetof(UTgfCharacterMovementExtensionComponent, CharacterOwner) == 0x0000A8, "Member 'UTgfCharacterMovementExtensionComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMovementExtensionComponent, MoveActorBlockedCheckDist) == 0x0000B0, "Member 'UTgfCharacterMovementExtensionComponent::MoveActorBlockedCheckDist' has a wrong offset!");
static_assert(offsetof(UTgfCharacterMovementExtensionComponent, MovementMonitorConfigList) == 0x0000C8, "Member 'UTgfCharacterMovementExtensionComponent::MovementMonitorConfigList' has a wrong offset!");

// Class LyraGame.TgfCharacterSummonComponent
// 0x0050 (0x00F8 - 0x00A8)
class UTgfCharacterSummonComponent final : public UPawnComponent
{
public:
	TWeakObjectPtr<class AActor>                  SummonSource;                                      // 0x00A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          SummonActorList;                                   // 0x00B0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x1];                                       // 0x00C0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDestroySummonsWhenDied;                           // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SummonDestroyDelayTime;                            // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroySummonsWhenLoseTarget;                     // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceWeaponAttack;                                // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToSummonActorList(class AActor* SummonActor);
	void ApplyEffectToSummonActor(const class AActor* SummonActor, const TArray<TSubclassOf<class UGameplayEffect>>& GEs);
	void ApplyEffectToSummonActors(const TArray<TSubclassOf<class UGameplayEffect>>& GEs);
	void DestroyAllSummonActors();
	void DestroyAllSummonActorsWithDelay(float DelayTime);
	void DestroySummonActorsWhenLoseTarget();
	void OnRep_SummonSource();
	void RemoveFromSummonActorList(class AActor* SummonActor);
	void SetDestroySummonsWhenDied(bool Destroy, float DelayTime);
	void SetSummonSource(class AActor* Source);
	void UpdateSummonActorList();

	TArray<class AActor*> GetSummonActors(bool Recursively) const;
	int32 GetSummonActorsCount() const;
	class AActor* GetSummonSource(bool Recursively) const;
	bool IsSummonSource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharacterSummonComponent">();
	}
	static class UTgfCharacterSummonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCharacterSummonComponent>();
	}
};
static_assert(alignof(UTgfCharacterSummonComponent) == 0x000008, "Wrong alignment on UTgfCharacterSummonComponent");
static_assert(sizeof(UTgfCharacterSummonComponent) == 0x0000F8, "Wrong size on UTgfCharacterSummonComponent");
static_assert(offsetof(UTgfCharacterSummonComponent, SummonSource) == 0x0000A8, "Member 'UTgfCharacterSummonComponent::SummonSource' has a wrong offset!");
static_assert(offsetof(UTgfCharacterSummonComponent, SummonActorList) == 0x0000B0, "Member 'UTgfCharacterSummonComponent::SummonActorList' has a wrong offset!");
static_assert(offsetof(UTgfCharacterSummonComponent, bDestroySummonsWhenDied) == 0x0000C1, "Member 'UTgfCharacterSummonComponent::bDestroySummonsWhenDied' has a wrong offset!");
static_assert(offsetof(UTgfCharacterSummonComponent, SummonDestroyDelayTime) == 0x0000C4, "Member 'UTgfCharacterSummonComponent::SummonDestroyDelayTime' has a wrong offset!");
static_assert(offsetof(UTgfCharacterSummonComponent, bDestroySummonsWhenLoseTarget) == 0x0000C8, "Member 'UTgfCharacterSummonComponent::bDestroySummonsWhenLoseTarget' has a wrong offset!");
static_assert(offsetof(UTgfCharacterSummonComponent, SourceWeaponAttack) == 0x0000CC, "Member 'UTgfCharacterSummonComponent::SourceWeaponAttack' has a wrong offset!");

// Class LyraGame.LyraWeaponStateComponent
// 0x0028 (0x00D0 - 0x00A8)
class ULyraWeaponStateComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientConfirmTargetData(uint16 UniqueId, bool bSuccess, const TArray<uint8>& HitReplaces);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponStateComponent">();
	}
	static class ULyraWeaponStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWeaponStateComponent>();
	}
};
static_assert(alignof(ULyraWeaponStateComponent) == 0x000008, "Wrong alignment on ULyraWeaponStateComponent");
static_assert(sizeof(ULyraWeaponStateComponent) == 0x0000D0, "Wrong size on ULyraWeaponStateComponent");

// Class LyraGame.TgfCharaMovementShadow
// 0x0008 (0x02A0 - 0x0298)
class ATgfCharaMovementShadow final : public AActor
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCharaMovementShadow">();
	}
	static class ATgfCharaMovementShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfCharaMovementShadow>();
	}
};
static_assert(alignof(ATgfCharaMovementShadow) == 0x000008, "Wrong alignment on ATgfCharaMovementShadow");
static_assert(sizeof(ATgfCharaMovementShadow) == 0x0002A0, "Wrong size on ATgfCharaMovementShadow");
static_assert(offsetof(ATgfCharaMovementShadow, CapsuleComponent) == 0x000298, "Member 'ATgfCharaMovementShadow::CapsuleComponent' has a wrong offset!");

// Class LyraGame.TgfCollectableLightComponent
// 0x0070 (0x0310 - 0x02A0)
class UTgfCollectableLightComponent final : public USceneComponent
{
public:
	bool                                          CanBeCollected;                                    // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x02A8(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         CollectableDistance;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectableAngle;                                  // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BufferZoneWidth;                                   // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereCollisionRadius;                             // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightEffect;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LightEffectComponent;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereCollision;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Collectable;                                       // 0x0300(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0xF];                                      // 0x0301(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetCollectable();
	void OnRep_Collectable();
	void SetCollectable(bool bCollectable);
	void SetupLightEffectComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCollectableLightComponent">();
	}
	static class UTgfCollectableLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCollectableLightComponent>();
	}
};
static_assert(alignof(UTgfCollectableLightComponent) == 0x000010, "Wrong alignment on UTgfCollectableLightComponent");
static_assert(sizeof(UTgfCollectableLightComponent) == 0x000310, "Wrong size on UTgfCollectableLightComponent");
static_assert(offsetof(UTgfCollectableLightComponent, CanBeCollected) == 0x0002A0, "Member 'UTgfCollectableLightComponent::CanBeCollected' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, RequiredTags) == 0x0002A8, "Member 'UTgfCollectableLightComponent::RequiredTags' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, CollectableDistance) == 0x0002C8, "Member 'UTgfCollectableLightComponent::CollectableDistance' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, CollectableAngle) == 0x0002CC, "Member 'UTgfCollectableLightComponent::CollectableAngle' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, BufferZoneWidth) == 0x0002D0, "Member 'UTgfCollectableLightComponent::BufferZoneWidth' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, SphereCollisionRadius) == 0x0002D4, "Member 'UTgfCollectableLightComponent::SphereCollisionRadius' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, LightEffect) == 0x0002D8, "Member 'UTgfCollectableLightComponent::LightEffect' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, LightEffectComponent) == 0x0002E0, "Member 'UTgfCollectableLightComponent::LightEffectComponent' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, SphereCollision) == 0x0002E8, "Member 'UTgfCollectableLightComponent::SphereCollision' has a wrong offset!");
static_assert(offsetof(UTgfCollectableLightComponent, Collectable) == 0x000300, "Member 'UTgfCollectableLightComponent::Collectable' has a wrong offset!");

// Class LyraGame.AsyncAction_FinishCameraBlend
// 0x0030 (0x0060 - 0x0030)
class UAsyncAction_FinishCameraBlend final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_FinishCameraBlend* FinishCameraBlend(class UObject* WorldContextObject, float LeadTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_FinishCameraBlend">();
	}
	static class UAsyncAction_FinishCameraBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_FinishCameraBlend>();
	}
};
static_assert(alignof(UAsyncAction_FinishCameraBlend) == 0x000008, "Wrong alignment on UAsyncAction_FinishCameraBlend");
static_assert(sizeof(UAsyncAction_FinishCameraBlend) == 0x000060, "Wrong size on UAsyncAction_FinishCameraBlend");
static_assert(offsetof(UAsyncAction_FinishCameraBlend, OnFinish) == 0x000030, "Member 'UAsyncAction_FinishCameraBlend::OnFinish' has a wrong offset!");

// Class LyraGame.TgfControllerSteamAchievementComponent
// 0x00C8 (0x0170 - 0x00A8)
class UTgfControllerSteamAchievementComponent final : public UControllerComponent
{
public:
	TArray<struct FGameplayMessageListenerHandle> ArrMessageHandle;                                  // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class APlayerState*                           OwnPlayerState;                                    // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALyraCharacter*                         OwnPlayerCharacter;                                // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALyraPlayerController*                  OwnPlayerController;                               // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int64, bool>                             MapRebirthSelfTeammateRoleID;                      // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int64, int32>                            MapOtherMemKillTeammateCnt;                        // 0x0120(0x0050)(NativeAccessSpecifierPrivate)

public:
	void OnOtherResurrect(class ALyraCharacter* Instigator);
	void OnPlayerKillEvent(const struct FGameplayTag& Channel, const struct FLyraVerbMessage& InMessage);
	void OnRebirthOtherMember(class AActor* RevivedTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfControllerSteamAchievementComponent">();
	}
	static class UTgfControllerSteamAchievementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfControllerSteamAchievementComponent>();
	}
};
static_assert(alignof(UTgfControllerSteamAchievementComponent) == 0x000008, "Wrong alignment on UTgfControllerSteamAchievementComponent");
static_assert(sizeof(UTgfControllerSteamAchievementComponent) == 0x000170, "Wrong size on UTgfControllerSteamAchievementComponent");
static_assert(offsetof(UTgfControllerSteamAchievementComponent, ArrMessageHandle) == 0x0000A8, "Member 'UTgfControllerSteamAchievementComponent::ArrMessageHandle' has a wrong offset!");
static_assert(offsetof(UTgfControllerSteamAchievementComponent, OwnPlayerState) == 0x0000B8, "Member 'UTgfControllerSteamAchievementComponent::OwnPlayerState' has a wrong offset!");
static_assert(offsetof(UTgfControllerSteamAchievementComponent, OwnPlayerCharacter) == 0x0000C0, "Member 'UTgfControllerSteamAchievementComponent::OwnPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UTgfControllerSteamAchievementComponent, OwnPlayerController) == 0x0000C8, "Member 'UTgfControllerSteamAchievementComponent::OwnPlayerController' has a wrong offset!");
static_assert(offsetof(UTgfControllerSteamAchievementComponent, MapRebirthSelfTeammateRoleID) == 0x0000D0, "Member 'UTgfControllerSteamAchievementComponent::MapRebirthSelfTeammateRoleID' has a wrong offset!");
static_assert(offsetof(UTgfControllerSteamAchievementComponent, MapOtherMemKillTeammateCnt) == 0x000120, "Member 'UTgfControllerSteamAchievementComponent::MapOtherMemKillTeammateCnt' has a wrong offset!");

// Class LyraGame.TgfEnterNpcStateAsyncAction
// 0x0030 (0x0060 - 0x0030)
class UTgfEnterNpcStateAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnEnter;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLeave;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfEnterNpcStateAsyncAction* WaitForGlobalNpcState(const class UObject* WorldContext, TSubclassOf<class UTgfNpcState> NpcState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEnterNpcStateAsyncAction">();
	}
	static class UTgfEnterNpcStateAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEnterNpcStateAsyncAction>();
	}
};
static_assert(alignof(UTgfEnterNpcStateAsyncAction) == 0x000008, "Wrong alignment on UTgfEnterNpcStateAsyncAction");
static_assert(sizeof(UTgfEnterNpcStateAsyncAction) == 0x000060, "Wrong size on UTgfEnterNpcStateAsyncAction");
static_assert(offsetof(UTgfEnterNpcStateAsyncAction, OnEnter) == 0x000030, "Member 'UTgfEnterNpcStateAsyncAction::OnEnter' has a wrong offset!");
static_assert(offsetof(UTgfEnterNpcStateAsyncAction, OnLeave) == 0x000040, "Member 'UTgfEnterNpcStateAsyncAction::OnLeave' has a wrong offset!");

// Class LyraGame.TgfEnvSurfaceTypeDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTgfEnvSurfaceTypeDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<EPhysicalSurface>                      AllowedSurfaceTypes;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEnvSurfaceTypeDataAsset">();
	}
	static class UTgfEnvSurfaceTypeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEnvSurfaceTypeDataAsset>();
	}
};
static_assert(alignof(UTgfEnvSurfaceTypeDataAsset) == 0x000008, "Wrong alignment on UTgfEnvSurfaceTypeDataAsset");
static_assert(sizeof(UTgfEnvSurfaceTypeDataAsset) == 0x000040, "Wrong size on UTgfEnvSurfaceTypeDataAsset");
static_assert(offsetof(UTgfEnvSurfaceTypeDataAsset, AllowedSurfaceTypes) == 0x000030, "Member 'UTgfEnvSurfaceTypeDataAsset::AllowedSurfaceTypes' has a wrong offset!");

// Class LyraGame.TgfEquipmentDataAsset
// 0x0020 (0x0050 - 0x0030)
class UTgfEquipmentDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<struct FTgfWeaponConfig>               WeaponConfigs;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfEquipmentConfig>            EquipmentConfigs;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentDataAsset">();
	}
	static class UTgfEquipmentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentDataAsset>();
	}
};
static_assert(alignof(UTgfEquipmentDataAsset) == 0x000008, "Wrong alignment on UTgfEquipmentDataAsset");
static_assert(sizeof(UTgfEquipmentDataAsset) == 0x000050, "Wrong size on UTgfEquipmentDataAsset");
static_assert(offsetof(UTgfEquipmentDataAsset, WeaponConfigs) == 0x000030, "Member 'UTgfEquipmentDataAsset::WeaponConfigs' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentDataAsset, EquipmentConfigs) == 0x000040, "Member 'UTgfEquipmentDataAsset::EquipmentConfigs' has a wrong offset!");

// Class LyraGame.LyraEquipmentManagerComponent
// 0x0130 (0x01D8 - 0x00A8)
class ULyraEquipmentManagerComponent : public UGameFrameworkComponent
{
public:
	struct FLyraEquipmentList                     EquipmentList;                                     // 0x00A8(0x0130)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class ULyraEquipmentInstance* StaticCreateInstance(class AActor* Owner, class ULyraInventoryItemInstance* ItemInstance, TSubclassOf<class ULyraEquipmentInstance> InstanceType);

	void ClearAllEquipment();
	void EquipItemByDefinition(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot);
	void EquipItemByInstance(class ULyraEquipmentInstance* Instance, ETgfEquipSlot Slot);
	class ULyraEquipmentInstance* GetFirstInstanceOfType(TSubclassOf<class ULyraEquipmentInstance> InstanceType);
	void OnRep_EquipmentList();
	void UnequipItemByDefinition(TSubclassOf<class ULyraEquipmentDefinition> EquipClass);
	void UnequipItemByInstance(class ULyraEquipmentInstance* Instance);
	void UnequipItemByItem(class ULyraInventoryItemInstance* ItemInstance);
	void UnequipItemByItemAuth(class ULyraInventoryItemInstance* ItemInstance);
	void UpdateEquipInstance(class ULyraEquipmentInstance* EquipInstance);
	void UpdateItemInstance(class ULyraInventoryItemInstance* ItemInstance);

	bool CanUnequipItemInstance(class ULyraEquipmentInstance* Instance, bool IsExchange) const;
	bool CanUnequipItemInventory(class ULyraInventoryItemInstance* Instance, bool IsExchange) const;
	class ULyraEquipmentInstance* CreateInstance(class ULyraInventoryItemInstance* ItemInstance) const;
	class ULyraEquipmentInstance* FindFirstItemByDefinition(TSubclassOf<class ULyraEquipmentDefinition> EquipDef) const;
	const TArray<struct FLyraAppliedEquipmentEntry> GetAllEntries() const;
	TArray<class ULyraEquipmentInstance*> GetAllEquips() const;
	int32 GetEntryIndexByEquipInstance(class ULyraEquipmentInstance* EquipInstance) const;
	int32 GetEntryIndexByItemInstance(class ULyraInventoryItemInstance* ItemInstance) const;
	class ULyraEquipmentInstance* GetEquipInstance(int32 Param_Index) const;
	class ULyraEquipmentInstance* GetEquipmentInstanceByItemInstance(class ULyraInventoryItemInstance* ItemInstance) const;
	TArray<class ULyraEquipmentInstance*> GetEquipmentInstancesOfType(TSubclassOf<class ULyraEquipmentInstance> InstanceType) const;
	ETgfEquipSlot GetSlotOfEquipment(const class ULyraEquipmentInstance* Equipment) const;
	bool IsEquipSlotEmpty(ETgfEquipSlot Slot) const;
	bool MatchSlotConfig(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot SlotType, ETgfEquipSubType WeaponType, bool bIgnoreDead) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraEquipmentManagerComponent">();
	}
	static class ULyraEquipmentManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraEquipmentManagerComponent>();
	}
};
static_assert(alignof(ULyraEquipmentManagerComponent) == 0x000008, "Wrong alignment on ULyraEquipmentManagerComponent");
static_assert(sizeof(ULyraEquipmentManagerComponent) == 0x0001D8, "Wrong size on ULyraEquipmentManagerComponent");
static_assert(offsetof(ULyraEquipmentManagerComponent, EquipmentList) == 0x0000A8, "Member 'ULyraEquipmentManagerComponent::EquipmentList' has a wrong offset!");

// Class LyraGame.TgfEquipmentManagerComponent
// 0x0188 (0x0360 - 0x01D8)
class UTgfEquipmentManagerComponent final : public ULyraEquipmentManagerComponent
{
public:
	ETgfWeaponChangeSlot                          CurrentWeaponSlot;                                 // 0x01D8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfWeaponChangeSlot                          AnimWeaponSlot;                                    // 0x01D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfWeaponChangeSlot                          LastWeaponSlot;                                    // 0x01DA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DB[0x5];                                      // 0x01DB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTgfWeaponSlot                         WeaponSlotList[0x7];                               // 0x01E0(0x0018)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ETgfEquipSlot                                 ActiveAdditionalSlot;                              // 0x0288(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETgfEquipQuality>                      AutoFillWeaponQuality;                             // 0x0290(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<ETgfEquipSlot>                         BlockingLootSlots;                                 // 0x02A0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<ETgfEquipSlot, int32>                    SlotIndexMap;                                      // 0x02B0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            GearsetIndexMap;                                   // 0x0300(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         RightWeaponHiddenCount;                            // 0x0350(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LeftWeaponHiddenCount;                             // 0x0354(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBlockingLootSlot(ETgfEquipSlot Slot);
	ETgfWeaponChangeSlot AddDefaultWeapon(class ULyraInventoryItemInstance* ItemInstance, class ULyraInventoryItemInstance** OutDropInstance);
	void AddDeltaGearsetLevel(int32 GearsetId, int32 DeltaLevel);
	void ChangeWeaponAnim(ETgfWeaponChangeSlot Slot, TSubclassOf<class UTgfWeaponAnimDefinition> AnimClass, class UTgfWeaponAnimInstance* OldAnimInstance);
	void CheckAllEquipmentsVaild(TArray<class ULyraInventoryItemInstance*>* OutDropInstances);
	void CheckStackZeroUnequip(ETgfWeaponChangeSlot Slot, bool bAttemptToRefill);
	bool CheckWeaponAnim(class UTgfWeaponAnimInstance* OldAnimInstance);
	void ClearAllGearsetLevel();
	void ClearBlockingLootSlot();
	void ConsumeItemByWeaponSlot(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 Nums, ETgfWeaponChangeSlot Slot, bool IgnoreSwitch);
	void DealLoosePointOnPlayerDeath();
	void ExchangeEquipsWithSlots(ETgfEquipSlot Slot1, ETgfEquipSlot Slot2);
	void ExchangeEquipToInventory(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot, bool CheckInInventory);
	void ExchangeEquipToInventoryFromLoot(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot, class UTgfEquipmentManagerComponent* SourceEquipment, class UTgfInventoryManagerComponent* SourceInventory, ETgfEquipSlot SourceSlot, int32 PosX, int32 PosY);
	void ExchangeWeaponSet(ETgfEquipSlot Set1RightSlot, ETgfEquipSlot Set1LeftSlot, ETgfEquipSlot Set2RightSlot, ETgfEquipSlot Set2LeftSlot);
	TArray<class UTgfEquipmentInstance*> GetAllEquipments(bool bIgnoreAdditional);
	TArray<ETgfEquipQuality> GetAutoFillWeaponQuility();
	bool HasZeroDurabilityEquip();
	void OnRep_CurrentWeaponSlot(ETgfWeaponChangeSlot OldWeaponSlot);
	void OnRep_WeaponSlotList();
	void RemoveEquipByItemInstance(class ULyraInventoryItemInstance* ItemInstance);
	void RemoveEquipBySlot(ETgfEquipSlot Slot);
	void RemoveEquipToInventory(ETgfEquipSlot Slot);
	void SetActiveAdditionalSlot(ETgfEquipSlot Slot);
	void SetAutoFillWeaponQuality(const TArray<ETgfEquipQuality>& QualityList);
	void SetEquipmentVisible(bool bVisible, bool AllowInClient, bool bForceAll, ETgfWeaponHandType RestrictWeapon);
	void SwitchWeaponSlot(ETgfWeaponChangeSlot Slot, bool NeedForce);

	bool CanConsumeItemByWeaponSlot(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 Nums, ETgfWeaponChangeSlot Slot) const;
	bool CanExchangeEquipsWithSlots(ETgfEquipSlot Slot1, ETgfEquipSlot Slot2) const;
	bool CanExchangeEquipToInventory(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot, bool CheckInInventory) const;
	bool CanLootUseEquip(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot) const;
	bool CanRemoveEquipToInventory(ETgfEquipSlot Slot) const;
	ETgfEquipSlot GetActiveAdditionalSlot() const;
	void GetAnimWeaponInstances(class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const;
	struct FTgfWeaponSlot GetAnimWeaponSlot() const;
	ETgfWeaponChangeSlot GetChangeSlotByEquipmentInstance(class ULyraEquipmentInstance* WeaponInstance) const;
	ETgfWeaponChangeSlot GetChangeSlotByInventoryInstance(class ULyraInventoryItemInstance* ItemInstance) const;
	class UTgfWeaponAnimInstance* GetCurrentWeaponAnimInstance() const;
	void GetCurrentWeaponInstances(class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const;
	struct FTgfWeaponSlot GetCurrentWeaponSlot() const;
	class ULyraEquipmentInstance* GetEquipBySlot(ETgfEquipSlot Slot, int32 IgnoreIndex) const;
	int32 GetGearsetLevel(int32 GearsetId) const;
	void GetLastWeaponInstances(class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const;
	void GetSlotWeaponInstances(ETgfWeaponChangeSlot Slot, class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const;
	ETgfBattleElement GetWeaponElement(ETgfUseAttackType AttackType) const;
	class UAnimMontage* GetWeaponInspectMontage(const struct FGameplayTagContainer& CosmeticTags) const;
	class ULyraEquipmentInstance* GetWeaponInstanceByAnother(class ULyraEquipmentInstance* WeaponInstance) const;
	bool IsBothWeaponHidden() const;
	bool IsLeftWeaponHidden() const;
	bool IsLootSlotBlocking(ETgfEquipSlot Slot) const;
	bool IsRightWeaponHidden() const;
	bool IsWeaponSlotEmpty(ETgfWeaponChangeSlot Slot) const;
	bool MatchAdditionalSlot(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot* OutSlot, bool bUseConfig) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentManagerComponent">();
	}
	static class UTgfEquipmentManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentManagerComponent>();
	}
};
static_assert(alignof(UTgfEquipmentManagerComponent) == 0x000008, "Wrong alignment on UTgfEquipmentManagerComponent");
static_assert(sizeof(UTgfEquipmentManagerComponent) == 0x000360, "Wrong size on UTgfEquipmentManagerComponent");
static_assert(offsetof(UTgfEquipmentManagerComponent, CurrentWeaponSlot) == 0x0001D8, "Member 'UTgfEquipmentManagerComponent::CurrentWeaponSlot' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, AnimWeaponSlot) == 0x0001D9, "Member 'UTgfEquipmentManagerComponent::AnimWeaponSlot' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, LastWeaponSlot) == 0x0001DA, "Member 'UTgfEquipmentManagerComponent::LastWeaponSlot' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, WeaponSlotList) == 0x0001E0, "Member 'UTgfEquipmentManagerComponent::WeaponSlotList' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, ActiveAdditionalSlot) == 0x000288, "Member 'UTgfEquipmentManagerComponent::ActiveAdditionalSlot' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, AutoFillWeaponQuality) == 0x000290, "Member 'UTgfEquipmentManagerComponent::AutoFillWeaponQuality' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, BlockingLootSlots) == 0x0002A0, "Member 'UTgfEquipmentManagerComponent::BlockingLootSlots' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, SlotIndexMap) == 0x0002B0, "Member 'UTgfEquipmentManagerComponent::SlotIndexMap' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, GearsetIndexMap) == 0x000300, "Member 'UTgfEquipmentManagerComponent::GearsetIndexMap' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, RightWeaponHiddenCount) == 0x000350, "Member 'UTgfEquipmentManagerComponent::RightWeaponHiddenCount' has a wrong offset!");
static_assert(offsetof(UTgfEquipmentManagerComponent, LeftWeaponHiddenCount) == 0x000354, "Member 'UTgfEquipmentManagerComponent::LeftWeaponHiddenCount' has a wrong offset!");

// Class LyraGame.TgfGameFollowUIItem
// 0x0028 (0x02A0 - 0x0278)
class UTgfGameFollowUIItem final : public UUserWidget
{
public:
	int32                                         OffsetCnt;                                         // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x1C];                                     // 0x027C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UTgfGameFollowUIManagerComponent*       OwningManager;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DestoryItem();
	void OnStartByMessage(const struct FHurtNotifyMessage& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameFollowUIItem">();
	}
	static class UTgfGameFollowUIItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameFollowUIItem>();
	}
};
static_assert(alignof(UTgfGameFollowUIItem) == 0x000008, "Wrong alignment on UTgfGameFollowUIItem");
static_assert(sizeof(UTgfGameFollowUIItem) == 0x0002A0, "Wrong size on UTgfGameFollowUIItem");
static_assert(offsetof(UTgfGameFollowUIItem, OffsetCnt) == 0x000278, "Member 'UTgfGameFollowUIItem::OffsetCnt' has a wrong offset!");
static_assert(offsetof(UTgfGameFollowUIItem, OwningManager) == 0x000298, "Member 'UTgfGameFollowUIItem::OwningManager' has a wrong offset!");

// Class LyraGame.TgfGameFollowUIManagerComponent
// 0x00D0 (0x0178 - 0x00A8)
class UTgfGameFollowUIManagerComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTgfGameFollowUIItem>       FollowUIItemClass;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ETgfMatchType>                         ShowHurtNumTypeList;                               // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x58];                                      // 0x00D0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UTgfGameFollowUIItem*>      FollowUIContainer;                                 // 0x0128(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	class UTgfGameFollowUIItem* CreateFollowUIItem(const struct FVector& InWorldPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameFollowUIManagerComponent">();
	}
	static class UTgfGameFollowUIManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameFollowUIManagerComponent>();
	}
};
static_assert(alignof(UTgfGameFollowUIManagerComponent) == 0x000008, "Wrong alignment on UTgfGameFollowUIManagerComponent");
static_assert(sizeof(UTgfGameFollowUIManagerComponent) == 0x000178, "Wrong size on UTgfGameFollowUIManagerComponent");
static_assert(offsetof(UTgfGameFollowUIManagerComponent, FollowUIItemClass) == 0x0000B8, "Member 'UTgfGameFollowUIManagerComponent::FollowUIItemClass' has a wrong offset!");
static_assert(offsetof(UTgfGameFollowUIManagerComponent, ShowHurtNumTypeList) == 0x0000C0, "Member 'UTgfGameFollowUIManagerComponent::ShowHurtNumTypeList' has a wrong offset!");
static_assert(offsetof(UTgfGameFollowUIManagerComponent, FollowUIContainer) == 0x000128, "Member 'UTgfGameFollowUIManagerComponent::FollowUIContainer' has a wrong offset!");

// Class LyraGame.TgfGameplayAbility_DebugTargetToSnap
// 0x0018 (0x06A0 - 0x0688)
class UTgfGameplayAbility_DebugTargetToSnap final : public ULyraGameplayAbility
{
public:
	bool                                          bShowDebug;                                        // 0x0688(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_689[0x3];                                      // 0x0689(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugScanRate;                                     // 0x068C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetScanRange;                                   // 0x0690(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScanFieldOfView;                                   // 0x0694(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScanVerticalFieldOfView;                           // 0x0698(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             TargetChannel;                                     // 0x069C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69D[0x3];                                      // 0x069D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility_DebugTargetToSnap">();
	}
	static class UTgfGameplayAbility_DebugTargetToSnap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility_DebugTargetToSnap>();
	}
};
static_assert(alignof(UTgfGameplayAbility_DebugTargetToSnap) == 0x000008, "Wrong alignment on UTgfGameplayAbility_DebugTargetToSnap");
static_assert(sizeof(UTgfGameplayAbility_DebugTargetToSnap) == 0x0006A0, "Wrong size on UTgfGameplayAbility_DebugTargetToSnap");
static_assert(offsetof(UTgfGameplayAbility_DebugTargetToSnap, bShowDebug) == 0x000688, "Member 'UTgfGameplayAbility_DebugTargetToSnap::bShowDebug' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_DebugTargetToSnap, DebugScanRate) == 0x00068C, "Member 'UTgfGameplayAbility_DebugTargetToSnap::DebugScanRate' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_DebugTargetToSnap, TargetScanRange) == 0x000690, "Member 'UTgfGameplayAbility_DebugTargetToSnap::TargetScanRange' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_DebugTargetToSnap, ScanFieldOfView) == 0x000694, "Member 'UTgfGameplayAbility_DebugTargetToSnap::ScanFieldOfView' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_DebugTargetToSnap, ScanVerticalFieldOfView) == 0x000698, "Member 'UTgfGameplayAbility_DebugTargetToSnap::ScanVerticalFieldOfView' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_DebugTargetToSnap, TargetChannel) == 0x00069C, "Member 'UTgfGameplayAbility_DebugTargetToSnap::TargetChannel' has a wrong offset!");

// Class LyraGame.TgfGameplayAbility_Rebirth
// 0x0008 (0x0690 - 0x0688)
class UTgfGameplayAbility_Rebirth : public ULyraGameplayAbility
{
public:
	bool                                          InRebirthing;                                      // 0x0688(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_689[0x7];                                      // 0x0689(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelRebirth();
	void CheckEquipmentsVaild(TArray<class ULyraInventoryItemInstance*>* DropItems);
	ETgfWeaponChangeSlot CheckWeaponSlot(class UTgfInventoryItemInstance** Param_DropItem);
	void DropItem(class UTgfInventoryItemInstance* Item);
	void FinishRebirth();
	void StartRebirth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility_Rebirth">();
	}
	static class UTgfGameplayAbility_Rebirth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility_Rebirth>();
	}
};
static_assert(alignof(UTgfGameplayAbility_Rebirth) == 0x000008, "Wrong alignment on UTgfGameplayAbility_Rebirth");
static_assert(sizeof(UTgfGameplayAbility_Rebirth) == 0x000690, "Wrong size on UTgfGameplayAbility_Rebirth");
static_assert(offsetof(UTgfGameplayAbility_Rebirth, InRebirthing) == 0x000688, "Member 'UTgfGameplayAbility_Rebirth::InRebirthing' has a wrong offset!");

// Class LyraGame.TgfGameplayAbility_SnapToTarget
// 0x0030 (0x06B8 - 0x0688)
class UTgfGameplayAbility_SnapToTarget : public ULyraGameplayAbility
{
public:
	float                                         TargetScanRange;                                   // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanFieldOfView;                                   // 0x068C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanVerticalFieldOfViewUp;                         // 0x0690(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanVerticalFieldOfViewDown;                       // 0x0694(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TargetChannel;                                     // 0x0698(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_699[0x3];                                      // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SafeSpace;                                         // 0x069C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToMove;                                        // 0x06A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveFlags;                                         // 0x06A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TransformSnapLerpCurve;                            // 0x06A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           LocationSnapLerpCurve;                             // 0x06B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnTargetLocationReached();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility_SnapToTarget">();
	}
	static class UTgfGameplayAbility_SnapToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility_SnapToTarget>();
	}
};
static_assert(alignof(UTgfGameplayAbility_SnapToTarget) == 0x000008, "Wrong alignment on UTgfGameplayAbility_SnapToTarget");
static_assert(sizeof(UTgfGameplayAbility_SnapToTarget) == 0x0006B8, "Wrong size on UTgfGameplayAbility_SnapToTarget");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, TargetScanRange) == 0x000688, "Member 'UTgfGameplayAbility_SnapToTarget::TargetScanRange' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, ScanFieldOfView) == 0x00068C, "Member 'UTgfGameplayAbility_SnapToTarget::ScanFieldOfView' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, ScanVerticalFieldOfViewUp) == 0x000690, "Member 'UTgfGameplayAbility_SnapToTarget::ScanVerticalFieldOfViewUp' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, ScanVerticalFieldOfViewDown) == 0x000694, "Member 'UTgfGameplayAbility_SnapToTarget::ScanVerticalFieldOfViewDown' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, TargetChannel) == 0x000698, "Member 'UTgfGameplayAbility_SnapToTarget::TargetChannel' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, SafeSpace) == 0x00069C, "Member 'UTgfGameplayAbility_SnapToTarget::SafeSpace' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, TimeToMove) == 0x0006A0, "Member 'UTgfGameplayAbility_SnapToTarget::TimeToMove' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, MoveFlags) == 0x0006A4, "Member 'UTgfGameplayAbility_SnapToTarget::MoveFlags' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, TransformSnapLerpCurve) == 0x0006A8, "Member 'UTgfGameplayAbility_SnapToTarget::TransformSnapLerpCurve' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_SnapToTarget, LocationSnapLerpCurve) == 0x0006B0, "Member 'UTgfGameplayAbility_SnapToTarget::LocationSnapLerpCurve' has a wrong offset!");

// Class LyraGame.TgfGameplayAura
// 0x00E8 (0x0110 - 0x0028)
class UTgfGameplayAura : public UObject
{
public:
	ETgfAuraNetExecutionPolicy                    NetExecutionPolicy;                                // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleRadius;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitZDistance;                                    // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxZDistance;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayEventTag;                                  // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CancelGameplayEventTag;                            // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    GEsAppliedToTargets;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         TickInterval;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfAuraCoolDownPolicy                        CoolDownPolicy;                                    // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CoolDownGE;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CoolDownTag;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TriggeredCallBackEventTag;                         // 0x0078(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHostileOnly;                                      // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayersOnly;                                      // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfAuraDeathPolicy                           InstigatorDeathPolicy;                             // 0x009E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayAuraAssetTags;                             // 0x00A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          NeedDisplayIcon;                                   // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AuraIcon;                                          // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x40];                                      // 0x00D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoreTarget(class ALyraCharacter* Target);
	bool BP_NeedApplyEffect(class ALyraCharacter* Target);
	void BroadCastGameplayMessage(const struct FGameplayTag& Tag, const struct FAuraMessageVerb& Message);
	float GetCapsuleRadius();
	void K2_OnAuraAdded(class UTgfAuraManagerComponent* AuraManagerComponent);
	void K2_OnAuraRemoved(class UTgfAuraManagerComponent* AuraManagerComponent);
	void K2_OnCharacterEnter(class ALyraCharacter* Target);
	void K2_OnCharacterLeave(class ALyraCharacter* Target);
	void K2_PreTickAura(float DeltaTime);
	void K2_TickAura(float DeltaTime);
	void RemoveIgnoreTarget(class ALyraCharacter* Target);

	class ULyraAbilitySystemComponent* GetInstigatorAbilitySystemComponent() const;
	class AActor* GetOwningActor() const;
	class ALyraCharacter* GetSourceCharacter() const;
	void GetTargetCharacters(TArray<class ALyraCharacter*>* OutTargets) const;
	float GetTotalRunningTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAura">();
	}
	static class UTgfGameplayAura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAura>();
	}
};
static_assert(alignof(UTgfGameplayAura) == 0x000008, "Wrong alignment on UTgfGameplayAura");
static_assert(sizeof(UTgfGameplayAura) == 0x000110, "Wrong size on UTgfGameplayAura");
static_assert(offsetof(UTgfGameplayAura, NetExecutionPolicy) == 0x000028, "Member 'UTgfGameplayAura::NetExecutionPolicy' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, CapsuleRadius) == 0x00002C, "Member 'UTgfGameplayAura::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, CapsuleHalfHeight) == 0x000030, "Member 'UTgfGameplayAura::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, LimitZDistance) == 0x000034, "Member 'UTgfGameplayAura::LimitZDistance' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, MaxZDistance) == 0x000038, "Member 'UTgfGameplayAura::MaxZDistance' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, GameplayEventTag) == 0x00003C, "Member 'UTgfGameplayAura::GameplayEventTag' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, CancelGameplayEventTag) == 0x000044, "Member 'UTgfGameplayAura::CancelGameplayEventTag' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, GEsAppliedToTargets) == 0x000050, "Member 'UTgfGameplayAura::GEsAppliedToTargets' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, TickInterval) == 0x000060, "Member 'UTgfGameplayAura::TickInterval' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, CoolDownPolicy) == 0x000064, "Member 'UTgfGameplayAura::CoolDownPolicy' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, CoolDownGE) == 0x000068, "Member 'UTgfGameplayAura::CoolDownGE' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, CoolDownTag) == 0x000070, "Member 'UTgfGameplayAura::CoolDownTag' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, TriggeredCallBackEventTag) == 0x000078, "Member 'UTgfGameplayAura::TriggeredCallBackEventTag' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, Duration) == 0x000098, "Member 'UTgfGameplayAura::Duration' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, bHostileOnly) == 0x00009C, "Member 'UTgfGameplayAura::bHostileOnly' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, bPlayersOnly) == 0x00009D, "Member 'UTgfGameplayAura::bPlayersOnly' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, InstigatorDeathPolicy) == 0x00009E, "Member 'UTgfGameplayAura::InstigatorDeathPolicy' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, GameplayAuraAssetTags) == 0x0000A0, "Member 'UTgfGameplayAura::GameplayAuraAssetTags' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, NeedDisplayIcon) == 0x0000C0, "Member 'UTgfGameplayAura::NeedDisplayIcon' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAura, AuraIcon) == 0x0000C8, "Member 'UTgfGameplayAura::AuraIcon' has a wrong offset!");

// Class LyraGame.TGFGameplayCueManager
// 0x0050 (0x0490 - 0x0440)
class UTGFGameplayCueManager final : public ULyraGameplayCueManager
{
public:
	TSet<class FString>                           MapsWithoutGameplayCue;                            // 0x0440(0x0050)(Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameplayCueManager">();
	}
	static class UTGFGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameplayCueManager>();
	}
};
static_assert(alignof(UTGFGameplayCueManager) == 0x000008, "Wrong alignment on UTGFGameplayCueManager");
static_assert(sizeof(UTGFGameplayCueManager) == 0x000490, "Wrong size on UTGFGameplayCueManager");
static_assert(offsetof(UTGFGameplayCueManager, MapsWithoutGameplayCue) == 0x000440, "Member 'UTGFGameplayCueManager::MapsWithoutGameplayCue' has a wrong offset!");

// Class LyraGame.TgfGameplayCueNotify_Looping
// 0x03D8 (0x1F28 - 0x1B50)
class ATgfGameplayCueNotify_Looping final : public AGameplayCueNotify_Looping
{
public:
	struct FTgfGameplayCueNotify_BurstEffects     TgfApplicationEffects;                             // 0x1B50(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_SpawnResult      TgfApplicationSpawnResults;                        // 0x1C40(0x0020)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_LoopingEffects   TgfLoopingEffects;                                 // 0x1C60(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_SpawnResult      TgfLoopingSpawnResults;                            // 0x1CE0(0x0020)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_BurstEffects     TgfRecurringEffects;                               // 0x1D00(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_SpawnResult      TgfRecurringSpawnResults;                          // 0x1DF0(0x0020)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_BurstEffects     TgfRemovalEffects;                                 // 0x1E10(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_SpawnResult      TgfRemovalSpawnResults;                            // 0x1F00(0x0020)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F20[0x8];                                     // 0x1F20(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTgfApplication(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling);
	void OnTgfLoopingStart(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling);
	void OnTgfRecurring(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling);
	void OnTgfRemoval(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayCueNotify_Looping">();
	}
	static class ATgfGameplayCueNotify_Looping* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfGameplayCueNotify_Looping>();
	}
};
static_assert(alignof(ATgfGameplayCueNotify_Looping) == 0x000008, "Wrong alignment on ATgfGameplayCueNotify_Looping");
static_assert(sizeof(ATgfGameplayCueNotify_Looping) == 0x001F28, "Wrong size on ATgfGameplayCueNotify_Looping");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfApplicationEffects) == 0x001B50, "Member 'ATgfGameplayCueNotify_Looping::TgfApplicationEffects' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfApplicationSpawnResults) == 0x001C40, "Member 'ATgfGameplayCueNotify_Looping::TgfApplicationSpawnResults' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfLoopingEffects) == 0x001C60, "Member 'ATgfGameplayCueNotify_Looping::TgfLoopingEffects' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfLoopingSpawnResults) == 0x001CE0, "Member 'ATgfGameplayCueNotify_Looping::TgfLoopingSpawnResults' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfRecurringEffects) == 0x001D00, "Member 'ATgfGameplayCueNotify_Looping::TgfRecurringEffects' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfRecurringSpawnResults) == 0x001DF0, "Member 'ATgfGameplayCueNotify_Looping::TgfRecurringSpawnResults' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfRemovalEffects) == 0x001E10, "Member 'ATgfGameplayCueNotify_Looping::TgfRemovalEffects' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_Looping, TgfRemovalSpawnResults) == 0x001F00, "Member 'ATgfGameplayCueNotify_Looping::TgfRemovalSpawnResults' has a wrong offset!");

// Class LyraGame.TgfGameplayEffect
// 0x0040 (0x08A8 - 0x0868)
class UTgfGameplayEffect : public UGameplayEffect
{
public:
	int32                                         GameplayEffectId;                                  // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedDisplayIcon;                                   // 0x086C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86D[0x3];                                      // 0x086D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BuffIcon;                                          // 0x0870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebuff;                                         // 0x0878(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_879[0x3];                                      // 0x0879(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x087C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDamageDirectionHint;                        // 0x0880(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_881[0x3];                                      // 0x0881(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FailedTag;                                         // 0x0884(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableApplyCD;                                     // 0x088C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88D[0x3];                                      // 0x088D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApplyCD;                                           // 0x0890(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedDumpToNextLevel;                               // 0x0894(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedIgnoreEvent;                                   // 0x0895(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfGameplayEffectActiveType                  ActiveType;                                        // 0x0896(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfGameplayEffectSkillType                   SkillType;                                         // 0x0897(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeRollback;                                    // 0x0898(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedHideDuration;                                  // 0x089C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89D[0x3];                                      // 0x089D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideDurationLimit;                                 // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayEffect">();
	}
	static class UTgfGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayEffect>();
	}
};
static_assert(alignof(UTgfGameplayEffect) == 0x000008, "Wrong alignment on UTgfGameplayEffect");
static_assert(sizeof(UTgfGameplayEffect) == 0x0008A8, "Wrong size on UTgfGameplayEffect");
static_assert(offsetof(UTgfGameplayEffect, GameplayEffectId) == 0x000868, "Member 'UTgfGameplayEffect::GameplayEffectId' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, NeedDisplayIcon) == 0x00086C, "Member 'UTgfGameplayEffect::NeedDisplayIcon' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, BuffIcon) == 0x000870, "Member 'UTgfGameplayEffect::BuffIcon' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, bIsDebuff) == 0x000878, "Member 'UTgfGameplayEffect::bIsDebuff' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, Priority) == 0x00087C, "Member 'UTgfGameplayEffect::Priority' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, bIgnoreDamageDirectionHint) == 0x000880, "Member 'UTgfGameplayEffect::bIgnoreDamageDirectionHint' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, FailedTag) == 0x000884, "Member 'UTgfGameplayEffect::FailedTag' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, EnableApplyCD) == 0x00088C, "Member 'UTgfGameplayEffect::EnableApplyCD' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, ApplyCD) == 0x000890, "Member 'UTgfGameplayEffect::ApplyCD' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, NeedDumpToNextLevel) == 0x000894, "Member 'UTgfGameplayEffect::NeedDumpToNextLevel' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, NeedIgnoreEvent) == 0x000895, "Member 'UTgfGameplayEffect::NeedIgnoreEvent' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, ActiveType) == 0x000896, "Member 'UTgfGameplayEffect::ActiveType' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, SkillType) == 0x000897, "Member 'UTgfGameplayEffect::SkillType' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, ChargeRollback) == 0x000898, "Member 'UTgfGameplayEffect::ChargeRollback' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, NeedHideDuration) == 0x00089C, "Member 'UTgfGameplayEffect::NeedHideDuration' has a wrong offset!");
static_assert(offsetof(UTgfGameplayEffect, HideDurationLimit) == 0x0008A0, "Member 'UTgfGameplayEffect::HideDurationLimit' has a wrong offset!");

// Class LyraGame.TgfGameplayEventRedirector
// 0x0018 (0x00C0 - 0x00A8)
class UTgfGameplayEventRedirector final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayEventRedirector">();
	}
	static class UTgfGameplayEventRedirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayEventRedirector>();
	}
};
static_assert(alignof(UTgfGameplayEventRedirector) == 0x000008, "Wrong alignment on UTgfGameplayEventRedirector");
static_assert(sizeof(UTgfGameplayEventRedirector) == 0x0000C0, "Wrong size on UTgfGameplayEventRedirector");

// Class LyraGame.TgfGameWidgetLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfGameWidgetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool BoolArrayIdxOf(const TArray<bool>& Array, int32 Idx, bool* Out);
	static void BroadcastKeyBindingChange(class UObject* Context);
	static const class UInputAction* FindInputActionForTag(const class UUserWidget* UserWidget, const struct FGameplayTag& InputTag, bool bLogNotFound);
	static const class UInputAction* FindInputActionForTagByController(const class APlayerController* PlayerController, const struct FGameplayTag& InputTag, bool bLogNotFound);
	static class UAbilitySystemComponent* GameWidgetGetAbilitySystemComponentFromActor(const class AActor* Actor);
	static void GetActiveGameplayEffectShowTotalAndRemainTime(const struct FActiveGameplayEffectHandle& ActiveHandle, float* RemainTime, float* TotalTime);
	static TArray<ETgfEquipQuality> GetAutoFillQuality(class UUserWidget* UserWidget);
	static float GetCameraFOVAngle(class UUserWidget* UserWidget);
	static bool GetCareerAndRaceFromNecklace(const class ALyraCharacter* Character, ETgfActorCareer* OutCareer, ETgfActorRace* OutRace);
	static class UCommonInputSubsystem* GetCommonInputSubsystem(class UUserWidget* UserWidget);
	static void GetDisplayCareerAndRace(class ALyraCharacter* Character, ETgfActorCareer* OutCareer, ETgfActorRace* OutRace);
	static class AActor* GetEffectCauserByEffectContext(const struct FGameplayEffectContextHandle& ContextHandle);
	static class UTgfGameFollowUIManagerComponent* GetFollowUIManagerComponent(class APlayerController* PlayerController);
	static struct FGameplayTag GetGameplayTagFromString(const class FString& TagString);
	static struct FKey GetInputKeyByInputAction(class ULyraLocalPlayer* LocalPlayer, class UInputAction* InputAction);
	static class FText GetInputKeyTextByInputAction(class ULyraLocalPlayer* LocalPlayer, class UInputAction* InputAction);
	static class ALyraCharacter* GetLyraCharacter(class UUserWidget* UserWidget);
	static float GetMagicPercent(class UAbilitySystemComponent* ASC);
	static float GetSoulEnergyPercent(class UAbilitySystemComponent* ASC);
	static class AActor* GetWidgetViewTarget(class UUserWidget* UserWidget);
	static bool Is0penoperationTips();
	static bool IsPVPMode(class APlayerController* PlayerController);
	static void RecomputeGameplayEffectStartWorldTimes(class ULyraAbilitySystemComponent* LyraASC);
	static void SetDSAutoFillQuality(class UUserWidget* UserWidget, const TArray<ETgfEquipQuality>& QualityList);
	static void ShowHurtNum(class APlayerController* PlayerController, const struct FHurtNotifyMessage& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameWidgetLibrary">();
	}
	static class UTgfGameWidgetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameWidgetLibrary>();
	}
};
static_assert(alignof(UTgfGameWidgetLibrary) == 0x000008, "Wrong alignment on UTgfGameWidgetLibrary");
static_assert(sizeof(UTgfGameWidgetLibrary) == 0x000028, "Wrong size on UTgfGameWidgetLibrary");

// Class LyraGame.TgfGearsetDefinition
// 0x0010 (0x0070 - 0x0060)
class UTgfGearsetDefinition final : public UTgfEquipmentDefinition
{
public:
	TArray<struct FTgfGearsetLevelAbilityItem>    GearsetAbilities;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGearsetDefinition">();
	}
	static class UTgfGearsetDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGearsetDefinition>();
	}
};
static_assert(alignof(UTgfGearsetDefinition) == 0x000008, "Wrong alignment on UTgfGearsetDefinition");
static_assert(sizeof(UTgfGearsetDefinition) == 0x000070, "Wrong size on UTgfGearsetDefinition");
static_assert(offsetof(UTgfGearsetDefinition, GearsetAbilities) == 0x000060, "Member 'UTgfGearsetDefinition::GearsetAbilities' has a wrong offset!");

// Class LyraGame.TgfHealthBarWidget
// 0x0058 (0x0308 - 0x02B0)
class UTgfHealthBarWidget final : public UTgfGameWidgetBase
{
public:
	class ULyraAbilitySystemComponent*            LyraASC;                                           // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfMagicAttributeSet*                  MagicAttributeSet;                                 // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfDefendAttributeSet*                 DefendAttributeSet;                                // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfSoulEnergyAttributeSet*             SoulEnergyAttributeSet;                            // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfNaturalEnergyAttributeSet*          NaturalEnergyAttributeSet;                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfMagicAttributeSet*                  CustomMagicAttributeSet;                           // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfSoulEnergyAttributeSet*             CustomSoulEnergyAttributeSet;                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfDefendAttributeSet*                 CustomDefendAttributeSet;                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfNaturalEnergyAttributeSet*          CustomNaturalEnergyAttributeSet;                   // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBuffAdd(class UTgfGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle, float RemainTime);
	void BP_OnGERemove(const struct FActiveGameplayEffectHandle& GEHandle);
	float GetCurHealth();
	float GetCurMagic();
	float GetCurNaturalEnergy();
	float GetCurShield();
	float GetCurSoulEnergy();
	float GetHealthPercent();
	float GetMagicPercent();
	float GetMaxHealth();
	float GetMaxMagic();
	float GetMaxNaturalEnergy();
	float GetMaxSoulEnergy();
	float GetNaturalEnergyPercent();
	float GetShieldPercent();
	float GetSoulEnergyPercent();
	void SetCustomAttribute(class ULyraAbilitySystemComponent* CustomASC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfHealthBarWidget">();
	}
	static class UTgfHealthBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfHealthBarWidget>();
	}
};
static_assert(alignof(UTgfHealthBarWidget) == 0x000008, "Wrong alignment on UTgfHealthBarWidget");
static_assert(sizeof(UTgfHealthBarWidget) == 0x000308, "Wrong size on UTgfHealthBarWidget");
static_assert(offsetof(UTgfHealthBarWidget, LyraASC) == 0x0002B0, "Member 'UTgfHealthBarWidget::LyraASC' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, MagicAttributeSet) == 0x0002B8, "Member 'UTgfHealthBarWidget::MagicAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, DefendAttributeSet) == 0x0002C0, "Member 'UTgfHealthBarWidget::DefendAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, SoulEnergyAttributeSet) == 0x0002C8, "Member 'UTgfHealthBarWidget::SoulEnergyAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, NaturalEnergyAttributeSet) == 0x0002D0, "Member 'UTgfHealthBarWidget::NaturalEnergyAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, CustomMagicAttributeSet) == 0x0002D8, "Member 'UTgfHealthBarWidget::CustomMagicAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, CustomSoulEnergyAttributeSet) == 0x0002E0, "Member 'UTgfHealthBarWidget::CustomSoulEnergyAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, CustomDefendAttributeSet) == 0x0002E8, "Member 'UTgfHealthBarWidget::CustomDefendAttributeSet' has a wrong offset!");
static_assert(offsetof(UTgfHealthBarWidget, CustomNaturalEnergyAttributeSet) == 0x0002F0, "Member 'UTgfHealthBarWidget::CustomNaturalEnergyAttributeSet' has a wrong offset!");

// Class LyraGame.TgfInertanceComponent
// 0x0060 (0x0300 - 0x02A0)
class UTgfInertanceComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2A0[0x30];                                     // 0x02A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x02D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SceneComponent;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowInZeroVelocity;                             // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFollowMode                                   FollowMode;                                        // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2[0x2];                                      // 0x02F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFollowDistance;                                 // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FollowFrame;                                       // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBlending;                                      // 0x02FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInertanceAnimInstance;                         // 0x02FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FE[0x2];                                      // 0x02FE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector BlendingToTarget(float DeltaTime, const struct FVector& InLocation, const struct FVector& Target);
	void SetComponent(class USceneComponent* InSceneComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInertanceComponent">();
	}
	static class UTgfInertanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInertanceComponent>();
	}
};
static_assert(alignof(UTgfInertanceComponent) == 0x000010, "Wrong alignment on UTgfInertanceComponent");
static_assert(sizeof(UTgfInertanceComponent) == 0x000300, "Wrong size on UTgfInertanceComponent");
static_assert(offsetof(UTgfInertanceComponent, TargetLocation) == 0x0002D0, "Member 'UTgfInertanceComponent::TargetLocation' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, SceneComponent) == 0x0002E8, "Member 'UTgfInertanceComponent::SceneComponent' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, bFollowInZeroVelocity) == 0x0002F0, "Member 'UTgfInertanceComponent::bFollowInZeroVelocity' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, FollowMode) == 0x0002F1, "Member 'UTgfInertanceComponent::FollowMode' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, MaxFollowDistance) == 0x0002F4, "Member 'UTgfInertanceComponent::MaxFollowDistance' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, FollowFrame) == 0x0002F8, "Member 'UTgfInertanceComponent::FollowFrame' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, bUseBlending) == 0x0002FC, "Member 'UTgfInertanceComponent::bUseBlending' has a wrong offset!");
static_assert(offsetof(UTgfInertanceComponent, bUseInertanceAnimInstance) == 0x0002FD, "Member 'UTgfInertanceComponent::bUseInertanceAnimInstance' has a wrong offset!");

// Class LyraGame.TgfInertanceAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UTgfInertanceAnimInstance final : public UAnimInstance
{
public:
	class UTgfInertanceComponent*                 Inertance;                                         // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTgfInertanceComponent* GetInertanceComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInertanceAnimInstance">();
	}
	static class UTgfInertanceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInertanceAnimInstance>();
	}
};
static_assert(alignof(UTgfInertanceAnimInstance) == 0x000010, "Wrong alignment on UTgfInertanceAnimInstance");
static_assert(sizeof(UTgfInertanceAnimInstance) == 0x000350, "Wrong size on UTgfInertanceAnimInstance");
static_assert(offsetof(UTgfInertanceAnimInstance, Inertance) == 0x000348, "Member 'UTgfInertanceAnimInstance::Inertance' has a wrong offset!");

// Class LyraGame.TgfInputDataAsset
// 0x0008 (0x0038 - 0x0030)
class UTgfInputDataAsset final : public UPrimaryDataAsset
{
public:
	double                                        GlobalInputTagDelay;                               // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInputDataAsset">();
	}
	static class UTgfInputDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInputDataAsset>();
	}
};
static_assert(alignof(UTgfInputDataAsset) == 0x000008, "Wrong alignment on UTgfInputDataAsset");
static_assert(sizeof(UTgfInputDataAsset) == 0x000038, "Wrong size on UTgfInputDataAsset");
static_assert(offsetof(UTgfInputDataAsset, GlobalInputTagDelay) == 0x000030, "Member 'UTgfInputDataAsset::GlobalInputTagDelay' has a wrong offset!");

// Class LyraGame.TgfInventoryCheats
// 0x0000 (0x0028 - 0x0028)
class UTgfInventoryCheats final : public UCheatManagerExtension
{
public:
	void AddBlockingLootSlot(int32 Slot);
	void AddGearsetLevel(int32 GearsetId, int32 DeltaLevel);
	void AddItem(const class FString& AssetName, int32 Nums);
	void AddLootItem(int32 ItemId, int32 Nums);
	void AddPackage(int32 PackageId);
	void ClearAllGearsetLevel();
	void InvenChangeSize(int32 SizeX, int32 SizeY, int32 Type);
	void ItemReady();
	void RecoverAmmo();
	void RemoveItem(const class FString& AssetName, int32 Nums);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryCheats">();
	}
	static class UTgfInventoryCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryCheats>();
	}
};
static_assert(alignof(UTgfInventoryCheats) == 0x000008, "Wrong alignment on UTgfInventoryCheats");
static_assert(sizeof(UTgfInventoryCheats) == 0x000028, "Wrong size on UTgfInventoryCheats");

// Class LyraGame.TgfInventoryDataAsset
// 0x0028 (0x0058 - 0x0030)
class UTgfInventoryDataAsset final : public UPrimaryDataAsset
{
public:
	struct FIntPoint                              PlayerInventorySize;                               // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              PVPInventorySize;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              PlayerStorageSize;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTgfInventoryPackageItem>       PackageList;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryDataAsset">();
	}
	static class UTgfInventoryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryDataAsset>();
	}
};
static_assert(alignof(UTgfInventoryDataAsset) == 0x000008, "Wrong alignment on UTgfInventoryDataAsset");
static_assert(sizeof(UTgfInventoryDataAsset) == 0x000058, "Wrong size on UTgfInventoryDataAsset");
static_assert(offsetof(UTgfInventoryDataAsset, PlayerInventorySize) == 0x000030, "Member 'UTgfInventoryDataAsset::PlayerInventorySize' has a wrong offset!");
static_assert(offsetof(UTgfInventoryDataAsset, PVPInventorySize) == 0x000038, "Member 'UTgfInventoryDataAsset::PVPInventorySize' has a wrong offset!");
static_assert(offsetof(UTgfInventoryDataAsset, PlayerStorageSize) == 0x000040, "Member 'UTgfInventoryDataAsset::PlayerStorageSize' has a wrong offset!");
static_assert(offsetof(UTgfInventoryDataAsset, PackageList) == 0x000048, "Member 'UTgfInventoryDataAsset::PackageList' has a wrong offset!");

// Class LyraGame.TgfInventoryFragment_Base
// 0x0008 (0x0030 - 0x0028)
class UTgfInventoryFragment_Base final : public ULyraInventoryItemFragment
{
public:
	ETgfItemType                                  ItemType;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryFragment_Base">();
	}
	static class UTgfInventoryFragment_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryFragment_Base>();
	}
};
static_assert(alignof(UTgfInventoryFragment_Base) == 0x000008, "Wrong alignment on UTgfInventoryFragment_Base");
static_assert(sizeof(UTgfInventoryFragment_Base) == 0x000030, "Wrong size on UTgfInventoryFragment_Base");
static_assert(offsetof(UTgfInventoryFragment_Base, ItemType) == 0x000028, "Member 'UTgfInventoryFragment_Base::ItemType' has a wrong offset!");

// Class LyraGame.TgfInventoryItemDefinition
// 0x0030 (0x0080 - 0x0050)
class UTgfInventoryItemDefinition : public ULyraInventoryItemDefinition
{
public:
	int32                                         ItemDefId;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Size;                                              // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStack;                                          // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDiscardStack;                                   // 0x005D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackCount;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfItemType                                  ItemType;                                          // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DropOnDeathInPVPType;                              // 0x0065(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfSkinSlot                                  SkinType;                                          // 0x0066(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfSkinCategory                              SkinCategory;                                      // 0x0067(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ETgfSkinSlot>                          AdditionalSkinType;                                // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bForbidSteal;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreLootBeam;                                    // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemDefinition">();
	}
	static class UTgfInventoryItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemDefinition>();
	}
};
static_assert(alignof(UTgfInventoryItemDefinition) == 0x000008, "Wrong alignment on UTgfInventoryItemDefinition");
static_assert(sizeof(UTgfInventoryItemDefinition) == 0x000080, "Wrong size on UTgfInventoryItemDefinition");
static_assert(offsetof(UTgfInventoryItemDefinition, ItemDefId) == 0x000050, "Member 'UTgfInventoryItemDefinition::ItemDefId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, Size) == 0x000054, "Member 'UTgfInventoryItemDefinition::Size' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, CanStack) == 0x00005C, "Member 'UTgfInventoryItemDefinition::CanStack' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, CanDiscardStack) == 0x00005D, "Member 'UTgfInventoryItemDefinition::CanDiscardStack' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, MaxStackCount) == 0x000060, "Member 'UTgfInventoryItemDefinition::MaxStackCount' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, ItemType) == 0x000064, "Member 'UTgfInventoryItemDefinition::ItemType' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, DropOnDeathInPVPType) == 0x000065, "Member 'UTgfInventoryItemDefinition::DropOnDeathInPVPType' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, SkinType) == 0x000066, "Member 'UTgfInventoryItemDefinition::SkinType' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, SkinCategory) == 0x000067, "Member 'UTgfInventoryItemDefinition::SkinCategory' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, AdditionalSkinType) == 0x000068, "Member 'UTgfInventoryItemDefinition::AdditionalSkinType' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, bForbidSteal) == 0x000078, "Member 'UTgfInventoryItemDefinition::bForbidSteal' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemDefinition, IgnoreLootBeam) == 0x000079, "Member 'UTgfInventoryItemDefinition::IgnoreLootBeam' has a wrong offset!");

// Class LyraGame.TgfInventoryItemWrapper_TemporalItemDivide
// 0x0010 (0x0058 - 0x0048)
class UTgfInventoryItemWrapper_TemporalItemDivide final : public UTgfInventoryItemWrapper
{
public:
	class UTgfInventoryItemWrapper*               OriginalItem;                                      // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivideNumber;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_TemporalItemDivide">();
	}
	static class UTgfInventoryItemWrapper_TemporalItemDivide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_TemporalItemDivide>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_TemporalItemDivide) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_TemporalItemDivide");
static_assert(sizeof(UTgfInventoryItemWrapper_TemporalItemDivide) == 0x000058, "Wrong size on UTgfInventoryItemWrapper_TemporalItemDivide");
static_assert(offsetof(UTgfInventoryItemWrapper_TemporalItemDivide, OriginalItem) == 0x000048, "Member 'UTgfInventoryItemWrapper_TemporalItemDivide::OriginalItem' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_TemporalItemDivide, DivideNumber) == 0x000050, "Member 'UTgfInventoryItemWrapper_TemporalItemDivide::DivideNumber' has a wrong offset!");

// Class LyraGame.LyraWeaponDebugSettings
// 0x0010 (0x0048 - 0x0038)
class ULyraWeaponDebugSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	float                                         DrawBulletTraceDuration;                           // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawBulletHitDuration;                             // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawBulletHitRadius;                               // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponDebugSettings">();
	}
	static class ULyraWeaponDebugSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWeaponDebugSettings>();
	}
};
static_assert(alignof(ULyraWeaponDebugSettings) == 0x000008, "Wrong alignment on ULyraWeaponDebugSettings");
static_assert(sizeof(ULyraWeaponDebugSettings) == 0x000048, "Wrong size on ULyraWeaponDebugSettings");
static_assert(offsetof(ULyraWeaponDebugSettings, DrawBulletTraceDuration) == 0x000038, "Member 'ULyraWeaponDebugSettings::DrawBulletTraceDuration' has a wrong offset!");
static_assert(offsetof(ULyraWeaponDebugSettings, DrawBulletHitDuration) == 0x00003C, "Member 'ULyraWeaponDebugSettings::DrawBulletHitDuration' has a wrong offset!");
static_assert(offsetof(ULyraWeaponDebugSettings, DrawBulletHitRadius) == 0x000040, "Member 'ULyraWeaponDebugSettings::DrawBulletHitRadius' has a wrong offset!");

// Class LyraGame.TgfInventoryManagerComponent
// 0x0030 (0x0208 - 0x01D8)
class UTgfInventoryManagerComponent : public ULyraInventoryManagerComponent
{
public:
	struct FIntPoint                              Size;                                              // 0x01D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              AdditionalSize;                                    // 0x01E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 InventoryGridIndex;                                // 0x01E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 AdditionalInventoryGridIndex;                      // 0x01F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static struct FIntPoint GetDefaultInventorySize();
	static struct FIntPoint GetDefaultInventorySizeInPVP();

	void AddItemInstanceWithPosition(class ULyraInventoryItemInstance* ItemInstance, const struct FIntPoint& Position, ELyraInventoryType InventoryType);
	void AutoMergeItemStacks();
	void ChangeEntryPosByInstance(class ULyraInventoryItemInstance* ItemInstance, const struct FIntPoint& Position, ELyraInventoryType InventoryType);
	void DropAllAddtionalInventoryItem(TArray<class ULyraInventoryItemInstance*>* DropItems);
	void ExchangeItemInstances(const TArray<class ULyraInventoryItemInstance*>& AddInstances, const TArray<class ULyraInventoryItemInstance*>& RemoveInstances, ELyraInventoryType InventoryType, bool CheckInInventory);
	void InitAdditionalInventoryWithSize(const struct FIntPoint& InventorySize);
	void InitInventoryWithSize(const struct FIntPoint& InventorySize);
	bool IsAdditonalInventoryEnable();
	void OnRep_AdditionalSize();
	void OnRep_Size();
	void ResizeInventory(const struct FIntPoint& NewSize, ELyraInventoryType InventoryType);

	bool CanExchangeItemInstances(const TArray<class ULyraInventoryItemInstance*>& AddInstances, const TArray<class ULyraInventoryItemInstance*>& RemoveInstances, ELyraInventoryType InventoryType, bool CheckInInventory) const;
	bool CanResizeInventory(const struct FIntPoint& NewSize, ELyraInventoryType InventoryType) const;
	bool GetEntryByPos(const struct FIntPoint& Position, struct FLyraInventoryEntry* Entry, ELyraInventoryType InventoryType) const;
	class ULyraInventoryItemInstance* GetItemInstanceByPos(const struct FIntPoint& Position, ELyraInventoryType InventoryType) const;
	struct FIntPoint GetItemSize(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass) const;
	struct FIntPoint GetSize(ELyraInventoryType InventoryType) const;
	bool IsPositionValid(const struct FIntPoint& Position, const struct FIntPoint& ItemSize, ELyraInventoryType InventoryType, int32 IgnoreIndex) const;
	bool IsPositionValidByItemDef(const struct FIntPoint& Position, TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType) const;
	bool IsPositionValidByItemInstance(const struct FIntPoint& Position, class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryManagerComponent">();
	}
	static class UTgfInventoryManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryManagerComponent>();
	}
};
static_assert(alignof(UTgfInventoryManagerComponent) == 0x000008, "Wrong alignment on UTgfInventoryManagerComponent");
static_assert(sizeof(UTgfInventoryManagerComponent) == 0x000208, "Wrong size on UTgfInventoryManagerComponent");
static_assert(offsetof(UTgfInventoryManagerComponent, Size) == 0x0001D8, "Member 'UTgfInventoryManagerComponent::Size' has a wrong offset!");
static_assert(offsetof(UTgfInventoryManagerComponent, AdditionalSize) == 0x0001E0, "Member 'UTgfInventoryManagerComponent::AdditionalSize' has a wrong offset!");
static_assert(offsetof(UTgfInventoryManagerComponent, InventoryGridIndex) == 0x0001E8, "Member 'UTgfInventoryManagerComponent::InventoryGridIndex' has a wrong offset!");
static_assert(offsetof(UTgfInventoryManagerComponent, AdditionalInventoryGridIndex) == 0x0001F8, "Member 'UTgfInventoryManagerComponent::AdditionalInventoryGridIndex' has a wrong offset!");

// Class LyraGame.TgfInventoryRoleWrapper_InGame
// 0x0050 (0x0080 - 0x0030)
class UTgfInventoryRoleWrapper_InGame final : public UTgfInventoryRoleWrapper
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfInventoryRoleWrapper_InGame* CreateInventoryRoleWrapperFromActor(class AActor* Actor, class UDataTable* RoleDisplaytable);

	ETgfActorCareer GetActorCareer() const;
	ETgfActorRace GetActorRace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryRoleWrapper_InGame">();
	}
	static class UTgfInventoryRoleWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryRoleWrapper_InGame>();
	}
};
static_assert(alignof(UTgfInventoryRoleWrapper_InGame) == 0x000008, "Wrong alignment on UTgfInventoryRoleWrapper_InGame");
static_assert(sizeof(UTgfInventoryRoleWrapper_InGame) == 0x000080, "Wrong size on UTgfInventoryRoleWrapper_InGame");

// Class LyraGame.TgfInventoryWrapper
// 0x0170 (0x0198 - 0x0028)
class UTgfInventoryWrapper : public UTgfBlueprintableObject
{
public:
	int32                                         PageId;                                            // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELyraInventoryType                            LyraInventoryType;                                 // 0x002C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfInventoryType                             InventoryType;                                     // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UTgfInventoryWrapper>    ParentInventoryContext;                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCompareModeIsOn;                                  // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOwnerListIsOn;                                    // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               PopupOverlayPanel;                                 // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStorageUpdated;                                  // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInventoryUpdated;                                // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEquipmentUpdated;                                // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttributeUpdated;                                // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnActiveWeaponUpdated;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDragInitiated;                                   // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCompareModeToggled;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOwnerListToggled;                                // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(class UTgfInventoryItemWrapper* ItemWrapper, class UTgfInventoryWrapper* Context)> OnPendingDivideOperation;                          // 0x00C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfInventoryWrapper*                   SelfInventoryContext;                              // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UTgfInventoryItemWrapper* ItemWrapper)> InventoryItemRightClickOverrideByLua;              // 0x00F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class UTgfInventoryItemWrapper* ItemWrapper)> InventoryItemLeftClickOverride;                    // 0x0100(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class ITooltipWidget>        ItemTooltipWidget;                                 // 0x0110(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTgfInventoryItemWrapper*>       CachedInventoryItems;                              // 0x0120(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<ETgfEquipSlot, class UTgfEquipmentWrapper*> CachedEquipments;                                  // 0x0130(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FTgfInventoryLockedItem>        LockedItems;                                       // 0x0180(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentGroup;                                      // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AreItemGearable(const class UTgfInventoryItemWrapper* Item, const class UTgfInventoryItemWrapper* Diamond, class FText* OutFailReason);

	bool AddToInventoryAutoPlacement(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool bCommit, class FText* OutFailReason);
	void AddToMenu(class UWidget* WidgetToAdd);
	bool CanDiscardEquipment(class UTgfEquipmentWrapper* Equipment, TArray<class UTgfEquipmentWrapper*>* OutEquipmentsToDiscard, class FText* OutFailReason);
	bool CanDiscardInventoryItem(class UTgfInventoryItemWrapper* Item, class FText* OutFailReason);
	bool CanTakeoffMainweapon(ETgfEquipSlot Slot);
	bool CheckMyHeirloom(class UTgfInventoryItemWrapper* Item, class FText* OutFailReason);
	void ClearEquipmentCache();
	bool DropToEquipmentSlot(class UTgfInventoryDragDropOperation* DragOperation, ETgfEquipSlot Slot, bool bCommit, int32 SlotId, class FText* OutFailReason);
	bool DropToEquipmentSlotForLua(class UTgfInventoryDragDropOperation* DragOperation, int32 Slot, bool bCommit, int32 SlotId, class FText* OutFailReason);
	bool DropToInventory(class UTgfInventoryDragDropOperation* DragOperation, const struct FIntPoint& DropPosition, const struct FIntPoint& DropSize, bool bCommit, int32 SlotId, class FText* OutFailReason);
	class UTgfInventoryItemWrapper* FindCompareTargetForItem(class UTgfInventoryItemWrapper* Item);
	void GearinItem(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemContext, class UTgfInventoryItemWrapper* Diamond, class UTgfInventoryWrapper* FromContext, ETgfEquipSlot EquipSlot, int32 GemSlot);
	TArray<class UTgfEquipmentWrapper*> GetAllEquipments();
	float GetAverageDefence();
	float GetAverageDPH();
	int32 GetCurrentGroup();
	class UTgfEquipmentWrapper* GetEquipmentBySlot(ETgfEquipSlot Slot);
	void GetInventoryItems(TArray<class UTgfInventoryItemWrapper*>* OutItems, bool bReadFromCache);
	TArray<class UTgfInventoryItemWrapper*> GetInventoryItemsOfPage(bool bReadFromCache);
	class UTgfInventoryItemWrapper* GetItemFromPosition(const struct FIntPoint& Position);
	void InvokeDragInitiatedEvent(class UTgfInventoryDragDropOperation* DragOperation);
	bool IsSoulBoundParts(ETgfEquipSlot Slot);
	bool RemoveEquipmentToInventory(class UTgfEquipmentWrapper* Equipment, bool bCommit, class FText* OutFailReason);
	int32 SetCurrentGroup(int32 Group);
	void SetInventoryType(ETgfInventoryType Type);
	void ToggleCompareMode();
	void ToggleOwnerListMode();
	bool TryAutoStack(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool bEquipSlot, bool bInventory, bool bCommit, class FText* OutFailReason);
	class UTgfInventoryItemWrapper* TryBeginItemDivide(class UTgfInventoryItemWrapper* SourceItem, int32 DivideNumber);
	bool TryCallInventoryLeftClickOverride(class UTgfInventoryItemWrapper* Item);
	bool TryCallInventoryRightClickOverride(class UTgfInventoryItemWrapper* Item);
	bool TryMoveToInventory(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool DisableStack, bool bCommit, class FText* OutFailReason);
	bool TryPutOnItem(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool bTargetEmptySlotOnly, bool bCommit, class FText* OutFailReason);
	bool TryUseItem(class UTgfInventoryItemWrapper* Item, int32 Count, int32 Param_Index, class FText* OutFailReason);

	bool CanSwapEquipments(ETgfEquipSlot SlotA, ETgfEquipSlot SlotB, class FText* OutFailReason) const;
	ETgfEquipSlot FindBestEquipSlotForItem(class UTgfInventoryItemWrapper* Item) const;
	ETgfActorCareer GetCharacterCareer() const;
	ETgfActorRace GetCharacterRace() const;
	ETgfWeaponChangeSlot GetCurrentWeaponSlot() const;
	class UTgfEquipmentWrapper* GetEquipmentBySlotCached(ETgfEquipSlot Slot) const;
	ETgfEquipSlot GetEquipSlotOfItem(const class UTgfInventoryItemWrapper* Item) const;
	int32 GetGearsetLevel(int32 GearsetId) const;
	struct FIntPoint GetInventorySize() const;
	struct FIntPoint GetItemPosition(const class UTgfInventoryItemWrapper* Item) const;
	struct FIntPoint GetItemSize(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass) const;
	TScriptInterface<class ITooltipWidget> GetItemTooltipWidget() const;
	TArray<class UTgfInventoryItemWrapper*> GetOverlappedItems(const struct FIntPoint& Position, const struct FIntPoint& Span) const;
	class ALyraCharacter* GetOwningCharacter() const;
	class UTgfInventoryWrapper* GetParentInventory() const;
	bool HasAdditionalInventory() const;
	bool HasBlockTag() const;
	bool IsAdditionalInventoryEnable() const;
	bool IsMithrillCharacter() const;
	bool MatchEquipmentWithSlot(class UTgfInventoryItemWrapper* Item, ETgfEquipSlot Slot, bool* bRoughlyMatch, class FText* OutFailReason) const;
	struct FTgfInventoryRequirementQuery QueryRequirementForEquipment(class UTgfInventoryItemWrapper* Item) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapper">();
	}
	static class UTgfInventoryWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapper>();
	}
};
static_assert(alignof(UTgfInventoryWrapper) == 0x000008, "Wrong alignment on UTgfInventoryWrapper");
static_assert(sizeof(UTgfInventoryWrapper) == 0x000198, "Wrong size on UTgfInventoryWrapper");
static_assert(offsetof(UTgfInventoryWrapper, PageId) == 0x000028, "Member 'UTgfInventoryWrapper::PageId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, LyraInventoryType) == 0x00002C, "Member 'UTgfInventoryWrapper::LyraInventoryType' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, InventoryType) == 0x00002D, "Member 'UTgfInventoryWrapper::InventoryType' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, ParentInventoryContext) == 0x000030, "Member 'UTgfInventoryWrapper::ParentInventoryContext' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, bCompareModeIsOn) == 0x000038, "Member 'UTgfInventoryWrapper::bCompareModeIsOn' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, bOwnerListIsOn) == 0x000039, "Member 'UTgfInventoryWrapper::bOwnerListIsOn' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, PopupOverlayPanel) == 0x000040, "Member 'UTgfInventoryWrapper::PopupOverlayPanel' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnStorageUpdated) == 0x000048, "Member 'UTgfInventoryWrapper::OnStorageUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnInventoryUpdated) == 0x000058, "Member 'UTgfInventoryWrapper::OnInventoryUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnEquipmentUpdated) == 0x000068, "Member 'UTgfInventoryWrapper::OnEquipmentUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnAttributeUpdated) == 0x000078, "Member 'UTgfInventoryWrapper::OnAttributeUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnActiveWeaponUpdated) == 0x000088, "Member 'UTgfInventoryWrapper::OnActiveWeaponUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnDragInitiated) == 0x000098, "Member 'UTgfInventoryWrapper::OnDragInitiated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnCompareModeToggled) == 0x0000A8, "Member 'UTgfInventoryWrapper::OnCompareModeToggled' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnOwnerListToggled) == 0x0000B8, "Member 'UTgfInventoryWrapper::OnOwnerListToggled' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, OnPendingDivideOperation) == 0x0000C8, "Member 'UTgfInventoryWrapper::OnPendingDivideOperation' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, SelfInventoryContext) == 0x0000D8, "Member 'UTgfInventoryWrapper::SelfInventoryContext' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, InventoryItemRightClickOverrideByLua) == 0x0000F0, "Member 'UTgfInventoryWrapper::InventoryItemRightClickOverrideByLua' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, InventoryItemLeftClickOverride) == 0x000100, "Member 'UTgfInventoryWrapper::InventoryItemLeftClickOverride' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, ItemTooltipWidget) == 0x000110, "Member 'UTgfInventoryWrapper::ItemTooltipWidget' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, CachedInventoryItems) == 0x000120, "Member 'UTgfInventoryWrapper::CachedInventoryItems' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, CachedEquipments) == 0x000130, "Member 'UTgfInventoryWrapper::CachedEquipments' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, LockedItems) == 0x000180, "Member 'UTgfInventoryWrapper::LockedItems' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper, CurrentGroup) == 0x000190, "Member 'UTgfInventoryWrapper::CurrentGroup' has a wrong offset!");

// Class LyraGame.TgfInventoryItemWrapper_InGame
// 0x0008 (0x0050 - 0x0048)
class UTgfInventoryItemWrapper_InGame final : public UTgfInventoryItemWrapper
{
public:
	TWeakObjectPtr<class UTgfInventoryItemInstance> ItemInstance;                                      // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_InGame">();
	}
	static class UTgfInventoryItemWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_InGame>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_InGame) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_InGame");
static_assert(sizeof(UTgfInventoryItemWrapper_InGame) == 0x000050, "Wrong size on UTgfInventoryItemWrapper_InGame");
static_assert(offsetof(UTgfInventoryItemWrapper_InGame, ItemInstance) == 0x000048, "Member 'UTgfInventoryItemWrapper_InGame::ItemInstance' has a wrong offset!");

// Class LyraGame.TgfEquipmentWrapper_InGame
// 0x0008 (0x0038 - 0x0030)
class UTgfEquipmentWrapper_InGame final : public UTgfEquipmentWrapper
{
public:
	TWeakObjectPtr<class UTgfEquipmentInstance>   EquipmentInstance;                                 // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentWrapper_InGame">();
	}
	static class UTgfEquipmentWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentWrapper_InGame>();
	}
};
static_assert(alignof(UTgfEquipmentWrapper_InGame) == 0x000008, "Wrong alignment on UTgfEquipmentWrapper_InGame");
static_assert(sizeof(UTgfEquipmentWrapper_InGame) == 0x000038, "Wrong size on UTgfEquipmentWrapper_InGame");
static_assert(offsetof(UTgfEquipmentWrapper_InGame, EquipmentInstance) == 0x000030, "Member 'UTgfEquipmentWrapper_InGame::EquipmentInstance' has a wrong offset!");

// Class LyraGame.LyraHeroComponent
// 0x0100 (0x01A8 - 0x00A8)
class ULyraHeroComponent final : public UPawnComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          BlockInput;                                        // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockInputCauseUI;                                 // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockInputAbilityPressed;                          // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x1];                                       // 0x00BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDurationToInspectWeapon;                        // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToInspectWeapon;                               // 0x00C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMappableConfigPair>            DefaultInputConfigs;                               // 0x00C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ULyraCameraMode>            AbilityCameraMode;                                 // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovingScaleContainer                  MovingScaleContainer;                              // 0x00E8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         LookMovingScale;                                   // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2f                              LookMovingClamp;                                   // 0x014C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 AnimationMoveScaleList;                            // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CancelByMoveAbilityTags;                           // 0x0188(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class ULyraHeroComponent* FindHeroComponent(const class AActor* Actor);

	void AddLookMovingScaleAndClamp(bool AddClamp, const struct FVector2f& Clamp, bool AddScale, float Scale);
	void AddMoveInterrputAbilityTag(const struct FGameplayTag& AbilityTag);
	void AddMovingScale(float Value);
	void ClearAbilityCameraModeFromServer(const struct FGameplayAbilitySpecHandle& OwningSpecHandle);
	void RemoveAnimationMoveScale(float Scale);
	void RemoveLookMovingScaleAndClamp(bool AddClamp, const struct FVector2f& Clamp, bool AddScale, float Scale);
	void RemoveMoveInterrputAbilityTag(const struct FGameplayTag& AbilityTag);
	void ResetInspectTimer();
	void SetAbilityCameraModeFromServer(TSubclassOf<class ULyraCameraMode> CameraMode, const struct FGameplayAbilitySpecHandle& OwningSpecHandle);
	void TryInspectWeapon();
	void UpdateInspectTimer(float DeltaTime);

	TSubclassOf<class ULyraCameraMode> DetermineCameraMode() const;
	TSubclassOf<class ULyraCameraMode> DetermineCameraModeThirdPerson() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHeroComponent">();
	}
	static class ULyraHeroComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHeroComponent>();
	}
};
static_assert(alignof(ULyraHeroComponent) == 0x000008, "Wrong alignment on ULyraHeroComponent");
static_assert(sizeof(ULyraHeroComponent) == 0x0001A8, "Wrong size on ULyraHeroComponent");
static_assert(offsetof(ULyraHeroComponent, BlockInput) == 0x0000B8, "Member 'ULyraHeroComponent::BlockInput' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, BlockInputCauseUI) == 0x0000B9, "Member 'ULyraHeroComponent::BlockInputCauseUI' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, BlockInputAbilityPressed) == 0x0000BA, "Member 'ULyraHeroComponent::BlockInputAbilityPressed' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, MaxDurationToInspectWeapon) == 0x0000BC, "Member 'ULyraHeroComponent::MaxDurationToInspectWeapon' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, TimeToInspectWeapon) == 0x0000C0, "Member 'ULyraHeroComponent::TimeToInspectWeapon' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, DefaultInputConfigs) == 0x0000C8, "Member 'ULyraHeroComponent::DefaultInputConfigs' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, AbilityCameraMode) == 0x0000D8, "Member 'ULyraHeroComponent::AbilityCameraMode' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, MovingScaleContainer) == 0x0000E8, "Member 'ULyraHeroComponent::MovingScaleContainer' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, LookMovingScale) == 0x000148, "Member 'ULyraHeroComponent::LookMovingScale' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, LookMovingClamp) == 0x00014C, "Member 'ULyraHeroComponent::LookMovingClamp' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, AnimationMoveScaleList) == 0x000158, "Member 'ULyraHeroComponent::AnimationMoveScaleList' has a wrong offset!");
static_assert(offsetof(ULyraHeroComponent, CancelByMoveAbilityTags) == 0x000188, "Member 'ULyraHeroComponent::CancelByMoveAbilityTags' has a wrong offset!");

// Class LyraGame.TgfInventoryWrapper_InGame
// 0x0090 (0x0228 - 0x0198)
class UTgfInventoryWrapper_InGame final : public UTgfInventoryWrapper
{
public:
	FMulticastInlineDelegateProperty_             OnInventoryStackCountUpdated;                      // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnBlockChangeEquipUpdated;                         // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAdditionalInventoryStateChanged;                 // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnGearsetLevelChanged;                             // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UTgfInventoryManagerComponent*          InventoryManager;                                  // 0x01D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfEquipmentManagerComponent*          EquipmentManager;                                  // 0x01E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemFunctionLibrary*                   ItemFunctionLibrary;                               // 0x01E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ContextActor;                                      // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALyraCharacter*                         Character;                                         // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x28];                                     // 0x0200(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckLootDisVaild(const class ULyraInventoryManagerComponent* LootInventoryManager);
	class ULyraInventoryItemInstance* DropItemInstance(class UTgfInventoryItemWrapper* Item, class ALyraCharacter* OwningCharacter);
	void OnAttributeChanged(class UTgfAttributeComponent* AttributeComponent, const struct FGameplayAttribute& Attribute);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapper_InGame">();
	}
	static class UTgfInventoryWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapper_InGame>();
	}
};
static_assert(alignof(UTgfInventoryWrapper_InGame) == 0x000008, "Wrong alignment on UTgfInventoryWrapper_InGame");
static_assert(sizeof(UTgfInventoryWrapper_InGame) == 0x000228, "Wrong size on UTgfInventoryWrapper_InGame");
static_assert(offsetof(UTgfInventoryWrapper_InGame, OnInventoryStackCountUpdated) == 0x000198, "Member 'UTgfInventoryWrapper_InGame::OnInventoryStackCountUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, OnBlockChangeEquipUpdated) == 0x0001A8, "Member 'UTgfInventoryWrapper_InGame::OnBlockChangeEquipUpdated' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, OnAdditionalInventoryStateChanged) == 0x0001B8, "Member 'UTgfInventoryWrapper_InGame::OnAdditionalInventoryStateChanged' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, OnGearsetLevelChanged) == 0x0001C8, "Member 'UTgfInventoryWrapper_InGame::OnGearsetLevelChanged' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, InventoryManager) == 0x0001D8, "Member 'UTgfInventoryWrapper_InGame::InventoryManager' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, EquipmentManager) == 0x0001E0, "Member 'UTgfInventoryWrapper_InGame::EquipmentManager' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, ItemFunctionLibrary) == 0x0001E8, "Member 'UTgfInventoryWrapper_InGame::ItemFunctionLibrary' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, ContextActor) == 0x0001F0, "Member 'UTgfInventoryWrapper_InGame::ContextActor' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_InGame, Character) == 0x0001F8, "Member 'UTgfInventoryWrapper_InGame::Character' has a wrong offset!");

// Class LyraGame.TgfInventoryWrapperLibrary_InGame
// 0x0000 (0x0028 - 0x0028)
class UTgfInventoryWrapperLibrary_InGame final : public UBlueprintFunctionLibrary
{
public:
	static class UTgfInventoryWrapper_InGame* CreateInventoryWrapperFromActor(class AActor* Actor, ETgfInventoryType Type, class UOverlay* InMainOverlayPanel, TScriptInterface<class ITooltipWidget> InItemTooltipWidget, class UTgfInventoryWrapper* ParentInventory, ELyraInventoryType InLyraInventoryType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapperLibrary_InGame">();
	}
	static class UTgfInventoryWrapperLibrary_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapperLibrary_InGame>();
	}
};
static_assert(alignof(UTgfInventoryWrapperLibrary_InGame) == 0x000008, "Wrong alignment on UTgfInventoryWrapperLibrary_InGame");
static_assert(sizeof(UTgfInventoryWrapperLibrary_InGame) == 0x000028, "Wrong size on UTgfInventoryWrapperLibrary_InGame");

// Class LyraGame.LyraInputComponent
// 0x0000 (0x0168 - 0x0168)
class ULyraInputComponent final : public UEnhancedInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputComponent">();
	}
	static class ULyraInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputComponent>();
	}
};
static_assert(alignof(ULyraInputComponent) == 0x000008, "Wrong alignment on ULyraInputComponent");
static_assert(sizeof(ULyraInputComponent) == 0x000168, "Wrong size on ULyraInputComponent");

// Class LyraGame.TgfItemAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UTgfItemAnimInstance : public UAnimInstance
{
public:
	bool IsOnDedicatedServer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfItemAnimInstance">();
	}
	static class UTgfItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfItemAnimInstance>();
	}
};
static_assert(alignof(UTgfItemAnimInstance) == 0x000010, "Wrong alignment on UTgfItemAnimInstance");
static_assert(sizeof(UTgfItemAnimInstance) == 0x000350, "Wrong size on UTgfItemAnimInstance");

// Class LyraGame.TgfItemCosmeticComponent
// 0x0018 (0x00C0 - 0x00A8)
class UTgfItemCosmeticComponent final : public UPawnComponent
{
public:
	struct FSkinDataPack                          CosmeticData;                                      // 0x00A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)

public:
	void CleanSlotSkins();
	TArray<int32> GetAllSkinIDs();
	TSubclassOf<class ULyraInventoryItemDefinition> GetBestFitDefByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> Def, int32 SkinId);
	TSubclassOf<class ULyraInventoryItemDefinition> GetBestFitDefByInstance(const class ULyraInventoryItemInstance* Instance);
	struct FTgfItemEffectDefinition GetBestFitKillEffect(int32 SkinId);
	int32 GetSlotSkinId(ETgfSkinSlot Type, ETgfSkinCategory Category);
	void SetPushedData();
	void SetSlotSkinId(ETgfSkinSlot Type, ETgfSkinCategory SkinCategory, int32 SkinId);
	void SetSlotSkinIdServerOnly(ETgfSkinSlot Part, int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfItemCosmeticComponent">();
	}
	static class UTgfItemCosmeticComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfItemCosmeticComponent>();
	}
};
static_assert(alignof(UTgfItemCosmeticComponent) == 0x000008, "Wrong alignment on UTgfItemCosmeticComponent");
static_assert(sizeof(UTgfItemCosmeticComponent) == 0x0000C0, "Wrong size on UTgfItemCosmeticComponent");
static_assert(offsetof(UTgfItemCosmeticComponent, CosmeticData) == 0x0000A8, "Member 'UTgfItemCosmeticComponent::CosmeticData' has a wrong offset!");

// Class LyraGame.LyraWorldSettings
// 0x0030 (0x04F0 - 0x04C0)
class ALyraWorldSettings final : public AWorldSettings
{
public:
	TSoftClassPtr<class UClass>                   DefaultGameplayExperience;                         // 0x04C0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWorldSettings">();
	}
	static class ALyraWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraWorldSettings>();
	}
};
static_assert(alignof(ALyraWorldSettings) == 0x000008, "Wrong alignment on ALyraWorldSettings");
static_assert(sizeof(ALyraWorldSettings) == 0x0004F0, "Wrong size on ALyraWorldSettings");
static_assert(offsetof(ALyraWorldSettings, DefaultGameplayExperience) == 0x0004C0, "Member 'ALyraWorldSettings::DefaultGameplayExperience' has a wrong offset!");

// Class LyraGame.TgfItemWidget
// 0x0040 (0x02F0 - 0x02B0)
class UTgfItemWidget : public UTgfGameWidgetBase
{
public:
	struct FGameplayTagContainer                  CooldownTags;                                      // 0x02B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         CDTotalTime;                                       // 0x02D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CDRemainTime;                                      // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedHideDuration;                                 // 0x02D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideDurationLimit;                                 // 0x02DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraAbilitySystemComponent*            LyraASC;                                           // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCooldownStart();
	class FString FormatCooldownTime(float CDTime);
	void SetCoolDownTags(TSubclassOf<class UTgfGameplayAbility> GAClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfItemWidget">();
	}
	static class UTgfItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfItemWidget>();
	}
};
static_assert(alignof(UTgfItemWidget) == 0x000008, "Wrong alignment on UTgfItemWidget");
static_assert(sizeof(UTgfItemWidget) == 0x0002F0, "Wrong size on UTgfItemWidget");
static_assert(offsetof(UTgfItemWidget, CooldownTags) == 0x0002B0, "Member 'UTgfItemWidget::CooldownTags' has a wrong offset!");
static_assert(offsetof(UTgfItemWidget, CDTotalTime) == 0x0002D0, "Member 'UTgfItemWidget::CDTotalTime' has a wrong offset!");
static_assert(offsetof(UTgfItemWidget, CDRemainTime) == 0x0002D4, "Member 'UTgfItemWidget::CDRemainTime' has a wrong offset!");
static_assert(offsetof(UTgfItemWidget, bNeedHideDuration) == 0x0002D8, "Member 'UTgfItemWidget::bNeedHideDuration' has a wrong offset!");
static_assert(offsetof(UTgfItemWidget, HideDurationLimit) == 0x0002DC, "Member 'UTgfItemWidget::HideDurationLimit' has a wrong offset!");
static_assert(offsetof(UTgfItemWidget, LyraASC) == 0x0002E0, "Member 'UTgfItemWidget::LyraASC' has a wrong offset!");

// Class LyraGame.TgfLevelCheats
// 0x0000 (0x0028 - 0x0028)
class UTgfLevelCheats final : public UCheatManagerExtension
{
public:
	void ActivateAllEscapeDevices();
	void DsQuitGame(int32 Type);
	void EndCurrentPhase();
	void ForceGC(bool CallServer, bool FullPurge);
	void MultiWorldTravel(const class FString& MapPath);
	void PrintPortalLocations(int32 PortalType);
	void SetDeathZoneEnabled(int32 Enabled);
	void ShowBattleId(bool bIsShow);
	void ShowGoblinThief();
	void ShowHurtNum(bool bIsShow);
	void ShowPing(bool bIsShow);
	void ShowServerFPS();
	void SpawnAllEscapeDevices();
	void SpawnAllPortalsAndScrolls();
	void SpawnOnePortal(int32 PortalType);
	void WaitingRoomCountdown(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfLevelCheats">();
	}
	static class UTgfLevelCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfLevelCheats>();
	}
};
static_assert(alignof(UTgfLevelCheats) == 0x000008, "Wrong alignment on UTgfLevelCheats");
static_assert(sizeof(UTgfLevelCheats) == 0x000028, "Wrong size on UTgfLevelCheats");

// Class LyraGame.LyraCharacter
// 0x01F0 (0x0820 - 0x0630)
class ALyraCharacter : public AModularCharacter
{
public:
	uint8                                         Pad_630[0x20];                                     // 0x0630(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             CharacterMoveBlockedDelegate;                      // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CharacterId;                                       // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_664[0x7C];                                     // 0x0664(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraPawnExtensionComponent*            PawnExtComponent;                                  // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfAttributeComponent*                 AttributeComponent;                                // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfBattleSecurityComponent*            BattleSecComponent;                                // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfCharacterAvatarComponent*           CharacterAvatarComponent;                          // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfCharacterAnimationHelperComponent*  AnimationHelperComponent;                          // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorMapComponent*                     ActorMapComponent;                                 // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfAuraManagerComponent*               AuraManagerComponent;                              // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLyraReplicatedAcceleration            ReplicatedAcceleration;                            // 0x0718(0x0003)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGenericTeamId                         MyTeamID;                                          // 0x071B(0x0001)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x0720(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	ETgfActorType                                 ActorType;                                         // 0x0730(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActorRoleTypeId;                                   // 0x0734(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfActorCareer                               ActorCareer;                                       // 0x0738(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfActorRace                                 ActorRace;                                         // 0x0739(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfActorGender                               ActorGender;                                       // 0x073A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73B[0x1];                                      // 0x073B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActorLevel;                                        // 0x073C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActorExp;                                          // 0x0740(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultGravityScale;                               // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 ActorStatIdList;                                   // 0x0748(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0760(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SpawnTransformSet;                                 // 0x07C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfActorCareer                               DisplayActorCareer;                                // 0x07C1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfActorRace                                 DisplayActorRace;                                  // 0x07C2(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreeze;                                           // 0x07C3(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C4[0x4];                                      // 0x07C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EyePitchOffset;                                    // 0x07C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractPortal;                                   // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnForceUseThirdPersonMesh;                         // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 DefaultCharacterName;                              // 0x07F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMithrilRebirthChanceExhausted;                   // 0x0800(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ReplicatedGravityScale;                            // 0x0810(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicatedCanWalkOffLedges;                       // 0x0814(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableActorMap;                                   // 0x0815(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_816[0x2];                                      // 0x0816(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MonsterBoundRate;                                  // 0x0818(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceAlwaysRelevent;                               // 0x081C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableDistanceSlowReplicateRate;                  // 0x081D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81E[0x2];                                      // 0x081E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallFreezeAction(bool bIsFreeze);
	void CollectMeshComponents(TArray<class UMeshComponent*>* Meshes);
	void ConsumeMithrilRebirthChance();
	void CopyAttachMentActors(class ALyraCharacter* SrcCharacter, class UClass* baseClass);
	void DestoryAttachMentActors(class UClass* baseClass);
	void DisableAvatarMeshClothSimulation(bool bDisable);
	void DisableMovementAndCollision();
	void ExcuteWhenExtractPortal(bool bWaiting);
	void FastSharedReplication(const struct FSharedRepMovement& SharedRepMovement);
	class ATgfAvatarActor* GetActiveAvatarActor();
	class FString GetDebugInfoString();
	ETgfActorCareer GetDisplayCareer();
	ETgfActorRace GetDisplayRace();
	bool HasInPortalTags(EPortalTagType Type);
	void LinkDefaultAnimLayer();
	void OnCancelRebirth(class AActor* Actor);
	void OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);
	void OnCosmeticViewChanged(bool IsFirstPerson);
	void OnDeathFinished(class AActor* OwningActor);
	void OnDeathStarted(class AActor* OwningActor);
	void OnFinishRebirth(class AActor* Actor);
	void OnRep_Avatar();
	void OnRep_DisplayActorCareer();
	void OnRep_DisplayActorRace();
	void OnRep_Freeze();
	void OnRep_GravityScale();
	void OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID);
	void OnRep_ReplicatedAcceleration();
	void OnRep_ReplicatedCanWalkOffLedges();
	void OnRepMyOpenId();
	void OnStartEscaping(class AActor* Actor);
	void OnStartRebirth(class AActor* Actor);
	void OnTravelAsSpectator(class AActor* Actor);
	void RemoveGameplayEffectWithGrantedTags(const struct FGameplayTagContainer& WithGrantedTags, int32 StacksToRemove);
	void ResetMovementAndCollision();
	void RestoredDefaultGravityScale();
	void ServerRPCChangeGender(int32 Param_Index);
	void ServerRPCChangeRace(int32 Param_Index);
	void ServerRPCNavigation(const struct FVector& DstLocation);
	void ServerRPCNavigationToActor(const class AActor* Goal);
	void SetAITick(bool Enabled);
	void SetClientTick(bool Enabled, ETgfPauseClientTickReason Reason);
	void SetClientTick_BP(bool Enabled);
	void SetComponentTick(bool Enabled, ETgfPauseActorTickReason Reason);
	void SetComponentTick_BP(bool Enabled);
	void SetDisplayCareer(ETgfActorCareer InCareer);
	void SetDisplayRace(ETgfActorRace InRace);
	void SetDSMeshTick(bool Enabled, ETgfPauseDSMeshTickReason Reason);
	void SetFreezeState(bool bFreezeState);
	void SetGravityScale(float Gravity, bool CacheDefault, bool NeedReplicate);
	void SetUseControllerRotation(bool bValue);
	bool ShouldAddTeammateMarker(class ALyraCharacter* Target, bool Summoned, bool IgnoreTarget, bool IgnoreDeath);
	void TickAnimationOnce();
	void ToggleAvatarMeshPostProcessBP();
	void ToggleCapsuleCollision(bool bEnable);
	void TriggerDebugTestInput();
	void TriggerInput(const class FString& InputStr);
	void TriggerInputContinous(const class FString& InputStr);

	ETgfActorCareer GetActorCareer() const;
	int32 GetActorExp() const;
	ETgfActorGender GetActorGender() const;
	int32 GetActorLevel() const;
	ETgfActorRace GetActorRace() const;
	int32 GetActorRoleTypeId() const;
	const TArray<int32> GetActorStatIdList() const;
	ETgfActorType GetActorType() const;
	class UTgfCharacterAvatarComponent* GetAvatarComponent() const;
	class FString GetCharacterName() const;
	class FString GetCharacterOpenId() const;
	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;
	class ALyraPlayerController* GetLyraPlayerController() const;
	class ALyraPlayerState* GetLyraPlayerState() const;
	class UTgfRagdollComponent* GetRagdollComponent() const;
	struct FTransform GetSpawnTransform() const;
	bool HasInventoryItem(TSubclassOf<class ULyraInventoryItemDefinition> ItemDefine) const;
	bool IsDeadOrDying() const;
	bool IsFirstPersonCharacter() const;
	bool IsMithrillCharacter() const;
	bool IsNotAlive() const;
	bool IsOnlyServerSide() const;
	bool IsOnlySpectator() const;
	bool IsPendingDeath() const;
	bool MithrilResurrecting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCharacter">();
	}
	static class ALyraCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraCharacter>();
	}
};
static_assert(alignof(ALyraCharacter) == 0x000010, "Wrong alignment on ALyraCharacter");
static_assert(sizeof(ALyraCharacter) == 0x000820, "Wrong size on ALyraCharacter");
static_assert(offsetof(ALyraCharacter, CharacterMoveBlockedDelegate) == 0x000650, "Member 'ALyraCharacter::CharacterMoveBlockedDelegate' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, CharacterId) == 0x000660, "Member 'ALyraCharacter::CharacterId' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, PawnExtComponent) == 0x0006E0, "Member 'ALyraCharacter::PawnExtComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, AttributeComponent) == 0x0006E8, "Member 'ALyraCharacter::AttributeComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, BattleSecComponent) == 0x0006F0, "Member 'ALyraCharacter::BattleSecComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, CharacterAvatarComponent) == 0x0006F8, "Member 'ALyraCharacter::CharacterAvatarComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, AnimationHelperComponent) == 0x000700, "Member 'ALyraCharacter::AnimationHelperComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorMapComponent) == 0x000708, "Member 'ALyraCharacter::ActorMapComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, AuraManagerComponent) == 0x000710, "Member 'ALyraCharacter::AuraManagerComponent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ReplicatedAcceleration) == 0x000718, "Member 'ALyraCharacter::ReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, MyTeamID) == 0x00071B, "Member 'ALyraCharacter::MyTeamID' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, OnTeamChangedDelegate) == 0x000720, "Member 'ALyraCharacter::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorType) == 0x000730, "Member 'ALyraCharacter::ActorType' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorRoleTypeId) == 0x000734, "Member 'ALyraCharacter::ActorRoleTypeId' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorCareer) == 0x000738, "Member 'ALyraCharacter::ActorCareer' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorRace) == 0x000739, "Member 'ALyraCharacter::ActorRace' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorGender) == 0x00073A, "Member 'ALyraCharacter::ActorGender' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorLevel) == 0x00073C, "Member 'ALyraCharacter::ActorLevel' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorExp) == 0x000740, "Member 'ALyraCharacter::ActorExp' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, DefaultGravityScale) == 0x000744, "Member 'ALyraCharacter::DefaultGravityScale' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ActorStatIdList) == 0x000748, "Member 'ALyraCharacter::ActorStatIdList' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, SpawnTransform) == 0x000760, "Member 'ALyraCharacter::SpawnTransform' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, SpawnTransformSet) == 0x0007C0, "Member 'ALyraCharacter::SpawnTransformSet' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, DisplayActorCareer) == 0x0007C1, "Member 'ALyraCharacter::DisplayActorCareer' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, DisplayActorRace) == 0x0007C2, "Member 'ALyraCharacter::DisplayActorRace' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, bFreeze) == 0x0007C3, "Member 'ALyraCharacter::bFreeze' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, EyePitchOffset) == 0x0007C8, "Member 'ALyraCharacter::EyePitchOffset' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, OnExtractPortal) == 0x0007D0, "Member 'ALyraCharacter::OnExtractPortal' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, OnForceUseThirdPersonMesh) == 0x0007E0, "Member 'ALyraCharacter::OnForceUseThirdPersonMesh' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, DefaultCharacterName) == 0x0007F0, "Member 'ALyraCharacter::DefaultCharacterName' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, OnMithrilRebirthChanceExhausted) == 0x000800, "Member 'ALyraCharacter::OnMithrilRebirthChanceExhausted' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ReplicatedGravityScale) == 0x000810, "Member 'ALyraCharacter::ReplicatedGravityScale' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, bReplicatedCanWalkOffLedges) == 0x000814, "Member 'ALyraCharacter::bReplicatedCanWalkOffLedges' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, DisableActorMap) == 0x000815, "Member 'ALyraCharacter::DisableActorMap' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, MonsterBoundRate) == 0x000818, "Member 'ALyraCharacter::MonsterBoundRate' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, ForceAlwaysRelevent) == 0x00081C, "Member 'ALyraCharacter::ForceAlwaysRelevent' has a wrong offset!");
static_assert(offsetof(ALyraCharacter, DisableDistanceSlowReplicateRate) == 0x00081D, "Member 'ALyraCharacter::DisableDistanceSlowReplicateRate' has a wrong offset!");

// Class LyraGame.LyraCharacterWithAbilities
// 0x0010 (0x0830 - 0x0820)
class ALyraCharacterWithAbilities : public ALyraCharacter
{
public:
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0820(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCharacterWithAbilities">();
	}
	static class ALyraCharacterWithAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraCharacterWithAbilities>();
	}
};
static_assert(alignof(ALyraCharacterWithAbilities) == 0x000010, "Wrong alignment on ALyraCharacterWithAbilities");
static_assert(sizeof(ALyraCharacterWithAbilities) == 0x000830, "Wrong size on ALyraCharacterWithAbilities");
static_assert(offsetof(ALyraCharacterWithAbilities, AbilitySystemComponent) == 0x000820, "Member 'ALyraCharacterWithAbilities::AbilitySystemComponent' has a wrong offset!");

// Class LyraGame.TgfListView
// 0x0010 (0x0C30 - 0x0C20)
class UTgfListView final : public UCommonListView
{
public:
	FMulticastInlineDelegateProperty_             BP_OnListViewScrolled;                             // 0x0C20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfListView">();
	}
	static class UTgfListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfListView>();
	}
};
static_assert(alignof(UTgfListView) == 0x000010, "Wrong alignment on UTgfListView");
static_assert(sizeof(UTgfListView) == 0x000C30, "Wrong size on UTgfListView");
static_assert(offsetof(UTgfListView, BP_OnListViewScrolled) == 0x000C20, "Member 'UTgfListView::BP_OnListViewScrolled' has a wrong offset!");

// Class LyraGame.TgfObjectListEntry
// 0x0000 (0x0028 - 0x0028)
class ITgfObjectListEntry final : public IUserObjectListEntry
{
public:
	void OnHovered();
	void OnUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfObjectListEntry">();
	}
	static class ITgfObjectListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITgfObjectListEntry>();
	}
};
static_assert(alignof(ITgfObjectListEntry) == 0x000008, "Wrong alignment on ITgfObjectListEntry");
static_assert(sizeof(ITgfObjectListEntry) == 0x000028, "Wrong size on ITgfObjectListEntry");

// Class LyraGame.LyraPawnData
// 0x0068 (0x0098 - 0x0030)
class ULyraPawnData final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class APawn>                      PawnClass;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULyraAbilitySet*>                AbilitySets;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class ULyraAbilityTagRelationshipMapping*     TagRelationshipMapping;                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULyraInputConfig*                       InputConfig;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULyraCameraMode>            DefaultCameraMode;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraCameraSelection>           CameraRulesWithTag;                                // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FLyraCameraSelection>           CamerasWithHigherPriorityThanAbility;              // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ULyraCameraMode>            SpectatorCameraMode;                               // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraCameraSelection>           CameraRulesWithTagWhenSpectated;                   // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPawnData">();
	}
	static class ULyraPawnData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPawnData>();
	}
};
static_assert(alignof(ULyraPawnData) == 0x000008, "Wrong alignment on ULyraPawnData");
static_assert(sizeof(ULyraPawnData) == 0x000098, "Wrong size on ULyraPawnData");
static_assert(offsetof(ULyraPawnData, PawnClass) == 0x000030, "Member 'ULyraPawnData::PawnClass' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, AbilitySets) == 0x000038, "Member 'ULyraPawnData::AbilitySets' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, TagRelationshipMapping) == 0x000048, "Member 'ULyraPawnData::TagRelationshipMapping' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, InputConfig) == 0x000050, "Member 'ULyraPawnData::InputConfig' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, DefaultCameraMode) == 0x000058, "Member 'ULyraPawnData::DefaultCameraMode' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, CameraRulesWithTag) == 0x000060, "Member 'ULyraPawnData::CameraRulesWithTag' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, CamerasWithHigherPriorityThanAbility) == 0x000070, "Member 'ULyraPawnData::CamerasWithHigherPriorityThanAbility' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, SpectatorCameraMode) == 0x000080, "Member 'ULyraPawnData::SpectatorCameraMode' has a wrong offset!");
static_assert(offsetof(ULyraPawnData, CameraRulesWithTagWhenSpectated) == 0x000088, "Member 'ULyraPawnData::CameraRulesWithTagWhenSpectated' has a wrong offset!");

// Class LyraGame.TgfLyraInteractComponent
// 0x0008 (0x00B0 - 0x00A8)
class UTgfLyraInteractComponent final : public UControllerComponent
{
public:
	bool                                          ChargeSkillMethod;                                 // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MouseTargetingMethod;                              // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSettingScreenDestruct(class UObject* Args);
	void InitSkillInputMethod();
	void RefreshServerSkillInputMethod(bool InputChargeSkillMethod, bool InputMouseTargetingMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfLyraInteractComponent">();
	}
	static class UTgfLyraInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfLyraInteractComponent>();
	}
};
static_assert(alignof(UTgfLyraInteractComponent) == 0x000008, "Wrong alignment on UTgfLyraInteractComponent");
static_assert(sizeof(UTgfLyraInteractComponent) == 0x0000B0, "Wrong size on UTgfLyraInteractComponent");
static_assert(offsetof(UTgfLyraInteractComponent, ChargeSkillMethod) == 0x0000A8, "Member 'UTgfLyraInteractComponent::ChargeSkillMethod' has a wrong offset!");
static_assert(offsetof(UTgfLyraInteractComponent, MouseTargetingMethod) == 0x0000A9, "Member 'UTgfLyraInteractComponent::MouseTargetingMethod' has a wrong offset!");

// Class LyraGame.TgfMagicAttributeSet
// 0x0090 (0x00C0 - 0x0030)
class UTgfMagicAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 CurMagic;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicOnHit;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicOnKill;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicOnHurt;                                       // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicOverTime;                                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicGenerateRate;                                 // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxMagicBase;                                      // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxMagicPercent;                                   // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicDeltaValue;                                   // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_CurMagic(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicGenerateRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicOnHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicOnHurt(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicOnKill(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicOverTime(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxMagicBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxMagicPercent(const struct FGameplayAttributeData& OldValue);

	float GetMaxMagicFinal() const;
	bool IsFullMP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMagicAttributeSet">();
	}
	static class UTgfMagicAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfMagicAttributeSet>();
	}
};
static_assert(alignof(UTgfMagicAttributeSet) == 0x000008, "Wrong alignment on UTgfMagicAttributeSet");
static_assert(sizeof(UTgfMagicAttributeSet) == 0x0000C0, "Wrong size on UTgfMagicAttributeSet");
static_assert(offsetof(UTgfMagicAttributeSet, CurMagic) == 0x000030, "Member 'UTgfMagicAttributeSet::CurMagic' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MagicOnHit) == 0x000040, "Member 'UTgfMagicAttributeSet::MagicOnHit' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MagicOnKill) == 0x000050, "Member 'UTgfMagicAttributeSet::MagicOnKill' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MagicOnHurt) == 0x000060, "Member 'UTgfMagicAttributeSet::MagicOnHurt' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MagicOverTime) == 0x000070, "Member 'UTgfMagicAttributeSet::MagicOverTime' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MagicGenerateRate) == 0x000080, "Member 'UTgfMagicAttributeSet::MagicGenerateRate' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MaxMagicBase) == 0x000090, "Member 'UTgfMagicAttributeSet::MaxMagicBase' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MaxMagicPercent) == 0x0000A0, "Member 'UTgfMagicAttributeSet::MaxMagicPercent' has a wrong offset!");
static_assert(offsetof(UTgfMagicAttributeSet, MagicDeltaValue) == 0x0000B0, "Member 'UTgfMagicAttributeSet::MagicDeltaValue' has a wrong offset!");

// Class LyraGame.LyraActivatableWidget
// 0x0008 (0x03F0 - 0x03E8)
class ULyraActivatableWidget : public UCommonActivatableWidget
{
public:
	ELyraWidgetInputMode                          InputConfig;                                       // 0x03E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMouseCaptureMode                             GameMouseCaptureMode;                              // 0x03E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EA[0x6];                                      // 0x03EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraActivatableWidget">();
	}
	static class ULyraActivatableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraActivatableWidget>();
	}
};
static_assert(alignof(ULyraActivatableWidget) == 0x000008, "Wrong alignment on ULyraActivatableWidget");
static_assert(sizeof(ULyraActivatableWidget) == 0x0003F0, "Wrong size on ULyraActivatableWidget");
static_assert(offsetof(ULyraActivatableWidget, InputConfig) == 0x0003E8, "Member 'ULyraActivatableWidget::InputConfig' has a wrong offset!");
static_assert(offsetof(ULyraActivatableWidget, GameMouseCaptureMode) == 0x0003E9, "Member 'ULyraActivatableWidget::GameMouseCaptureMode' has a wrong offset!");

// Class LyraGame.LyraControllerComponent_CharacterParts
// 0x0010 (0x00B8 - 0x00A8)
class ULyraControllerComponent_CharacterParts final : public UControllerComponent
{
public:
	TArray<struct FLyraControllerCharacterPartEntry> CharacterParts;                                    // 0x00A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddCharacterPart(const struct FLyraCharacterPart& NewPart);
	bool AddTgfSplitPart(const struct FTgfCharaPartChangeConfig& NewPart);
	void OnControlledCharacterDead();
	void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void RemoveAllCharacterParts();
	void RemoveCharacterPart(const struct FLyraCharacterPart& PartToRemove);
	void RemoveTgfSplitPart(ETgfCharaPart PartEnum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraControllerComponent_CharacterParts">();
	}
	static class ULyraControllerComponent_CharacterParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraControllerComponent_CharacterParts>();
	}
};
static_assert(alignof(ULyraControllerComponent_CharacterParts) == 0x000008, "Wrong alignment on ULyraControllerComponent_CharacterParts");
static_assert(sizeof(ULyraControllerComponent_CharacterParts) == 0x0000B8, "Wrong size on ULyraControllerComponent_CharacterParts");
static_assert(offsetof(ULyraControllerComponent_CharacterParts, CharacterParts) == 0x0000A8, "Member 'ULyraControllerComponent_CharacterParts::CharacterParts' has a wrong offset!");

// Class LyraGame.TgfMapWidgetBase
// 0x0050 (0x0440 - 0x03F0)
class UTgfMapWidgetBase final : public ULyraActivatableWidget
{
public:
	TMap<ETGFBriefMapViewBorderType, float>       MapBorderPlayerRotatorMap;                         // 0x03F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FVector2D NativeAbsoluteUVPosToUniformViewportPosition(const struct FVector2D& InAbsoluteUVPos, const struct FLinearColor& InViewportRect);
	struct FLinearColor NativeCalculateUVRect(const struct FVector4& InMapBounds, const struct FVector2D& InMapUVScale);
	bool NativeCheckInPlayerView(const struct FVector& InActorLoc, const float& InPlayerViewSize, const class UWidget* InMapArea, const struct FVector4& InMapBounds, const struct FVector2D& InMapUVScale, struct FVector2D* OutWidgetPos, struct FVector2D* OutBorderPos, float* OutBorderRotator);
	bool NativeGetBorderIntersection(const struct FVector2D& BorderA, const struct FVector2D& BorderB, const struct FVector2D& BorderC, const struct FVector2D& BorderD, struct FVector2D* OutIntersectionLoc);
	struct FVector2D NativeGetOutViewBorderViewData(const struct FVector2D& InLeftBottom, const struct FVector2D& InLeftTop, const struct FVector2D& InRightBottom, const struct FVector2D& InRightTop, const struct FVector2D& InTargetLocation, const struct FVector2D& InViewCenterLocation, float* OutBorderPlayerRotator);
	void NativeUpdatePlayerWidgetRenderTransform(const class AActor* InActor, const struct FLinearColor& InUVRect, class UWidget* InWidget, const class UWidget* InMapArea, const struct FVector4& InMapBounds);
	struct FVector2D NativeWorldPositionToAbsoluteUVPosition(const struct FVector& InWorldLoc, const struct FVector4& InMapBounds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMapWidgetBase">();
	}
	static class UTgfMapWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfMapWidgetBase>();
	}
};
static_assert(alignof(UTgfMapWidgetBase) == 0x000008, "Wrong alignment on UTgfMapWidgetBase");
static_assert(sizeof(UTgfMapWidgetBase) == 0x000440, "Wrong size on UTgfMapWidgetBase");
static_assert(offsetof(UTgfMapWidgetBase, MapBorderPlayerRotatorMap) == 0x0003F0, "Member 'UTgfMapWidgetBase::MapBorderPlayerRotatorMap' has a wrong offset!");

// Class LyraGame.TgfMaterialParameterModifierInterface
// 0x0000 (0x0028 - 0x0028)
class ITgfMaterialParameterModifierInterface final : public IInterface
{
public:
	class USkeletalMeshComponent* GetMesh();
	void SetMaterialParameter_Float(class FName Param, float Value);

	bool EnableDynamicMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMaterialParameterModifierInterface">();
	}
	static class ITgfMaterialParameterModifierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITgfMaterialParameterModifierInterface>();
	}
};
static_assert(alignof(ITgfMaterialParameterModifierInterface) == 0x000008, "Wrong alignment on ITgfMaterialParameterModifierInterface");
static_assert(sizeof(ITgfMaterialParameterModifierInterface) == 0x000028, "Wrong size on ITgfMaterialParameterModifierInterface");

// Class LyraGame.LyraQuickBarComponent
// 0x0028 (0x00D0 - 0x00A8)
class ULyraQuickBarComponent final : public UControllerComponent
{
public:
	int32                                         NumSlots;                                          // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULyraInventoryItemInstance*>     Slots;                                             // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         ActiveSlotIndex;                                   // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraEquipmentInstance*                 EquippedItem;                                      // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddItemToSlot(int32 SlotIndex, class ULyraInventoryItemInstance* Item);
	void CycleActiveSlotBackward();
	void CycleActiveSlotForward();
	void OnRep_ActiveSlotIndex();
	void OnRep_Slots();
	class ULyraInventoryItemInstance* RemoveItemFromSlot(int32 SlotIndex);
	void SetActiveSlotIndex(int32 NewIndex);

	int32 GetActiveSlotIndex() const;
	class ULyraInventoryItemInstance* GetActiveSlotItem() const;
	int32 GetNextFreeItemSlot() const;
	TArray<class ULyraInventoryItemInstance*> GetSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraQuickBarComponent">();
	}
	static class ULyraQuickBarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraQuickBarComponent>();
	}
};
static_assert(alignof(ULyraQuickBarComponent) == 0x000008, "Wrong alignment on ULyraQuickBarComponent");
static_assert(sizeof(ULyraQuickBarComponent) == 0x0000D0, "Wrong size on ULyraQuickBarComponent");
static_assert(offsetof(ULyraQuickBarComponent, NumSlots) == 0x0000A8, "Member 'ULyraQuickBarComponent::NumSlots' has a wrong offset!");
static_assert(offsetof(ULyraQuickBarComponent, Slots) == 0x0000B0, "Member 'ULyraQuickBarComponent::Slots' has a wrong offset!");
static_assert(offsetof(ULyraQuickBarComponent, ActiveSlotIndex) == 0x0000C0, "Member 'ULyraQuickBarComponent::ActiveSlotIndex' has a wrong offset!");
static_assert(offsetof(ULyraQuickBarComponent, EquippedItem) == 0x0000C8, "Member 'ULyraQuickBarComponent::EquippedItem' has a wrong offset!");

// Class LyraGame.TgfMonsterPostAnim
// 0x00A0 (0x03F0 - 0x0350)
class UTgfMonsterPostAnim final : public UAnimInstance
{
public:
	float                                         Alpha;                                             // 0x0348(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FVector>             BoneComputeList;                                   // 0x0350(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             BonePositionList;                                  // 0x03A0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMonsterPostAnim">();
	}
	static class UTgfMonsterPostAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfMonsterPostAnim>();
	}
};
static_assert(alignof(UTgfMonsterPostAnim) == 0x000010, "Wrong alignment on UTgfMonsterPostAnim");
static_assert(sizeof(UTgfMonsterPostAnim) == 0x0003F0, "Wrong size on UTgfMonsterPostAnim");
static_assert(offsetof(UTgfMonsterPostAnim, Alpha) == 0x000348, "Member 'UTgfMonsterPostAnim::Alpha' has a wrong offset!");
static_assert(offsetof(UTgfMonsterPostAnim, BoneComputeList) == 0x000350, "Member 'UTgfMonsterPostAnim::BoneComputeList' has a wrong offset!");
static_assert(offsetof(UTgfMonsterPostAnim, BonePositionList) == 0x0003A0, "Member 'UTgfMonsterPostAnim::BonePositionList' has a wrong offset!");

// Class LyraGame.TgfMonsterReaction
// 0x0080 (0x0128 - 0x00A8)
class UTgfMonsterReaction final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCharaHitMonster;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bNeedHitReact;                                     // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             BoneNamePositionMap;                               // 0x00D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void ComputeBonePositions(class UTgfMonsterPostAnim* MonsterPostProcessAnim, float DirectionIntensity, float Alpha);
	void ComputeHitDirection(class AActor* FirstChara);
	class UTgfMonsterPostAnim* GetPostProcessAnim();
	void ResetBonePositions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMonsterReaction">();
	}
	static class UTgfMonsterReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfMonsterReaction>();
	}
};
static_assert(alignof(UTgfMonsterReaction) == 0x000008, "Wrong alignment on UTgfMonsterReaction");
static_assert(sizeof(UTgfMonsterReaction) == 0x000128, "Wrong size on UTgfMonsterReaction");
static_assert(offsetof(UTgfMonsterReaction, OnCharaHitMonster) == 0x0000A8, "Member 'UTgfMonsterReaction::OnCharaHitMonster' has a wrong offset!");
static_assert(offsetof(UTgfMonsterReaction, bNeedHitReact) == 0x0000B8, "Member 'UTgfMonsterReaction::bNeedHitReact' has a wrong offset!");
static_assert(offsetof(UTgfMonsterReaction, bDrawDebug) == 0x0000B9, "Member 'UTgfMonsterReaction::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UTgfMonsterReaction, Intensity) == 0x0000BC, "Member 'UTgfMonsterReaction::Intensity' has a wrong offset!");
static_assert(offsetof(UTgfMonsterReaction, HitDirection) == 0x0000C0, "Member 'UTgfMonsterReaction::HitDirection' has a wrong offset!");
static_assert(offsetof(UTgfMonsterReaction, BoneNamePositionMap) == 0x0000D8, "Member 'UTgfMonsterReaction::BoneNamePositionMap' has a wrong offset!");

// Class LyraGame.TgfMovementCollision
// 0x0030 (0x05A0 - 0x0570)
class UTgfMovementCollision final : public UCapsuleComponent
{
public:
	class UCurveFloat*                            CollisionYOffsetCurve;                             // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CollisionZOffsetCurve;                             // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x28];                                     // 0x0578(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMovementCollision">();
	}
	static class UTgfMovementCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfMovementCollision>();
	}
};
static_assert(alignof(UTgfMovementCollision) == 0x000010, "Wrong alignment on UTgfMovementCollision");
static_assert(sizeof(UTgfMovementCollision) == 0x0005A0, "Wrong size on UTgfMovementCollision");
static_assert(offsetof(UTgfMovementCollision, CollisionYOffsetCurve) == 0x000568, "Member 'UTgfMovementCollision::CollisionYOffsetCurve' has a wrong offset!");
static_assert(offsetof(UTgfMovementCollision, CollisionZOffsetCurve) == 0x000570, "Member 'UTgfMovementCollision::CollisionZOffsetCurve' has a wrong offset!");

// Class LyraGame.TgfAttributeComponent
// 0x0428 (0x04D0 - 0x00A8)
class UTgfAttributeComponent final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDeathStarted;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeathFinished;                                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRebirthStart;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRebirthCanceled;                                 // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRebirthFinish;                                   // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEscapingStart;                                   // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTravelAsSpectator;                               // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemDropOnDeath;                                 // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageCaused;                                    // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageTaken;                                     // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKillingCaused;                                   // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKillingTaken;                                    // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttrChanged;                                     // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCommonAttrChanged;                               // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTagChanged;                                      // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCommonTagChanged;                                // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttributeInitialized;                            // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamagePartTriggered;                             // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x01C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTgfDamagePartMonitorConfig>    DamagePartConfigList;                              // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTgfDeathStateInfo                     DeathStateInfo;                                    // 0x01E0(0x00F8)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FName                                   CurveGroupName;                                    // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurveLevel;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAttribute>             ChangeCallBackAttrList;                            // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTgfFirstLevelAttrDataAsset*            FirstLevelConfig;                                  // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULyraAbilitySet*>                DefaultAbilitySetsToGrant;                         // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ULyraAbilityTagRelationshipMapping*     TagRelationshipMapping;                            // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLyraAbilitySet_GrantedHandles         GrantedHandles;                                    // 0x0318(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLyraAbilitySet_GrantedHandles         DefaultGrantedHandles;                             // 0x0398(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0xA0];                                     // 0x0418(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxEventRecursion;                                 // 0x04B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttrCommonEventStackFrame>     EventStackFrame;                                   // 0x04C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UTgfAttributeComponent* FindAttributeComponent(const class AActor* Actor);

	bool AddDamagePartMonitor(const struct FTgfDamagePartMonitorConfig& NewMonitorConfig, bool CheckUnique);
	void CancelRebirth();
	int32 CheckTriggerDamagePartMonitor(const struct FGameplayTagContainer& InstigatorTags, const struct FGameplayTagContainer& TargetTags, const struct FGameplayTag& RestrictAssetTag, float Damage, int32 Times, bool ForceTrigger);
	void ClearDefaultGranted();
	void ClearTalentGranted();
	void ClientDamageDirectionEvent(const float Direction, bool bIsGuarded, class AActor* DamageInstigator, class AActor* DamageTarget);
	void CopyAttrValueFromASC(class ULyraAbilitySystemComponent* OtherASC, float Rate, bool NeedDirect);
	void DamageSelfDestruct(bool bFellOutOfWorld);
	void DumpAttrValueFromASC(class ULyraAbilitySystemComponent* OtherASC, float Rate);
	struct FTgfResetInitAttrArgs DumpLevelAttr();
	void FinishDeath(bool StopRagdoll);
	void FinishRebirth();
	bool GetDamagePartMonitor(const struct FGameplayTag& AssetTag, struct FTgfDamagePartMonitorConfig* OutConfig);
	void GrantAbilitySet(const class ULyraAbilitySet* AbilitySet);
	void InitDefault(bool NeedReinitAttr, bool NeedResetFirstLevel);
	void InitFirstLevel();
	void InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC);
	void InitTalents();
	void MulticastDeathEvent(class AActor* DamageInstigator, class AActor* DamageTarget);
	void OnRep_DeathStateInfo(const struct FTgfDeathStateInfo& OldDeathStateInfo);
	void RebirthReinitData(bool ReinitInventory);
	void RegistAttrHandlesBP(const struct FGameplayAttribute& Attribute);
	void RegistTagHandlesBP(const struct FGameplayTag& GameplayTag);
	void RemoveDamagePartMonitor(const struct FGameplayTag& DamagePartMonitorTag);
	void ResetInitAttribute(const struct FTgfResetInitAttrArgs& Args);
	void SetInitAttribute(const struct FGameplayAttribute& Attribute, float Value, EGameplayModOp Mod);
	void StartDeath(EAnimConfigDirection DeathDirection, const struct FHitResult& HitResult);
	void StartEscaping();
	void StartRebirth();
	void TravelAsSpectator();
	void UninitializeFromAbilitySystem();
	void UpdateAIAttributes(bool bAngleSpeed, bool bSightDistance, bool bHearingDistance, bool bLightDistance);

	const class UAttributeSet* GetAttributeSet(TSubclassOf<class UAttributeSet> AttributeSetClass) const;
	bool GetDeadOrDying() const;
	EAnimConfigDirection GetDeathDirection() const;
	ETgfDeathState GetDeathState() const;
	struct FHitResult GetHitResult() const;
	bool IsDeadOrDying() const;
	bool IsNotAlive() const;
	bool IsOnlySpectator() const;
	bool IsPendingDeath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAttributeComponent">();
	}
	static class UTgfAttributeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAttributeComponent>();
	}
};
static_assert(alignof(UTgfAttributeComponent) == 0x000008, "Wrong alignment on UTgfAttributeComponent");
static_assert(sizeof(UTgfAttributeComponent) == 0x0004D0, "Wrong size on UTgfAttributeComponent");
static_assert(offsetof(UTgfAttributeComponent, OnDeathStarted) == 0x0000A8, "Member 'UTgfAttributeComponent::OnDeathStarted' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnDeathFinished) == 0x0000B8, "Member 'UTgfAttributeComponent::OnDeathFinished' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnRebirthStart) == 0x0000C8, "Member 'UTgfAttributeComponent::OnRebirthStart' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnRebirthCanceled) == 0x0000D8, "Member 'UTgfAttributeComponent::OnRebirthCanceled' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnRebirthFinish) == 0x0000E8, "Member 'UTgfAttributeComponent::OnRebirthFinish' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnEscapingStart) == 0x0000F8, "Member 'UTgfAttributeComponent::OnEscapingStart' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnTravelAsSpectator) == 0x000108, "Member 'UTgfAttributeComponent::OnTravelAsSpectator' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnItemDropOnDeath) == 0x000118, "Member 'UTgfAttributeComponent::OnItemDropOnDeath' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnDamageCaused) == 0x000128, "Member 'UTgfAttributeComponent::OnDamageCaused' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnDamageTaken) == 0x000138, "Member 'UTgfAttributeComponent::OnDamageTaken' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnKillingCaused) == 0x000148, "Member 'UTgfAttributeComponent::OnKillingCaused' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnKillingTaken) == 0x000158, "Member 'UTgfAttributeComponent::OnKillingTaken' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnAttrChanged) == 0x000168, "Member 'UTgfAttributeComponent::OnAttrChanged' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnCommonAttrChanged) == 0x000178, "Member 'UTgfAttributeComponent::OnCommonAttrChanged' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnTagChanged) == 0x000188, "Member 'UTgfAttributeComponent::OnTagChanged' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnCommonTagChanged) == 0x000198, "Member 'UTgfAttributeComponent::OnCommonTagChanged' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnAttributeInitialized) == 0x0001A8, "Member 'UTgfAttributeComponent::OnAttributeInitialized' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, OnDamagePartTriggered) == 0x0001B8, "Member 'UTgfAttributeComponent::OnDamagePartTriggered' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, AbilitySystemComponent) == 0x0001C8, "Member 'UTgfAttributeComponent::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, DamagePartConfigList) == 0x0001D0, "Member 'UTgfAttributeComponent::DamagePartConfigList' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, DeathStateInfo) == 0x0001E0, "Member 'UTgfAttributeComponent::DeathStateInfo' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, CurveGroupName) == 0x0002D8, "Member 'UTgfAttributeComponent::CurveGroupName' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, CurveLevel) == 0x0002E0, "Member 'UTgfAttributeComponent::CurveLevel' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, ChangeCallBackAttrList) == 0x0002E8, "Member 'UTgfAttributeComponent::ChangeCallBackAttrList' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, FirstLevelConfig) == 0x0002F8, "Member 'UTgfAttributeComponent::FirstLevelConfig' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, DefaultAbilitySetsToGrant) == 0x000300, "Member 'UTgfAttributeComponent::DefaultAbilitySetsToGrant' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, TagRelationshipMapping) == 0x000310, "Member 'UTgfAttributeComponent::TagRelationshipMapping' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, GrantedHandles) == 0x000318, "Member 'UTgfAttributeComponent::GrantedHandles' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, DefaultGrantedHandles) == 0x000398, "Member 'UTgfAttributeComponent::DefaultGrantedHandles' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, MaxEventRecursion) == 0x0004B8, "Member 'UTgfAttributeComponent::MaxEventRecursion' has a wrong offset!");
static_assert(offsetof(UTgfAttributeComponent, EventStackFrame) == 0x0004C0, "Member 'UTgfAttributeComponent::EventStackFrame' has a wrong offset!");

// Class LyraGame.TgfNaturalEnergyAttributeSet
// 0x0090 (0x00C0 - 0x0030)
class UTgfNaturalEnergyAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 CurNaturalEnergy;                                  // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 NaturalEnergyOnHit;                                // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 NaturalEnergyOnKill;                               // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 NaturalEnergyOnHurt;                               // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 NaturalEnergyOverTime;                             // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 NaturalEnergyGenerateRate;                         // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxNaturalEnergyBase;                              // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxNaturalEnergyPercent;                           // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 NaturalEnergyDeltaValue;                           // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_CurNaturalEnergy(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxNaturalEnergyBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxNaturalEnergyPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_NaturalEnergyGenerateRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_NaturalEnergyOnHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_NaturalEnergyOnHurt(const struct FGameplayAttributeData& OldValue);
	void OnRep_NaturalEnergyOnKill(const struct FGameplayAttributeData& OldValue);
	void OnRep_NaturalEnergyOverTime(const struct FGameplayAttributeData& OldValue);

	float GetMaxNaturalEnergyFinal() const;
	bool IsFullNEP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfNaturalEnergyAttributeSet">();
	}
	static class UTgfNaturalEnergyAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfNaturalEnergyAttributeSet>();
	}
};
static_assert(alignof(UTgfNaturalEnergyAttributeSet) == 0x000008, "Wrong alignment on UTgfNaturalEnergyAttributeSet");
static_assert(sizeof(UTgfNaturalEnergyAttributeSet) == 0x0000C0, "Wrong size on UTgfNaturalEnergyAttributeSet");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, CurNaturalEnergy) == 0x000030, "Member 'UTgfNaturalEnergyAttributeSet::CurNaturalEnergy' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, NaturalEnergyOnHit) == 0x000040, "Member 'UTgfNaturalEnergyAttributeSet::NaturalEnergyOnHit' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, NaturalEnergyOnKill) == 0x000050, "Member 'UTgfNaturalEnergyAttributeSet::NaturalEnergyOnKill' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, NaturalEnergyOnHurt) == 0x000060, "Member 'UTgfNaturalEnergyAttributeSet::NaturalEnergyOnHurt' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, NaturalEnergyOverTime) == 0x000070, "Member 'UTgfNaturalEnergyAttributeSet::NaturalEnergyOverTime' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, NaturalEnergyGenerateRate) == 0x000080, "Member 'UTgfNaturalEnergyAttributeSet::NaturalEnergyGenerateRate' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, MaxNaturalEnergyBase) == 0x000090, "Member 'UTgfNaturalEnergyAttributeSet::MaxNaturalEnergyBase' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, MaxNaturalEnergyPercent) == 0x0000A0, "Member 'UTgfNaturalEnergyAttributeSet::MaxNaturalEnergyPercent' has a wrong offset!");
static_assert(offsetof(UTgfNaturalEnergyAttributeSet, NaturalEnergyDeltaValue) == 0x0000B0, "Member 'UTgfNaturalEnergyAttributeSet::NaturalEnergyDeltaValue' has a wrong offset!");

// Class LyraGame.TgfNpcBehavior
// 0x0078 (0x00A0 - 0x0028)
class UTgfNpcBehavior : public UObject
{
public:
	int32                                         BehaviorId;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExecutionDelay;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaximumExecutions;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExecutingPossibility;                              // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumExecutingInterval;                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALyraCharacter>          OwningCharacter;                                   // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UTgfNpcState>            CurrentState;                                      // 0x0044(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ULyraAbilitySystemComponent> AbilitySystem;                                     // 0x004C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UTgfInteractorEventComponent> EventComponent;                                    // 0x0054(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  OwningActor;                                       // 0x005C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UTgfNpcStateManagerComponent> StateManager;                                      // 0x0064(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0xC];                                       // 0x006C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TriggerTags;                                       // 0x0078(0x0020)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoBehavior(const struct FGameplayTag& GameplayTag, const struct FGameplayEventData& EventData);
	void DoChecks(const struct FGameplayTag& GameplayTag, const struct FGameplayEventData& EventData, bool* PassCheck);
	bool GetIsEditor();
	class AActor* GetOwningActor();
	class ALyraCharacter* GetOwningCharacter();
	int32 GetReceivedEventNumber(const struct FGameplayTag& EventTag);
	bool HasReceivedEvent(const struct FGameplayTag& EventTag);
	void MoveToNextState(TSubclassOf<class UTgfNpcState> NextState);
	bool PlayerEquipsItem(class ALyraCharacter* Player, TSubclassOf<class ULyraEquipmentDefinition> Item);
	bool PlayerHasItems(class ALyraCharacter* Player, TSubclassOf<class ULyraInventoryItemDefinition> Item, int32 RequiredNumber);
	bool PlayerInventoryHasItems(class ALyraCharacter* Player, TSubclassOf<class ULyraInventoryItemDefinition> Item, int32 RequiredNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfNpcBehavior">();
	}
	static class UTgfNpcBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfNpcBehavior>();
	}
};
static_assert(alignof(UTgfNpcBehavior) == 0x000008, "Wrong alignment on UTgfNpcBehavior");
static_assert(sizeof(UTgfNpcBehavior) == 0x0000A0, "Wrong size on UTgfNpcBehavior");
static_assert(offsetof(UTgfNpcBehavior, BehaviorId) == 0x000028, "Member 'UTgfNpcBehavior::BehaviorId' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, ExecutionDelay) == 0x00002C, "Member 'UTgfNpcBehavior::ExecutionDelay' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, MaximumExecutions) == 0x000030, "Member 'UTgfNpcBehavior::MaximumExecutions' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, ExecutingPossibility) == 0x000034, "Member 'UTgfNpcBehavior::ExecutingPossibility' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, MinimumExecutingInterval) == 0x000038, "Member 'UTgfNpcBehavior::MinimumExecutingInterval' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, OwningCharacter) == 0x00003C, "Member 'UTgfNpcBehavior::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, CurrentState) == 0x000044, "Member 'UTgfNpcBehavior::CurrentState' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, AbilitySystem) == 0x00004C, "Member 'UTgfNpcBehavior::AbilitySystem' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, EventComponent) == 0x000054, "Member 'UTgfNpcBehavior::EventComponent' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, OwningActor) == 0x00005C, "Member 'UTgfNpcBehavior::OwningActor' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, StateManager) == 0x000064, "Member 'UTgfNpcBehavior::StateManager' has a wrong offset!");
static_assert(offsetof(UTgfNpcBehavior, TriggerTags) == 0x000078, "Member 'UTgfNpcBehavior::TriggerTags' has a wrong offset!");

// Class LyraGame.LyraPickupDefinition
// 0x0038 (0x0068 - 0x0030)
class ULyraPickupDefinition : public UDataAsset
{
public:
	TSubclassOf<class ULyraInventoryItemDefinition> InventoryItemDefinition;                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DisplayMesh;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCoolDownSeconds;                              // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             PickedUpSound;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             RespawnedSound;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PickedUpEffect;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         RespawnedEffect;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPickupDefinition">();
	}
	static class ULyraPickupDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPickupDefinition>();
	}
};
static_assert(alignof(ULyraPickupDefinition) == 0x000008, "Wrong alignment on ULyraPickupDefinition");
static_assert(sizeof(ULyraPickupDefinition) == 0x000068, "Wrong size on ULyraPickupDefinition");
static_assert(offsetof(ULyraPickupDefinition, InventoryItemDefinition) == 0x000030, "Member 'ULyraPickupDefinition::InventoryItemDefinition' has a wrong offset!");
static_assert(offsetof(ULyraPickupDefinition, DisplayMesh) == 0x000038, "Member 'ULyraPickupDefinition::DisplayMesh' has a wrong offset!");
static_assert(offsetof(ULyraPickupDefinition, SpawnCoolDownSeconds) == 0x000040, "Member 'ULyraPickupDefinition::SpawnCoolDownSeconds' has a wrong offset!");
static_assert(offsetof(ULyraPickupDefinition, PickedUpSound) == 0x000048, "Member 'ULyraPickupDefinition::PickedUpSound' has a wrong offset!");
static_assert(offsetof(ULyraPickupDefinition, RespawnedSound) == 0x000050, "Member 'ULyraPickupDefinition::RespawnedSound' has a wrong offset!");
static_assert(offsetof(ULyraPickupDefinition, PickedUpEffect) == 0x000058, "Member 'ULyraPickupDefinition::PickedUpEffect' has a wrong offset!");
static_assert(offsetof(ULyraPickupDefinition, RespawnedEffect) == 0x000060, "Member 'ULyraPickupDefinition::RespawnedEffect' has a wrong offset!");

// Class LyraGame.TgfNpcState
// 0x00C8 (0x00F0 - 0x0028)
class UTgfNpcState : public UObject
{
public:
	TArray<struct FTgfNpcEventStruct>             Events;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UTgfNpcBehavior*>                OnEnterBehaviors;                                  // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UTgfNpcBehavior*>                OnLeaveBehaviors;                                  // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ToGrantTags;                                       // 0x0058(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x78];                                      // 0x0078(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetOwningActor();
	class ALyraCharacter* GetOwningCharacter();
	int32 GetReceivedEventNumber(const struct FGameplayTag& EventTag);
	bool HasReceivedEvent(const struct FGameplayTag& EventTag);
	void OnEnterState();
	void OnLeaveState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfNpcState">();
	}
	static class UTgfNpcState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfNpcState>();
	}
};
static_assert(alignof(UTgfNpcState) == 0x000008, "Wrong alignment on UTgfNpcState");
static_assert(sizeof(UTgfNpcState) == 0x0000F0, "Wrong size on UTgfNpcState");
static_assert(offsetof(UTgfNpcState, Events) == 0x000028, "Member 'UTgfNpcState::Events' has a wrong offset!");
static_assert(offsetof(UTgfNpcState, OnEnterBehaviors) == 0x000038, "Member 'UTgfNpcState::OnEnterBehaviors' has a wrong offset!");
static_assert(offsetof(UTgfNpcState, OnLeaveBehaviors) == 0x000048, "Member 'UTgfNpcState::OnLeaveBehaviors' has a wrong offset!");
static_assert(offsetof(UTgfNpcState, ToGrantTags) == 0x000058, "Member 'UTgfNpcState::ToGrantTags' has a wrong offset!");

// Class LyraGame.TgfNpcStateManagerComponent
// 0x00C0 (0x0168 - 0x00A8)
class UTgfNpcStateManagerComponent final : public UGameFrameworkComponent
{
public:
	bool                                          bAuthorityOnly;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCosmetic;                                         // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTgfNpcState>               InitialState;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTgfNpcState*                           CurrentState;                                      // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALyraCharacter*                         OwningCharacter;                                   // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0xA0];                                      // 0x00C8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTgfNpcState* GetCurrentState();
	class ALyraCharacter* GetOwningCharacter();
	bool IsInState(TSubclassOf<class UTgfNpcState> NpcState);
	void MoveToState(TSubclassOf<class UTgfNpcState> NextState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfNpcStateManagerComponent">();
	}
	static class UTgfNpcStateManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfNpcStateManagerComponent>();
	}
};
static_assert(alignof(UTgfNpcStateManagerComponent) == 0x000008, "Wrong alignment on UTgfNpcStateManagerComponent");
static_assert(sizeof(UTgfNpcStateManagerComponent) == 0x000168, "Wrong size on UTgfNpcStateManagerComponent");
static_assert(offsetof(UTgfNpcStateManagerComponent, bAuthorityOnly) == 0x0000A8, "Member 'UTgfNpcStateManagerComponent::bAuthorityOnly' has a wrong offset!");
static_assert(offsetof(UTgfNpcStateManagerComponent, bCosmetic) == 0x0000A9, "Member 'UTgfNpcStateManagerComponent::bCosmetic' has a wrong offset!");
static_assert(offsetof(UTgfNpcStateManagerComponent, InitialState) == 0x0000B0, "Member 'UTgfNpcStateManagerComponent::InitialState' has a wrong offset!");
static_assert(offsetof(UTgfNpcStateManagerComponent, CurrentState) == 0x0000B8, "Member 'UTgfNpcStateManagerComponent::CurrentState' has a wrong offset!");
static_assert(offsetof(UTgfNpcStateManagerComponent, OwningCharacter) == 0x0000C0, "Member 'UTgfNpcStateManagerComponent::OwningCharacter' has a wrong offset!");

// Class LyraGame.LyraContextEffectsSet
// 0x0050 (0x0078 - 0x0028)
class ULyraContextEffectsSet final : public UObject
{
public:
	TSet<class ULyraContextEffectsLibrary*>       LyraContextEffectsLibraries;                       // 0x0028(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraContextEffectsSet">();
	}
	static class ULyraContextEffectsSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraContextEffectsSet>();
	}
};
static_assert(alignof(ULyraContextEffectsSet) == 0x000008, "Wrong alignment on ULyraContextEffectsSet");
static_assert(sizeof(ULyraContextEffectsSet) == 0x000078, "Wrong size on ULyraContextEffectsSet");
static_assert(offsetof(ULyraContextEffectsSet, LyraContextEffectsLibraries) == 0x000028, "Member 'ULyraContextEffectsSet::LyraContextEffectsLibraries' has a wrong offset!");

// Class LyraGame.TgfObjectListDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTgfObjectListDataAsset final : public UDataAsset
{
public:
	TArray<class UObject*>                        Objects;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfObjectListDataAsset">();
	}
	static class UTgfObjectListDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfObjectListDataAsset>();
	}
};
static_assert(alignof(UTgfObjectListDataAsset) == 0x000008, "Wrong alignment on UTgfObjectListDataAsset");
static_assert(sizeof(UTgfObjectListDataAsset) == 0x000040, "Wrong size on UTgfObjectListDataAsset");
static_assert(offsetof(UTgfObjectListDataAsset, Objects) == 0x000030, "Member 'UTgfObjectListDataAsset::Objects' has a wrong offset!");

// Class LyraGame.TgfPlayerGameFlow
// 0x0008 (0x00B0 - 0x00A8)
class UTgfPlayerGameFlow : public UPlayerStateComponent
{
public:
	float                                         DefaultTeleportPointZOffset;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientEscape();
	void ClientTeleport();
	void ClientTeleportPawn(class APawn* Pawn, const struct FVector& Location, const struct FRotator& Rotation);
	void K2_ServerEscape();
	void K2_ServerTeleport();
	void OnPlayerEnterPortal(const struct FTgfEnterPortalParameter& Parameter);
	void ServerEscape();
	void ServerTeleport();
	void TeleportToChosenPoint(bool IsDeathPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfPlayerGameFlow">();
	}
	static class UTgfPlayerGameFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfPlayerGameFlow>();
	}
};
static_assert(alignof(UTgfPlayerGameFlow) == 0x000008, "Wrong alignment on UTgfPlayerGameFlow");
static_assert(sizeof(UTgfPlayerGameFlow) == 0x0000B0, "Wrong size on UTgfPlayerGameFlow");
static_assert(offsetof(UTgfPlayerGameFlow, DefaultTeleportPointZOffset) == 0x0000A8, "Member 'UTgfPlayerGameFlow::DefaultTeleportPointZOffset' has a wrong offset!");

// Class LyraGame.TgfGearsetInstance
// 0x0088 (0x0170 - 0x00E8)
class UTgfGearsetInstance final : public UTgfEquipmentInstance
{
public:
	int32                                         GearsetLevel;                                      // 0x00E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLyraAbilitySet_GrantedHandles         GearsetGrantedHandles;                             // 0x00F0(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddGearsetLevel(int32 Level);
	void OnRep_GearsetLevel();

	int32 GetGearsetLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGearsetInstance">();
	}
	static class UTgfGearsetInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGearsetInstance>();
	}
};
static_assert(alignof(UTgfGearsetInstance) == 0x000008, "Wrong alignment on UTgfGearsetInstance");
static_assert(sizeof(UTgfGearsetInstance) == 0x000170, "Wrong size on UTgfGearsetInstance");
static_assert(offsetof(UTgfGearsetInstance, GearsetLevel) == 0x0000E8, "Member 'UTgfGearsetInstance::GearsetLevel' has a wrong offset!");
static_assert(offsetof(UTgfGearsetInstance, GearsetGrantedHandles) == 0x0000F0, "Member 'UTgfGearsetInstance::GearsetGrantedHandles' has a wrong offset!");

// Class LyraGame.TgfProjectileBase
// 0x0410 (0x06A8 - 0x0298)
class ATgfProjectileBase : public AActor
{
public:
	struct FGameplayEffectContextHandle           GECH;                                              // 0x0298(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x02B8(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InstigatorAttackWeight;                            // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstigatorWeaponAttack;                            // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProjectileInitParams                  ProjectileInitParams;                              // 0x03A8(0x0080)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x0428(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewerIsOwner;                                    // 0x0440(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfEquipQuality                              EquipQuality;                                      // 0x0441(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_442[0x6];                                      // 0x0442(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, TSubclassOf<class UGameplayEffect>> HitPassiveSrcTagSrcGE;                             // 0x0448(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class UGameplayEffect>> HitPassiveSrcTagTrgGE;                             // 0x0498(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class UGameplayEffect>> HitPassiveTrgTagSrcGE;                             // 0x04E8(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class UGameplayEffect>> HitPassiveTrgTagTrgGE;                             // 0x0538(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InterruptGE;                                       // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectClass;                               // 0x0590(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            BattleInteractGE;                                  // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DefenceTag;                                        // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityHurtTags;                                   // 0x05B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIgnoreGuard;                                      // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxGuardAngleLeft;                                 // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGuardAngleRight;                                // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CounterGE;                                         // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CounterMinorGE;                                    // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoDestroyWaitTime;                               // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachToActorWhenHit;                              // 0x05F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideAttackWeight;                              // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanHitInstigator;                                  // 0x05FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanCauseCritical;                                  // 0x05FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ServerCheckClientHit;                              // 0x05FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ServerWaitClientHitNoActor;                        // 0x05FF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerWaitClientHitNoActorTime;                    // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0x2];                                      // 0x0604(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          BornPosCheck;                                      // 0x0606(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_607[0x1];                                      // 0x0607(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BornPosCheckDist;                                  // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerCheckAngle;                                  // 0x060C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreCheckLength;                                 // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitActorHitResultDistXYCheck;                      // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitActorHitResultDistZCheck;                       // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTgfAuraManagerComponent*               AuraManagerComponent;                              // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAuras;                                         // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTgfGameplayAura>>   GameplayAuras;                                     // 0x0630(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bNeedInstigator;                                   // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x17];                                     // 0x0641(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ExplodeGameplayCueTag;                             // 0x0658(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExplodeDecal;                                  // 0x0660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_661[0x3];                                      // 0x0661(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ExplodeDecalGameplayCueTag;                        // 0x0664(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplodeRadius;                                     // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ExplodeObjectTypes;                                // 0x0670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ExplodeDecalObjectTypes;                           // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ExplodeBlockCheck;                                 // 0x0690(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreExplodeHitResultBlockingHit;                // 0x0691(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ExplodeBlockTraceChannel;                          // 0x0692(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggeredExplode;                                 // 0x0693(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    HitEnvironmentGE;                                  // 0x0698(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AddGameplayAuras();
	void ApplyProjectileEffect(class AActor* InHitActor, const struct FHitResult& InHitResult, bool AutoDestroy);
	void ChangeMesh(class USkeletalMesh* Mesh);
	bool CheckGuarded();
	bool CheckHitInteractEnvironment(const struct FHitResult& Result);
	void ClientNotifyApplyProjectileEffect(class AActor* InHitActor, const struct FHitResult& InHitResult, bool AutoDestroy);
	void Explode(TArray<class AActor*>* OutActors, bool AutoDestroy, class AActor* InExcludedActor, bool IgnoreSelf, const struct FVector& ExplodeCenter);
	void InitDifferentTeam();
	void InitGameplayEffectContext(const struct FProjectileInitParams& Params_0);
	void InitGameplayEffectContextInBP();
	void InitOwnerTeam();
	void InitSameTeam();
	void InitUnknownTeam();
	void RemoveGameplayAuras();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfProjectileBase">();
	}
	static class ATgfProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfProjectileBase>();
	}
};
static_assert(alignof(ATgfProjectileBase) == 0x000008, "Wrong alignment on ATgfProjectileBase");
static_assert(sizeof(ATgfProjectileBase) == 0x0006A8, "Wrong size on ATgfProjectileBase");
static_assert(offsetof(ATgfProjectileBase, GECH) == 0x000298, "Member 'ATgfProjectileBase::GECH' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitActor) == 0x0002B0, "Member 'ATgfProjectileBase::HitActor' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitResult) == 0x0002B8, "Member 'ATgfProjectileBase::HitResult' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, InstigatorAttackWeight) == 0x0003A0, "Member 'ATgfProjectileBase::InstigatorAttackWeight' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, InstigatorWeaponAttack) == 0x0003A4, "Member 'ATgfProjectileBase::InstigatorWeaponAttack' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ProjectileInitParams) == 0x0003A8, "Member 'ATgfProjectileBase::ProjectileInitParams' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, StartPos) == 0x000428, "Member 'ATgfProjectileBase::StartPos' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bViewerIsOwner) == 0x000440, "Member 'ATgfProjectileBase::bViewerIsOwner' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, EquipQuality) == 0x000441, "Member 'ATgfProjectileBase::EquipQuality' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitPassiveSrcTagSrcGE) == 0x000448, "Member 'ATgfProjectileBase::HitPassiveSrcTagSrcGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitPassiveSrcTagTrgGE) == 0x000498, "Member 'ATgfProjectileBase::HitPassiveSrcTagTrgGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitPassiveTrgTagSrcGE) == 0x0004E8, "Member 'ATgfProjectileBase::HitPassiveTrgTagSrcGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitPassiveTrgTagTrgGE) == 0x000538, "Member 'ATgfProjectileBase::HitPassiveTrgTagTrgGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, InterruptGE) == 0x000588, "Member 'ATgfProjectileBase::InterruptGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, GameplayEffectClass) == 0x000590, "Member 'ATgfProjectileBase::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, BattleInteractGE) == 0x0005A0, "Member 'ATgfProjectileBase::BattleInteractGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, DefenceTag) == 0x0005A8, "Member 'ATgfProjectileBase::DefenceTag' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, AbilityHurtTags) == 0x0005B0, "Member 'ATgfProjectileBase::AbilityHurtTags' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bIgnoreGuard) == 0x0005D0, "Member 'ATgfProjectileBase::bIgnoreGuard' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, MaxGuardAngleLeft) == 0x0005D4, "Member 'ATgfProjectileBase::MaxGuardAngleLeft' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, MaxGuardAngleRight) == 0x0005D8, "Member 'ATgfProjectileBase::MaxGuardAngleRight' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, CounterGE) == 0x0005E0, "Member 'ATgfProjectileBase::CounterGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, CounterMinorGE) == 0x0005E8, "Member 'ATgfProjectileBase::CounterMinorGE' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, AutoDestroyWaitTime) == 0x0005F0, "Member 'ATgfProjectileBase::AutoDestroyWaitTime' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, AttachToActorWhenHit) == 0x0005F4, "Member 'ATgfProjectileBase::AttachToActorWhenHit' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, OverrideAttackWeight) == 0x0005F8, "Member 'ATgfProjectileBase::OverrideAttackWeight' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, CanHitInstigator) == 0x0005FC, "Member 'ATgfProjectileBase::CanHitInstigator' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, CanCauseCritical) == 0x0005FD, "Member 'ATgfProjectileBase::CanCauseCritical' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ServerCheckClientHit) == 0x0005FE, "Member 'ATgfProjectileBase::ServerCheckClientHit' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ServerWaitClientHitNoActor) == 0x0005FF, "Member 'ATgfProjectileBase::ServerWaitClientHitNoActor' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ServerWaitClientHitNoActorTime) == 0x000600, "Member 'ATgfProjectileBase::ServerWaitClientHitNoActorTime' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, BornPosCheck) == 0x000606, "Member 'ATgfProjectileBase::BornPosCheck' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, BornPosCheckDist) == 0x000608, "Member 'ATgfProjectileBase::BornPosCheckDist' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ServerCheckAngle) == 0x00060C, "Member 'ATgfProjectileBase::ServerCheckAngle' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, IgnoreCheckLength) == 0x000610, "Member 'ATgfProjectileBase::IgnoreCheckLength' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitActorHitResultDistXYCheck) == 0x000614, "Member 'ATgfProjectileBase::HitActorHitResultDistXYCheck' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitActorHitResultDistZCheck) == 0x000618, "Member 'ATgfProjectileBase::HitActorHitResultDistZCheck' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, AuraManagerComponent) == 0x000620, "Member 'ATgfProjectileBase::AuraManagerComponent' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bUseAuras) == 0x000628, "Member 'ATgfProjectileBase::bUseAuras' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, GameplayAuras) == 0x000630, "Member 'ATgfProjectileBase::GameplayAuras' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bNeedInstigator) == 0x000640, "Member 'ATgfProjectileBase::bNeedInstigator' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeGameplayCueTag) == 0x000658, "Member 'ATgfProjectileBase::ExplodeGameplayCueTag' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bUseExplodeDecal) == 0x000660, "Member 'ATgfProjectileBase::bUseExplodeDecal' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeDecalGameplayCueTag) == 0x000664, "Member 'ATgfProjectileBase::ExplodeDecalGameplayCueTag' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeRadius) == 0x00066C, "Member 'ATgfProjectileBase::ExplodeRadius' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeObjectTypes) == 0x000670, "Member 'ATgfProjectileBase::ExplodeObjectTypes' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeDecalObjectTypes) == 0x000680, "Member 'ATgfProjectileBase::ExplodeDecalObjectTypes' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeBlockCheck) == 0x000690, "Member 'ATgfProjectileBase::ExplodeBlockCheck' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bIgnoreExplodeHitResultBlockingHit) == 0x000691, "Member 'ATgfProjectileBase::bIgnoreExplodeHitResultBlockingHit' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, ExplodeBlockTraceChannel) == 0x000692, "Member 'ATgfProjectileBase::ExplodeBlockTraceChannel' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, bTriggeredExplode) == 0x000693, "Member 'ATgfProjectileBase::bTriggeredExplode' has a wrong offset!");
static_assert(offsetof(ATgfProjectileBase, HitEnvironmentGE) == 0x000698, "Member 'ATgfProjectileBase::HitEnvironmentGE' has a wrong offset!");

// Class LyraGame.TgfProjectileAnimDrive
// 0x00C8 (0x0770 - 0x06A8)
class ATgfProjectileAnimDrive final : public ATgfProjectileBase
{
public:
	bool                                          DebugHit;                                          // 0x06A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastPos;                                           // 0x06B0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActor;                                       // 0x06C8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FocusActor;                                        // 0x06D8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FDateTime>         HitActorMap;                                       // 0x06E8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannelTypes;                                 // 0x0738(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x7];                                      // 0x0739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TraceObjectTypes;                                  // 0x0740(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ResetIgnoreMilliseconds;                           // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaitCheckFrame;                                    // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxTraceHalfSize;                                  // 0x0758(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CheckHit(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfProjectileAnimDrive">();
	}
	static class ATgfProjectileAnimDrive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfProjectileAnimDrive>();
	}
};
static_assert(alignof(ATgfProjectileAnimDrive) == 0x000008, "Wrong alignment on ATgfProjectileAnimDrive");
static_assert(sizeof(ATgfProjectileAnimDrive) == 0x000770, "Wrong size on ATgfProjectileAnimDrive");
static_assert(offsetof(ATgfProjectileAnimDrive, DebugHit) == 0x0006A8, "Member 'ATgfProjectileAnimDrive::DebugHit' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, LastPos) == 0x0006B0, "Member 'ATgfProjectileAnimDrive::LastPos' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, IgnoreActor) == 0x0006C8, "Member 'ATgfProjectileAnimDrive::IgnoreActor' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, FocusActor) == 0x0006D8, "Member 'ATgfProjectileAnimDrive::FocusActor' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, HitActorMap) == 0x0006E8, "Member 'ATgfProjectileAnimDrive::HitActorMap' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, TraceChannelTypes) == 0x000738, "Member 'ATgfProjectileAnimDrive::TraceChannelTypes' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, TraceObjectTypes) == 0x000740, "Member 'ATgfProjectileAnimDrive::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, ResetIgnoreMilliseconds) == 0x000750, "Member 'ATgfProjectileAnimDrive::ResetIgnoreMilliseconds' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, WaitCheckFrame) == 0x000754, "Member 'ATgfProjectileAnimDrive::WaitCheckFrame' has a wrong offset!");
static_assert(offsetof(ATgfProjectileAnimDrive, BoxTraceHalfSize) == 0x000758, "Member 'ATgfProjectileAnimDrive::BoxTraceHalfSize' has a wrong offset!");

// Class LyraGame.LyraPlatformEmulationSettings
// 0x0058 (0x0090 - 0x0038)
class ULyraPlatformEmulationSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	struct FGameplayTagContainer                  AdditionalPlatformTraitsToEnable;                  // 0x0038(0x0020)(Edit, Config, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AdditionalPlatformTraitsToSuppress;                // 0x0058(0x0020)(Edit, Config, NativeAccessSpecifierPrivate)
	class FName                                   PretendPlatform;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PretendBaseDeviceProfile;                          // 0x0080(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyFrameRateSettingsInPIE;                      // 0x0088(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyFrontEndPerformanceOptionsInPIE;             // 0x0089(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyDeviceProfilesInPIE;                         // 0x008A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FName> GetKnownDeviceProfiles() const;
	TArray<class FName> GetKnownPlatformIds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlatformEmulationSettings">();
	}
	static class ULyraPlatformEmulationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPlatformEmulationSettings>();
	}
};
static_assert(alignof(ULyraPlatformEmulationSettings) == 0x000008, "Wrong alignment on ULyraPlatformEmulationSettings");
static_assert(sizeof(ULyraPlatformEmulationSettings) == 0x000090, "Wrong size on ULyraPlatformEmulationSettings");
static_assert(offsetof(ULyraPlatformEmulationSettings, AdditionalPlatformTraitsToEnable) == 0x000038, "Member 'ULyraPlatformEmulationSettings::AdditionalPlatformTraitsToEnable' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, AdditionalPlatformTraitsToSuppress) == 0x000058, "Member 'ULyraPlatformEmulationSettings::AdditionalPlatformTraitsToSuppress' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, PretendPlatform) == 0x000078, "Member 'ULyraPlatformEmulationSettings::PretendPlatform' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, PretendBaseDeviceProfile) == 0x000080, "Member 'ULyraPlatformEmulationSettings::PretendBaseDeviceProfile' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, bApplyFrameRateSettingsInPIE) == 0x000088, "Member 'ULyraPlatformEmulationSettings::bApplyFrameRateSettingsInPIE' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, bApplyFrontEndPerformanceOptionsInPIE) == 0x000089, "Member 'ULyraPlatformEmulationSettings::bApplyFrontEndPerformanceOptionsInPIE' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, bApplyDeviceProfilesInPIE) == 0x00008A, "Member 'ULyraPlatformEmulationSettings::bApplyDeviceProfilesInPIE' has a wrong offset!");

// Class LyraGame.TgfProjectileBlockerComponent
// 0x0010 (0x0590 - 0x0580)
class UTgfProjectileBlockerComponent final : public UBoxComponent
{
public:
	bool                                          bAttachCharacter;                                  // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_581[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BlockerAttachSocket;                               // 0x0584(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfProjectileBlockerComponent">();
	}
	static class UTgfProjectileBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfProjectileBlockerComponent>();
	}
};
static_assert(alignof(UTgfProjectileBlockerComponent) == 0x000010, "Wrong alignment on UTgfProjectileBlockerComponent");
static_assert(sizeof(UTgfProjectileBlockerComponent) == 0x000590, "Wrong size on UTgfProjectileBlockerComponent");
static_assert(offsetof(UTgfProjectileBlockerComponent, bAttachCharacter) == 0x000580, "Member 'UTgfProjectileBlockerComponent::bAttachCharacter' has a wrong offset!");
static_assert(offsetof(UTgfProjectileBlockerComponent, BlockerAttachSocket) == 0x000584, "Member 'UTgfProjectileBlockerComponent::BlockerAttachSocket' has a wrong offset!");

// Class LyraGame.TgfQuickIntoryWidget
// 0x0000 (0x02B0 - 0x02B0)
class UTgfQuickIntoryWidget final : public UTgfGameWidgetBase
{
public:
	void BP_OnViewTargetChanged();
	void OnChangeViewTarget(class AActor* NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfQuickIntoryWidget">();
	}
	static class UTgfQuickIntoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfQuickIntoryWidget>();
	}
};
static_assert(alignof(UTgfQuickIntoryWidget) == 0x000008, "Wrong alignment on UTgfQuickIntoryWidget");
static_assert(sizeof(UTgfQuickIntoryWidget) == 0x0002B0, "Wrong size on UTgfQuickIntoryWidget");

// Class LyraGame.TgfRagdollComponent
// 0x00F0 (0x0198 - 0x00A8)
class UTgfRagdollComponent final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRagDollTriggered;                                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRagDollStopped;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDetectLand;                                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComputeImpulse;                                  // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResetProperties;                                 // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          InRagDoll;                                         // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedRagdoll;                                       // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedChangePhysics;                                 // 0x00FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          RagdollPhysics;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayStop;                                         // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSnapshot;                                       // 0x010D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E[0x2];                                      // 0x010E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          OldPhysicsAsset;                                   // 0x0110(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OldCollisionProfileName;                           // 0x0118(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitImpulse;                                        // 0x0120(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RagdollBoneRoot;                                   // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneToAddForce;                                    // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           RagdollBones;                                      // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BoundsScale;                                       // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        LineTracePoints;                                   // 0x0160(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          NeedFixRoot;                                       // 0x0170(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedAddImpluse;                                    // 0x0171(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedBreak;                                         // 0x0172(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173[0x1];                                      // 0x0173(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BreakBoneRoot;                                     // 0x0174(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExclusiveBreakBones;                               // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ForceScaleZ;                                       // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceScaleXY;                                      // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyPhysicalAnimationProfileBelow(class FName BodyName, class FName ProfileName, bool bIncludeSelf, bool bClearNotFound);
	void SetPhysAnimEnabled(bool Enabled);

	class UPhysicalAnimationComponent* GetPhysAnimComp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfRagdollComponent">();
	}
	static class UTgfRagdollComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfRagdollComponent>();
	}
};
static_assert(alignof(UTgfRagdollComponent) == 0x000008, "Wrong alignment on UTgfRagdollComponent");
static_assert(sizeof(UTgfRagdollComponent) == 0x000198, "Wrong size on UTgfRagdollComponent");
static_assert(offsetof(UTgfRagdollComponent, OnRagDollTriggered) == 0x0000A8, "Member 'UTgfRagdollComponent::OnRagDollTriggered' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, OnRagDollStopped) == 0x0000B8, "Member 'UTgfRagdollComponent::OnRagDollStopped' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, OnDetectLand) == 0x0000C8, "Member 'UTgfRagdollComponent::OnDetectLand' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, OnComputeImpulse) == 0x0000D8, "Member 'UTgfRagdollComponent::OnComputeImpulse' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, OnResetProperties) == 0x0000E8, "Member 'UTgfRagdollComponent::OnResetProperties' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, InRagDoll) == 0x0000F8, "Member 'UTgfRagdollComponent::InRagDoll' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, NeedRagdoll) == 0x0000F9, "Member 'UTgfRagdollComponent::NeedRagdoll' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, NeedChangePhysics) == 0x0000FA, "Member 'UTgfRagdollComponent::NeedChangePhysics' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, RagdollPhysics) == 0x000100, "Member 'UTgfRagdollComponent::RagdollPhysics' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, DelayStop) == 0x000108, "Member 'UTgfRagdollComponent::DelayStop' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, DrawDebug) == 0x00010C, "Member 'UTgfRagdollComponent::DrawDebug' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, UseSnapshot) == 0x00010D, "Member 'UTgfRagdollComponent::UseSnapshot' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, OldPhysicsAsset) == 0x000110, "Member 'UTgfRagdollComponent::OldPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, OldCollisionProfileName) == 0x000118, "Member 'UTgfRagdollComponent::OldCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, HitImpulse) == 0x000120, "Member 'UTgfRagdollComponent::HitImpulse' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, RagdollBoneRoot) == 0x000138, "Member 'UTgfRagdollComponent::RagdollBoneRoot' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, BoneToAddForce) == 0x000140, "Member 'UTgfRagdollComponent::BoneToAddForce' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, RagdollBones) == 0x000148, "Member 'UTgfRagdollComponent::RagdollBones' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, BoundsScale) == 0x000158, "Member 'UTgfRagdollComponent::BoundsScale' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, LineTracePoints) == 0x000160, "Member 'UTgfRagdollComponent::LineTracePoints' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, NeedFixRoot) == 0x000170, "Member 'UTgfRagdollComponent::NeedFixRoot' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, NeedAddImpluse) == 0x000171, "Member 'UTgfRagdollComponent::NeedAddImpluse' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, NeedBreak) == 0x000172, "Member 'UTgfRagdollComponent::NeedBreak' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, BreakBoneRoot) == 0x000174, "Member 'UTgfRagdollComponent::BreakBoneRoot' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, ExclusiveBreakBones) == 0x000180, "Member 'UTgfRagdollComponent::ExclusiveBreakBones' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, ForceScaleZ) == 0x000190, "Member 'UTgfRagdollComponent::ForceScaleZ' has a wrong offset!");
static_assert(offsetof(UTgfRagdollComponent, ForceScaleXY) == 0x000194, "Member 'UTgfRagdollComponent::ForceScaleXY' has a wrong offset!");

// Class LyraGame.TgfRangedWeaponAnimHelperInterface
// 0x0000 (0x0028 - 0x0028)
class ITgfRangedWeaponAnimHelperInterface final : public IInterface
{
public:
	class UTgfRangedWeaponAnimHelperComponent* GetHelperComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfRangedWeaponAnimHelperInterface">();
	}
	static class ITgfRangedWeaponAnimHelperInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITgfRangedWeaponAnimHelperInterface>();
	}
};
static_assert(alignof(ITgfRangedWeaponAnimHelperInterface) == 0x000008, "Wrong alignment on ITgfRangedWeaponAnimHelperInterface");
static_assert(sizeof(ITgfRangedWeaponAnimHelperInterface) == 0x000028, "Wrong size on ITgfRangedWeaponAnimHelperInterface");

// Class LyraGame.GameFeatureAction_AddGameplayCuePath
// 0x0010 (0x0038 - 0x0028)
class UGameFeatureAction_AddGameplayCuePath final : public UGameFeatureAction
{
public:
	TArray<struct FDirectoryPath>                 DirectoryPathsToAdd;                               // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddGameplayCuePath">();
	}
	static class UGameFeatureAction_AddGameplayCuePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddGameplayCuePath>();
	}
};
static_assert(alignof(UGameFeatureAction_AddGameplayCuePath) == 0x000008, "Wrong alignment on UGameFeatureAction_AddGameplayCuePath");
static_assert(sizeof(UGameFeatureAction_AddGameplayCuePath) == 0x000038, "Wrong size on UGameFeatureAction_AddGameplayCuePath");
static_assert(offsetof(UGameFeatureAction_AddGameplayCuePath, DirectoryPathsToAdd) == 0x000028, "Member 'UGameFeatureAction_AddGameplayCuePath::DirectoryPathsToAdd' has a wrong offset!");

// Class LyraGame.TgfRangedWeaponAnimHelperComponent
// 0x00B0 (0x0158 - 0x00A8)
class UTgfRangedWeaponAnimHelperComponent final : public UGameFrameworkComponent
{
public:
	struct FWeaponAnimStateInfo                   StatusInfo;                                        // 0x00A8(0x0002)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERangedWeaponActionType, struct FArrowAnimConfig> AimingMontageConfigs;                              // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<ERangedWeaponActionType, struct FArrowAnimConfig> NormalMontageConfigs;                              // 0x0100(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CachedMesh;                                        // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveDraw();
	void ReceiveFire();
	void ReceiveReload();
	void ReceiveReset();
	void ReceiveToggleADS(bool bEnable);
	void ToAction(ERangedWeaponActionType Action, float MontagePlayRate);
	void TryPlayActionMontage(ERangedWeaponActionType Action, float Rate);

	const struct FWeaponAnimStateInfo GetStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfRangedWeaponAnimHelperComponent">();
	}
	static class UTgfRangedWeaponAnimHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfRangedWeaponAnimHelperComponent>();
	}
};
static_assert(alignof(UTgfRangedWeaponAnimHelperComponent) == 0x000008, "Wrong alignment on UTgfRangedWeaponAnimHelperComponent");
static_assert(sizeof(UTgfRangedWeaponAnimHelperComponent) == 0x000158, "Wrong size on UTgfRangedWeaponAnimHelperComponent");
static_assert(offsetof(UTgfRangedWeaponAnimHelperComponent, StatusInfo) == 0x0000A8, "Member 'UTgfRangedWeaponAnimHelperComponent::StatusInfo' has a wrong offset!");
static_assert(offsetof(UTgfRangedWeaponAnimHelperComponent, AimingMontageConfigs) == 0x0000B0, "Member 'UTgfRangedWeaponAnimHelperComponent::AimingMontageConfigs' has a wrong offset!");
static_assert(offsetof(UTgfRangedWeaponAnimHelperComponent, NormalMontageConfigs) == 0x000100, "Member 'UTgfRangedWeaponAnimHelperComponent::NormalMontageConfigs' has a wrong offset!");
static_assert(offsetof(UTgfRangedWeaponAnimHelperComponent, CachedMesh) == 0x000150, "Member 'UTgfRangedWeaponAnimHelperComponent::CachedMesh' has a wrong offset!");

// Class LyraGame.TgfReplicationGraph
// 0x0140 (0x06C0 - 0x0580)
class UTgfReplicationGraph final : public UReplicationGraph
{
public:
	TArray<class UClass*>                         SpatializedClasses;                                // 0x0578(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x0588(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AlwaysRelevantClasses;                             // 0x0598(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x05B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x108];                                    // 0x05B8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfReplicationGraph">();
	}
	static class UTgfReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfReplicationGraph>();
	}
};
static_assert(alignof(UTgfReplicationGraph) == 0x000010, "Wrong alignment on UTgfReplicationGraph");
static_assert(sizeof(UTgfReplicationGraph) == 0x0006C0, "Wrong size on UTgfReplicationGraph");
static_assert(offsetof(UTgfReplicationGraph, SpatializedClasses) == 0x000578, "Member 'UTgfReplicationGraph::SpatializedClasses' has a wrong offset!");
static_assert(offsetof(UTgfReplicationGraph, NonSpatializedChildClasses) == 0x000588, "Member 'UTgfReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");
static_assert(offsetof(UTgfReplicationGraph, AlwaysRelevantClasses) == 0x000598, "Member 'UTgfReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UTgfReplicationGraph, GridNode) == 0x0005A8, "Member 'UTgfReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UTgfReplicationGraph, AlwaysRelevantNode) == 0x0005B0, "Member 'UTgfReplicationGraph::AlwaysRelevantNode' has a wrong offset!");

// Class LyraGame.TgfReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0028 (0x0078 - 0x0050)
class UTgfReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UTgfReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UTgfReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UTgfReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UTgfReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000078, "Wrong size on UTgfReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class LyraGame.TgfSkillWidgetBase
// 0x0098 (0x0348 - 0x02B0)
class UTgfSkillWidgetBase : public UTgfGameWidgetBase
{
public:
	class UTgfGameplayAbility*                    RelatedGA;                                         // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRelease;                                       // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayShowCooldownTime;                             // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CheckCanActiveTag;                                 // 0x02C0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x48];                                     // 0x02E0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAbilitySystemComponent*            LyraASC;                                           // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTgfMagicAttributeSet*                  MagicAttributeSet;                                 // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnActivateRelatedGAFailed();
	void BP_OnBuffAdd(class UTgfGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle, float RemainTime, float TotalTime);
	void BP_OnCooldownEnd();
	void BP_OnCooldownStart(float CooldownTime, float TotalTime, bool bNeedHideDuration, float HideDurationLimit);
	void BP_OnGameplayAbilityEnd(class UGameplayAbility* GameplayAbility);
	void BP_OnGEApply(const class UGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void BP_OnGERemove(const struct FActiveGameplayEffectHandle& GEHandle);
	void BP_OnSkillResourceChanged();
	bool CheckCostEnough();
	bool CheckHasAdditionalWeapon();
	bool CheckSkillCanActive();
	class FString FormatCooldownTime(float CDTime);
	void StartSkillCooldown(float ShowCDTime, float DelayTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSkillWidgetBase">();
	}
	static class UTgfSkillWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSkillWidgetBase>();
	}
};
static_assert(alignof(UTgfSkillWidgetBase) == 0x000008, "Wrong alignment on UTgfSkillWidgetBase");
static_assert(sizeof(UTgfSkillWidgetBase) == 0x000348, "Wrong size on UTgfSkillWidgetBase");
static_assert(offsetof(UTgfSkillWidgetBase, RelatedGA) == 0x0002B0, "Member 'UTgfSkillWidgetBase::RelatedGA' has a wrong offset!");
static_assert(offsetof(UTgfSkillWidgetBase, bCanRelease) == 0x0002B8, "Member 'UTgfSkillWidgetBase::bCanRelease' has a wrong offset!");
static_assert(offsetof(UTgfSkillWidgetBase, DelayShowCooldownTime) == 0x0002BC, "Member 'UTgfSkillWidgetBase::DelayShowCooldownTime' has a wrong offset!");
static_assert(offsetof(UTgfSkillWidgetBase, CheckCanActiveTag) == 0x0002C0, "Member 'UTgfSkillWidgetBase::CheckCanActiveTag' has a wrong offset!");
static_assert(offsetof(UTgfSkillWidgetBase, LyraASC) == 0x000328, "Member 'UTgfSkillWidgetBase::LyraASC' has a wrong offset!");
static_assert(offsetof(UTgfSkillWidgetBase, MagicAttributeSet) == 0x000330, "Member 'UTgfSkillWidgetBase::MagicAttributeSet' has a wrong offset!");

// Class LyraGame.TgfSnapToTargetDataAsset
// 0x0048 (0x0078 - 0x0030)
class UTgfSnapToTargetDataAsset final : public UPrimaryDataAsset
{
public:
	struct FTgfSnapQueryConfig                    QueryConfig;                                       // 0x0030(0x0048)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	bool GetQueryConfig(struct FTgfSnapQueryConfig* OutSnapQueryConfig) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSnapToTargetDataAsset">();
	}
	static class UTgfSnapToTargetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSnapToTargetDataAsset>();
	}
};
static_assert(alignof(UTgfSnapToTargetDataAsset) == 0x000008, "Wrong alignment on UTgfSnapToTargetDataAsset");
static_assert(sizeof(UTgfSnapToTargetDataAsset) == 0x000078, "Wrong size on UTgfSnapToTargetDataAsset");
static_assert(offsetof(UTgfSnapToTargetDataAsset, QueryConfig) == 0x000030, "Member 'UTgfSnapToTargetDataAsset::QueryConfig' has a wrong offset!");

// Class LyraGame.TgfModularActor
// 0x0000 (0x0298 - 0x0298)
class ATgfModularActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfModularActor">();
	}
	static class ATgfModularActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfModularActor>();
	}
};
static_assert(alignof(ATgfModularActor) == 0x000008, "Wrong alignment on ATgfModularActor");
static_assert(sizeof(ATgfModularActor) == 0x000298, "Wrong size on ATgfModularActor");

// Class LyraGame.LyraGameFeature_AddGameplayCuePaths
// 0x0008 (0x0030 - 0x0028)
class ULyraGameFeature_AddGameplayCuePaths final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameFeature_AddGameplayCuePaths">();
	}
	static class ULyraGameFeature_AddGameplayCuePaths* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameFeature_AddGameplayCuePaths>();
	}
};
static_assert(alignof(ULyraGameFeature_AddGameplayCuePaths) == 0x000008, "Wrong alignment on ULyraGameFeature_AddGameplayCuePaths");
static_assert(sizeof(ULyraGameFeature_AddGameplayCuePaths) == 0x000030, "Wrong size on ULyraGameFeature_AddGameplayCuePaths");

// Class LyraGame.TgfSpectatingActor
// 0x0018 (0x02B0 - 0x0298)
class ATgfSpectatingActor final : public ATgfModularActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULyraCameraComponent*                   CameraComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTgfCameraMode_SpectateActor> CameraModeClass;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExperienceLoaded(const class ULyraExperienceDefinition* Experience);

	TSubclassOf<class ULyraCameraMode> DetermineCameraMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSpectatingActor">();
	}
	static class ATgfSpectatingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfSpectatingActor>();
	}
};
static_assert(alignof(ATgfSpectatingActor) == 0x000008, "Wrong alignment on ATgfSpectatingActor");
static_assert(sizeof(ATgfSpectatingActor) == 0x0002B0, "Wrong size on ATgfSpectatingActor");
static_assert(offsetof(ATgfSpectatingActor, SceneComponent) == 0x000298, "Member 'ATgfSpectatingActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ATgfSpectatingActor, CameraComponent) == 0x0002A0, "Member 'ATgfSpectatingActor::CameraComponent' has a wrong offset!");
static_assert(offsetof(ATgfSpectatingActor, CameraModeClass) == 0x0002A8, "Member 'ATgfSpectatingActor::CameraModeClass' has a wrong offset!");

// Class LyraGame.TgfSpectatorManagerComponent
// 0x0068 (0x0110 - 0x00A8)
class UTgfSpectatorManagerComponent : public UControllerComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	ESpectatingTargetType                         CurrentSpectatingTarget;                           // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CountDownTime;                                     // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForbiddenTimeDuration;                             // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PitchOffsetForControlRotation;                     // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddSpectatingActors(class ATgfSpectatingActor* Actor);
	void CancelWidgetWhenSwitch();
	void FinishBlockSpectate();
	void ForceSwitchToOwn();
	void HandlePlayerDeath();
	void HandlePlayerDeathMithril(bool NeedSpectatePlayer);
	void MithrilRebirthCountDown();
	void MithrilRebirthNotice(class ALyraCharacter* Target);
	void OnViewMithrilRebirthExhausted(class ALyraCharacter* Target);
	void OnViewTargetDeathFinish(class AActor* OwningActor);
	void OnViewTargetExtractPortal(class AActor* TargetPawn);
	void OpenSpectateNoticeWindow(ESpectatingTargetType TargetType);
	void PVPRebirthCountDown();
	void ServerChangeViewTarget(class AActor* Target, ESpectatingTargetType CurrentType);
	void SetCurrentViewTarget(class AActor* Target);
	void StopSpectate();
	void StopSpectateWhenRebirth();
	void TrySpectate(bool ReverseSelection);
	bool WaitingToSpectate(bool IgnoreNoTarget, bool DirectlySpectate, bool NeedSpectatePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSpectatorManagerComponent">();
	}
	static class UTgfSpectatorManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSpectatorManagerComponent>();
	}
};
static_assert(alignof(UTgfSpectatorManagerComponent) == 0x000008, "Wrong alignment on UTgfSpectatorManagerComponent");
static_assert(sizeof(UTgfSpectatorManagerComponent) == 0x000110, "Wrong size on UTgfSpectatorManagerComponent");
static_assert(offsetof(UTgfSpectatorManagerComponent, CurrentSpectatingTarget) == 0x0000F8, "Member 'UTgfSpectatorManagerComponent::CurrentSpectatingTarget' has a wrong offset!");
static_assert(offsetof(UTgfSpectatorManagerComponent, CountDownTime) == 0x0000FC, "Member 'UTgfSpectatorManagerComponent::CountDownTime' has a wrong offset!");
static_assert(offsetof(UTgfSpectatorManagerComponent, ForbiddenTimeDuration) == 0x000100, "Member 'UTgfSpectatorManagerComponent::ForbiddenTimeDuration' has a wrong offset!");
static_assert(offsetof(UTgfSpectatorManagerComponent, PitchOffsetForControlRotation) == 0x000108, "Member 'UTgfSpectatorManagerComponent::PitchOffsetForControlRotation' has a wrong offset!");

// Class LyraGame.TgfStaffBeamDecal
// 0x0040 (0x0330 - 0x02F0)
class UTgfStaffBeamDecal : public UDecalComponent
{
public:
	float                                         BeamDecalLifeSpan;                                 // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeamDecalMaxSize;                                  // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BeamDecalLocation;                                 // 0x02F8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BeamDecalRotation;                                 // 0x0310(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBeamDecalPos(const struct FVector& CurrentPos);
	void SetBeamDecalRot(const struct FVector& HitNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfStaffBeamDecal">();
	}
	static class UTgfStaffBeamDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfStaffBeamDecal>();
	}
};
static_assert(alignof(UTgfStaffBeamDecal) == 0x000010, "Wrong alignment on UTgfStaffBeamDecal");
static_assert(sizeof(UTgfStaffBeamDecal) == 0x000330, "Wrong size on UTgfStaffBeamDecal");
static_assert(offsetof(UTgfStaffBeamDecal, BeamDecalLifeSpan) == 0x0002F0, "Member 'UTgfStaffBeamDecal::BeamDecalLifeSpan' has a wrong offset!");
static_assert(offsetof(UTgfStaffBeamDecal, BeamDecalMaxSize) == 0x0002F4, "Member 'UTgfStaffBeamDecal::BeamDecalMaxSize' has a wrong offset!");
static_assert(offsetof(UTgfStaffBeamDecal, BeamDecalLocation) == 0x0002F8, "Member 'UTgfStaffBeamDecal::BeamDecalLocation' has a wrong offset!");
static_assert(offsetof(UTgfStaffBeamDecal, BeamDecalRotation) == 0x000310, "Member 'UTgfStaffBeamDecal::BeamDecalRotation' has a wrong offset!");

// Class LyraGame.LyraNumberPopComponent_MeshText
// 0x00F0 (0x0198 - 0x00A8)
class ULyraNumberPopComponent_MeshText final : public ULyraNumberPopComponent
{
public:
	TArray<class ULyraDamagePopStyle*>            Styles;                                            // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         ComponentLifespan;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceFromCameraBeforeDoublingSize;              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalHitSizeMultiplier;                         // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FontXSize;                                         // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FontYSize;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpacingPercentageForOnes;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NumberOfNumberRotations;                           // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SignDigitParameterName;                            // 0x00D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ColorParameterName;                                // 0x00DC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AnimationLifespanParameterName;                    // 0x00E4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IsCriticalHitParameterName;                        // 0x00EC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MoveToCameraParameterName;                         // 0x00F4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PositionParameterNames;                            // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ScaleRotationAngleParameterNames;                  // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           DurationParameterNames;                            // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class UStaticMesh*, struct FPooledNumberPopComponentList> PooledComponentMap;                                // 0x0130(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLiveNumberPopEntry>            LiveComponents;                                    // 0x0180(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraNumberPopComponent_MeshText">();
	}
	static class ULyraNumberPopComponent_MeshText* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraNumberPopComponent_MeshText>();
	}
};
static_assert(alignof(ULyraNumberPopComponent_MeshText) == 0x000008, "Wrong alignment on ULyraNumberPopComponent_MeshText");
static_assert(sizeof(ULyraNumberPopComponent_MeshText) == 0x000198, "Wrong size on ULyraNumberPopComponent_MeshText");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, Styles) == 0x0000A8, "Member 'ULyraNumberPopComponent_MeshText::Styles' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, ComponentLifespan) == 0x0000B8, "Member 'ULyraNumberPopComponent_MeshText::ComponentLifespan' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, DistanceFromCameraBeforeDoublingSize) == 0x0000BC, "Member 'ULyraNumberPopComponent_MeshText::DistanceFromCameraBeforeDoublingSize' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, CriticalHitSizeMultiplier) == 0x0000C0, "Member 'ULyraNumberPopComponent_MeshText::CriticalHitSizeMultiplier' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, FontXSize) == 0x0000C4, "Member 'ULyraNumberPopComponent_MeshText::FontXSize' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, FontYSize) == 0x0000C8, "Member 'ULyraNumberPopComponent_MeshText::FontYSize' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, SpacingPercentageForOnes) == 0x0000CC, "Member 'ULyraNumberPopComponent_MeshText::SpacingPercentageForOnes' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, NumberOfNumberRotations) == 0x0000D0, "Member 'ULyraNumberPopComponent_MeshText::NumberOfNumberRotations' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, SignDigitParameterName) == 0x0000D4, "Member 'ULyraNumberPopComponent_MeshText::SignDigitParameterName' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, ColorParameterName) == 0x0000DC, "Member 'ULyraNumberPopComponent_MeshText::ColorParameterName' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, AnimationLifespanParameterName) == 0x0000E4, "Member 'ULyraNumberPopComponent_MeshText::AnimationLifespanParameterName' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, IsCriticalHitParameterName) == 0x0000EC, "Member 'ULyraNumberPopComponent_MeshText::IsCriticalHitParameterName' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, MoveToCameraParameterName) == 0x0000F4, "Member 'ULyraNumberPopComponent_MeshText::MoveToCameraParameterName' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, PositionParameterNames) == 0x000100, "Member 'ULyraNumberPopComponent_MeshText::PositionParameterNames' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, ScaleRotationAngleParameterNames) == 0x000110, "Member 'ULyraNumberPopComponent_MeshText::ScaleRotationAngleParameterNames' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, DurationParameterNames) == 0x000120, "Member 'ULyraNumberPopComponent_MeshText::DurationParameterNames' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, PooledComponentMap) == 0x000130, "Member 'ULyraNumberPopComponent_MeshText::PooledComponentMap' has a wrong offset!");
static_assert(offsetof(ULyraNumberPopComponent_MeshText, LiveComponents) == 0x000180, "Member 'ULyraNumberPopComponent_MeshText::LiveComponents' has a wrong offset!");

// Class LyraGame.TgfStatBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfStatBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddActorIntStat(class AActor* Actor, ETgfActorIntStatisticType Type, int32 TypeId, int32 Value);
	static void AddActorRelationIntStat(class AActor* Actor, ETgfActorRelationStatisticType Type, class AActor* OtherPlayer, int32 Value);
	static void AddActorRelationIntStatById(class AActor* Actor, ETgfActorRelationStatisticType Type, const class FString& OtherPlayerOpenId, int32 Value);
	static ELyraTeamComparison CompareActorTeams(const class UWorld* World, const class UObject* A, const class UObject* B);
	static class ALyraCharacter* FindSummonMaster(const class ALyraCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfStatBlueprintFunctionLibrary">();
	}
	static class UTgfStatBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfStatBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTgfStatBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTgfStatBlueprintFunctionLibrary");
static_assert(sizeof(UTgfStatBlueprintFunctionLibrary) == 0x000028, "Wrong size on UTgfStatBlueprintFunctionLibrary");

// Class LyraGame.TgfStaticInteraction
// 0x0030 (0x02C8 - 0x0298)
class ATgfStaticInteraction : public ATgfModularActor
{
public:
	bool                                          EnabledNetDormancy;                                // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTgfInteractorBattleComponent*          InteractorBattleComponent;                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfInteractorEventComponent*           InteractorEventComponent;                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfInterableType                             InterableType;                                     // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 InterableStatIdList;                               // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddRepObject(class UObject* Object);
	void BindMoonPhaseChangeEvent();
	void HandleHomelandMoonPhaseChangeEvent(class UObject* Args);
	void K2_HandleHomelandMoonPhaseChangeEvent(int32 MoonPhase);
	void K2_OnActorChannelOpen();
	void K2_OnEndPlay();
	void K2_OnNetCleanup();
	void K2_OnPostNetInit();
	void K2_OnPostNetReceive();
	void K2_OnPreNetReceive();
	void OnDeathFinished(class AActor* OwningActor);
	void OnDeathStarted(class AActor* OwningActor);
	void RemoveRepObject(class UObject* Object);

	const TArray<int32> GetInterableStatIdList() const;
	ETgfInterableType GetInterableType() const;
	bool IsDeadOrDying() const;
	bool IsEnableBattle() const;
	bool IsLightType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfStaticInteraction">();
	}
	static class ATgfStaticInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfStaticInteraction>();
	}
};
static_assert(alignof(ATgfStaticInteraction) == 0x000008, "Wrong alignment on ATgfStaticInteraction");
static_assert(sizeof(ATgfStaticInteraction) == 0x0002C8, "Wrong size on ATgfStaticInteraction");
static_assert(offsetof(ATgfStaticInteraction, EnabledNetDormancy) == 0x000298, "Member 'ATgfStaticInteraction::EnabledNetDormancy' has a wrong offset!");
static_assert(offsetof(ATgfStaticInteraction, InteractorBattleComponent) == 0x0002A0, "Member 'ATgfStaticInteraction::InteractorBattleComponent' has a wrong offset!");
static_assert(offsetof(ATgfStaticInteraction, InteractorEventComponent) == 0x0002A8, "Member 'ATgfStaticInteraction::InteractorEventComponent' has a wrong offset!");
static_assert(offsetof(ATgfStaticInteraction, InterableType) == 0x0002B0, "Member 'ATgfStaticInteraction::InterableType' has a wrong offset!");
static_assert(offsetof(ATgfStaticInteraction, InterableStatIdList) == 0x0002B8, "Member 'ATgfStaticInteraction::InterableStatIdList' has a wrong offset!");

// Class LyraGame.LyraGameFeaturePolicy
// 0x0010 (0x0038 - 0x0028)
class ULyraGameFeaturePolicy final : public UDefaultGameFeaturesProjectPolicies
{
public:
	TArray<class UObject*>                        Observers;                                         // 0x0028(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameFeaturePolicy">();
	}
	static class ULyraGameFeaturePolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameFeaturePolicy>();
	}
};
static_assert(alignof(ULyraGameFeaturePolicy) == 0x000008, "Wrong alignment on ULyraGameFeaturePolicy");
static_assert(sizeof(ULyraGameFeaturePolicy) == 0x000038, "Wrong size on ULyraGameFeaturePolicy");
static_assert(offsetof(ULyraGameFeaturePolicy, Observers) == 0x000028, "Member 'ULyraGameFeaturePolicy::Observers' has a wrong offset!");

// Class LyraGame.TgfSystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfSystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void OnQuitGame();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSystemBlueprintLibrary">();
	}
	static class UTgfSystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSystemBlueprintLibrary>();
	}
};
static_assert(alignof(UTgfSystemBlueprintLibrary) == 0x000008, "Wrong alignment on UTgfSystemBlueprintLibrary");
static_assert(sizeof(UTgfSystemBlueprintLibrary) == 0x000028, "Wrong size on UTgfSystemBlueprintLibrary");

// Class LyraGame.TgfTargetToSnapComponent
// 0x0000 (0x02A0 - 0x02A0)
class UTgfTargetToSnapComponent final : public USceneComponent
{
public:
	static struct FVector GetTargetLocation(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfTargetToSnapComponent">();
	}
	static class UTgfTargetToSnapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfTargetToSnapComponent>();
	}
};
static_assert(alignof(UTgfTargetToSnapComponent) == 0x000010, "Wrong alignment on UTgfTargetToSnapComponent");
static_assert(sizeof(UTgfTargetToSnapComponent) == 0x0002A0, "Wrong size on UTgfTargetToSnapComponent");

// Class LyraGame.LyraGameMode
// 0x0080 (0x03B8 - 0x0338)
class ALyraGameMode : public AModularGameModeBase
{
public:
	TSubclassOf<class AAIController>              BotControllerClass;                                // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x70];                                     // 0x0340(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeathZoneEnabled;                                 // 0x03B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfMatchType                                 MatchType;                                         // 0x03B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B2[0x6];                                      // 0x03B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* ChooseDeathPoint(class AController* Player);
	class AActor* ChooseWaitingPoint(class AController* Player);
	void DestroyCharacter(class AController* Controller);
	void RequestPlayerRestartNextFrame(class AController* Controller, bool bForceReset);
	class AAIController* SpawnCharacter(TSubclassOf<class ALyraAIController> ControllerClass, class ULyraAIControllerData* ControllerData, const struct FTransform& Transform, int32 TeamId);

	ETgfMatchType GetMatchType() const;
	const class ULyraPawnData* GetPawnDataForController(const class AController* InController) const;
	bool IsPvpMatchType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameMode">();
	}
	static class ALyraGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraGameMode>();
	}
};
static_assert(alignof(ALyraGameMode) == 0x000008, "Wrong alignment on ALyraGameMode");
static_assert(sizeof(ALyraGameMode) == 0x0003B8, "Wrong size on ALyraGameMode");
static_assert(offsetof(ALyraGameMode, BotControllerClass) == 0x000338, "Member 'ALyraGameMode::BotControllerClass' has a wrong offset!");
static_assert(offsetof(ALyraGameMode, bDeathZoneEnabled) == 0x0003B0, "Member 'ALyraGameMode::bDeathZoneEnabled' has a wrong offset!");
static_assert(offsetof(ALyraGameMode, MatchType) == 0x0003B1, "Member 'ALyraGameMode::MatchType' has a wrong offset!");

// Class LyraGame.TGFTeamCreationComponent
// 0x0000 (0x00A8 - 0x00A8)
class UTGFTeamCreationComponent final : public UGameStateComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamCreationComponent">();
	}
	static class UTGFTeamCreationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamCreationComponent>();
	}
};
static_assert(alignof(UTGFTeamCreationComponent) == 0x000008, "Wrong alignment on UTGFTeamCreationComponent");
static_assert(sizeof(UTGFTeamCreationComponent) == 0x0000A8, "Wrong size on UTGFTeamCreationComponent");

// Class LyraGame.TgfTestNetRPCs
// 0x0000 (0x0298 - 0x0298)
class ATgfTestNetRPCs final : public AActor
{
public:
	void ClientCall(ECallSource CallSource);
	void ServerCall(ECallSource CallSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfTestNetRPCs">();
	}
	static class ATgfTestNetRPCs* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfTestNetRPCs>();
	}
};
static_assert(alignof(ATgfTestNetRPCs) == 0x000008, "Wrong alignment on ATgfTestNetRPCs");
static_assert(sizeof(ATgfTestNetRPCs) == 0x000298, "Wrong size on ATgfTestNetRPCs");

// Class LyraGame.AsyncAction_LevelReady
// 0x0028 (0x0058 - 0x0030)
class UAsyncAction_LevelReady final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_LevelReady* WaitForLevelReady(class UObject* WorldContextObject, float TimeoutSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_LevelReady">();
	}
	static class UAsyncAction_LevelReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_LevelReady>();
	}
};
static_assert(alignof(UAsyncAction_LevelReady) == 0x000008, "Wrong alignment on UAsyncAction_LevelReady");
static_assert(sizeof(UAsyncAction_LevelReady) == 0x000058, "Wrong size on UAsyncAction_LevelReady");
static_assert(offsetof(UAsyncAction_LevelReady, OnReady) == 0x000030, "Member 'UAsyncAction_LevelReady::OnReady' has a wrong offset!");

// Class LyraGame.TGFThreatManagerComponent
// 0x00D8 (0x0180 - 0x00A8)
class UTGFThreatManagerComponent final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnThreatListOpen;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnThreatListClose;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnThreatTargetChanged;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    ThreatList;                                        // 0x00D8(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AActor*                                 ThreatTarget;                                      // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    TeamThreatList;                                    // 0x0130(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	float AddThreat(class AActor* Actor, float Threat);
	void ClearTeamThreatList();
	void ClearThreatList();
	float GetHighestThreat(class AActor** Target);
	float GetLowestThreat(class AActor** Target);
	TArray<struct FThreatInfo> GetSortedTargets(ETgfMonsterSelectTargetType SelectType, bool ASC);
	float GetSortedThreat(bool ASC, int32 Param_Index, class AActor** Target);
	float GetTeamThreat(class AActor* Actor);
	TMap<class AActor*, float> GetTeamThreatList();
	float GetThreat(class AActor* Actor);
	TMap<class AActor*, float> GetThreatList();
	class AActor* GetThreatTarget();
	bool HasTeamThreat(class AActor* Actor);
	bool HasThreat(class AActor* Actor);
	bool HasThreats();
	void RemoveTeamThreat(class AActor* Actor);
	float RemoveThreat(class AActor* Actor);
	void SetTeamThreat(class AActor* Actor, float Threat);
	void SetThreatTarget(class AActor* Actor);
	void SyncThreatList(class UTGFThreatManagerComponent* Source, bool SyncThreatValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFThreatManagerComponent">();
	}
	static class UTGFThreatManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFThreatManagerComponent>();
	}
};
static_assert(alignof(UTGFThreatManagerComponent) == 0x000008, "Wrong alignment on UTGFThreatManagerComponent");
static_assert(sizeof(UTGFThreatManagerComponent) == 0x000180, "Wrong size on UTGFThreatManagerComponent");
static_assert(offsetof(UTGFThreatManagerComponent, OnThreatListOpen) == 0x0000A8, "Member 'UTGFThreatManagerComponent::OnThreatListOpen' has a wrong offset!");
static_assert(offsetof(UTGFThreatManagerComponent, OnThreatListClose) == 0x0000B8, "Member 'UTGFThreatManagerComponent::OnThreatListClose' has a wrong offset!");
static_assert(offsetof(UTGFThreatManagerComponent, OnThreatTargetChanged) == 0x0000C8, "Member 'UTGFThreatManagerComponent::OnThreatTargetChanged' has a wrong offset!");
static_assert(offsetof(UTGFThreatManagerComponent, ThreatList) == 0x0000D8, "Member 'UTGFThreatManagerComponent::ThreatList' has a wrong offset!");
static_assert(offsetof(UTGFThreatManagerComponent, ThreatTarget) == 0x000128, "Member 'UTGFThreatManagerComponent::ThreatTarget' has a wrong offset!");
static_assert(offsetof(UTGFThreatManagerComponent, TeamThreatList) == 0x000130, "Member 'UTGFThreatManagerComponent::TeamThreatList' has a wrong offset!");

// Class LyraGame.TgfUIActionRouter
// 0x0000 (0x0158 - 0x0158)
class UTgfUIActionRouter final : public UCommonUIActionRouterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfUIActionRouter">();
	}
	static class UTgfUIActionRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfUIActionRouter>();
	}
};
static_assert(alignof(UTgfUIActionRouter) == 0x000008, "Wrong alignment on UTgfUIActionRouter");
static_assert(sizeof(UTgfUIActionRouter) == 0x000158, "Wrong size on UTgfUIActionRouter");

// Class LyraGame.GameFeatureAction_AddWidgets
// 0x0070 (0x00E8 - 0x0078)
class UGameFeatureAction_AddWidgets final : public UGameFeatureAction_WorldActionBase
{
public:
	TArray<struct FLyraHUDLayoutRequest>          Layout;                                            // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLyraHUDElementEntry>           Widgets;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddWidgets">();
	}
	static class UGameFeatureAction_AddWidgets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddWidgets>();
	}
};
static_assert(alignof(UGameFeatureAction_AddWidgets) == 0x000008, "Wrong alignment on UGameFeatureAction_AddWidgets");
static_assert(sizeof(UGameFeatureAction_AddWidgets) == 0x0000E8, "Wrong size on UGameFeatureAction_AddWidgets");
static_assert(offsetof(UGameFeatureAction_AddWidgets, Layout) == 0x000078, "Member 'UGameFeatureAction_AddWidgets::Layout' has a wrong offset!");
static_assert(offsetof(UGameFeatureAction_AddWidgets, Widgets) == 0x000088, "Member 'UGameFeatureAction_AddWidgets::Widgets' has a wrong offset!");

// Class LyraGame.TgfUIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfUIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ACEReportPlayer(const class FString& TargetOpenIdAndZoneIdString, const struct FPlayerNameData& TargetInPlayerNameData, class APlayerController* SourcePC);
	static void ChangeAnimationCurve(class UWidgetAnimation* InAnimation, class FName TargetTrackName, class UObject* BindingObject, float StartValue, float EndValue);
	static bool GetActivityOpened(int32 ActivityId);
	static class FString GetAppVersion();
	static bool GetChargeSkillMethod();
	static float GetConfiguredServerFrame(float DefaultValue);
	static ECommonInputType GetCurrentInputType(class UUserWidget* Widget);
	static int64 GetCurrentTimeStamp();
	static bool GetIsShowWeaponOperationTips();
	static class FName GetKeyName(const struct FKey& Key);
	static bool GetMouseTargetingMethod();
	static class FString GetNameFromPlayerNameData(const struct FPlayerNameData& InPlayerNameData, bool bIsForceUseHiddenName);
	static int32 GetPingLevelByConfig(float Ping);
	static class FString GetRoleHeadPortraitIconPathInGame(int32 TypeId, int32 Gender, int32 FaceId, int32 SkinColor, int32 RowId);
	static struct FDateTime GetUtcTime();
	static class ACharacter* GetWidgetOwnerCharacter(class UUserWidget* UserWidget);
	static bool IsLinuxVersion();
	static bool IsTooltipsAttributeAppendRange();
	static bool IsWolrdTearingDown(class UUserWidget* UserWidget);
	static class UUserWidget* OpenGuideWindow(class UUserWidget* FromWindow);
	static class UUserWidget* OpenKeyBindingConflictWindow();
	static void OpenReturnToLobbyConfirmWindow(class UUserWidget* FromWindow);
	static class UUserWidget* OpenSettingWindow(class UUserWidget* FromWindow);
	static bool PathExists(const class FString& Path);
	static void SendHomelandInteractTime();
	static void SendHomelandPickupMessage(int32 ItemId);
	static void SendPVPChallengeReceiveAwardMessage();
	static void SendReport(const struct FReportRecord& Record);
	static void SetInBattlePing(int32 InBattlePing);
	static bool SetIsShowWeaponOperationTips();
	static bool ShouldDrawDebug();
	static void ShouldShutDownHallGlobalEffects(bool bIsOpen);
	static bool ShouldTakeDeathScreenshot();
	static void ShowToast(const class FText& Message);
	static void ShowToastWithActor(const class FText& Message, class AActor* InputActor);
	static void ShowToastWithActorAndTime(const class FText& Message, class AActor* InputActor, float Time);
	static void ShowToastWithObject(const class FText& Message, class UObject* InputObject);
	static bool TakeDeathScreenshot(class FString* OutShotPath);
	static void ToggleGvoiceMic(bool bIsOpen);
	static void ToggleOptimizationForSceneCapture(bool bIsOpen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfUIBlueprintLibrary">();
	}
	static class UTgfUIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfUIBlueprintLibrary>();
	}
};
static_assert(alignof(UTgfUIBlueprintLibrary) == 0x000008, "Wrong alignment on UTgfUIBlueprintLibrary");
static_assert(sizeof(UTgfUIBlueprintLibrary) == 0x000028, "Wrong size on UTgfUIBlueprintLibrary");

// Class LyraGame.TgfVoiceChatBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfVoiceChatBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void RegisterVoiceChatActor(class AActor* Actor, const class FString& UserId);
	static void UnregisterVoiceChatActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfVoiceChatBlueprintLibrary">();
	}
	static class UTgfVoiceChatBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfVoiceChatBlueprintLibrary>();
	}
};
static_assert(alignof(UTgfVoiceChatBlueprintLibrary) == 0x000008, "Wrong alignment on UTgfVoiceChatBlueprintLibrary");
static_assert(sizeof(UTgfVoiceChatBlueprintLibrary) == 0x000028, "Wrong size on UTgfVoiceChatBlueprintLibrary");

// Class LyraGame.LyraExperienceManager
// 0x0050 (0x0080 - 0x0030)
class ULyraExperienceManager final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraExperienceManager">();
	}
	static class ULyraExperienceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraExperienceManager>();
	}
};
static_assert(alignof(ULyraExperienceManager) == 0x000008, "Wrong alignment on ULyraExperienceManager");
static_assert(sizeof(ULyraExperienceManager) == 0x000080, "Wrong size on ULyraExperienceManager");

// Class LyraGame.TgfWaitAbilityTask_TargetMovementMode
// 0x0020 (0x00A0 - 0x0080)
class UTgfWaitAbilityTask_TargetMovementMode final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnMode;                                            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfWaitAbilityTask_TargetMovementMode* CreateWaitTargetMovementMode(class UGameplayAbility* OwningAbility, EMovementMode MovementMode, uint8 CustomMode);

	void OnMovementModeChange(class ACharacter* Character, EMovementMode PrvMovementMode, uint8 PrvCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWaitAbilityTask_TargetMovementMode">();
	}
	static class UTgfWaitAbilityTask_TargetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWaitAbilityTask_TargetMovementMode>();
	}
};
static_assert(alignof(UTgfWaitAbilityTask_TargetMovementMode) == 0x000008, "Wrong alignment on UTgfWaitAbilityTask_TargetMovementMode");
static_assert(sizeof(UTgfWaitAbilityTask_TargetMovementMode) == 0x0000A0, "Wrong size on UTgfWaitAbilityTask_TargetMovementMode");
static_assert(offsetof(UTgfWaitAbilityTask_TargetMovementMode, OnMode) == 0x000080, "Member 'UTgfWaitAbilityTask_TargetMovementMode::OnMode' has a wrong offset!");

// Class LyraGame.TgfWeaponAnimDefinition
// 0x0090 (0x00F0 - 0x0060)
class UTgfWeaponAnimDefinition : public UTgfEquipmentDefinition
{
public:
	struct FLyraAnimLayerSelectionSet             EquippedAnimSet;                                   // 0x0060(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLyraAnimLayerSelectionSet             UneuippedAnimSet;                                  // 0x0078(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTgfWeaponEquipMontagesSet             EquipMontagesSet;                                  // 0x0090(0x0020)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAnimTagPairSet                        IdleAnimation;                                     // 0x00B0(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsRightIdleAnimation;                             // 0x00C8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTgfWeaponInspectionMontagesSet        InspectionMontagesSet;                             // 0x00D0(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UTgfWeaponTips>             WeaponTipsClass;                                   // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const class UAnimSequenceBase* PickIdleAnimation(const struct FGameplayTagContainer& CosmeticTags, bool* bIsRight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWeaponAnimDefinition">();
	}
	static class UTgfWeaponAnimDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWeaponAnimDefinition>();
	}
};
static_assert(alignof(UTgfWeaponAnimDefinition) == 0x000008, "Wrong alignment on UTgfWeaponAnimDefinition");
static_assert(sizeof(UTgfWeaponAnimDefinition) == 0x0000F0, "Wrong size on UTgfWeaponAnimDefinition");
static_assert(offsetof(UTgfWeaponAnimDefinition, EquippedAnimSet) == 0x000060, "Member 'UTgfWeaponAnimDefinition::EquippedAnimSet' has a wrong offset!");
static_assert(offsetof(UTgfWeaponAnimDefinition, UneuippedAnimSet) == 0x000078, "Member 'UTgfWeaponAnimDefinition::UneuippedAnimSet' has a wrong offset!");
static_assert(offsetof(UTgfWeaponAnimDefinition, EquipMontagesSet) == 0x000090, "Member 'UTgfWeaponAnimDefinition::EquipMontagesSet' has a wrong offset!");
static_assert(offsetof(UTgfWeaponAnimDefinition, IdleAnimation) == 0x0000B0, "Member 'UTgfWeaponAnimDefinition::IdleAnimation' has a wrong offset!");
static_assert(offsetof(UTgfWeaponAnimDefinition, bIsRightIdleAnimation) == 0x0000C8, "Member 'UTgfWeaponAnimDefinition::bIsRightIdleAnimation' has a wrong offset!");
static_assert(offsetof(UTgfWeaponAnimDefinition, InspectionMontagesSet) == 0x0000D0, "Member 'UTgfWeaponAnimDefinition::InspectionMontagesSet' has a wrong offset!");
static_assert(offsetof(UTgfWeaponAnimDefinition, WeaponTipsClass) == 0x0000E8, "Member 'UTgfWeaponAnimDefinition::WeaponTipsClass' has a wrong offset!");

// Class LyraGame.LyraTextHotfixConfig
// 0x0010 (0x0048 - 0x0038)
class ULyraTextHotfixConfig final : public UDeveloperSettings
{
public:
	TArray<struct FPolyglotTextData>              TextReplacements;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTextHotfixConfig">();
	}
	static class ULyraTextHotfixConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTextHotfixConfig>();
	}
};
static_assert(alignof(ULyraTextHotfixConfig) == 0x000008, "Wrong alignment on ULyraTextHotfixConfig");
static_assert(sizeof(ULyraTextHotfixConfig) == 0x000048, "Wrong size on ULyraTextHotfixConfig");
static_assert(offsetof(ULyraTextHotfixConfig, TextReplacements) == 0x000038, "Member 'ULyraTextHotfixConfig::TextReplacements' has a wrong offset!");

// Class LyraGame.TgfWeaponDefinition
// 0x00A8 (0x0108 - 0x0060)
class UTgfWeaponDefinition : public UTgfEquipmentDefinition
{
public:
	TSubclassOf<class UTgfWeaponAnimDefinition>   SingleAnimWeaponDefinition;                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTgfWeaponAnimConfig>           DoubleHandsConfig;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EPhysicalSurface                              GuardSurfaceType;                                  // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATgfProjectileBase>         NormalProjectile;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATgfProjectileBase>         TrackProjectile;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATgfProjectileBase>         AnimDriveProjectile;                               // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATgfProjectileBase>         NoHitProjectile;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class ATgfProjectileBase>> TaggedProjectile;                                  // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class ULyraInventoryItemDefinition> AmmoDefinition;                                    // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmmo;                                           // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoAutoRecover;                                   // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAmmoType                               AmmoType;                                          // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoDisplayCnt;                                    // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TSubclassOf<class UTgfWeaponAnimDefinition> GetWeaponAnimDefinition(ETgfEquipSubType AssistSlot, bool ForceSingle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWeaponDefinition">();
	}
	static class UTgfWeaponDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWeaponDefinition>();
	}
};
static_assert(alignof(UTgfWeaponDefinition) == 0x000008, "Wrong alignment on UTgfWeaponDefinition");
static_assert(sizeof(UTgfWeaponDefinition) == 0x000108, "Wrong size on UTgfWeaponDefinition");
static_assert(offsetof(UTgfWeaponDefinition, SingleAnimWeaponDefinition) == 0x000060, "Member 'UTgfWeaponDefinition::SingleAnimWeaponDefinition' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, DoubleHandsConfig) == 0x000068, "Member 'UTgfWeaponDefinition::DoubleHandsConfig' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, GuardSurfaceType) == 0x000078, "Member 'UTgfWeaponDefinition::GuardSurfaceType' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, NormalProjectile) == 0x000080, "Member 'UTgfWeaponDefinition::NormalProjectile' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, TrackProjectile) == 0x000088, "Member 'UTgfWeaponDefinition::TrackProjectile' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, AnimDriveProjectile) == 0x000090, "Member 'UTgfWeaponDefinition::AnimDriveProjectile' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, NoHitProjectile) == 0x000098, "Member 'UTgfWeaponDefinition::NoHitProjectile' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, TaggedProjectile) == 0x0000A0, "Member 'UTgfWeaponDefinition::TaggedProjectile' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, AmmoDefinition) == 0x0000F0, "Member 'UTgfWeaponDefinition::AmmoDefinition' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, MaxAmmo) == 0x0000F8, "Member 'UTgfWeaponDefinition::MaxAmmo' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, AmmoAutoRecover) == 0x0000FC, "Member 'UTgfWeaponDefinition::AmmoAutoRecover' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, AmmoType) == 0x000100, "Member 'UTgfWeaponDefinition::AmmoType' has a wrong offset!");
static_assert(offsetof(UTgfWeaponDefinition, AmmoDisplayCnt) == 0x000104, "Member 'UTgfWeaponDefinition::AmmoDisplayCnt' has a wrong offset!");

// Class LyraGame.TgfWeaponTips
// 0x0000 (0x0298 - 0x0298)
class UTgfWeaponTips final : public UTickerUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWeaponTips">();
	}
	static class UTgfWeaponTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWeaponTips>();
	}
};
static_assert(alignof(UTgfWeaponTips) == 0x000008, "Wrong alignment on UTgfWeaponTips");
static_assert(sizeof(UTgfWeaponTips) == 0x000298, "Wrong size on UTgfWeaponTips");

// Class LyraGame.LyraUserFacingExperienceDefinition
// 0x00F8 (0x0128 - 0x0030)
class ULyraUserFacingExperienceDefinition final : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetId                        MapId;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ExperienceID;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ExtraArgs;                                         // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TileTitle;                                         // 0x00A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TileSubTitle;                                      // 0x00B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TileDescription;                                   // 0x00D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             TileIcon;                                          // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LoadingScreenWidget;                               // 0x00F0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDefaultExperience;                              // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInFrontEnd;                                   // 0x0121(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordReplay;                                     // 0x0122(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x1];                                      // 0x0123(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayerCount;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UCommonSession_HostSessionRequest* CreateHostingRequest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUserFacingExperienceDefinition">();
	}
	static class ULyraUserFacingExperienceDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUserFacingExperienceDefinition>();
	}
};
static_assert(alignof(ULyraUserFacingExperienceDefinition) == 0x000008, "Wrong alignment on ULyraUserFacingExperienceDefinition");
static_assert(sizeof(ULyraUserFacingExperienceDefinition) == 0x000128, "Wrong size on ULyraUserFacingExperienceDefinition");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, MapId) == 0x000030, "Member 'ULyraUserFacingExperienceDefinition::MapId' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, ExperienceID) == 0x000040, "Member 'ULyraUserFacingExperienceDefinition::ExperienceID' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, ExtraArgs) == 0x000050, "Member 'ULyraUserFacingExperienceDefinition::ExtraArgs' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, TileTitle) == 0x0000A0, "Member 'ULyraUserFacingExperienceDefinition::TileTitle' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, TileSubTitle) == 0x0000B8, "Member 'ULyraUserFacingExperienceDefinition::TileSubTitle' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, TileDescription) == 0x0000D0, "Member 'ULyraUserFacingExperienceDefinition::TileDescription' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, TileIcon) == 0x0000E8, "Member 'ULyraUserFacingExperienceDefinition::TileIcon' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, LoadingScreenWidget) == 0x0000F0, "Member 'ULyraUserFacingExperienceDefinition::LoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, bIsDefaultExperience) == 0x000120, "Member 'ULyraUserFacingExperienceDefinition::bIsDefaultExperience' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, bShowInFrontEnd) == 0x000121, "Member 'ULyraUserFacingExperienceDefinition::bShowInFrontEnd' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, bRecordReplay) == 0x000122, "Member 'ULyraUserFacingExperienceDefinition::bRecordReplay' has a wrong offset!");
static_assert(offsetof(ULyraUserFacingExperienceDefinition, MaxPlayerCount) == 0x000124, "Member 'ULyraUserFacingExperienceDefinition::MaxPlayerCount' has a wrong offset!");

// Class LyraGame.TgfWidgetFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfWidgetFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetGridSlotColumnSpan(const class UGridSlot* Slot);
	static int32 GetGridSlotRowSpan(const class UGridSlot* Slot);
	static class UTexture2D* LoadTextureFromPath(const class FString& Path);
	static struct FVector2D MakePopupWindowPosition(const struct FVector2D& AnchorPosition, const struct FVector2D& AnchorSize, const struct FVector2D& Size);
	static void MarkInsightAnchor(const class FString& InsightDataString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWidgetFunctionLibrary">();
	}
	static class UTgfWidgetFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWidgetFunctionLibrary>();
	}
};
static_assert(alignof(UTgfWidgetFunctionLibrary) == 0x000008, "Wrong alignment on UTgfWidgetFunctionLibrary");
static_assert(sizeof(UTgfWidgetFunctionLibrary) == 0x000028, "Wrong size on UTgfWidgetFunctionLibrary");

// Class LyraGame.TgfWidgetGamepadWrapper
// 0x0090 (0x00B8 - 0x0028)
class UTgfWidgetGamepadWrapper final : public UTgfBlueprintableObject
{
public:
	class UUserWidget*                            OwnerWidget;                                       // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            CachedFocusWidget;                                 // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            DefaultFocusWidget;                                // 0x0038(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentIdx;                                        // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FWidgetList>               CanFocusedWidgets;                                 // 0x0048(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUserWidget*>                    DebugPoints;                                       // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddCanFocusedWidget(class UUserWidget* UserWidget, int32 PageIdx);
	void BindCustomNavigation(class UUserWidget* Widget);
	class UUserWidget* BP_GetDefaultFocusWidget();
	class UUserWidget* GetDefaultFocusWidget();
	class UUserWidget* GetNextFocWidget(EUINavigation Navigation, class UUserWidget* FromWidget);
	struct FVector2D GetWidgetCenterLocation(class UUserWidget* Widget);
	void InitWrapper(class UUserWidget* Owner);
	void RemoveCanFocusedWidget(class UUserWidget* UserWidget, int32 PageIdx);
	void RemoveDebugPoints(TSubclassOf<class UUserWidget> WidgetClass);
	void SetInventoryAnalogCursor();
	void ShowDebugPoints(TSubclassOf<class UUserWidget> WidgetClass);

	class UCommonInputSubsystem* GetCommonInputSubsystem() const;
	ECommonInputType GetCurrentInputType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWidgetGamepadWrapper">();
	}
	static class UTgfWidgetGamepadWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWidgetGamepadWrapper>();
	}
};
static_assert(alignof(UTgfWidgetGamepadWrapper) == 0x000008, "Wrong alignment on UTgfWidgetGamepadWrapper");
static_assert(sizeof(UTgfWidgetGamepadWrapper) == 0x0000B8, "Wrong size on UTgfWidgetGamepadWrapper");
static_assert(offsetof(UTgfWidgetGamepadWrapper, OwnerWidget) == 0x000028, "Member 'UTgfWidgetGamepadWrapper::OwnerWidget' has a wrong offset!");
static_assert(offsetof(UTgfWidgetGamepadWrapper, CachedFocusWidget) == 0x000030, "Member 'UTgfWidgetGamepadWrapper::CachedFocusWidget' has a wrong offset!");
static_assert(offsetof(UTgfWidgetGamepadWrapper, DefaultFocusWidget) == 0x000038, "Member 'UTgfWidgetGamepadWrapper::DefaultFocusWidget' has a wrong offset!");
static_assert(offsetof(UTgfWidgetGamepadWrapper, CurrentIdx) == 0x000040, "Member 'UTgfWidgetGamepadWrapper::CurrentIdx' has a wrong offset!");
static_assert(offsetof(UTgfWidgetGamepadWrapper, CanFocusedWidgets) == 0x000048, "Member 'UTgfWidgetGamepadWrapper::CanFocusedWidgets' has a wrong offset!");
static_assert(offsetof(UTgfWidgetGamepadWrapper, DebugPoints) == 0x0000A8, "Member 'UTgfWidgetGamepadWrapper::DebugPoints' has a wrong offset!");

// Class LyraGame.LyraExperienceActionSet
// 0x0020 (0x0050 - 0x0030)
class ULyraExperienceActionSet final : public UPrimaryDataAsset
{
public:
	TArray<class UGameFeatureAction*>             Actions;                                           // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FString>                         GameFeaturesToEnable;                              // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraExperienceActionSet">();
	}
	static class ULyraExperienceActionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraExperienceActionSet>();
	}
};
static_assert(alignof(ULyraExperienceActionSet) == 0x000008, "Wrong alignment on ULyraExperienceActionSet");
static_assert(sizeof(ULyraExperienceActionSet) == 0x000050, "Wrong size on ULyraExperienceActionSet");
static_assert(offsetof(ULyraExperienceActionSet, Actions) == 0x000030, "Member 'ULyraExperienceActionSet::Actions' has a wrong offset!");
static_assert(offsetof(ULyraExperienceActionSet, GameFeaturesToEnable) == 0x000040, "Member 'ULyraExperienceActionSet::GameFeaturesToEnable' has a wrong offset!");

// Class LyraGame.TgfWidgetGamepadWrapperLibrary
// 0x0000 (0x0028 - 0x0028)
class UTgfWidgetGamepadWrapperLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UTgfWidgetGamepadWrapper* CreateWidgetGamepadWrapper(class UUserWidget* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWidgetGamepadWrapperLibrary">();
	}
	static class UTgfWidgetGamepadWrapperLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWidgetGamepadWrapperLibrary>();
	}
};
static_assert(alignof(UTgfWidgetGamepadWrapperLibrary) == 0x000008, "Wrong alignment on UTgfWidgetGamepadWrapperLibrary");
static_assert(sizeof(UTgfWidgetGamepadWrapperLibrary) == 0x000028, "Wrong size on UTgfWidgetGamepadWrapperLibrary");

// Class LyraGame.TgfWorldInventoryManagerComponent
// 0x0000 (0x0208 - 0x0208)
class UTgfWorldInventoryManagerComponent final : public UTgfInventoryManagerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWorldInventoryManagerComponent">();
	}
	static class UTgfWorldInventoryManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWorldInventoryManagerComponent>();
	}
};
static_assert(alignof(UTgfWorldInventoryManagerComponent) == 0x000008, "Wrong alignment on UTgfWorldInventoryManagerComponent");
static_assert(sizeof(UTgfWorldInventoryManagerComponent) == 0x000208, "Wrong size on UTgfWorldInventoryManagerComponent");

// Class LyraGame.TgfWrapBox
// 0x0018 (0x01A8 - 0x0190)
class UTgfWrapBox final : public UWrapBox
{
public:
	bool                                          bInvertVertically;                                 // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_191[0x17];                                     // 0x0191(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWrapBox">();
	}
	static class UTgfWrapBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWrapBox>();
	}
};
static_assert(alignof(UTgfWrapBox) == 0x000008, "Wrong alignment on UTgfWrapBox");
static_assert(sizeof(UTgfWrapBox) == 0x0001A8, "Wrong size on UTgfWrapBox");
static_assert(offsetof(UTgfWrapBox, bInvertVertically) == 0x000190, "Member 'UTgfWrapBox::bInvertVertically' has a wrong offset!");

// Class LyraGame.TgfInputModifierValueScale
// 0x0028 (0x0050 - 0x0028)
class UTgfInputModifierValueScale final : public UInputModifier
{
public:
	bool                                          bX;                                                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bY;                                                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZ;                                                // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MouseSensitivityConvertCurve;                      // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInputModifierValueScale">();
	}
	static class UTgfInputModifierValueScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInputModifierValueScale>();
	}
};
static_assert(alignof(UTgfInputModifierValueScale) == 0x000008, "Wrong alignment on UTgfInputModifierValueScale");
static_assert(sizeof(UTgfInputModifierValueScale) == 0x000050, "Wrong size on UTgfInputModifierValueScale");
static_assert(offsetof(UTgfInputModifierValueScale, bX) == 0x000028, "Member 'UTgfInputModifierValueScale::bX' has a wrong offset!");
static_assert(offsetof(UTgfInputModifierValueScale, bY) == 0x000029, "Member 'UTgfInputModifierValueScale::bY' has a wrong offset!");
static_assert(offsetof(UTgfInputModifierValueScale, bZ) == 0x00002A, "Member 'UTgfInputModifierValueScale::bZ' has a wrong offset!");
static_assert(offsetof(UTgfInputModifierValueScale, Scale) == 0x000030, "Member 'UTgfInputModifierValueScale::Scale' has a wrong offset!");
static_assert(offsetof(UTgfInputModifierValueScale, MouseSensitivityConvertCurve) == 0x000048, "Member 'UTgfInputModifierValueScale::MouseSensitivityConvertCurve' has a wrong offset!");

// Class LyraGame.LyraAbilityCost_InventoryItem
// 0x0030 (0x0068 - 0x0038)
class ULyraAbilityCost_InventoryItem final : public ULyraAbilityCost
{
public:
	struct FScalableFloat                         Quantity;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ULyraInventoryItemDefinition> ItemDefinition;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilityCost_InventoryItem">();
	}
	static class ULyraAbilityCost_InventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilityCost_InventoryItem>();
	}
};
static_assert(alignof(ULyraAbilityCost_InventoryItem) == 0x000008, "Wrong alignment on ULyraAbilityCost_InventoryItem");
static_assert(sizeof(ULyraAbilityCost_InventoryItem) == 0x000068, "Wrong size on ULyraAbilityCost_InventoryItem");
static_assert(offsetof(ULyraAbilityCost_InventoryItem, Quantity) == 0x000038, "Member 'ULyraAbilityCost_InventoryItem::Quantity' has a wrong offset!");
static_assert(offsetof(ULyraAbilityCost_InventoryItem, ItemDefinition) == 0x000060, "Member 'ULyraAbilityCost_InventoryItem::ItemDefinition' has a wrong offset!");

// Class LyraGame.LyraAbilityCost_ItemTagStack
// 0x0038 (0x0070 - 0x0038)
class ULyraAbilityCost_ItemTagStack final : public ULyraAbilityCost
{
public:
	struct FScalableFloat                         Quantity;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Tag;                                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FailureTag;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilityCost_ItemTagStack">();
	}
	static class ULyraAbilityCost_ItemTagStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilityCost_ItemTagStack>();
	}
};
static_assert(alignof(ULyraAbilityCost_ItemTagStack) == 0x000008, "Wrong alignment on ULyraAbilityCost_ItemTagStack");
static_assert(sizeof(ULyraAbilityCost_ItemTagStack) == 0x000070, "Wrong size on ULyraAbilityCost_ItemTagStack");
static_assert(offsetof(ULyraAbilityCost_ItemTagStack, Quantity) == 0x000038, "Member 'ULyraAbilityCost_ItemTagStack::Quantity' has a wrong offset!");
static_assert(offsetof(ULyraAbilityCost_ItemTagStack, Tag) == 0x000060, "Member 'ULyraAbilityCost_ItemTagStack::Tag' has a wrong offset!");
static_assert(offsetof(ULyraAbilityCost_ItemTagStack, FailureTag) == 0x000068, "Member 'ULyraAbilityCost_ItemTagStack::FailureTag' has a wrong offset!");

// Class LyraGame.LyraSettingsListEntrySetting_KeyboardInput
// 0x0048 (0x0348 - 0x0300)
class ULyraSettingsListEntrySetting_KeyboardInput final : public UGameSettingListEntry_Setting
{
public:
	struct FKey                                   OriginalKeyToBind;                                 // 0x0300(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraSettingKeyboardInput*              KeyboardInputSetting;                              // 0x0318(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameSettingPressAnyKey>    PressAnyKeyPanelClass;                             // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKeyAlreadyBoundWarning>    KeyAlreadyBoundWarningPanelClass;                  // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraButtonBase*                        Button_PrimaryKey;                                 // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraButtonBase*                        Button_SecondaryKey;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraButtonBase*                        Button_Clear;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingsListEntrySetting_KeyboardInput">();
	}
	static class ULyraSettingsListEntrySetting_KeyboardInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingsListEntrySetting_KeyboardInput>();
	}
};
static_assert(alignof(ULyraSettingsListEntrySetting_KeyboardInput) == 0x000008, "Wrong alignment on ULyraSettingsListEntrySetting_KeyboardInput");
static_assert(sizeof(ULyraSettingsListEntrySetting_KeyboardInput) == 0x000348, "Wrong size on ULyraSettingsListEntrySetting_KeyboardInput");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, OriginalKeyToBind) == 0x000300, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::OriginalKeyToBind' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, KeyboardInputSetting) == 0x000318, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::KeyboardInputSetting' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, PressAnyKeyPanelClass) == 0x000320, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::PressAnyKeyPanelClass' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, KeyAlreadyBoundWarningPanelClass) == 0x000328, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::KeyAlreadyBoundWarningPanelClass' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_PrimaryKey) == 0x000330, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_PrimaryKey' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_SecondaryKey) == 0x000338, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_SecondaryKey' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_Clear) == 0x000340, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_Clear' has a wrong offset!");

// Class LyraGame.LyraAbilityCost_PlayerTagStack
// 0x0030 (0x0068 - 0x0038)
class ULyraAbilityCost_PlayerTagStack final : public ULyraAbilityCost
{
public:
	struct FScalableFloat                         Quantity;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Tag;                                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilityCost_PlayerTagStack">();
	}
	static class ULyraAbilityCost_PlayerTagStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilityCost_PlayerTagStack>();
	}
};
static_assert(alignof(ULyraAbilityCost_PlayerTagStack) == 0x000008, "Wrong alignment on ULyraAbilityCost_PlayerTagStack");
static_assert(sizeof(ULyraAbilityCost_PlayerTagStack) == 0x000068, "Wrong size on ULyraAbilityCost_PlayerTagStack");
static_assert(offsetof(ULyraAbilityCost_PlayerTagStack, Quantity) == 0x000038, "Member 'ULyraAbilityCost_PlayerTagStack::Quantity' has a wrong offset!");
static_assert(offsetof(ULyraAbilityCost_PlayerTagStack, Tag) == 0x000060, "Member 'ULyraAbilityCost_PlayerTagStack::Tag' has a wrong offset!");

// Class LyraGame.LyraGameplayAbility_Death
// 0x0008 (0x0690 - 0x0688)
class ULyraGameplayAbility_Death : public ULyraGameplayAbility
{
public:
	bool                                          bAutoStartDeath;                                   // 0x0688(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InDeathing;                                        // 0x0689(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68A[0x6];                                      // 0x068A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishDeath();
	void StartDeath(EAnimConfigDirection DeathDirection, const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayAbility_Death">();
	}
	static class ULyraGameplayAbility_Death* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayAbility_Death>();
	}
};
static_assert(alignof(ULyraGameplayAbility_Death) == 0x000008, "Wrong alignment on ULyraGameplayAbility_Death");
static_assert(sizeof(ULyraGameplayAbility_Death) == 0x000690, "Wrong size on ULyraGameplayAbility_Death");
static_assert(offsetof(ULyraGameplayAbility_Death, bAutoStartDeath) == 0x000688, "Member 'ULyraGameplayAbility_Death::bAutoStartDeath' has a wrong offset!");
static_assert(offsetof(ULyraGameplayAbility_Death, InDeathing) == 0x000689, "Member 'ULyraGameplayAbility_Death::InDeathing' has a wrong offset!");

// Class LyraGame.LyraGameplayAbility_Jump
// 0x0000 (0x0688 - 0x0688)
class ULyraGameplayAbility_Jump : public ULyraGameplayAbility
{
public:
	void CharacterJumpStart();
	void CharacterJumpStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayAbility_Jump">();
	}
	static class ULyraGameplayAbility_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayAbility_Jump>();
	}
};
static_assert(alignof(ULyraGameplayAbility_Jump) == 0x000008, "Wrong alignment on ULyraGameplayAbility_Jump");
static_assert(sizeof(ULyraGameplayAbility_Jump) == 0x000688, "Wrong size on ULyraGameplayAbility_Jump");

// Class LyraGame.LyraGameplayAbility_Killing
// 0x0000 (0x0688 - 0x0688)
class ULyraGameplayAbility_Killing : public ULyraGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayAbility_Killing">();
	}
	static class ULyraGameplayAbility_Killing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayAbility_Killing>();
	}
};
static_assert(alignof(ULyraGameplayAbility_Killing) == 0x000008, "Wrong alignment on ULyraGameplayAbility_Killing");
static_assert(sizeof(ULyraGameplayAbility_Killing) == 0x000688, "Wrong size on ULyraGameplayAbility_Killing");

// Class LyraGame.LyraInputModifierGamepadSensitivity
// 0x0018 (0x0040 - 0x0028)
class ULyraInputModifierGamepadSensitivity final : public UInputModifier
{
public:
	ELyraTargetingType                            TargetingType;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAimSensitivityData*                SensitivityLevelTable;                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MouseSensitivityConvertCurve;                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierGamepadSensitivity">();
	}
	static class ULyraInputModifierGamepadSensitivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierGamepadSensitivity>();
	}
};
static_assert(alignof(ULyraInputModifierGamepadSensitivity) == 0x000008, "Wrong alignment on ULyraInputModifierGamepadSensitivity");
static_assert(sizeof(ULyraInputModifierGamepadSensitivity) == 0x000040, "Wrong size on ULyraInputModifierGamepadSensitivity");
static_assert(offsetof(ULyraInputModifierGamepadSensitivity, TargetingType) == 0x000028, "Member 'ULyraInputModifierGamepadSensitivity::TargetingType' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierGamepadSensitivity, SensitivityLevelTable) == 0x000030, "Member 'ULyraInputModifierGamepadSensitivity::SensitivityLevelTable' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierGamepadSensitivity, MouseSensitivityConvertCurve) == 0x000038, "Member 'ULyraInputModifierGamepadSensitivity::MouseSensitivityConvertCurve' has a wrong offset!");

// Class LyraGame.LyraGameplayAbility_Reset
// 0x0000 (0x0688 - 0x0688)
class ULyraGameplayAbility_Reset final : public ULyraGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayAbility_Reset">();
	}
	static class ULyraGameplayAbility_Reset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayAbility_Reset>();
	}
};
static_assert(alignof(ULyraGameplayAbility_Reset) == 0x000008, "Wrong alignment on ULyraGameplayAbility_Reset");
static_assert(sizeof(ULyraGameplayAbility_Reset) == 0x000688, "Wrong size on ULyraGameplayAbility_Reset");

// Class LyraGame.TgfGameplayCueNotify_BurstLatent
// 0x0110 (0x0B70 - 0x0A60)
class ATgfGameplayCueNotify_BurstLatent final : public AGameplayCueNotify_BurstLatent
{
public:
	struct FTgfGameplayCueNotify_BurstEffects     TgfBurstEffects;                                   // 0x0A60(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTgfGameplayCueNotify_SpawnResult      TgfBurstSpawnResults;                              // 0x0B50(0x0020)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnTgfBurst(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling, EPhysicalSurface SurfaceType);
	void PrintRecord(const class FString& TagString, class AActor* Target, const struct FGameplayCueParameters& Parameters);
	bool ShouldPlayGameplayCue(const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayCueNotify_BurstLatent">();
	}
	static class ATgfGameplayCueNotify_BurstLatent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfGameplayCueNotify_BurstLatent>();
	}
};
static_assert(alignof(ATgfGameplayCueNotify_BurstLatent) == 0x000008, "Wrong alignment on ATgfGameplayCueNotify_BurstLatent");
static_assert(sizeof(ATgfGameplayCueNotify_BurstLatent) == 0x000B70, "Wrong size on ATgfGameplayCueNotify_BurstLatent");
static_assert(offsetof(ATgfGameplayCueNotify_BurstLatent, TgfBurstEffects) == 0x000A60, "Member 'ATgfGameplayCueNotify_BurstLatent::TgfBurstEffects' has a wrong offset!");
static_assert(offsetof(ATgfGameplayCueNotify_BurstLatent, TgfBurstSpawnResults) == 0x000B50, "Member 'ATgfGameplayCueNotify_BurstLatent::TgfBurstSpawnResults' has a wrong offset!");

// Class LyraGame.AbilityTask_WaitForInteractableTargets_SingleLineTrace
// 0x0100 (0x01B0 - 0x00B0)
class UAbilityTask_WaitForInteractableTargets_SingleLineTrace final : public UAbilityTask_WaitForInteractableTargets
{
public:
	struct FInteractionQuery                      InteractionQuery;                                  // 0x00B0(0x0038)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  StartLocation;                                     // 0x00F0(0x00A0)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x20];                                     // 0x0190(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitForInteractableTargets_SingleLineTrace* WaitForInteractableTargets_SingleLineTrace(class UGameplayAbility* OwningAbility, const struct FInteractionQuery& Param_InteractionQuery, const struct FCollisionProfileName& TraceProfile, const struct FGameplayAbilityTargetingLocationInfo& Param_StartLocation, float InteractionScanRange, float InteractionScanRate, bool bShowDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitForInteractableTargets_SingleLineTrace">();
	}
	static class UAbilityTask_WaitForInteractableTargets_SingleLineTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitForInteractableTargets_SingleLineTrace>();
	}
};
static_assert(alignof(UAbilityTask_WaitForInteractableTargets_SingleLineTrace) == 0x000010, "Wrong alignment on UAbilityTask_WaitForInteractableTargets_SingleLineTrace");
static_assert(sizeof(UAbilityTask_WaitForInteractableTargets_SingleLineTrace) == 0x0001B0, "Wrong size on UAbilityTask_WaitForInteractableTargets_SingleLineTrace");
static_assert(offsetof(UAbilityTask_WaitForInteractableTargets_SingleLineTrace, InteractionQuery) == 0x0000B0, "Member 'UAbilityTask_WaitForInteractableTargets_SingleLineTrace::InteractionQuery' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitForInteractableTargets_SingleLineTrace, StartLocation) == 0x0000F0, "Member 'UAbilityTask_WaitForInteractableTargets_SingleLineTrace::StartLocation' has a wrong offset!");

// Class LyraGame.LyraCombatSet
// 0x0020 (0x0050 - 0x0030)
class ULyraCombatSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 BaseDamage;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameplayAttributeData                 BaseHeal;                                          // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_BaseDamage(const struct FGameplayAttributeData& OldValue);
	void OnRep_BaseHeal(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCombatSet">();
	}
	static class ULyraCombatSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCombatSet>();
	}
};
static_assert(alignof(ULyraCombatSet) == 0x000008, "Wrong alignment on ULyraCombatSet");
static_assert(sizeof(ULyraCombatSet) == 0x000050, "Wrong size on ULyraCombatSet");
static_assert(offsetof(ULyraCombatSet, BaseDamage) == 0x000030, "Member 'ULyraCombatSet::BaseDamage' has a wrong offset!");
static_assert(offsetof(ULyraCombatSet, BaseHeal) == 0x000040, "Member 'ULyraCombatSet::BaseHeal' has a wrong offset!");

// Class LyraGame.LyraHealthSet
// 0x0060 (0x0090 - 0x0030)
class ULyraHealthSet final : public ULyraAttributeSet
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 Health;                                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 Healing;                                           // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FGameplayAttributeData                 Damage;                                            // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	void OnRep_Health(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHealthSet">();
	}
	static class ULyraHealthSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHealthSet>();
	}
};
static_assert(alignof(ULyraHealthSet) == 0x000008, "Wrong alignment on ULyraHealthSet");
static_assert(sizeof(ULyraHealthSet) == 0x000090, "Wrong size on ULyraHealthSet");
static_assert(offsetof(ULyraHealthSet, Health) == 0x000048, "Member 'ULyraHealthSet::Health' has a wrong offset!");
static_assert(offsetof(ULyraHealthSet, MaxHealth) == 0x000058, "Member 'ULyraHealthSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(ULyraHealthSet, Healing) == 0x000070, "Member 'ULyraHealthSet::Healing' has a wrong offset!");
static_assert(offsetof(ULyraHealthSet, Damage) == 0x000080, "Member 'ULyraHealthSet::Damage' has a wrong offset!");

// Class LyraGame.InputModifierMouseYSensitivityScaling
// 0x0000 (0x0028 - 0x0028)
class UInputModifierMouseYSensitivityScaling final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputModifierMouseYSensitivityScaling">();
	}
	static class UInputModifierMouseYSensitivityScaling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputModifierMouseYSensitivityScaling>();
	}
};
static_assert(alignof(UInputModifierMouseYSensitivityScaling) == 0x000008, "Wrong alignment on UInputModifierMouseYSensitivityScaling");
static_assert(sizeof(UInputModifierMouseYSensitivityScaling) == 0x000028, "Wrong size on UInputModifierMouseYSensitivityScaling");

// Class LyraGame.LyraMovementSet
// 0x0010 (0x0040 - 0x0030)
class ULyraMovementSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 MoveSpeed;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_MoveSpeed(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraMovementSet">();
	}
	static class ULyraMovementSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraMovementSet>();
	}
};
static_assert(alignof(ULyraMovementSet) == 0x000008, "Wrong alignment on ULyraMovementSet");
static_assert(sizeof(ULyraMovementSet) == 0x000040, "Wrong size on ULyraMovementSet");
static_assert(offsetof(ULyraMovementSet, MoveSpeed) == 0x000030, "Member 'ULyraMovementSet::MoveSpeed' has a wrong offset!");

// Class LyraGame.TgfAIAttributeSet
// 0x0080 (0x00B0 - 0x0030)
class UTgfAIAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 AngleSpeedBase;                                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AngleSpeedPercent;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SightDistanceBase;                                 // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SightDistancePercent;                              // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HearingDistanceBase;                               // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HearingDistancePercent;                            // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightDistanceBase;                                 // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightDistancePercent;                              // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void ApplyAngleSpeedBaseMod(float Mod);
	void OnRep_AngleSpeedBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_AngleSpeedPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_HearingDistanceBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_HearingDistancePercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightDistanceBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightDistancePercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_SightDistanceBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_SightDistancePercent(const struct FGameplayAttributeData& OldValue);

	float GetAngleSpeedFinal() const;
	float GetHearingDistanceFinal() const;
	float GetLightDistanceFinal() const;
	float GetSightDistanceFinal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAIAttributeSet">();
	}
	static class UTgfAIAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAIAttributeSet>();
	}
};
static_assert(alignof(UTgfAIAttributeSet) == 0x000008, "Wrong alignment on UTgfAIAttributeSet");
static_assert(sizeof(UTgfAIAttributeSet) == 0x0000B0, "Wrong size on UTgfAIAttributeSet");
static_assert(offsetof(UTgfAIAttributeSet, AngleSpeedBase) == 0x000030, "Member 'UTgfAIAttributeSet::AngleSpeedBase' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, AngleSpeedPercent) == 0x000040, "Member 'UTgfAIAttributeSet::AngleSpeedPercent' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, SightDistanceBase) == 0x000050, "Member 'UTgfAIAttributeSet::SightDistanceBase' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, SightDistancePercent) == 0x000060, "Member 'UTgfAIAttributeSet::SightDistancePercent' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, HearingDistanceBase) == 0x000070, "Member 'UTgfAIAttributeSet::HearingDistanceBase' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, HearingDistancePercent) == 0x000080, "Member 'UTgfAIAttributeSet::HearingDistancePercent' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, LightDistanceBase) == 0x000090, "Member 'UTgfAIAttributeSet::LightDistanceBase' has a wrong offset!");
static_assert(offsetof(UTgfAIAttributeSet, LightDistancePercent) == 0x0000A0, "Member 'UTgfAIAttributeSet::LightDistancePercent' has a wrong offset!");

// Class LyraGame.LyraSettingBasedScalar
// 0x0058 (0x0080 - 0x0028)
class ULyraSettingBasedScalar final : public UInputModifier
{
public:
	class FName                                   XAxisScalarSettingName;                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   YAxisScalarSettingName;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZAxisScalarSettingName;                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxValueClamp;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinValueClamp;                                     // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingBasedScalar">();
	}
	static class ULyraSettingBasedScalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingBasedScalar>();
	}
};
static_assert(alignof(ULyraSettingBasedScalar) == 0x000008, "Wrong alignment on ULyraSettingBasedScalar");
static_assert(sizeof(ULyraSettingBasedScalar) == 0x000080, "Wrong size on ULyraSettingBasedScalar");
static_assert(offsetof(ULyraSettingBasedScalar, XAxisScalarSettingName) == 0x000028, "Member 'ULyraSettingBasedScalar::XAxisScalarSettingName' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, YAxisScalarSettingName) == 0x000030, "Member 'ULyraSettingBasedScalar::YAxisScalarSettingName' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, ZAxisScalarSettingName) == 0x000038, "Member 'ULyraSettingBasedScalar::ZAxisScalarSettingName' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, MaxValueClamp) == 0x000040, "Member 'ULyraSettingBasedScalar::MaxValueClamp' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, MinValueClamp) == 0x000058, "Member 'ULyraSettingBasedScalar::MinValueClamp' has a wrong offset!");

// Class LyraGame.TgfAttackAttributeSet
// 0x0208 (0x0238 - 0x0030)
class UTgfAttackAttributeSet final : public ULyraAttributeSet
{
public:
	float                                         AnimAddiAttackWeight;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 RightWeaponAttack;                                 // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftWeaponAttack;                                  // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalWeaponAttack;                            // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AttackBonus;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AttackBoostRate;                                   // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveFactorRate;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CriticalRate;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritDamageRate;                                    // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EliteBoostRate;                                    // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UncontrolledBoostRate;                             // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SkillBoostRate;                                    // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementBoostRateNone;                              // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementBoostRateFire;                              // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementBoostRateIce;                               // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementBoostRateThunder;                           // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementBoostRateLight;                             // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementBoostRateDark;                              // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResPierceNone;                              // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResPierceFire;                              // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResPierceIce;                               // 0x0168(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResPierceThunder;                           // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResPierceLight;                             // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResPierceDark;                              // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RightAttGearLevel;                                 // 0x01A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftAttGearLevel;                                  // 0x01B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalAttGearLevel;                            // 0x01C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ExtraAttGearLevel;                                 // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RightAttackWeight;                                 // 0x01E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftAttackWeight;                                  // 0x01F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalAttackWeight;                            // 0x0208(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DefIgnoreBase;                                     // 0x0218(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DefIgnorePercent;                                  // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_AdditionalAttackWeight(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalAttGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalWeaponAttack(const struct FGameplayAttributeData& OldValue);
	void OnRep_AttackBonus(const struct FGameplayAttributeData& OldValue);
	void OnRep_AttackBoostRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_CritDamageRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_CriticalRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_DefIgnoreBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_DefIgnorePercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementBoostRateDark(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementBoostRateFire(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementBoostRateIce(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementBoostRateLight(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementBoostRateNone(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementBoostRateThunder(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResPierceDark(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResPierceFire(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResPierceIce(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResPierceLight(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResPierceNone(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResPierceThunder(const struct FGameplayAttributeData& OldValue);
	void OnRep_EliteBoostRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ExtraAttGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftAttackWeight(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftAttGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftWeaponAttack(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveFactorRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightAttackWeight(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightAttGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightWeaponAttack(const struct FGameplayAttributeData& OldValue);
	void OnRep_SkillBoostRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_UncontrolledBoostRate(const struct FGameplayAttributeData& OldValue);

	float GetAttackWeightWithAnim(ETgfUseAttackType AttackType) const;
	float GetAttGearLevel(ETgfUseAttackType AttackType) const;
	float GetDefIgnoreFinal() const;
	float GetElementBoostRate(ETgfBattleElement Element) const;
	float GetElementResPierce(ETgfBattleElement Element) const;
	float GetWeaponAttack(ETgfUseAttackType AttackType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAttackAttributeSet">();
	}
	static class UTgfAttackAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAttackAttributeSet>();
	}
};
static_assert(alignof(UTgfAttackAttributeSet) == 0x000008, "Wrong alignment on UTgfAttackAttributeSet");
static_assert(sizeof(UTgfAttackAttributeSet) == 0x000238, "Wrong size on UTgfAttackAttributeSet");
static_assert(offsetof(UTgfAttackAttributeSet, AnimAddiAttackWeight) == 0x000030, "Member 'UTgfAttackAttributeSet::AnimAddiAttackWeight' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, RightWeaponAttack) == 0x000038, "Member 'UTgfAttackAttributeSet::RightWeaponAttack' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, LeftWeaponAttack) == 0x000048, "Member 'UTgfAttackAttributeSet::LeftWeaponAttack' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, AdditionalWeaponAttack) == 0x000058, "Member 'UTgfAttackAttributeSet::AdditionalWeaponAttack' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, AttackBonus) == 0x000068, "Member 'UTgfAttackAttributeSet::AttackBonus' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, AttackBoostRate) == 0x000078, "Member 'UTgfAttackAttributeSet::AttackBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, MoveFactorRate) == 0x000088, "Member 'UTgfAttackAttributeSet::MoveFactorRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, CriticalRate) == 0x000098, "Member 'UTgfAttackAttributeSet::CriticalRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, CritDamageRate) == 0x0000A8, "Member 'UTgfAttackAttributeSet::CritDamageRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, EliteBoostRate) == 0x0000B8, "Member 'UTgfAttackAttributeSet::EliteBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, UncontrolledBoostRate) == 0x0000C8, "Member 'UTgfAttackAttributeSet::UncontrolledBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, SkillBoostRate) == 0x0000D8, "Member 'UTgfAttackAttributeSet::SkillBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementBoostRateNone) == 0x0000E8, "Member 'UTgfAttackAttributeSet::ElementBoostRateNone' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementBoostRateFire) == 0x0000F8, "Member 'UTgfAttackAttributeSet::ElementBoostRateFire' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementBoostRateIce) == 0x000108, "Member 'UTgfAttackAttributeSet::ElementBoostRateIce' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementBoostRateThunder) == 0x000118, "Member 'UTgfAttackAttributeSet::ElementBoostRateThunder' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementBoostRateLight) == 0x000128, "Member 'UTgfAttackAttributeSet::ElementBoostRateLight' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementBoostRateDark) == 0x000138, "Member 'UTgfAttackAttributeSet::ElementBoostRateDark' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementResPierceNone) == 0x000148, "Member 'UTgfAttackAttributeSet::ElementResPierceNone' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementResPierceFire) == 0x000158, "Member 'UTgfAttackAttributeSet::ElementResPierceFire' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementResPierceIce) == 0x000168, "Member 'UTgfAttackAttributeSet::ElementResPierceIce' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementResPierceThunder) == 0x000178, "Member 'UTgfAttackAttributeSet::ElementResPierceThunder' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementResPierceLight) == 0x000188, "Member 'UTgfAttackAttributeSet::ElementResPierceLight' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ElementResPierceDark) == 0x000198, "Member 'UTgfAttackAttributeSet::ElementResPierceDark' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, RightAttGearLevel) == 0x0001A8, "Member 'UTgfAttackAttributeSet::RightAttGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, LeftAttGearLevel) == 0x0001B8, "Member 'UTgfAttackAttributeSet::LeftAttGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, AdditionalAttGearLevel) == 0x0001C8, "Member 'UTgfAttackAttributeSet::AdditionalAttGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, ExtraAttGearLevel) == 0x0001D8, "Member 'UTgfAttackAttributeSet::ExtraAttGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, RightAttackWeight) == 0x0001E8, "Member 'UTgfAttackAttributeSet::RightAttackWeight' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, LeftAttackWeight) == 0x0001F8, "Member 'UTgfAttackAttributeSet::LeftAttackWeight' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, AdditionalAttackWeight) == 0x000208, "Member 'UTgfAttackAttributeSet::AdditionalAttackWeight' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, DefIgnoreBase) == 0x000218, "Member 'UTgfAttackAttributeSet::DefIgnoreBase' has a wrong offset!");
static_assert(offsetof(UTgfAttackAttributeSet, DefIgnorePercent) == 0x000228, "Member 'UTgfAttackAttributeSet::DefIgnorePercent' has a wrong offset!");

// Class LyraGame.TgfBuffArgAttributeSet
// 0x0100 (0x0130 - 0x0030)
class UTgfBuffArgAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 BurningStack;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BurningDamage;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BurningIntervalBase;                               // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BurningIntervalPercent;                            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FreezingRateBase;                                  // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FreezingRatePercent;                               // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FreezingDurationBase;                              // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FreezingDurationPercent;                           // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BloodingDamage;                                    // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BloodingDurationBase;                              // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BloodingDurationPercent;                           // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BloodingIntervalBase;                              // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BloodingIntervalPercent;                           // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KillingMaxLayerMaxHealthPercent;                   // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KillingMaxLayerAttackBoostRate;                    // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KillingMaxLayerCriticalRate;                       // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_BloodingDamage(const struct FGameplayAttributeData& OldValue);
	void OnRep_BloodingDurationBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_BloodingDurationPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_BloodingIntervalBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_BloodingIntervalPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_BurningDamage(const struct FGameplayAttributeData& OldValue);
	void OnRep_BurningIntervalBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_BurningIntervalPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_BurningStack(const struct FGameplayAttributeData& OldValue);
	void OnRep_FreezingDurationBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_FreezingDurationPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_FreezingRateBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_FreezingRatePercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_KillingMaxLayerAttackBoostRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_KillingMaxLayerCriticalRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_KillingMaxLayerMaxHealthPercent(const struct FGameplayAttributeData& OldValue);

	float GetBloodingDurationFinal() const;
	float GetBloodingIntervalFinal() const;
	float GetBurningIntervalFinal() const;
	float GetFreezingDurationFinal() const;
	float GetFreezingRateFinal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBuffArgAttributeSet">();
	}
	static class UTgfBuffArgAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBuffArgAttributeSet>();
	}
};
static_assert(alignof(UTgfBuffArgAttributeSet) == 0x000008, "Wrong alignment on UTgfBuffArgAttributeSet");
static_assert(sizeof(UTgfBuffArgAttributeSet) == 0x000130, "Wrong size on UTgfBuffArgAttributeSet");
static_assert(offsetof(UTgfBuffArgAttributeSet, BurningStack) == 0x000030, "Member 'UTgfBuffArgAttributeSet::BurningStack' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BurningDamage) == 0x000040, "Member 'UTgfBuffArgAttributeSet::BurningDamage' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BurningIntervalBase) == 0x000050, "Member 'UTgfBuffArgAttributeSet::BurningIntervalBase' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BurningIntervalPercent) == 0x000060, "Member 'UTgfBuffArgAttributeSet::BurningIntervalPercent' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, FreezingRateBase) == 0x000070, "Member 'UTgfBuffArgAttributeSet::FreezingRateBase' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, FreezingRatePercent) == 0x000080, "Member 'UTgfBuffArgAttributeSet::FreezingRatePercent' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, FreezingDurationBase) == 0x000090, "Member 'UTgfBuffArgAttributeSet::FreezingDurationBase' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, FreezingDurationPercent) == 0x0000A0, "Member 'UTgfBuffArgAttributeSet::FreezingDurationPercent' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BloodingDamage) == 0x0000B0, "Member 'UTgfBuffArgAttributeSet::BloodingDamage' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BloodingDurationBase) == 0x0000C0, "Member 'UTgfBuffArgAttributeSet::BloodingDurationBase' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BloodingDurationPercent) == 0x0000D0, "Member 'UTgfBuffArgAttributeSet::BloodingDurationPercent' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BloodingIntervalBase) == 0x0000E0, "Member 'UTgfBuffArgAttributeSet::BloodingIntervalBase' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, BloodingIntervalPercent) == 0x0000F0, "Member 'UTgfBuffArgAttributeSet::BloodingIntervalPercent' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, KillingMaxLayerMaxHealthPercent) == 0x000100, "Member 'UTgfBuffArgAttributeSet::KillingMaxLayerMaxHealthPercent' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, KillingMaxLayerAttackBoostRate) == 0x000110, "Member 'UTgfBuffArgAttributeSet::KillingMaxLayerAttackBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfBuffArgAttributeSet, KillingMaxLayerCriticalRate) == 0x000120, "Member 'UTgfBuffArgAttributeSet::KillingMaxLayerCriticalRate' has a wrong offset!");

// Class LyraGame.InteractionStatics
// 0x0000 (0x0028 - 0x0028)
class UInteractionStatics final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* GetActorFromInteractableTarget(TScriptInterface<class IInteractableTarget> InteractableTarget);
	static void GetInteractableTargetsFromActor(class AActor* Actor, TArray<TScriptInterface<class IInteractableTarget>>* OutInteractableTargets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStatics">();
	}
	static class UInteractionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStatics>();
	}
};
static_assert(alignof(UInteractionStatics) == 0x000008, "Wrong alignment on UInteractionStatics");
static_assert(sizeof(UInteractionStatics) == 0x000028, "Wrong size on UInteractionStatics");

// Class LyraGame.TgfDefendAttributeSet
// 0x0258 (0x0288 - 0x0030)
class UTgfDefendAttributeSet final : public ULyraAttributeSet
{
public:
	float                                         AnimAddiDefendValue;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardedAnimAddiDefendValue;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 CurHealth;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CurShield;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AddShield;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CalculatedShield;                                  // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PermanintShield;                                   // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceRate;                                  // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageVulnerRate;                                  // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EliteReduceRate;                                   // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UncontrolledReduceRate;                            // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RightShieldAngle;                                  // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftShieldAngle;                                   // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RightGuardedDamageReduceRate;                      // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftGuardedDamageReduceRate;                       // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ExtraGuardedDamageReduceRate;                      // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RightDefendValue;                                  // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftDefendValue;                                   // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DefaultDefendValue;                                // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResistanceRateNone;                         // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResistanceRateFire;                         // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResistanceRateIce;                          // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResistanceRateThunder;                      // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResistanceRateLight;                        // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementResistanceRateDark;                         // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RightDefGearLevel;                                 // 0x01B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LeftDefGearLevel;                                  // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ChestDefGearLevel;                                 // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 TrousersDefGearLevel;                              // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HelmetDefGearLevel;                                // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ExtraDefGearLevel;                                 // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthBase;                                     // 0x0210(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthPercent;                                  // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthExtra;                                    // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingValue;                                      // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageValue;                                       // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CriticalDamage;                                    // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CriticalHealing;                                   // 0x0270(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LeftShieldDamage;                                  // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfBattleElement                             LastDamageElement;                                 // 0x0284(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AddShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_CalculatedShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_ChestDefGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_CurHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_CurShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageReduceRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageVulnerRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_DefaultDefendValue(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResistanceRateDark(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResistanceRateFire(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResistanceRateIce(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResistanceRateLight(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResistanceRateNone(const struct FGameplayAttributeData& OldValue);
	void OnRep_ElementResistanceRateThunder(const struct FGameplayAttributeData& OldValue);
	void OnRep_EliteReduceRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ExtraDefGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_ExtraGuardedDamageReduceRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_HelmetDefGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftDefendValue(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftDefGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftGuardedDamageReduceRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_LeftShieldAngle(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthExtra(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_PermanintShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightDefendValue(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightDefGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightGuardedDamageReduceRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_RightShieldAngle(const struct FGameplayAttributeData& OldValue);
	void OnRep_TrousersDefGearLevel(const struct FGameplayAttributeData& OldValue);
	void OnRep_UncontrolledReduceRate(const struct FGameplayAttributeData& OldValue);

	float GetCurShieldFinal() const;
	float GetDefendValueWithAnim(bool IsGuarded) const;
	float GetDefGearLevel() const;
	float GetElementResistanceRate(ETgfBattleElement Element) const;
	float GetFinalElementResistanceRate(ETgfBattleElement AttackElement, ETgfBattleElement DefendElement) const;
	float GetGuardedDamageReduceRate() const;
	float GetMaxHealthFinal() const;
	bool HasHurtPartHeadTag() const;
	bool IsFullHP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfDefendAttributeSet">();
	}
	static class UTgfDefendAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfDefendAttributeSet>();
	}
};
static_assert(alignof(UTgfDefendAttributeSet) == 0x000008, "Wrong alignment on UTgfDefendAttributeSet");
static_assert(sizeof(UTgfDefendAttributeSet) == 0x000288, "Wrong size on UTgfDefendAttributeSet");
static_assert(offsetof(UTgfDefendAttributeSet, AnimAddiDefendValue) == 0x000030, "Member 'UTgfDefendAttributeSet::AnimAddiDefendValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, GuardedAnimAddiDefendValue) == 0x000034, "Member 'UTgfDefendAttributeSet::GuardedAnimAddiDefendValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, CurHealth) == 0x000040, "Member 'UTgfDefendAttributeSet::CurHealth' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, CurShield) == 0x000050, "Member 'UTgfDefendAttributeSet::CurShield' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, AddShield) == 0x000060, "Member 'UTgfDefendAttributeSet::AddShield' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, CalculatedShield) == 0x000070, "Member 'UTgfDefendAttributeSet::CalculatedShield' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, PermanintShield) == 0x000080, "Member 'UTgfDefendAttributeSet::PermanintShield' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, DamageReduceRate) == 0x000090, "Member 'UTgfDefendAttributeSet::DamageReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, DamageVulnerRate) == 0x0000A0, "Member 'UTgfDefendAttributeSet::DamageVulnerRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, EliteReduceRate) == 0x0000B0, "Member 'UTgfDefendAttributeSet::EliteReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, UncontrolledReduceRate) == 0x0000C0, "Member 'UTgfDefendAttributeSet::UncontrolledReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, RightShieldAngle) == 0x0000D0, "Member 'UTgfDefendAttributeSet::RightShieldAngle' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, LeftShieldAngle) == 0x0000E0, "Member 'UTgfDefendAttributeSet::LeftShieldAngle' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, RightGuardedDamageReduceRate) == 0x0000F0, "Member 'UTgfDefendAttributeSet::RightGuardedDamageReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, LeftGuardedDamageReduceRate) == 0x000100, "Member 'UTgfDefendAttributeSet::LeftGuardedDamageReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ExtraGuardedDamageReduceRate) == 0x000110, "Member 'UTgfDefendAttributeSet::ExtraGuardedDamageReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, RightDefendValue) == 0x000120, "Member 'UTgfDefendAttributeSet::RightDefendValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, LeftDefendValue) == 0x000130, "Member 'UTgfDefendAttributeSet::LeftDefendValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, DefaultDefendValue) == 0x000140, "Member 'UTgfDefendAttributeSet::DefaultDefendValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ElementResistanceRateNone) == 0x000150, "Member 'UTgfDefendAttributeSet::ElementResistanceRateNone' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ElementResistanceRateFire) == 0x000160, "Member 'UTgfDefendAttributeSet::ElementResistanceRateFire' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ElementResistanceRateIce) == 0x000170, "Member 'UTgfDefendAttributeSet::ElementResistanceRateIce' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ElementResistanceRateThunder) == 0x000180, "Member 'UTgfDefendAttributeSet::ElementResistanceRateThunder' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ElementResistanceRateLight) == 0x000190, "Member 'UTgfDefendAttributeSet::ElementResistanceRateLight' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ElementResistanceRateDark) == 0x0001A0, "Member 'UTgfDefendAttributeSet::ElementResistanceRateDark' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, RightDefGearLevel) == 0x0001B0, "Member 'UTgfDefendAttributeSet::RightDefGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, LeftDefGearLevel) == 0x0001C0, "Member 'UTgfDefendAttributeSet::LeftDefGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ChestDefGearLevel) == 0x0001D0, "Member 'UTgfDefendAttributeSet::ChestDefGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, TrousersDefGearLevel) == 0x0001E0, "Member 'UTgfDefendAttributeSet::TrousersDefGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, HelmetDefGearLevel) == 0x0001F0, "Member 'UTgfDefendAttributeSet::HelmetDefGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, ExtraDefGearLevel) == 0x000200, "Member 'UTgfDefendAttributeSet::ExtraDefGearLevel' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, MaxHealthBase) == 0x000210, "Member 'UTgfDefendAttributeSet::MaxHealthBase' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, MaxHealthPercent) == 0x000220, "Member 'UTgfDefendAttributeSet::MaxHealthPercent' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, MaxHealthExtra) == 0x000230, "Member 'UTgfDefendAttributeSet::MaxHealthExtra' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, HealingValue) == 0x000240, "Member 'UTgfDefendAttributeSet::HealingValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, DamageValue) == 0x000250, "Member 'UTgfDefendAttributeSet::DamageValue' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, CriticalDamage) == 0x000260, "Member 'UTgfDefendAttributeSet::CriticalDamage' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, CriticalHealing) == 0x000270, "Member 'UTgfDefendAttributeSet::CriticalHealing' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, LeftShieldDamage) == 0x000280, "Member 'UTgfDefendAttributeSet::LeftShieldDamage' has a wrong offset!");
static_assert(offsetof(UTgfDefendAttributeSet, LastDamageElement) == 0x000284, "Member 'UTgfDefendAttributeSet::LastDamageElement' has a wrong offset!");

// Class LyraGame.TgfFirstLevelAttrDataAsset
// 0x0040 (0x0070 - 0x0030)
class UTgfFirstLevelAttrDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<struct FTgfFirstLevelAttrCfgItem>      FirstLevelAttrs;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfCareerRaceCfgItem>          CareerRaces;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMatchAbilityItem>           MatchItems;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTgfMithrilAbilityItem>         MithrilItems;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFirstLevelAttrDataAsset">();
	}
	static class UTgfFirstLevelAttrDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFirstLevelAttrDataAsset>();
	}
};
static_assert(alignof(UTgfFirstLevelAttrDataAsset) == 0x000008, "Wrong alignment on UTgfFirstLevelAttrDataAsset");
static_assert(sizeof(UTgfFirstLevelAttrDataAsset) == 0x000070, "Wrong size on UTgfFirstLevelAttrDataAsset");
static_assert(offsetof(UTgfFirstLevelAttrDataAsset, FirstLevelAttrs) == 0x000030, "Member 'UTgfFirstLevelAttrDataAsset::FirstLevelAttrs' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttrDataAsset, CareerRaces) == 0x000040, "Member 'UTgfFirstLevelAttrDataAsset::CareerRaces' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttrDataAsset, MatchItems) == 0x000050, "Member 'UTgfFirstLevelAttrDataAsset::MatchItems' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttrDataAsset, MithrilItems) == 0x000060, "Member 'UTgfFirstLevelAttrDataAsset::MithrilItems' has a wrong offset!");

// Class LyraGame.LyraInventoryItemInstance
// 0x0188 (0x01B0 - 0x0028)
class ULyraInventoryItemInstance : public UObject
{
public:
	struct FGameplayTagStackContainer             StatTags;                                          // 0x0028(0x0168)(Net, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ULyraInventoryItemDefinition> ItemDef;                                           // 0x0190(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULyraInventoryItemDefinition> SkinItemDef;                                       // 0x0198(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkinId;                                            // 0x01A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StackCount;                                        // 0x01A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStatTagStack(const struct FGameplayTag& Tag, int32 TagCount);
	class ULyraInventoryItemInstance* DuplicateItemInstance(class UObject* NewOuter, bool NeedSkin);
	void OnRep_ItemDef();
	void OnRep_StackCount(int32 OldCount);
	void RemoveStatTagStack(const struct FGameplayTag& Tag, int32 TagCount);
	void SetStackCount(int32 Value);

	bool CanDiscardStack() const;
	const class ULyraInventoryItemFragment* FindFragmentByClass(TSubclassOf<class ULyraInventoryItemFragment> FragmentClass, bool NeedSkined) const;
	TSubclassOf<class ULyraEquipmentDefinition> GetEquipDefinition(bool NeedSkined) const;
	TSubclassOf<class ULyraInventoryItemDefinition> GetItemDef(bool NeedSkined) const;
	int32 GetItemId() const;
	TSubclassOf<class ULyraInventoryItemDefinition> GetSkinItemDef() const;
	int32 GetStackCount() const;
	int32 GetStatTagStackCount(const struct FGameplayTag& Tag) const;
	bool HasStatTag(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInventoryItemInstance">();
	}
	static class ULyraInventoryItemInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInventoryItemInstance>();
	}
};
static_assert(alignof(ULyraInventoryItemInstance) == 0x000008, "Wrong alignment on ULyraInventoryItemInstance");
static_assert(sizeof(ULyraInventoryItemInstance) == 0x0001B0, "Wrong size on ULyraInventoryItemInstance");
static_assert(offsetof(ULyraInventoryItemInstance, StatTags) == 0x000028, "Member 'ULyraInventoryItemInstance::StatTags' has a wrong offset!");
static_assert(offsetof(ULyraInventoryItemInstance, ItemDef) == 0x000190, "Member 'ULyraInventoryItemInstance::ItemDef' has a wrong offset!");
static_assert(offsetof(ULyraInventoryItemInstance, SkinItemDef) == 0x000198, "Member 'ULyraInventoryItemInstance::SkinItemDef' has a wrong offset!");
static_assert(offsetof(ULyraInventoryItemInstance, SkinId) == 0x0001A0, "Member 'ULyraInventoryItemInstance::SkinId' has a wrong offset!");
static_assert(offsetof(ULyraInventoryItemInstance, StackCount) == 0x0001A4, "Member 'ULyraInventoryItemInstance::StackCount' has a wrong offset!");

// Class LyraGame.TgfFirstLevelAttributeSet
// 0x0218 (0x0248 - 0x0030)
class UTgfFirstLevelAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 Strength;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Dexterity;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Stamina;                                           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Intelligence;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Will;                                              // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Faith;                                             // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FLyraAbilitySet_GrantedHandles         GrantedHandles;                                    // 0x0090(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class ULyraAbilitySet*>                  GrantedAbilitySet;                                 // 0x0110(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FLyraAbilitySet_GrantedHandles         GrantedTalentHandles;                              // 0x0160(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class ULyraAbilitySet*>                  GrantedTalentAbilitySet;                           // 0x01E0(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FTgfActorRuntimeTalent>         Talents;                                           // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsFirstLevelAttribute(const struct FGameplayAttribute& Attribute);
	static bool IsSatisfiedAttribute(struct FTgfActorRuntimeTalent* Talent, class ULyraAbilitySystemComponent* Abs);

	void OnRep_Dexterity(const struct FGameplayAttributeData& OldValue);
	void OnRep_Faith(const struct FGameplayAttributeData& OldValue);
	void OnRep_Intelligence(const struct FGameplayAttributeData& OldValue);
	void OnRep_Stamina(const struct FGameplayAttributeData& OldValue);
	void OnRep_Strength(const struct FGameplayAttributeData& OldValue);
	void OnRep_Will(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFirstLevelAttributeSet">();
	}
	static class UTgfFirstLevelAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFirstLevelAttributeSet>();
	}
};
static_assert(alignof(UTgfFirstLevelAttributeSet) == 0x000008, "Wrong alignment on UTgfFirstLevelAttributeSet");
static_assert(sizeof(UTgfFirstLevelAttributeSet) == 0x000248, "Wrong size on UTgfFirstLevelAttributeSet");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Strength) == 0x000030, "Member 'UTgfFirstLevelAttributeSet::Strength' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Dexterity) == 0x000040, "Member 'UTgfFirstLevelAttributeSet::Dexterity' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Stamina) == 0x000050, "Member 'UTgfFirstLevelAttributeSet::Stamina' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Intelligence) == 0x000060, "Member 'UTgfFirstLevelAttributeSet::Intelligence' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Will) == 0x000070, "Member 'UTgfFirstLevelAttributeSet::Will' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Faith) == 0x000080, "Member 'UTgfFirstLevelAttributeSet::Faith' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, GrantedHandles) == 0x000090, "Member 'UTgfFirstLevelAttributeSet::GrantedHandles' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, GrantedAbilitySet) == 0x000110, "Member 'UTgfFirstLevelAttributeSet::GrantedAbilitySet' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, GrantedTalentHandles) == 0x000160, "Member 'UTgfFirstLevelAttributeSet::GrantedTalentHandles' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, GrantedTalentAbilitySet) == 0x0001E0, "Member 'UTgfFirstLevelAttributeSet::GrantedTalentAbilitySet' has a wrong offset!");
static_assert(offsetof(UTgfFirstLevelAttributeSet, Talents) == 0x000230, "Member 'UTgfFirstLevelAttributeSet::Talents' has a wrong offset!");

// Class LyraGame.TgfRecoverAttributeSet
// 0x0100 (0x0130 - 0x0030)
class UTgfRecoverAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 LifeLeachRate;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealWoundRate;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealOnHit;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealOnKill;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealOverTime;                                      // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealBonus;                                         // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealBoostRate;                                     // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealReceiveRate;                                   // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ShieldBonus;                                       // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ShieldBoostRate;                                   // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ShieldReceiveRate;                                 // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ResCostReduceRate;                                 // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ResGenerateRate;                                   // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SkillCooldownScaleRate;                            // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GainGoldOutOfPortal;                               // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ExpBoostRateOutOfPortal;                           // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_ExpBoostRateOutOfPortal(const struct FGameplayAttributeData& OldValue);
	void OnRep_GainGoldOutOfPortal(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealBonus(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealBoostRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealOnHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealOnKill(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealOverTime(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealReceiveRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealWoundRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_LifeLeachRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ResCostReduceRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ResGenerateRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ShieldBonus(const struct FGameplayAttributeData& OldValue);
	void OnRep_ShieldBoostRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ShieldReceiveRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_SkillCooldownScaleRate(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfRecoverAttributeSet">();
	}
	static class UTgfRecoverAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfRecoverAttributeSet>();
	}
};
static_assert(alignof(UTgfRecoverAttributeSet) == 0x000008, "Wrong alignment on UTgfRecoverAttributeSet");
static_assert(sizeof(UTgfRecoverAttributeSet) == 0x000130, "Wrong size on UTgfRecoverAttributeSet");
static_assert(offsetof(UTgfRecoverAttributeSet, LifeLeachRate) == 0x000030, "Member 'UTgfRecoverAttributeSet::LifeLeachRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealWoundRate) == 0x000040, "Member 'UTgfRecoverAttributeSet::HealWoundRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealOnHit) == 0x000050, "Member 'UTgfRecoverAttributeSet::HealOnHit' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealOnKill) == 0x000060, "Member 'UTgfRecoverAttributeSet::HealOnKill' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealOverTime) == 0x000070, "Member 'UTgfRecoverAttributeSet::HealOverTime' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealBonus) == 0x000080, "Member 'UTgfRecoverAttributeSet::HealBonus' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealBoostRate) == 0x000090, "Member 'UTgfRecoverAttributeSet::HealBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, HealReceiveRate) == 0x0000A0, "Member 'UTgfRecoverAttributeSet::HealReceiveRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, ShieldBonus) == 0x0000B0, "Member 'UTgfRecoverAttributeSet::ShieldBonus' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, ShieldBoostRate) == 0x0000C0, "Member 'UTgfRecoverAttributeSet::ShieldBoostRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, ShieldReceiveRate) == 0x0000D0, "Member 'UTgfRecoverAttributeSet::ShieldReceiveRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, ResCostReduceRate) == 0x0000E0, "Member 'UTgfRecoverAttributeSet::ResCostReduceRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, ResGenerateRate) == 0x0000F0, "Member 'UTgfRecoverAttributeSet::ResGenerateRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, SkillCooldownScaleRate) == 0x000100, "Member 'UTgfRecoverAttributeSet::SkillCooldownScaleRate' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, GainGoldOutOfPortal) == 0x000110, "Member 'UTgfRecoverAttributeSet::GainGoldOutOfPortal' has a wrong offset!");
static_assert(offsetof(UTgfRecoverAttributeSet, ExpBoostRateOutOfPortal) == 0x000120, "Member 'UTgfRecoverAttributeSet::ExpBoostRateOutOfPortal' has a wrong offset!");

// Class LyraGame.InventoryFragment_PickupIcon
// 0x0030 (0x0058 - 0x0028)
class UInventoryFragment_PickupIcon final : public ULyraInventoryItemFragment
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           PadColor;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_PickupIcon">();
	}
	static class UInventoryFragment_PickupIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_PickupIcon>();
	}
};
static_assert(alignof(UInventoryFragment_PickupIcon) == 0x000008, "Wrong alignment on UInventoryFragment_PickupIcon");
static_assert(sizeof(UInventoryFragment_PickupIcon) == 0x000058, "Wrong size on UInventoryFragment_PickupIcon");
static_assert(offsetof(UInventoryFragment_PickupIcon, SkeletalMesh) == 0x000028, "Member 'UInventoryFragment_PickupIcon::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_PickupIcon, DisplayName) == 0x000030, "Member 'UInventoryFragment_PickupIcon::DisplayName' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_PickupIcon, PadColor) == 0x000048, "Member 'UInventoryFragment_PickupIcon::PadColor' has a wrong offset!");

// Class LyraGame.TgfSpeedAttributeSet
// 0x00B0 (0x00E0 - 0x0030)
class UTgfSpeedAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 DeathZoneTime;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AttackSpeedRate;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RecoverableItemConsumeSpeedRate;                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeaponChangeSpeedRate;                             // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ThrowableItemConsumeSpeedRate;                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedBase;                                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedPercent;                                  // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LevelInteractSpeedRate;                            // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LevelInteractSpeedAdditional;                      // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpellCastSpeedRate;                                // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpellCastSpeedAdditional;                          // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void ApplySpeedBaseMod(float Mod);
	void OnRep_AttackSpeedRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_DeathZoneTime(const struct FGameplayAttributeData& OldValue);
	void OnRep_LevelInteractSpeedAdditional(const struct FGameplayAttributeData& OldValue);
	void OnRep_LevelInteractSpeedRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_RecoverableItemConsumeSpeedRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpellCastSpeedAdditional(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpellCastSpeedRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_ThrowableItemConsumeSpeedRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_WeaponChangeSpeedRate(const struct FGameplayAttributeData& OldValue);

	float GetLevelInteractSpeedFinal(float BaseTime) const;
	float GetMoveSpeedFinal() const;
	float GetSpellCastSpeedFinal(float BaseTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSpeedAttributeSet">();
	}
	static class UTgfSpeedAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSpeedAttributeSet>();
	}
};
static_assert(alignof(UTgfSpeedAttributeSet) == 0x000008, "Wrong alignment on UTgfSpeedAttributeSet");
static_assert(sizeof(UTgfSpeedAttributeSet) == 0x0000E0, "Wrong size on UTgfSpeedAttributeSet");
static_assert(offsetof(UTgfSpeedAttributeSet, DeathZoneTime) == 0x000030, "Member 'UTgfSpeedAttributeSet::DeathZoneTime' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, AttackSpeedRate) == 0x000040, "Member 'UTgfSpeedAttributeSet::AttackSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, RecoverableItemConsumeSpeedRate) == 0x000050, "Member 'UTgfSpeedAttributeSet::RecoverableItemConsumeSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, WeaponChangeSpeedRate) == 0x000060, "Member 'UTgfSpeedAttributeSet::WeaponChangeSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, ThrowableItemConsumeSpeedRate) == 0x000070, "Member 'UTgfSpeedAttributeSet::ThrowableItemConsumeSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, MoveSpeedBase) == 0x000080, "Member 'UTgfSpeedAttributeSet::MoveSpeedBase' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, MoveSpeedPercent) == 0x000090, "Member 'UTgfSpeedAttributeSet::MoveSpeedPercent' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, LevelInteractSpeedRate) == 0x0000A0, "Member 'UTgfSpeedAttributeSet::LevelInteractSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, LevelInteractSpeedAdditional) == 0x0000B0, "Member 'UTgfSpeedAttributeSet::LevelInteractSpeedAdditional' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, SpellCastSpeedRate) == 0x0000C0, "Member 'UTgfSpeedAttributeSet::SpellCastSpeedRate' has a wrong offset!");
static_assert(offsetof(UTgfSpeedAttributeSet, SpellCastSpeedAdditional) == 0x0000D0, "Member 'UTgfSpeedAttributeSet::SpellCastSpeedAdditional' has a wrong offset!");

// Class LyraGame.TgfStatEffectAttributeSet
// 0x0060 (0x0090 - 0x0030)
class UTgfStatEffectAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 MoveSpeedWithHitRunning;                           // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealOverTimeWithHitRunning;                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CriticalRateWithHitRunning;                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LifeLeachRateWithHitRunning;                       // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AttackBoostRateWithFullHealth;                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CriticalRateWithFullHealth;                        // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_AttackBoostRateWithFullHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_CriticalRateWithFullHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_CriticalRateWithHitRunning(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealOverTimeWithHitRunning(const struct FGameplayAttributeData& OldValue);
	void OnRep_LifeLeachRateWithHitRunning(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedWithHitRunning(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfStatEffectAttributeSet">();
	}
	static class UTgfStatEffectAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfStatEffectAttributeSet>();
	}
};
static_assert(alignof(UTgfStatEffectAttributeSet) == 0x000008, "Wrong alignment on UTgfStatEffectAttributeSet");
static_assert(sizeof(UTgfStatEffectAttributeSet) == 0x000090, "Wrong size on UTgfStatEffectAttributeSet");
static_assert(offsetof(UTgfStatEffectAttributeSet, MoveSpeedWithHitRunning) == 0x000030, "Member 'UTgfStatEffectAttributeSet::MoveSpeedWithHitRunning' has a wrong offset!");
static_assert(offsetof(UTgfStatEffectAttributeSet, HealOverTimeWithHitRunning) == 0x000040, "Member 'UTgfStatEffectAttributeSet::HealOverTimeWithHitRunning' has a wrong offset!");
static_assert(offsetof(UTgfStatEffectAttributeSet, CriticalRateWithHitRunning) == 0x000050, "Member 'UTgfStatEffectAttributeSet::CriticalRateWithHitRunning' has a wrong offset!");
static_assert(offsetof(UTgfStatEffectAttributeSet, LifeLeachRateWithHitRunning) == 0x000060, "Member 'UTgfStatEffectAttributeSet::LifeLeachRateWithHitRunning' has a wrong offset!");
static_assert(offsetof(UTgfStatEffectAttributeSet, AttackBoostRateWithFullHealth) == 0x000070, "Member 'UTgfStatEffectAttributeSet::AttackBoostRateWithFullHealth' has a wrong offset!");
static_assert(offsetof(UTgfStatEffectAttributeSet, CriticalRateWithFullHealth) == 0x000080, "Member 'UTgfStatEffectAttributeSet::CriticalRateWithFullHealth' has a wrong offset!");

// Class LyraGame.GameplayAbilityTargetActor_Interact
// 0x0000 (0x0400 - 0x0400)
class AGameplayAbilityTargetActor_Interact final : public AGameplayAbilityTargetActor_Trace
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbilityTargetActor_Interact">();
	}
	static class AGameplayAbilityTargetActor_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_Interact>();
	}
};
static_assert(alignof(AGameplayAbilityTargetActor_Interact) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor_Interact");
static_assert(sizeof(AGameplayAbilityTargetActor_Interact) == 0x000400, "Wrong size on AGameplayAbilityTargetActor_Interact");

// Class LyraGame.TgfTriggerEffectAttributeSet
// 0x00E0 (0x0110 - 0x0030)
class UTgfTriggerEffectAttributeSet final : public ULyraAttributeSet
{
public:
	struct FGameplayAttributeData                 AdditionalFixedDamageOnCausingHit;                 // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalElementNoneDamageOnCausingHit;           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalElementFireDamageOnCausingHit;           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalElementIceDamageOnCausingHit;            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalElementThunderDamageOnCausingHit;        // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalElementLightDamageOnCausingHit;          // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalElementDarkDamageOnCausingHit;           // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealOnOpenChest;                                   // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicOnOpenChest;                                  // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GainGoldOnOpenChest;                               // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GainGoldOnKill;                                    // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealOnDefendSuccess;                               // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageOnDefendSuccess;                             // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AddShieldOnCastSkill;                              // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_AdditionalElementDarkDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalElementFireDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalElementIceDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalElementLightDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalElementNoneDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalElementThunderDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AdditionalFixedDamageOnCausingHit(const struct FGameplayAttributeData& OldValue);
	void OnRep_AddShieldOnCastSkill(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageOnDefendSuccess(const struct FGameplayAttributeData& OldValue);
	void OnRep_GainGoldOnKill(const struct FGameplayAttributeData& OldValue);
	void OnRep_GainGoldOnOpenChest(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealOnDefendSuccess(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealOnOpenChest(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicOnOpenChest(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfTriggerEffectAttributeSet">();
	}
	static class UTgfTriggerEffectAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfTriggerEffectAttributeSet>();
	}
};
static_assert(alignof(UTgfTriggerEffectAttributeSet) == 0x000008, "Wrong alignment on UTgfTriggerEffectAttributeSet");
static_assert(sizeof(UTgfTriggerEffectAttributeSet) == 0x000110, "Wrong size on UTgfTriggerEffectAttributeSet");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalFixedDamageOnCausingHit) == 0x000030, "Member 'UTgfTriggerEffectAttributeSet::AdditionalFixedDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalElementNoneDamageOnCausingHit) == 0x000040, "Member 'UTgfTriggerEffectAttributeSet::AdditionalElementNoneDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalElementFireDamageOnCausingHit) == 0x000050, "Member 'UTgfTriggerEffectAttributeSet::AdditionalElementFireDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalElementIceDamageOnCausingHit) == 0x000060, "Member 'UTgfTriggerEffectAttributeSet::AdditionalElementIceDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalElementThunderDamageOnCausingHit) == 0x000070, "Member 'UTgfTriggerEffectAttributeSet::AdditionalElementThunderDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalElementLightDamageOnCausingHit) == 0x000080, "Member 'UTgfTriggerEffectAttributeSet::AdditionalElementLightDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AdditionalElementDarkDamageOnCausingHit) == 0x000090, "Member 'UTgfTriggerEffectAttributeSet::AdditionalElementDarkDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, HealOnOpenChest) == 0x0000A0, "Member 'UTgfTriggerEffectAttributeSet::HealOnOpenChest' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, MagicOnOpenChest) == 0x0000B0, "Member 'UTgfTriggerEffectAttributeSet::MagicOnOpenChest' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, GainGoldOnOpenChest) == 0x0000C0, "Member 'UTgfTriggerEffectAttributeSet::GainGoldOnOpenChest' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, GainGoldOnKill) == 0x0000D0, "Member 'UTgfTriggerEffectAttributeSet::GainGoldOnKill' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, HealOnDefendSuccess) == 0x0000E0, "Member 'UTgfTriggerEffectAttributeSet::HealOnDefendSuccess' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, DamageOnDefendSuccess) == 0x0000F0, "Member 'UTgfTriggerEffectAttributeSet::DamageOnDefendSuccess' has a wrong offset!");
static_assert(offsetof(UTgfTriggerEffectAttributeSet, AddShieldOnCastSkill) == 0x000100, "Member 'UTgfTriggerEffectAttributeSet::AddShieldOnCastSkill' has a wrong offset!");

// Class LyraGame.TgfExecutionModifier
// 0x01D0 (0x01F8 - 0x0028)
class UTgfExecutionModifier final : public UObject
{
public:
	ETgfExecutionModifierTriggerType              TriggerType;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfExecutionModifierTriggerType              AffectType;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfExecutionModifierAttrValue> AttrValueList;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               GameplayEffectTags;                                // 0x0040(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   GameplayEffectQuery;                               // 0x0080(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULyraAbilitySystemComponent*            RestrictSource;                                    // 0x01D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULyraAbilitySystemComponent*>    RestrictTargetList;                                // 0x01D8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULyraAbilitySystemComponent*            AffectChara;                                       // 0x01E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurrentAdded;                                      // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TurnOffModifier();
	void TurnOnGameplayEffectModifier(const struct FGameplayEffectSpec& Spec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfExecutionModifier">();
	}
	static class UTgfExecutionModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfExecutionModifier>();
	}
};
static_assert(alignof(UTgfExecutionModifier) == 0x000008, "Wrong alignment on UTgfExecutionModifier");
static_assert(sizeof(UTgfExecutionModifier) == 0x0001F8, "Wrong size on UTgfExecutionModifier");
static_assert(offsetof(UTgfExecutionModifier, TriggerType) == 0x000028, "Member 'UTgfExecutionModifier::TriggerType' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, AffectType) == 0x000029, "Member 'UTgfExecutionModifier::AffectType' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, AttrValueList) == 0x000030, "Member 'UTgfExecutionModifier::AttrValueList' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, GameplayEffectTags) == 0x000040, "Member 'UTgfExecutionModifier::GameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, GameplayEffectQuery) == 0x000080, "Member 'UTgfExecutionModifier::GameplayEffectQuery' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, RestrictSource) == 0x0001D0, "Member 'UTgfExecutionModifier::RestrictSource' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, RestrictTargetList) == 0x0001D8, "Member 'UTgfExecutionModifier::RestrictTargetList' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, AffectChara) == 0x0001E8, "Member 'UTgfExecutionModifier::AffectChara' has a wrong offset!");
static_assert(offsetof(UTgfExecutionModifier, CurrentAdded) == 0x0001F0, "Member 'UTgfExecutionModifier::CurrentAdded' has a wrong offset!");

// Class LyraGame.PickupableStatics
// 0x0000 (0x0028 - 0x0028)
class UPickupableStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AddPickupToInventory(class ULyraInventoryManagerComponent* InventoryComponent, TScriptInterface<class IPickupable> Pickup);
	static TScriptInterface<class IPickupable> GetFirstPickupableFromActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupableStatics">();
	}
	static class UPickupableStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickupableStatics>();
	}
};
static_assert(alignof(UPickupableStatics) == 0x000008, "Wrong alignment on UPickupableStatics");
static_assert(sizeof(UPickupableStatics) == 0x000028, "Wrong size on UPickupableStatics");

// Class LyraGame.LyraDamageExecution
// 0x0000 (0x0070 - 0x0070)
class ULyraDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDamageExecution">();
	}
	static class ULyraDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraDamageExecution>();
	}
};
static_assert(alignof(ULyraDamageExecution) == 0x000008, "Wrong alignment on ULyraDamageExecution");
static_assert(sizeof(ULyraDamageExecution) == 0x000070, "Wrong size on ULyraDamageExecution");

// Class LyraGame.LyraHealExecution
// 0x0000 (0x0070 - 0x0070)
class ULyraHealExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHealExecution">();
	}
	static class ULyraHealExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHealExecution>();
	}
};
static_assert(alignof(ULyraHealExecution) == 0x000008, "Wrong alignment on ULyraHealExecution");
static_assert(sizeof(ULyraHealExecution) == 0x000070, "Wrong size on ULyraHealExecution");

// Class LyraGame.TgfAddShieldExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfAddShieldExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAddShieldExecution">();
	}
	static class UTgfAddShieldExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAddShieldExecution>();
	}
};
static_assert(alignof(UTgfAddShieldExecution) == 0x000008, "Wrong alignment on UTgfAddShieldExecution");
static_assert(sizeof(UTgfAddShieldExecution) == 0x000070, "Wrong size on UTgfAddShieldExecution");

// Class LyraGame.TgfDamageExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfDamageExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfDamageExecution">();
	}
	static class UTgfDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfDamageExecution>();
	}
};
static_assert(alignof(UTgfDamageExecution) == 0x000008, "Wrong alignment on UTgfDamageExecution");
static_assert(sizeof(UTgfDamageExecution) == 0x000070, "Wrong size on UTgfDamageExecution");

// Class LyraGame.GameplayMessageProcessor
// 0x0010 (0x00B8 - 0x00A8)
class UGameplayMessageProcessor final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayMessageProcessor">();
	}
	static class UGameplayMessageProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayMessageProcessor>();
	}
};
static_assert(alignof(UGameplayMessageProcessor) == 0x000008, "Wrong alignment on UGameplayMessageProcessor");
static_assert(sizeof(UGameplayMessageProcessor) == 0x0000B8, "Wrong size on UGameplayMessageProcessor");

// Class LyraGame.TgfFixedAddShieldExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfFixedAddShieldExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFixedAddShieldExecution">();
	}
	static class UTgfFixedAddShieldExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFixedAddShieldExecution>();
	}
};
static_assert(alignof(UTgfFixedAddShieldExecution) == 0x000008, "Wrong alignment on UTgfFixedAddShieldExecution");
static_assert(sizeof(UTgfFixedAddShieldExecution) == 0x000070, "Wrong size on UTgfFixedAddShieldExecution");

// Class LyraGame.TgfFixedDamageExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfFixedDamageExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFixedDamageExecution">();
	}
	static class UTgfFixedDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFixedDamageExecution>();
	}
};
static_assert(alignof(UTgfFixedDamageExecution) == 0x000008, "Wrong alignment on UTgfFixedDamageExecution");
static_assert(sizeof(UTgfFixedDamageExecution) == 0x000070, "Wrong size on UTgfFixedDamageExecution");

// Class LyraGame.InventoryFragment_SetStats
// 0x0050 (0x0078 - 0x0028)
class UInventoryFragment_SetStats final : public ULyraInventoryItemFragment
{
public:
	TMap<struct FGameplayTag, int32>              InitialItemStats;                                  // 0x0028(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_SetStats">();
	}
	static class UInventoryFragment_SetStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_SetStats>();
	}
};
static_assert(alignof(UInventoryFragment_SetStats) == 0x000008, "Wrong alignment on UInventoryFragment_SetStats");
static_assert(sizeof(UInventoryFragment_SetStats) == 0x000078, "Wrong size on UInventoryFragment_SetStats");
static_assert(offsetof(UInventoryFragment_SetStats, InitialItemStats) == 0x000028, "Member 'UInventoryFragment_SetStats::InitialItemStats' has a wrong offset!");

// Class LyraGame.TgfFixedHealExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfFixedHealExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFixedHealExecution">();
	}
	static class UTgfFixedHealExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFixedHealExecution>();
	}
};
static_assert(alignof(UTgfFixedHealExecution) == 0x000008, "Wrong alignment on UTgfFixedHealExecution");
static_assert(sizeof(UTgfFixedHealExecution) == 0x000070, "Wrong size on UTgfFixedHealExecution");

// Class LyraGame.TgfFixedMagicExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfFixedMagicExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFixedMagicExecution">();
	}
	static class UTgfFixedMagicExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFixedMagicExecution>();
	}
};
static_assert(alignof(UTgfFixedMagicExecution) == 0x000008, "Wrong alignment on UTgfFixedMagicExecution");
static_assert(sizeof(UTgfFixedMagicExecution) == 0x000070, "Wrong size on UTgfFixedMagicExecution");

// Class LyraGame.LyraContextEffectsLibrary
// 0x0028 (0x0050 - 0x0028)
class ULyraContextEffectsLibrary final : public UObject
{
public:
	TArray<struct FLyraContextEffects>            ContextEffects;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULyraActiveContextEffects*>      ActiveContextEffects;                              // 0x0038(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	EContextEffectsLibraryLoadState               EffectsLoadState;                                  // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetEffects(const struct FGameplayTag& Effect, const struct FGameplayTagContainer& Context, TArray<class USoundBase*>* Sounds, TArray<class UNiagaraSystem*>* NiagaraSystems);
	void LoadEffects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraContextEffectsLibrary">();
	}
	static class ULyraContextEffectsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraContextEffectsLibrary>();
	}
};
static_assert(alignof(ULyraContextEffectsLibrary) == 0x000008, "Wrong alignment on ULyraContextEffectsLibrary");
static_assert(sizeof(ULyraContextEffectsLibrary) == 0x000050, "Wrong size on ULyraContextEffectsLibrary");
static_assert(offsetof(ULyraContextEffectsLibrary, ContextEffects) == 0x000028, "Member 'ULyraContextEffectsLibrary::ContextEffects' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectsLibrary, ActiveContextEffects) == 0x000038, "Member 'ULyraContextEffectsLibrary::ActiveContextEffects' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectsLibrary, EffectsLoadState) == 0x000048, "Member 'ULyraContextEffectsLibrary::EffectsLoadState' has a wrong offset!");

// Class LyraGame.TgfFixedNaturalEnergyExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfFixedNaturalEnergyExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFixedNaturalEnergyExecution">();
	}
	static class UTgfFixedNaturalEnergyExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFixedNaturalEnergyExecution>();
	}
};
static_assert(alignof(UTgfFixedNaturalEnergyExecution) == 0x000008, "Wrong alignment on UTgfFixedNaturalEnergyExecution");
static_assert(sizeof(UTgfFixedNaturalEnergyExecution) == 0x000070, "Wrong size on UTgfFixedNaturalEnergyExecution");

// Class LyraGame.TgfFixedSoulEnergyExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfFixedSoulEnergyExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfFixedSoulEnergyExecution">();
	}
	static class UTgfFixedSoulEnergyExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfFixedSoulEnergyExecution>();
	}
};
static_assert(alignof(UTgfFixedSoulEnergyExecution) == 0x000008, "Wrong alignment on UTgfFixedSoulEnergyExecution");
static_assert(sizeof(UTgfFixedSoulEnergyExecution) == 0x000070, "Wrong size on UTgfFixedSoulEnergyExecution");

// Class LyraGame.LyraPlayerController
// 0x00C0 (0x0920 - 0x0860)
class ALyraPlayerController : public ACommonPlayerController
{
public:
	uint8                                         Pad_860[0x10];                                     // 0x0860(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeViewTarget;                                // 0x0870(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSettingSharedChanged;                            // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          DisableUpdatingAlivingTime;                        // 0x0890(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_891[0x7];                                      // 0x0891(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x0898(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	class APlayerState*                           LastSeenPlayerState;                               // 0x08A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B0[0x67];                                     // 0x08B0(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowPing;                                          // 0x0917(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceHidePlayerNames;                              // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_919[0x7];                                      // 0x0919(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientEstimatePing(float DeltaTime);
	void ClientPingEstimationReq(const int32& Version, const int64& ClientCallTime);
	class AActor* GetCurrentViewTarget();
	float GetPredictPing();
	bool GetReconnect();
	bool GetSpectatorMode();
	void IncreaseAndCheckSecurityInvalidCount(int32 Reason);
	void K2_OnEndAutoRun();
	void K2_OnStartAutoRun();
	void NotifyClientLoaded();
	void OnPlayerStateChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);
	void ServerBanQuitGame();
	void ServerCheat(const class FString& Msg);
	void ServerCheatAll(const class FString& Msg);
	void ServerDeathQuitGame();
	void ServerEscapeQuitGame();
	void ServerPingEstimationRsp(const int32& Version, const int64& CallTime);
	void ServerSelfQuitGame();
	void ServerTeleportToWaitingRoom();
	void SetIgnoreFlushPressedKeys(const TArray<class UInputAction*>& IgnoreInputActions);
	void SetIsAutoRunning(const bool bEnabled);
	void Teleport(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	bool TryToRecordClientReplay();

	bool GetIsAutoRunning() const;
	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;
	class ALyraHUD* GetLyraHUD() const;
	class ALyraPlayerState* GetLyraPlayerState() const;
	bool IsOnlyAliving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerController">();
	}
	static class ALyraPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerController>();
	}
};
static_assert(alignof(ALyraPlayerController) == 0x000008, "Wrong alignment on ALyraPlayerController");
static_assert(sizeof(ALyraPlayerController) == 0x000920, "Wrong size on ALyraPlayerController");
static_assert(offsetof(ALyraPlayerController, OnChangeViewTarget) == 0x000870, "Member 'ALyraPlayerController::OnChangeViewTarget' has a wrong offset!");
static_assert(offsetof(ALyraPlayerController, OnSettingSharedChanged) == 0x000880, "Member 'ALyraPlayerController::OnSettingSharedChanged' has a wrong offset!");
static_assert(offsetof(ALyraPlayerController, DisableUpdatingAlivingTime) == 0x000890, "Member 'ALyraPlayerController::DisableUpdatingAlivingTime' has a wrong offset!");
static_assert(offsetof(ALyraPlayerController, OnTeamChangedDelegate) == 0x000898, "Member 'ALyraPlayerController::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ALyraPlayerController, LastSeenPlayerState) == 0x0008A8, "Member 'ALyraPlayerController::LastSeenPlayerState' has a wrong offset!");
static_assert(offsetof(ALyraPlayerController, ShowPing) == 0x000917, "Member 'ALyraPlayerController::ShowPing' has a wrong offset!");
static_assert(offsetof(ALyraPlayerController, ForceHidePlayerNames) == 0x000918, "Member 'ALyraPlayerController::ForceHidePlayerNames' has a wrong offset!");

// Class LyraGame.TgfHealExecution
// 0x0000 (0x0070 - 0x0070)
class UTgfHealExecution final : public UTgfBaseExecution
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfHealExecution">();
	}
	static class UTgfHealExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfHealExecution>();
	}
};
static_assert(alignof(UTgfHealExecution) == 0x000008, "Wrong alignment on UTgfHealExecution");
static_assert(sizeof(UTgfHealExecution) == 0x000070, "Wrong size on UTgfHealExecution");

// Class LyraGame.TgfMagicModMagnitudeCalculation
// 0x0040 (0x0080 - 0x0040)
class UTgfMagicModMagnitudeCalculation final : public UTgfBaseModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfMagicModMagnitudeCalculation">();
	}
	static class UTgfMagicModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfMagicModMagnitudeCalculation>();
	}
};
static_assert(alignof(UTgfMagicModMagnitudeCalculation) == 0x000008, "Wrong alignment on UTgfMagicModMagnitudeCalculation");
static_assert(sizeof(UTgfMagicModMagnitudeCalculation) == 0x000080, "Wrong size on UTgfMagicModMagnitudeCalculation");

// Class LyraGame.LyraDamagePopStyle
// 0x0088 (0x00B8 - 0x0030)
class ULyraDamagePopStyle final : public UDataAsset
{
public:
	class FString                                 DisplayText;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      MatchPattern;                                      // 0x0040(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CriticalColor;                                     // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TextMesh;                                          // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideColor;                                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMesh;                                     // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDamagePopStyle">();
	}
	static class ULyraDamagePopStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraDamagePopStyle>();
	}
};
static_assert(alignof(ULyraDamagePopStyle) == 0x000008, "Wrong alignment on ULyraDamagePopStyle");
static_assert(sizeof(ULyraDamagePopStyle) == 0x0000B8, "Wrong size on ULyraDamagePopStyle");
static_assert(offsetof(ULyraDamagePopStyle, DisplayText) == 0x000030, "Member 'ULyraDamagePopStyle::DisplayText' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyle, MatchPattern) == 0x000040, "Member 'ULyraDamagePopStyle::MatchPattern' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyle, Color) == 0x000088, "Member 'ULyraDamagePopStyle::Color' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyle, CriticalColor) == 0x000098, "Member 'ULyraDamagePopStyle::CriticalColor' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyle, TextMesh) == 0x0000A8, "Member 'ULyraDamagePopStyle::TextMesh' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyle, bOverrideColor) == 0x0000B0, "Member 'ULyraDamagePopStyle::bOverrideColor' has a wrong offset!");
static_assert(offsetof(ULyraDamagePopStyle, bOverrideMesh) == 0x0000B1, "Member 'ULyraDamagePopStyle::bOverrideMesh' has a wrong offset!");

// Class LyraGame.TgfNaturalEnergyModMagnitudeCalculation
// 0x0040 (0x0080 - 0x0040)
class UTgfNaturalEnergyModMagnitudeCalculation final : public UTgfBaseModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfNaturalEnergyModMagnitudeCalculation">();
	}
	static class UTgfNaturalEnergyModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfNaturalEnergyModMagnitudeCalculation>();
	}
};
static_assert(alignof(UTgfNaturalEnergyModMagnitudeCalculation) == 0x000008, "Wrong alignment on UTgfNaturalEnergyModMagnitudeCalculation");
static_assert(sizeof(UTgfNaturalEnergyModMagnitudeCalculation) == 0x000080, "Wrong size on UTgfNaturalEnergyModMagnitudeCalculation");

// Class LyraGame.TgfSoulEnergyModMagnitudeCalculation
// 0x0040 (0x0080 - 0x0040)
class UTgfSoulEnergyModMagnitudeCalculation final : public UTgfBaseModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSoulEnergyModMagnitudeCalculation">();
	}
	static class UTgfSoulEnergyModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSoulEnergyModMagnitudeCalculation>();
	}
};
static_assert(alignof(UTgfSoulEnergyModMagnitudeCalculation) == 0x000008, "Wrong alignment on UTgfSoulEnergyModMagnitudeCalculation");
static_assert(sizeof(UTgfSoulEnergyModMagnitudeCalculation) == 0x000080, "Wrong size on UTgfSoulEnergyModMagnitudeCalculation");

// Class LyraGame.LyraContextEffectComponent
// 0x0110 (0x01B8 - 0x00A8)
class ULyraContextEffectComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConvertPhysicalSurfaceToContext;                  // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DefaultEffectContexts;                             // 0x00B8(0x0020)(Edit, NativeAccessSpecifierPublic)
	TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>> DefaultContextEffectsLibraries;                    // 0x00D8(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CurrentContexts;                                   // 0x0128(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>> CurrentContextEffectsLibraries;                    // 0x0148(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UAudioComponent*>                ActiveAudioComponents;                             // 0x0198(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              ActiveNiagaraComponents;                           // 0x01A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void AnimMotionEffect_Implementation(const class FName bone, const struct FGameplayTag& MotionEffect, class USceneComponent* StaticMeshComponent, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const class UAnimSequenceBase* AnimationSequence, const bool bHitSuccess, const struct FHitResult& HitResult, const struct FGameplayTagContainer& Contexts, const struct FVector& VFXScale, float AudioVolume, float AudioPitch);
	void UpdateEffectContexts(const struct FGameplayTagContainer& NewEffectContexts);
	void UpdateLibraries(const TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>>& NewContextEffectsLibraries);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraContextEffectComponent">();
	}
	static class ULyraContextEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraContextEffectComponent>();
	}
};
static_assert(alignof(ULyraContextEffectComponent) == 0x000008, "Wrong alignment on ULyraContextEffectComponent");
static_assert(sizeof(ULyraContextEffectComponent) == 0x0001B8, "Wrong size on ULyraContextEffectComponent");
static_assert(offsetof(ULyraContextEffectComponent, bConvertPhysicalSurfaceToContext) == 0x0000B0, "Member 'ULyraContextEffectComponent::bConvertPhysicalSurfaceToContext' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectComponent, DefaultEffectContexts) == 0x0000B8, "Member 'ULyraContextEffectComponent::DefaultEffectContexts' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectComponent, DefaultContextEffectsLibraries) == 0x0000D8, "Member 'ULyraContextEffectComponent::DefaultContextEffectsLibraries' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectComponent, CurrentContexts) == 0x000128, "Member 'ULyraContextEffectComponent::CurrentContexts' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectComponent, CurrentContextEffectsLibraries) == 0x000148, "Member 'ULyraContextEffectComponent::CurrentContextEffectsLibraries' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectComponent, ActiveAudioComponents) == 0x000198, "Member 'ULyraContextEffectComponent::ActiveAudioComponents' has a wrong offset!");
static_assert(offsetof(ULyraContextEffectComponent, ActiveNiagaraComponents) == 0x0001A8, "Member 'ULyraContextEffectComponent::ActiveNiagaraComponents' has a wrong offset!");

// Class LyraGame.LyraAbilitySet
// 0x00C0 (0x00F0 - 0x0030)
class ULyraAbilitySet final : public UDataAsset
{
public:
	TArray<struct FLyraAbilitySet_DynamicGameplayTag> DynamicSetByCaller;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLyraAbilitySet_DynamicAttributeValue> DynamicAttrValues;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLyraAbilitySet_DynamicAbilityLevel    OverrideAbilityLevel;                              // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ETgfItemAffixType                             AffixType;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilitySetId;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraAbilitySet_GameplayAbility> GrantedGameplayAbilities;                          // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_GameplayEffect> GrantedGameplayEffects;                            // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_AttributeSet>   GrantedAttributes;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_Aura>           GrantedAuras;                                      // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_AttributeValue> GrantedAttrValues;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_LooseGameTag>   GrantedGameTags;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_DamagePartMonitor> GrantedDamagePartMonitors;                         // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAbilitySet_MovementMonitor> GrantedMovementMonitors;                           // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          EnableInAdditionalSlot;                            // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DealAdditionalAbilitySystem(class ULyraAbilitySystemComponent* LyraASC, struct FLyraAbilitySet_GrantedHandles* OutGrantedHandles) const;
	TArray<TSubclassOf<class ULyraGameplayAbility>> GetGrantedGameplayAbilityClasses() const;
	void GiveToAbilitySystem(class ULyraAbilitySystemComponent* LyraASC, struct FLyraAbilitySet_GrantedHandles* OutGrantedHandles, class UObject* SourceObject, ETgfEquipAttrParseType AttrParseType) const;
	bool NeedEnableInAdditionalSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilitySet">();
	}
	static class ULyraAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilitySet>();
	}
};
static_assert(alignof(ULyraAbilitySet) == 0x000008, "Wrong alignment on ULyraAbilitySet");
static_assert(sizeof(ULyraAbilitySet) == 0x0000F0, "Wrong size on ULyraAbilitySet");
static_assert(offsetof(ULyraAbilitySet, DynamicSetByCaller) == 0x000030, "Member 'ULyraAbilitySet::DynamicSetByCaller' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, DynamicAttrValues) == 0x000040, "Member 'ULyraAbilitySet::DynamicAttrValues' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, OverrideAbilityLevel) == 0x000050, "Member 'ULyraAbilitySet::OverrideAbilityLevel' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, AffixType) == 0x000060, "Member 'ULyraAbilitySet::AffixType' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, AbilitySetId) == 0x000064, "Member 'ULyraAbilitySet::AbilitySetId' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedGameplayAbilities) == 0x000068, "Member 'ULyraAbilitySet::GrantedGameplayAbilities' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedGameplayEffects) == 0x000078, "Member 'ULyraAbilitySet::GrantedGameplayEffects' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedAttributes) == 0x000088, "Member 'ULyraAbilitySet::GrantedAttributes' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedAuras) == 0x000098, "Member 'ULyraAbilitySet::GrantedAuras' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedAttrValues) == 0x0000A8, "Member 'ULyraAbilitySet::GrantedAttrValues' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedGameTags) == 0x0000B8, "Member 'ULyraAbilitySet::GrantedGameTags' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedDamagePartMonitors) == 0x0000C8, "Member 'ULyraAbilitySet::GrantedDamagePartMonitors' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, GrantedMovementMonitors) == 0x0000D8, "Member 'ULyraAbilitySet::GrantedMovementMonitors' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySet, EnableInAdditionalSlot) == 0x0000E8, "Member 'ULyraAbilitySet::EnableInAdditionalSlot' has a wrong offset!");

// Class LyraGame.LyraAbilitySourceInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraAbilitySourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilitySourceInterface">();
	}
	static class ILyraAbilitySourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraAbilitySourceInterface>();
	}
};
static_assert(alignof(ILyraAbilitySourceInterface) == 0x000008, "Wrong alignment on ILyraAbilitySourceInterface");
static_assert(sizeof(ILyraAbilitySourceInterface) == 0x000028, "Wrong size on ILyraAbilitySourceInterface");

// Class LyraGame.LyraLocalPlayer
// 0x0030 (0x0318 - 0x02E8)
class ULyraLocalPlayer final : public UCommonLocalPlayer
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraSettingsShared*                    SharedSettings;                                    // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   InputMappingContext;                               // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x0300(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APlayerController>       LastBoundPC;                                       // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCompletedAudioDeviceSwap(const struct FSwapAudioOutputResult& SwapResult);
	void OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);

	class ULyraSettingsLocal* GetLocalSettings() const;
	class ULyraSettingsShared* GetSharedSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraLocalPlayer">();
	}
	static class ULyraLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraLocalPlayer>();
	}
};
static_assert(alignof(ULyraLocalPlayer) == 0x000008, "Wrong alignment on ULyraLocalPlayer");
static_assert(sizeof(ULyraLocalPlayer) == 0x000318, "Wrong size on ULyraLocalPlayer");
static_assert(offsetof(ULyraLocalPlayer, SharedSettings) == 0x0002F0, "Member 'ULyraLocalPlayer::SharedSettings' has a wrong offset!");
static_assert(offsetof(ULyraLocalPlayer, InputMappingContext) == 0x0002F8, "Member 'ULyraLocalPlayer::InputMappingContext' has a wrong offset!");
static_assert(offsetof(ULyraLocalPlayer, OnTeamChangedDelegate) == 0x000300, "Member 'ULyraLocalPlayer::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULyraLocalPlayer, LastBoundPC) == 0x000310, "Member 'ULyraLocalPlayer::LastBoundPC' has a wrong offset!");

// Class LyraGame.LyraAbilitySystemComponent
// 0x0140 (0x1650 - 0x1510)
class ULyraAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_1510[0x18];                                    // 0x1510(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAbilityTagRelationshipMapping*     TagRelationshipMapping;                            // 0x1528(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAbilitySetChange;                                // 0x1530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1540[0x110];                                   // 0x1540(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityInputTagPressed(const struct FGameplayTag& InputTag);
	void AbilityInputTagReleased(const struct FGameplayTag& InputTag);
	void AddInputTagDelayOverride(const struct FGameplayTag& Tag, double Time);
	void ApplyDumpedGameplayEffect(const TArray<struct FTGFDumpedGameplayEffect>& DumpedArray);
	void CancelAbilitiesOnOwnClient(const struct FGameplayTagContainer& WithTags, const struct FGameplayTagContainer& WithoutTags);
	void ClientNotifyAbilityFailed(const class UGameplayAbility* Ability, const struct FGameplayTagContainer& FailureReason);
	bool GetAbilityWithTag(struct FGameplayAbilitySpecHandle* OutHandler, const struct FGameplayTag& Tag);
	TArray<class UGameplayAbility*> GetAllActiveGameplayAbilitys();
	class UTgfAttributeComponent* GetAttributeComponent();
	class UTgfAuraManagerComponent* GetAuraManagerComponent();
	class UTgfCharacterMovementExtensionComponent* GetCharaMoveExtComponent();
	TArray<class UGameplayAbility*> GetGameplayAbilityByDynamicAbilityTag(const struct FGameplayTag& Tag);
	double GetInputDelayTime(const class ULyraGameplayAbility* Ability);
	class ALyraCharacter* GetOwnerLyraCharacter();
	struct FGameplayAbilitySpecHandle GiveAbilityByInputTag(TSubclassOf<class UGameplayAbility> Ability, const struct FGameplayTag& InputTag, const int32 AbilityLevel);
	void InterruptAbility(const struct FGameplayAbilitySpecHandle& Handle);
	void InterruptAbilityByClass(TSubclassOf<class UGameplayAbility> Ability);
	void InterruptAbilityByTag(const struct FGameplayTag& Tag);
	void InterruptAbilityByTagContainer(const struct FGameplayTagContainer& TagContainer);
	bool IsAbilityCoolingDown(TSubclassOf<class UGameplayAbility> Ability);
	bool IsImmuneDamageFromSource(class ULyraAbilitySystemComponent* Source, struct FGameplayTagContainer* AddContainer);
	void PopAbilityTagClick(const struct FGameplayTag& InputTag);
	int32 RemoveAbilityCooldown(TSubclassOf<class UGameplayAbility> Ability);
	bool RemoveActiveEffectByHandle(const struct FActiveGameplayEffectHandle& Handle, int32 StacksToRemove);
	void RemoveInputTagDelayOverride(const struct FGameplayTag& Tag);
	void ReportClientTaskProgress(ETGFInGameRookieTaskType TaskType, class ALyraCharacter* InstigatorCharacter, int64 Progress);
	void SendGameplayEventToClient(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void TryActivateAbilitiesOnSpawn();

	void DumpGameplayEffect(TArray<struct FTGFDumpedGameplayEffect>* OutArray) const;
	TArray<struct FActiveGameplayEffectHandle> GetRandomActiveEffects(const struct FGameplayTagContainer& Tags, int32 Num) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilitySystemComponent">();
	}
	static class ULyraAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilitySystemComponent>();
	}
};
static_assert(alignof(ULyraAbilitySystemComponent) == 0x000008, "Wrong alignment on ULyraAbilitySystemComponent");
static_assert(sizeof(ULyraAbilitySystemComponent) == 0x001650, "Wrong size on ULyraAbilitySystemComponent");
static_assert(offsetof(ULyraAbilitySystemComponent, TagRelationshipMapping) == 0x001528, "Member 'ULyraAbilitySystemComponent::TagRelationshipMapping' has a wrong offset!");
static_assert(offsetof(ULyraAbilitySystemComponent, OnAbilitySetChange) == 0x001530, "Member 'ULyraAbilitySystemComponent::OnAbilitySetChange' has a wrong offset!");

// Class LyraGame.LyraAbilitySystemGlobals
// 0x0000 (0x02B0 - 0x02B0)
class ULyraAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilitySystemGlobals">();
	}
	static class ULyraAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilitySystemGlobals>();
	}
};
static_assert(alignof(ULyraAbilitySystemGlobals) == 0x000008, "Wrong alignment on ULyraAbilitySystemGlobals");
static_assert(sizeof(ULyraAbilitySystemGlobals) == 0x0002B0, "Wrong size on ULyraAbilitySystemGlobals");

// Class LyraGame.LyraPlayerState
// 0x0680 (0x0A30 - 0x03B0)
class ALyraPlayerState : public AModularPlayerState
{
public:
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerNameData                        PlayerNameData;                                    // 0x03C0(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FPlayerIntStatistics                   IntStatistics;                                     // 0x03F0(0x0120)(Net, NativeAccessSpecifierPublic)
	struct FPlayerFloatStatistics                 FloatStatistics;                                   // 0x0510(0x0120)(Net, NativeAccessSpecifierPublic)
	struct FPlayerRelationIntStatistics           RelationIntStatistics;                             // 0x0630(0x0120)(Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_750[0xF0];                                     // 0x0750(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HasInitedPlayerData;                               // 0x0840(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_841[0x7];                                      // 0x0841(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraPawnData*                          PawnData;                                          // 0x0848(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x0850(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_860[0x10];                                     // 0x0860(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0870(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELyraPlayerConnectionType                     MyPlayerConnectionType;                            // 0x0878(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         MyTeamID;                                          // 0x0879(0x0001)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETgfPVPTeamColor                              TeamColor;                                         // 0x087A(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_87B[0x1];                                      // 0x087B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MySquadID;                                         // 0x087C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         MyRoleGuid;                                        // 0x0880(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         MyUserID;                                          // 0x0888(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MyZoneID;                                          // 0x0890(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_894[0x4];                                      // 0x0894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagStackContainer             StatTags;                                          // 0x0898(0x0168)(Net, NativeAccessSpecifierPrivate)
	class FString                                 MyOpenId;                                          // 0x0A00(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDisconnected;                                    // 0x0A10(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSelfQuit;                                        // 0x0A11(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEscapeQuit;                                      // 0x0A12(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDeathQuit;                                       // 0x0A13(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsBanQuit;                                         // 0x0A14(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTeleportToWaitingRoom;                           // 0x0A15(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETgfForceType                                 ForceType;                                         // 0x0A16(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A17[0x1];                                      // 0x0A17(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MithrilRemainingRebirthChances;                    // 0x0A18(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETgfPlayerSceneTag                            SceneTag;                                          // 0x0A1C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1D[0x3];                                      // 0x0A1D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalExp;                                          // 0x0A20(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A24[0xC];                                      // 0x0A24(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStatTagStack(const struct FGameplayTag& Tag, int32 StackCount);
	void ClientBroadcastMessage(const struct FLyraVerbMessage& Message);
	void ClientSelfQuit();
	bool GetIsDisconnected();
	struct FPlayerNameData GetPlayerNameData();
	ETgfPVPTeamColor GetTeamColor();
	void GMSetPlayerName(const class FString& Param_Name);
	void OnRep_FloatStatistics(const struct FPlayerFloatStatisticItemEntry& FloatStatisticItem);
	void OnRep_ForceType();
	void OnRep_IntStatistics(const struct FPlayerIntStatisticItemEntry& IntStatisticItem);
	void OnRep_IsTeleportToWaitingRoom();
	void OnRep_MithrilRemainingRebirthChances();
	void OnRep_MyOpenId();
	void OnRep_MyRoleGuid();
	void OnRep_MySquadID();
	void OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID);
	void OnRep_MyUserID();
	void OnRep_MyZoneID();
	void OnRep_PawnData();
	void OnRep_RelationIntStatistics(const struct FPlayerRelationIntStatisticItemEntry& RelationIntStatisticItem);
	void OnRep_SceneTag();
	void PlayerAddExp(int32 ExpCount);
	void RemoveStatTagStack(const struct FGameplayTag& Tag, int32 StackCount);
	void ServerCallBanQuit();
	void ServerCallDeathQuit();
	void ServerCallEscapeQuit(bool JudgeTeammateDeathQuit);
	void ServerCallSelfQuit();
	void ServerCallTeleportToWaitingRoom();
	void SetFloatStatisticsRepType(ETgfActorFloatStatisticType Type);
	void SetIntStatisticsRepType(ETgfActorIntStatisticType Type, int32 TypeId);
	void SetIsDisconnected(bool IsOk);
	void SetPlayerSceneTag(ETgfPlayerSceneTag Tag);
	void SetRelationIntStatisticsRepType(ETgfActorRelationStatisticType Type, const class FString& OpenID);
	void SettleDisconnectTimeDuration();

	float GetDisconnectedTimeDuration() const;
	bool GetIsBanQuit() const;
	bool GetIsDeathQuit() const;
	bool GetIsEscapeQuit() const;
	bool GetIsMithrilCharacter() const;
	bool GetIsSelfQuit() const;
	bool GetIsTeleportToWaitingRoom() const;
	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;
	class ALyraPlayerController* GetLyraPlayerController() const;
	int32 GetMithrilRemainingRebirthChances() const;
	class FString GetOpenId() const;
	ELyraPlayerConnectionType GetPlayerConnectionType() const;
	ETgfPlayerSceneTag GetPlayerSceneTag() const;
	int64 GetRoleGuid() const;
	int32 GetSquadId() const;
	int32 GetStatTagStackCount(const struct FGameplayTag& Tag) const;
	int32 GetTeamId() const;
	int32 GetTotalExp() const;
	int64 GetUserId() const;
	int32 GetZoneId() const;
	bool HasStatTag(const struct FGameplayTag& Tag) const;
	bool NeedIgnoreAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerState">();
	}
	static class ALyraPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerState>();
	}
};
static_assert(alignof(ALyraPlayerState) == 0x000008, "Wrong alignment on ALyraPlayerState");
static_assert(sizeof(ALyraPlayerState) == 0x000A30, "Wrong size on ALyraPlayerState");
static_assert(offsetof(ALyraPlayerState, PlayerNameData) == 0x0003C0, "Member 'ALyraPlayerState::PlayerNameData' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IntStatistics) == 0x0003F0, "Member 'ALyraPlayerState::IntStatistics' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, FloatStatistics) == 0x000510, "Member 'ALyraPlayerState::FloatStatistics' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, RelationIntStatistics) == 0x000630, "Member 'ALyraPlayerState::RelationIntStatistics' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, HasInitedPlayerData) == 0x000840, "Member 'ALyraPlayerState::HasInitedPlayerData' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, PawnData) == 0x000848, "Member 'ALyraPlayerState::PawnData' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, OnTeamChangedDelegate) == 0x000850, "Member 'ALyraPlayerState::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, AbilitySystemComponent) == 0x000870, "Member 'ALyraPlayerState::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MyPlayerConnectionType) == 0x000878, "Member 'ALyraPlayerState::MyPlayerConnectionType' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MyTeamID) == 0x000879, "Member 'ALyraPlayerState::MyTeamID' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, TeamColor) == 0x00087A, "Member 'ALyraPlayerState::TeamColor' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MySquadID) == 0x00087C, "Member 'ALyraPlayerState::MySquadID' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MyRoleGuid) == 0x000880, "Member 'ALyraPlayerState::MyRoleGuid' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MyUserID) == 0x000888, "Member 'ALyraPlayerState::MyUserID' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MyZoneID) == 0x000890, "Member 'ALyraPlayerState::MyZoneID' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, StatTags) == 0x000898, "Member 'ALyraPlayerState::StatTags' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MyOpenId) == 0x000A00, "Member 'ALyraPlayerState::MyOpenId' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IsDisconnected) == 0x000A10, "Member 'ALyraPlayerState::IsDisconnected' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IsSelfQuit) == 0x000A11, "Member 'ALyraPlayerState::IsSelfQuit' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IsEscapeQuit) == 0x000A12, "Member 'ALyraPlayerState::IsEscapeQuit' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IsDeathQuit) == 0x000A13, "Member 'ALyraPlayerState::IsDeathQuit' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IsBanQuit) == 0x000A14, "Member 'ALyraPlayerState::IsBanQuit' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, IsTeleportToWaitingRoom) == 0x000A15, "Member 'ALyraPlayerState::IsTeleportToWaitingRoom' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, ForceType) == 0x000A16, "Member 'ALyraPlayerState::ForceType' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, MithrilRemainingRebirthChances) == 0x000A18, "Member 'ALyraPlayerState::MithrilRemainingRebirthChances' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, SceneTag) == 0x000A1C, "Member 'ALyraPlayerState::SceneTag' has a wrong offset!");
static_assert(offsetof(ALyraPlayerState, TotalExp) == 0x000A20, "Member 'ALyraPlayerState::TotalExp' has a wrong offset!");

// Class LyraGame.LyraAbilityTagRelationshipMapping
// 0x0010 (0x0040 - 0x0030)
class ULyraAbilityTagRelationshipMapping final : public UDataAsset
{
public:
	TArray<struct FLyraAbilityTagRelationship>    AbilityTagRelationships;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAbilityTagRelationshipMapping">();
	}
	static class ULyraAbilityTagRelationshipMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAbilityTagRelationshipMapping>();
	}
};
static_assert(alignof(ULyraAbilityTagRelationshipMapping) == 0x000008, "Wrong alignment on ULyraAbilityTagRelationshipMapping");
static_assert(sizeof(ULyraAbilityTagRelationshipMapping) == 0x000040, "Wrong size on ULyraAbilityTagRelationshipMapping");
static_assert(offsetof(ULyraAbilityTagRelationshipMapping, AbilityTagRelationships) == 0x000030, "Member 'ULyraAbilityTagRelationshipMapping::AbilityTagRelationships' has a wrong offset!");

// Class LyraGame.LyraGlobalAbilitySystem
// 0x00B0 (0x00E0 - 0x0030)
class ULyraGlobalAbilitySystem final : public UWorldSubsystem
{
public:
	TMap<TSubclassOf<class UGameplayAbility>, struct FGlobalAppliedAbilityList> AppliedAbilities;                                  // 0x0030(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UGameplayEffect>, struct FGlobalAppliedEffectList> AppliedEffects;                                    // 0x0080(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ULyraAbilitySystemComponent*>    RegisteredASCs;                                    // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ApplyAbilityToAll(TSubclassOf<class UGameplayAbility> Ability);
	void ApplyEffectToAll(TSubclassOf<class UGameplayEffect> Effect);
	void RemoveAbilityFromAll(TSubclassOf<class UGameplayAbility> Ability);
	void RemoveEffectFromAll(TSubclassOf<class UGameplayEffect> Effect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGlobalAbilitySystem">();
	}
	static class ULyraGlobalAbilitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGlobalAbilitySystem>();
	}
};
static_assert(alignof(ULyraGlobalAbilitySystem) == 0x000008, "Wrong alignment on ULyraGlobalAbilitySystem");
static_assert(sizeof(ULyraGlobalAbilitySystem) == 0x0000E0, "Wrong size on ULyraGlobalAbilitySystem");
static_assert(offsetof(ULyraGlobalAbilitySystem, AppliedAbilities) == 0x000030, "Member 'ULyraGlobalAbilitySystem::AppliedAbilities' has a wrong offset!");
static_assert(offsetof(ULyraGlobalAbilitySystem, AppliedEffects) == 0x000080, "Member 'ULyraGlobalAbilitySystem::AppliedEffects' has a wrong offset!");
static_assert(offsetof(ULyraGlobalAbilitySystem, RegisteredASCs) == 0x0000D0, "Member 'ULyraGlobalAbilitySystem::RegisteredASCs' has a wrong offset!");

// Class LyraGame.LyraPlayerSpawningManagerComponent
// 0x00D8 (0x0180 - 0x00A8)
class ULyraPlayerSpawningManagerComponent final : public UGameStateComponent
{
public:
	struct FLyraCachedPlayerStarts                CachedPlayerStarts;                                // 0x00A8(0x0030)(Transient, NativeAccessSpecifierPrivate)
	TMap<ETgfPlayerSceneTag, struct FTgfPlayerStartsGroupInfo> PlayerStartGroupInfos;                             // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<ETgfPlayerSceneTag, struct FTgfPlayerStartsGroupInfo> WaitingPoints;                                     // 0x0128(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APlayerStart* GetFirstRandomPlayerStartsInRegion(class AController* Controller, const struct FVector& Center, float Radius);
	class APlayerStart* GetRandomPlayerStartOutRegion(class AController* Controller, const struct FVector& Center, float Radius, bool HasDeathZone, const struct FVector& DeathZoneCenter, float DeathZoneRadius);
	void K2_OnFinishRestartPlayer(class AController* Player, const struct FRotator& StartRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerSpawningManagerComponent">();
	}
	static class ULyraPlayerSpawningManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPlayerSpawningManagerComponent>();
	}
};
static_assert(alignof(ULyraPlayerSpawningManagerComponent) == 0x000008, "Wrong alignment on ULyraPlayerSpawningManagerComponent");
static_assert(sizeof(ULyraPlayerSpawningManagerComponent) == 0x000180, "Wrong size on ULyraPlayerSpawningManagerComponent");
static_assert(offsetof(ULyraPlayerSpawningManagerComponent, CachedPlayerStarts) == 0x0000A8, "Member 'ULyraPlayerSpawningManagerComponent::CachedPlayerStarts' has a wrong offset!");
static_assert(offsetof(ULyraPlayerSpawningManagerComponent, PlayerStartGroupInfos) == 0x0000D8, "Member 'ULyraPlayerSpawningManagerComponent::PlayerStartGroupInfos' has a wrong offset!");
static_assert(offsetof(ULyraPlayerSpawningManagerComponent, WaitingPoints) == 0x000128, "Member 'ULyraPlayerSpawningManagerComponent::WaitingPoints' has a wrong offset!");

// Class LyraGame.LyraGamePhaseAbility
// 0x0008 (0x0690 - 0x0688)
class ULyraGamePhaseAbility : public ULyraGameplayAbility
{
public:
	struct FGameplayTag                           GamePhaseTag;                                      // 0x0688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EndPhase();
	void SetAllActorAliveTime(bool OnlyRefreshStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGamePhaseAbility">();
	}
	static class ULyraGamePhaseAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGamePhaseAbility>();
	}
};
static_assert(alignof(ULyraGamePhaseAbility) == 0x000008, "Wrong alignment on ULyraGamePhaseAbility");
static_assert(sizeof(ULyraGamePhaseAbility) == 0x000690, "Wrong size on ULyraGamePhaseAbility");
static_assert(offsetof(ULyraGamePhaseAbility, GamePhaseTag) == 0x000688, "Member 'ULyraGamePhaseAbility::GamePhaseTag' has a wrong offset!");

// Class LyraGame.LyraGamePhaseSubsystem
// 0x0080 (0x00B0 - 0x0030)
class ULyraGamePhaseSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             EndCurrentPhase;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_StartPhase(TSubclassOf<class ULyraGamePhaseAbility> Phase, const TDelegate<void(class ULyraGamePhaseAbility* Phase)>& PhaseEnded);
	void K2_WhenPhaseEnds(const struct FGameplayTag& PhaseTag, EPhaseTagMatchType MatchType, TDelegate<void(struct FGameplayTag& PhaseTag)> WhenPhaseEnd);
	void K2_WhenPhaseStartsOrIsActive(const struct FGameplayTag& PhaseTag, EPhaseTagMatchType MatchType, TDelegate<void(struct FGameplayTag& PhaseTag)> WhenPhaseActive);

	bool IsPhaseActive(const struct FGameplayTag& PhaseTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGamePhaseSubsystem">();
	}
	static class ULyraGamePhaseSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGamePhaseSubsystem>();
	}
};
static_assert(alignof(ULyraGamePhaseSubsystem) == 0x000008, "Wrong alignment on ULyraGamePhaseSubsystem");
static_assert(sizeof(ULyraGamePhaseSubsystem) == 0x0000B0, "Wrong size on ULyraGamePhaseSubsystem");
static_assert(offsetof(ULyraGamePhaseSubsystem, EndCurrentPhase) == 0x000030, "Member 'ULyraGamePhaseSubsystem::EndCurrentPhase' has a wrong offset!");

// Class LyraGame.AbilityTask_ApplyTgfMoveToForce
// 0x00C8 (0x0190 - 0x00C8)
class UAbilityTask_ApplyTgfMoveToForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	FMulticastInlineDelegateProperty_             OnTimedOut;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnTimedOutAndDestinationReached;                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             DestinationReachedButNotTimeOut;                   // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	int32                                         RootMotionPriority;                                // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x0100(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0118(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0130(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateRotation;                                   // 0x0134(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StartRotation;                                     // 0x0138(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x0150(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RotateDuration;                                    // 0x0168(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x016C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x016D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x016E(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16F[0x1];                                      // 0x016F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0170(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IgnoreZLimit;                                      // 0x0180(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184[0xC];                                      // 0x0184(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyTgfMoveToForce* ApplyTgfMoveToForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, const struct FVector& Param_TargetLocation, float Param_Duration, bool Param_bUpdateRotation, const struct FRotator& Param_TargetRotation, float Param_RotateDuration, bool Param_bSetNewMovementMode, EMovementMode MovementMode, bool Param_bRestrictSpeedToExpected, class UCurveVector* Param_PathOffsetCurve, float Param_IgnoreZLimit, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_ApplyTgfMoveToForce">();
	}
	static class UAbilityTask_ApplyTgfMoveToForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyTgfMoveToForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyTgfMoveToForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyTgfMoveToForce");
static_assert(sizeof(UAbilityTask_ApplyTgfMoveToForce) == 0x000190, "Wrong size on UAbilityTask_ApplyTgfMoveToForce");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, OnTimedOut) == 0x0000C8, "Member 'UAbilityTask_ApplyTgfMoveToForce::OnTimedOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, OnTimedOutAndDestinationReached) == 0x0000D8, "Member 'UAbilityTask_ApplyTgfMoveToForce::OnTimedOutAndDestinationReached' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, DestinationReachedButNotTimeOut) == 0x0000E8, "Member 'UAbilityTask_ApplyTgfMoveToForce::DestinationReachedButNotTimeOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, RootMotionPriority) == 0x0000F8, "Member 'UAbilityTask_ApplyTgfMoveToForce::RootMotionPriority' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, StartLocation) == 0x000100, "Member 'UAbilityTask_ApplyTgfMoveToForce::StartLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, TargetLocation) == 0x000118, "Member 'UAbilityTask_ApplyTgfMoveToForce::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, Duration) == 0x000130, "Member 'UAbilityTask_ApplyTgfMoveToForce::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, bUpdateRotation) == 0x000134, "Member 'UAbilityTask_ApplyTgfMoveToForce::bUpdateRotation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, StartRotation) == 0x000138, "Member 'UAbilityTask_ApplyTgfMoveToForce::StartRotation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, TargetRotation) == 0x000150, "Member 'UAbilityTask_ApplyTgfMoveToForce::TargetRotation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, RotateDuration) == 0x000168, "Member 'UAbilityTask_ApplyTgfMoveToForce::RotateDuration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, bSetNewMovementMode) == 0x00016C, "Member 'UAbilityTask_ApplyTgfMoveToForce::bSetNewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, NewMovementMode) == 0x00016D, "Member 'UAbilityTask_ApplyTgfMoveToForce::NewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, bRestrictSpeedToExpected) == 0x00016E, "Member 'UAbilityTask_ApplyTgfMoveToForce::bRestrictSpeedToExpected' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, PathOffsetCurve) == 0x000170, "Member 'UAbilityTask_ApplyTgfMoveToForce::PathOffsetCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyTgfMoveToForce, IgnoreZLimit) == 0x000180, "Member 'UAbilityTask_ApplyTgfMoveToForce::IgnoreZLimit' has a wrong offset!");

// Class LyraGame.AbilityTask_MoveActor
// 0x0098 (0x0160 - 0x00C8)
class UAbilityTask_MoveActor final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	FMulticastInlineDelegateProperty_             OnTimedOut;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         RootMotionPriority;                                // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartTransform;                                    // 0x00E0(0x0060)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0140(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           LocationCurve;                                     // 0x0148(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExtractRootMotionCurve;                         // 0x0150(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldIgnoreZAccumulate;                          // 0x0151(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x0152(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x0153(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x0154(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_155[0xB];                                      // 0x0155(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_MoveActor* ApplyMoveActor(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, float Param_Duration, class UCurveVector* Param_LocationCurve, bool Param_bIsExtractRootMotionCurve, bool Param_bShouldIgnoreZAccumulate, bool Param_bSetNewMovementMode, EMovementMode MovementMode, bool Param_bRestrictSpeedToExpected, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinished, float ClampVelocityOnFinish);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_MoveActor">();
	}
	static class UAbilityTask_MoveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_MoveActor>();
	}
};
static_assert(alignof(UAbilityTask_MoveActor) == 0x000010, "Wrong alignment on UAbilityTask_MoveActor");
static_assert(sizeof(UAbilityTask_MoveActor) == 0x000160, "Wrong size on UAbilityTask_MoveActor");
static_assert(offsetof(UAbilityTask_MoveActor, OnTimedOut) == 0x0000C8, "Member 'UAbilityTask_MoveActor::OnTimedOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, RootMotionPriority) == 0x0000D8, "Member 'UAbilityTask_MoveActor::RootMotionPriority' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, StartTransform) == 0x0000E0, "Member 'UAbilityTask_MoveActor::StartTransform' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, Duration) == 0x000140, "Member 'UAbilityTask_MoveActor::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, LocationCurve) == 0x000148, "Member 'UAbilityTask_MoveActor::LocationCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, bIsExtractRootMotionCurve) == 0x000150, "Member 'UAbilityTask_MoveActor::bIsExtractRootMotionCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, bShouldIgnoreZAccumulate) == 0x000151, "Member 'UAbilityTask_MoveActor::bShouldIgnoreZAccumulate' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, bSetNewMovementMode) == 0x000152, "Member 'UAbilityTask_MoveActor::bSetNewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, NewMovementMode) == 0x000153, "Member 'UAbilityTask_MoveActor::NewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveActor, bRestrictSpeedToExpected) == 0x000154, "Member 'UAbilityTask_MoveActor::bRestrictSpeedToExpected' has a wrong offset!");

// Class LyraGame.LyraPlayerStartSet
// 0x0020 (0x02B8 - 0x0298)
class ALyraPlayerStartSet final : public AActor
{
public:
	bool                                          bWaitingPointSet;                                  // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfPVPTeamColor                              TeamColor;                                         // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeathPointSet;                                    // 0x029A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfPlayerSceneTag                            PlayerSceneTag;                                    // 0x029B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x1C];                                     // 0x029C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetTeamId();
	void SetTeamId(int32 Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerStartSet">();
	}
	static class ALyraPlayerStartSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerStartSet>();
	}
};
static_assert(alignof(ALyraPlayerStartSet) == 0x000008, "Wrong alignment on ALyraPlayerStartSet");
static_assert(sizeof(ALyraPlayerStartSet) == 0x0002B8, "Wrong size on ALyraPlayerStartSet");
static_assert(offsetof(ALyraPlayerStartSet, bWaitingPointSet) == 0x000298, "Member 'ALyraPlayerStartSet::bWaitingPointSet' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStartSet, TeamColor) == 0x000299, "Member 'ALyraPlayerStartSet::TeamColor' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStartSet, bDeathPointSet) == 0x00029A, "Member 'ALyraPlayerStartSet::bDeathPointSet' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStartSet, PlayerSceneTag) == 0x00029B, "Member 'ALyraPlayerStartSet::PlayerSceneTag' has a wrong offset!");

// Class LyraGame.AbilityTask_SnapToTarget
// 0x01D8 (0x02A0 - 0x00C8)
class alignas(0x10) UAbilityTask_SnapToTarget final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         RootMotionPriority;                                // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x00E0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               StartRotation;                                     // 0x00F8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0110(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x0128(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0140(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0148(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableDestinationReachedInterrupt;               // 0x014C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x014D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x014E(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x014F(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0xF0];                                     // 0x0150(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0240(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            LocationSnapLerpCurve;                             // 0x0248(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RotationSnapLerpCurve;                             // 0x0250(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetLerpSpeedHorizontalCurve;                    // 0x0258(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetLerpSpeedVerticalCurve;                      // 0x0260(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetRotationLerpSpeed;                           // 0x0268(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x34];                                     // 0x026C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_SnapToTarget* ApplySnapToTargetTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, class AActor* Param_TargetActor, float Param_Duration, class UCurveFloat* TargetLerpSpeedHorizontal, class UCurveFloat* TargetLerpSpeedVertical, float Param_TargetRotationLerpSpeed, bool Param_bSetNewMovementMode, EMovementMode MovementMode, int32 MoveFlags, bool Param_bRestrictSpeedToExpected, class UCurveFloat* LocationCurve, class UCurveFloat* RotationCurve, class UCurveFloat* Param_TimeMappingCurve, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool Param_bDisableDestinationReachedInterrupt);

	void OnRep_TargetLocation();
	void OnRep_TargetRotation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_SnapToTarget">();
	}
	static class UAbilityTask_SnapToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_SnapToTarget>();
	}
};
static_assert(alignof(UAbilityTask_SnapToTarget) == 0x000010, "Wrong alignment on UAbilityTask_SnapToTarget");
static_assert(sizeof(UAbilityTask_SnapToTarget) == 0x0002A0, "Wrong size on UAbilityTask_SnapToTarget");
static_assert(offsetof(UAbilityTask_SnapToTarget, OnFinished) == 0x0000C8, "Member 'UAbilityTask_SnapToTarget::OnFinished' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, RootMotionPriority) == 0x0000D8, "Member 'UAbilityTask_SnapToTarget::RootMotionPriority' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, StartLocation) == 0x0000E0, "Member 'UAbilityTask_SnapToTarget::StartLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, StartRotation) == 0x0000F8, "Member 'UAbilityTask_SnapToTarget::StartRotation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TargetLocation) == 0x000110, "Member 'UAbilityTask_SnapToTarget::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TargetRotation) == 0x000128, "Member 'UAbilityTask_SnapToTarget::TargetRotation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TargetActor) == 0x000140, "Member 'UAbilityTask_SnapToTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, Duration) == 0x000148, "Member 'UAbilityTask_SnapToTarget::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, bDisableDestinationReachedInterrupt) == 0x00014C, "Member 'UAbilityTask_SnapToTarget::bDisableDestinationReachedInterrupt' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, bSetNewMovementMode) == 0x00014D, "Member 'UAbilityTask_SnapToTarget::bSetNewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, NewMovementMode) == 0x00014E, "Member 'UAbilityTask_SnapToTarget::NewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, bRestrictSpeedToExpected) == 0x00014F, "Member 'UAbilityTask_SnapToTarget::bRestrictSpeedToExpected' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TimeMappingCurve) == 0x000240, "Member 'UAbilityTask_SnapToTarget::TimeMappingCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, LocationSnapLerpCurve) == 0x000248, "Member 'UAbilityTask_SnapToTarget::LocationSnapLerpCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, RotationSnapLerpCurve) == 0x000250, "Member 'UAbilityTask_SnapToTarget::RotationSnapLerpCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TargetLerpSpeedHorizontalCurve) == 0x000258, "Member 'UAbilityTask_SnapToTarget::TargetLerpSpeedHorizontalCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TargetLerpSpeedVerticalCurve) == 0x000260, "Member 'UAbilityTask_SnapToTarget::TargetLerpSpeedVerticalCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SnapToTarget, TargetRotationLerpSpeed) == 0x000268, "Member 'UAbilityTask_SnapToTarget::TargetRotationLerpSpeed' has a wrong offset!");

// Class LyraGame.TgfAbilityTask_ApplyConstantDynamicForce
// 0x0050 (0x0118 - 0x00C8)
class UTgfAbilityTask_ApplyConstantDynamicForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	int32                                         RootMotionPriority;                                // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldDirection;                                    // 0x00E0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x00FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepActorForwardDirection;                        // 0x0101(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0108(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGravity;                                    // 0x0110(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfAbilityTask_ApplyConstantDynamicForce* ApplyConstantDynamicForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, const struct FVector& Param_WorldDirection, float Param_Strength, float Param_Duration, bool Param_bKeepActorForwardDirection, bool Param_bIsAdditive, class UCurveFloat* Param_StrengthOverTime, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool Param_bEnableGravity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityTask_ApplyConstantDynamicForce">();
	}
	static class UTgfAbilityTask_ApplyConstantDynamicForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityTask_ApplyConstantDynamicForce>();
	}
};
static_assert(alignof(UTgfAbilityTask_ApplyConstantDynamicForce) == 0x000008, "Wrong alignment on UTgfAbilityTask_ApplyConstantDynamicForce");
static_assert(sizeof(UTgfAbilityTask_ApplyConstantDynamicForce) == 0x000118, "Wrong size on UTgfAbilityTask_ApplyConstantDynamicForce");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, OnFinish) == 0x0000C8, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::OnFinish' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, RootMotionPriority) == 0x0000D8, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::RootMotionPriority' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, WorldDirection) == 0x0000E0, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::WorldDirection' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, Strength) == 0x0000F8, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::Strength' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, Duration) == 0x0000FC, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::Duration' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, bIsAdditive) == 0x000100, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::bIsAdditive' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, bKeepActorForwardDirection) == 0x000101, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::bKeepActorForwardDirection' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, StrengthOverTime) == 0x000108, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_ApplyConstantDynamicForce, bEnableGravity) == 0x000110, "Member 'UTgfAbilityTask_ApplyConstantDynamicForce::bEnableGravity' has a wrong offset!");

// Class LyraGame.LyraSettingValueDiscrete_MobileFPSType
// 0x0018 (0x0180 - 0x0168)
class ULyraSettingValueDiscrete_MobileFPSType final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_MobileFPSType">();
	}
	static class ULyraSettingValueDiscrete_MobileFPSType* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_MobileFPSType>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_MobileFPSType) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_MobileFPSType");
static_assert(sizeof(ULyraSettingValueDiscrete_MobileFPSType) == 0x000180, "Wrong size on ULyraSettingValueDiscrete_MobileFPSType");

// Class LyraGame.TgfAbilityTask_TrackConstantForce
// 0x0080 (0x0148 - 0x00C8)
class UTgfAbilityTask_TrackConstantForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnForceStopDash;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	int32                                         RootMotionPriority;                                // 0x00E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x00EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x00F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x00F4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime;                                  // 0x00F8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGravity;                                    // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0108(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTgfDashTrackingSettings               TrackingSettings;                                  // 0x0110(0x0014)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TrackingTime;                                      // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StartRotation;                                     // 0x0130(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UTgfAbilityTask_TrackConstantForce* ApplyTrackConstantForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, class AActor* Param_TargetActor, float Param_Strength, float Param_Duration, const struct FTgfDashTrackingSettings& Param_TrackingSettings, bool Param_bIsAdditive, class UCurveFloat* Param_StrengthOverTime, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool Param_bEnableGravity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAbilityTask_TrackConstantForce">();
	}
	static class UTgfAbilityTask_TrackConstantForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAbilityTask_TrackConstantForce>();
	}
};
static_assert(alignof(UTgfAbilityTask_TrackConstantForce) == 0x000008, "Wrong alignment on UTgfAbilityTask_TrackConstantForce");
static_assert(sizeof(UTgfAbilityTask_TrackConstantForce) == 0x000148, "Wrong size on UTgfAbilityTask_TrackConstantForce");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, OnFinish) == 0x0000C8, "Member 'UTgfAbilityTask_TrackConstantForce::OnFinish' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, OnForceStopDash) == 0x0000D8, "Member 'UTgfAbilityTask_TrackConstantForce::OnForceStopDash' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, RootMotionPriority) == 0x0000E8, "Member 'UTgfAbilityTask_TrackConstantForce::RootMotionPriority' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, Strength) == 0x0000EC, "Member 'UTgfAbilityTask_TrackConstantForce::Strength' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, Duration) == 0x0000F0, "Member 'UTgfAbilityTask_TrackConstantForce::Duration' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, bIsAdditive) == 0x0000F4, "Member 'UTgfAbilityTask_TrackConstantForce::bIsAdditive' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, StrengthOverTime) == 0x0000F8, "Member 'UTgfAbilityTask_TrackConstantForce::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, bEnableGravity) == 0x000100, "Member 'UTgfAbilityTask_TrackConstantForce::bEnableGravity' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, TargetActor) == 0x000108, "Member 'UTgfAbilityTask_TrackConstantForce::TargetActor' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, TrackingSettings) == 0x000110, "Member 'UTgfAbilityTask_TrackConstantForce::TrackingSettings' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, TrackingTime) == 0x000124, "Member 'UTgfAbilityTask_TrackConstantForce::TrackingTime' has a wrong offset!");
static_assert(offsetof(UTgfAbilityTask_TrackConstantForce, StartRotation) == 0x000130, "Member 'UTgfAbilityTask_TrackConstantForce::StartRotation' has a wrong offset!");

// Class LyraGame.BTTask_RotateToFaceBBEntryEx
// 0x0028 (0x00C8 - 0x00A0)
class UBTTask_RotateToFaceBBEntryEx final : public UBTTask_RotateToFaceBBEntry
{
public:
	struct FBlackboardKeySelector                 PrecisionBlackboardKey;                            // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RotateToFaceBBEntryEx">();
	}
	static class UBTTask_RotateToFaceBBEntryEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RotateToFaceBBEntryEx>();
	}
};
static_assert(alignof(UBTTask_RotateToFaceBBEntryEx) == 0x000008, "Wrong alignment on UBTTask_RotateToFaceBBEntryEx");
static_assert(sizeof(UBTTask_RotateToFaceBBEntryEx) == 0x0000C8, "Wrong size on UBTTask_RotateToFaceBBEntryEx");
static_assert(offsetof(UBTTask_RotateToFaceBBEntryEx, PrecisionBlackboardKey) == 0x0000A0, "Member 'UBTTask_RotateToFaceBBEntryEx::PrecisionBlackboardKey' has a wrong offset!");

// Class LyraGame.LyraAnimInstance
// 0x00F0 (0x0440 - 0x0350)
class ULyraAnimInstance : public UAnimInstance
{
public:
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x0348(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GroundDistance;                                    // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x036C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultDeathTime;                                  // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0xCC];                                     // 0x0374(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetActiveTagAnimSetIndex(const TArray<struct FGameplayTag>& Tags);
	void GetCurrentWeaponVector(struct FVector* RightVec, struct FVector* UpVec, struct FVector* ForwardVec);
	bool GetFootLand(struct FFootLandHitInfo* Right, struct FFootLandHitInfo* Left, struct FVector* BipHeight, float MaxDis, bool bRelative, bool bDebug, float DebugRadius);
	struct FVector GetLeftHandSwordLocation(float Offset, float HandHelperRate, bool bDebug, float DebugRadius);
	struct FVector GetWeaponSocketLocation(class FName SocketName, TSubclassOf<class AActor> TemplateBase);
	struct FTransform GetWeaponSocketTransform(class FName SocketName, TSubclassOf<class AActor> TemplateBase);
	float Montage_GetModifyPlayRate(const class UAnimMontage* Montage, ELyraPlayRateModifyKey Key);
	void Montage_SetModifyPlayRate(const class UAnimMontage* Montage, ELyraPlayRateModifyKey Key, float ModifyRate);

	float GetBone2BoneZOffset(class FName First, class FName Second) const;
	float GetBoneComponentLocationZ(class FName BoneName) const;
	struct FTransform GetBoneTransform(class FName BoneName) const;
	float GetCurrentDeathAnimationLength() const;
	float GetDeathAnimationLength(EAnimConfigDirection DeathDirection) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAnimInstance">();
	}
	static class ULyraAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAnimInstance>();
	}
};
static_assert(alignof(ULyraAnimInstance) == 0x000010, "Wrong alignment on ULyraAnimInstance");
static_assert(sizeof(ULyraAnimInstance) == 0x000440, "Wrong size on ULyraAnimInstance");
static_assert(offsetof(ULyraAnimInstance, GameplayTagPropertyMap) == 0x000348, "Member 'ULyraAnimInstance::GameplayTagPropertyMap' has a wrong offset!");
static_assert(offsetof(ULyraAnimInstance, GroundDistance) == 0x000368, "Member 'ULyraAnimInstance::GroundDistance' has a wrong offset!");
static_assert(offsetof(ULyraAnimInstance, bIsJumping) == 0x00036C, "Member 'ULyraAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(ULyraAnimInstance, DefaultDeathTime) == 0x000370, "Member 'ULyraAnimInstance::DefaultDeathTime' has a wrong offset!");

// Class LyraGame.LyraAudioMixEffectsSubsystem
// 0x0068 (0x0098 - 0x0030)
class ULyraAudioMixEffectsSubsystem final : public UWorldSubsystem
{
public:
	class USoundControlBusMix*                    DefaultBaseMix;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBusMix*                    LoadingScreenMix;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBusMix*                    UserMix;                                           // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       OverallControlBus;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       MusicControlBus;                                   // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       SoundFXControlBus;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       DialogueControlBus;                                // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       VoiceChatControlBus;                               // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLyraAudioSubmixEffectsChain>   HDRSubmixEffectChain;                              // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAudioSubmixEffectsChain>   LDRSubmixEffectChain;                              // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAudioMixEffectsSubsystem">();
	}
	static class ULyraAudioMixEffectsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAudioMixEffectsSubsystem>();
	}
};
static_assert(alignof(ULyraAudioMixEffectsSubsystem) == 0x000008, "Wrong alignment on ULyraAudioMixEffectsSubsystem");
static_assert(sizeof(ULyraAudioMixEffectsSubsystem) == 0x000098, "Wrong size on ULyraAudioMixEffectsSubsystem");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, DefaultBaseMix) == 0x000030, "Member 'ULyraAudioMixEffectsSubsystem::DefaultBaseMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, LoadingScreenMix) == 0x000038, "Member 'ULyraAudioMixEffectsSubsystem::LoadingScreenMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, UserMix) == 0x000040, "Member 'ULyraAudioMixEffectsSubsystem::UserMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, OverallControlBus) == 0x000048, "Member 'ULyraAudioMixEffectsSubsystem::OverallControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, MusicControlBus) == 0x000050, "Member 'ULyraAudioMixEffectsSubsystem::MusicControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, SoundFXControlBus) == 0x000058, "Member 'ULyraAudioMixEffectsSubsystem::SoundFXControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, DialogueControlBus) == 0x000060, "Member 'ULyraAudioMixEffectsSubsystem::DialogueControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, VoiceChatControlBus) == 0x000068, "Member 'ULyraAudioMixEffectsSubsystem::VoiceChatControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, HDRSubmixEffectChain) == 0x000070, "Member 'ULyraAudioMixEffectsSubsystem::HDRSubmixEffectChain' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, LDRSubmixEffectChain) == 0x000080, "Member 'ULyraAudioMixEffectsSubsystem::LDRSubmixEffectChain' has a wrong offset!");

// Class LyraGame.LyraSettingValueDiscreteDynamic_AudioOutputDevice
// 0x0058 (0x0228 - 0x01D0)
class ULyraSettingValueDiscreteDynamic_AudioOutputDevice final : public UGameSettingValueDiscreteDynamic
{
public:
	uint8                                         Pad_1D0[0x58];                                     // 0x01D0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DefaultDeviceChanged(EAudioDeviceChangedRole InRole, const class FString& DeviceID);
	void DeviceAddedOrRemoved(const class FString& DeviceID);
	void OnAudioOutputDevicesObtained(const TArray<struct FAudioOutputDeviceInfo>& AvailableDevices);
	void OnCompletedDeviceSwap(const struct FSwapAudioOutputResult& SwapResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscreteDynamic_AudioOutputDevice">();
	}
	static class ULyraSettingValueDiscreteDynamic_AudioOutputDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscreteDynamic_AudioOutputDevice>();
	}
};
static_assert(alignof(ULyraSettingValueDiscreteDynamic_AudioOutputDevice) == 0x000008, "Wrong alignment on ULyraSettingValueDiscreteDynamic_AudioOutputDevice");
static_assert(sizeof(ULyraSettingValueDiscreteDynamic_AudioOutputDevice) == 0x000228, "Wrong size on ULyraSettingValueDiscreteDynamic_AudioOutputDevice");

// Class LyraGame.LyraAudioSettings
// 0x0120 (0x0158 - 0x0038)
class ULyraAudioSettings final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        DefaultControlBusMix;                              // 0x0038(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LoadingScreenControlBusMix;                        // 0x0058(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UserSettingsControlBusMix;                         // 0x0078(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OverallVolumeControlBus;                           // 0x0098(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicVolumeControlBus;                             // 0x00B8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoundFXVolumeControlBus;                           // 0x00D8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DialogueVolumeControlBus;                          // 0x00F8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VoiceChatVolumeControlBus;                         // 0x0118(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraSubmixEffectChainMap>      HDRAudioSubmixEffectChain;                         // 0x0138(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLyraSubmixEffectChainMap>      LDRAudioSubmixEffectChain;                         // 0x0148(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAudioSettings">();
	}
	static class ULyraAudioSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAudioSettings>();
	}
};
static_assert(alignof(ULyraAudioSettings) == 0x000008, "Wrong alignment on ULyraAudioSettings");
static_assert(sizeof(ULyraAudioSettings) == 0x000158, "Wrong size on ULyraAudioSettings");
static_assert(offsetof(ULyraAudioSettings, DefaultControlBusMix) == 0x000038, "Member 'ULyraAudioSettings::DefaultControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, LoadingScreenControlBusMix) == 0x000058, "Member 'ULyraAudioSettings::LoadingScreenControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, UserSettingsControlBusMix) == 0x000078, "Member 'ULyraAudioSettings::UserSettingsControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, OverallVolumeControlBus) == 0x000098, "Member 'ULyraAudioSettings::OverallVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, MusicVolumeControlBus) == 0x0000B8, "Member 'ULyraAudioSettings::MusicVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, SoundFXVolumeControlBus) == 0x0000D8, "Member 'ULyraAudioSettings::SoundFXVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, DialogueVolumeControlBus) == 0x0000F8, "Member 'ULyraAudioSettings::DialogueVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, VoiceChatVolumeControlBus) == 0x000118, "Member 'ULyraAudioSettings::VoiceChatVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, HDRAudioSubmixEffectChain) == 0x000138, "Member 'ULyraAudioSettings::HDRAudioSubmixEffectChain' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, LDRAudioSubmixEffectChain) == 0x000148, "Member 'ULyraAudioSettings::LDRAudioSubmixEffectChain' has a wrong offset!");

// Class LyraGame.LyraBrightnessEditor
// 0x0050 (0x0438 - 0x03E8)
class ULyraBrightnessEditor final : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_3E8[0x20];                                     // 0x03E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanCancel;                                        // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0xF];                                      // 0x0409(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        Switcher_SafeZoneMessage;                          // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonRichTextBlock*                   RichText_Default;                                  // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Back;                                       // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Done;                                       // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBackClicked();
	void HandleDoneClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraBrightnessEditor">();
	}
	static class ULyraBrightnessEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraBrightnessEditor>();
	}
};
static_assert(alignof(ULyraBrightnessEditor) == 0x000008, "Wrong alignment on ULyraBrightnessEditor");
static_assert(sizeof(ULyraBrightnessEditor) == 0x000438, "Wrong size on ULyraBrightnessEditor");
static_assert(offsetof(ULyraBrightnessEditor, bCanCancel) == 0x000408, "Member 'ULyraBrightnessEditor::bCanCancel' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, Switcher_SafeZoneMessage) == 0x000418, "Member 'ULyraBrightnessEditor::Switcher_SafeZoneMessage' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, RichText_Default) == 0x000420, "Member 'ULyraBrightnessEditor::RichText_Default' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, Button_Back) == 0x000428, "Member 'ULyraBrightnessEditor::Button_Back' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, Button_Done) == 0x000430, "Member 'ULyraBrightnessEditor::Button_Done' has a wrong offset!");

// Class LyraGame.LyraCameraComponent
// 0x07F0 (0x1220 - 0x0A30)
class ULyraCameraComponent final : public UCameraComponent
{
public:
	uint8                                         Pad_A30[0x10];                                     // 0x0A30(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraCameraModeStack*                   CameraModeStack;                                   // 0x0A40(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A48[0x4];                                      // 0x0A48(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AspectRationThreshold;                             // 0x0A4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A50[0x7D0];                                    // 0x0A50(0x07D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULyraCameraComponent* FindCameraComponent(const class AActor* Actor);

	void ChangeAspectRatio(uint32 ResX, uint32 ResY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraComponent">();
	}
	static class ULyraCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraComponent>();
	}
};
static_assert(alignof(ULyraCameraComponent) == 0x000010, "Wrong alignment on ULyraCameraComponent");
static_assert(sizeof(ULyraCameraComponent) == 0x001220, "Wrong size on ULyraCameraComponent");
static_assert(offsetof(ULyraCameraComponent, CameraModeStack) == 0x000A40, "Member 'ULyraCameraComponent::CameraModeStack' has a wrong offset!");
static_assert(offsetof(ULyraCameraComponent, AspectRationThreshold) == 0x000A4C, "Member 'ULyraCameraComponent::AspectRationThreshold' has a wrong offset!");

// Class LyraGame.LyraCameraModeStack
// 0x0028 (0x0050 - 0x0028)
class ULyraCameraModeStack final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULyraCameraMode*>                CameraModeInstances;                               // 0x0030(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ULyraCameraMode*>                CameraModeStack;                                   // 0x0040(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCameraModeStack">();
	}
	static class ULyraCameraModeStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCameraModeStack>();
	}
};
static_assert(alignof(ULyraCameraModeStack) == 0x000008, "Wrong alignment on ULyraCameraModeStack");
static_assert(sizeof(ULyraCameraModeStack) == 0x000050, "Wrong size on ULyraCameraModeStack");
static_assert(offsetof(ULyraCameraModeStack, CameraModeInstances) == 0x000030, "Member 'ULyraCameraModeStack::CameraModeInstances' has a wrong offset!");
static_assert(offsetof(ULyraCameraModeStack, CameraModeStack) == 0x000040, "Member 'ULyraCameraModeStack::CameraModeStack' has a wrong offset!");

// Class LyraGame.LyraPlayerCameraManager
// 0x0190 (0x34E0 - 0x3350)
class ALyraPlayerCameraManager : public APlayerCameraManager
{
public:
	bool                                          bNeedRotateFPPMesh;                                // 0x3350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3351[0x7];                                     // 0x3351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FppBlockTagContainer;                              // 0x3358(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CameraOffsetCurve;                                 // 0x3378(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FTransform                             FPPMeshOffset;                                     // 0x3400(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FPPMeshOffsetByFovCurve;                           // 0x3460(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMeshAmend;                                    // 0x3468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraOffsetMax;                                   // 0x346C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchMultiplier;                                  // 0x3470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3474[0x4];                                     // 0x3474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTgfCameraShake_Moving>     TgfMovingCameraShake;                              // 0x3478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTgfCameraShake_Moving*                 TgfMovingCameraShakeIns;                           // 0x3480(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3488[0x50];                                    // 0x3488(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraUICameraManagerComponent*          UICamera;                                          // 0x34D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerCameraManager">();
	}
	static class ALyraPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerCameraManager>();
	}
};
static_assert(alignof(ALyraPlayerCameraManager) == 0x000010, "Wrong alignment on ALyraPlayerCameraManager");
static_assert(sizeof(ALyraPlayerCameraManager) == 0x0034E0, "Wrong size on ALyraPlayerCameraManager");
static_assert(offsetof(ALyraPlayerCameraManager, bNeedRotateFPPMesh) == 0x003350, "Member 'ALyraPlayerCameraManager::bNeedRotateFPPMesh' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, FppBlockTagContainer) == 0x003358, "Member 'ALyraPlayerCameraManager::FppBlockTagContainer' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, CameraOffsetCurve) == 0x003378, "Member 'ALyraPlayerCameraManager::CameraOffsetCurve' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, FPPMeshOffset) == 0x003400, "Member 'ALyraPlayerCameraManager::FPPMeshOffset' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, FPPMeshOffsetByFovCurve) == 0x003460, "Member 'ALyraPlayerCameraManager::FPPMeshOffsetByFovCurve' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, PitchMeshAmend) == 0x003468, "Member 'ALyraPlayerCameraManager::PitchMeshAmend' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, CameraOffsetMax) == 0x00346C, "Member 'ALyraPlayerCameraManager::CameraOffsetMax' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, CrouchMultiplier) == 0x003470, "Member 'ALyraPlayerCameraManager::CrouchMultiplier' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, TgfMovingCameraShake) == 0x003478, "Member 'ALyraPlayerCameraManager::TgfMovingCameraShake' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, TgfMovingCameraShakeIns) == 0x003480, "Member 'ALyraPlayerCameraManager::TgfMovingCameraShakeIns' has a wrong offset!");
static_assert(offsetof(ALyraPlayerCameraManager, UICamera) == 0x0034D8, "Member 'ALyraPlayerCameraManager::UICamera' has a wrong offset!");

// Class LyraGame.LyraReplaySubsystem
// 0x0020 (0x0050 - 0x0030)
class ULyraReplaySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayer*                           LocalPlayerDeletingReplays;                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool DoesPlatformSupportReplays();

	void CleanupLocalReplays(class ULocalPlayer* LocalPlayer, int32 NumReplaysToKeep);
	void PlayReplay(class ULyraReplayListEntry* Replay);
	void RecordClientReplay(class APlayerController* PlayerController);
	void RecordReplay(bool IsClient, int32 Param_Index);
	void SeekInActiveReplay(float TimeInSeconds);

	float GetReplayCurrentTime() const;
	float GetReplayLengthInSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraReplaySubsystem">();
	}
	static class ULyraReplaySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraReplaySubsystem>();
	}
};
static_assert(alignof(ULyraReplaySubsystem) == 0x000008, "Wrong alignment on ULyraReplaySubsystem");
static_assert(sizeof(ULyraReplaySubsystem) == 0x000050, "Wrong size on ULyraReplaySubsystem");
static_assert(offsetof(ULyraReplaySubsystem, LocalPlayerDeletingReplays) == 0x000040, "Member 'ULyraReplaySubsystem::LocalPlayerDeletingReplays' has a wrong offset!");

// Class LyraGame.LyraUICameraManagerComponent
// 0x0010 (0x00B8 - 0x00A8)
class ULyraUICameraManagerComponent final : public UActorComponent
{
public:
	class AActor*                                 ViewTarget;                                        // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdatingViewTarget;                               // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUICameraManagerComponent">();
	}
	static class ULyraUICameraManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUICameraManagerComponent>();
	}
};
static_assert(alignof(ULyraUICameraManagerComponent) == 0x000008, "Wrong alignment on ULyraUICameraManagerComponent");
static_assert(sizeof(ULyraUICameraManagerComponent) == 0x0000B8, "Wrong size on ULyraUICameraManagerComponent");
static_assert(offsetof(ULyraUICameraManagerComponent, ViewTarget) == 0x0000A8, "Member 'ULyraUICameraManagerComponent::ViewTarget' has a wrong offset!");
static_assert(offsetof(ULyraUICameraManagerComponent, bUpdatingViewTarget) == 0x0000B0, "Member 'ULyraUICameraManagerComponent::bUpdatingViewTarget' has a wrong offset!");

// Class LyraGame.LyraCharacterMovementComponent
// 0x04C0 (0x13D0 - 0x0F10)
class ULyraCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	class UPrimitiveComponent*                    LastBlockedComponent;                              // 0x0F08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PenetrationOverlapCheckInflation;                  // 0x0F10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F14[0x24];                                     // 0x0F14(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PantherCollisionRadius;                            // 0x0F38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PantherPerchRadius;                                // 0x0F3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F40[0x30];                                     // 0x0F40(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LooseCheckMaxPositionErrorSquared;                 // 0x0F70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F74[0xFC];                                     // 0x0F74(0x00FC)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x1070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasReplicatedAcceleration;                        // 0x1078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceJumpInitSpeed;                               // 0x1079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_107A[0x2];                                     // 0x107A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedJumpZVelocity;                               // 0x107C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CachedActorRotator;                                // 0x1080(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CachedMeshRelativeRotator;                         // 0x1098(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CachedMeshRotator;                                 // 0x10B0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableSimulateTurn;                               // 0x10C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLinearBlending;                                   // 0x10C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10CA[0x2];                                     // 0x10CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearBlendingTime;                                // 0x10CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnAnimAngle;                                     // 0x10D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stiffness;                                         // 0x10D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LerpSpeed;                                         // 0x10D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaTurnAngle;                                    // 0x10DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatSpringState                      SpringStateCache;                                  // 0x10E0(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBlendingUtilParamsCache               CachedParams;                                      // 0x10EC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F8[0x2D8];                                   // 0x10F8(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlendToTargetTurnAngle();
	void EndPantherState(bool bClientSimulation);
	const struct FLyraCharacterGroundInfo GetGroundInfo();
	void InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC);
	void PreventTurnAngle();
	void ResetSimulateTurnToDefault();
	void SetCanWalkOffLedges(bool bEnabled);
	void SetUseLooseServerDistCheck(bool bEnable);
	void StartPantherState(bool bClientSimulation);
	void ToggleSimulateTurn(bool bEnable);
	void UninitializeFromAbilitySystem();

	bool IsJumping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCharacterMovementComponent">();
	}
	static class ULyraCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCharacterMovementComponent>();
	}
};
static_assert(alignof(ULyraCharacterMovementComponent) == 0x000010, "Wrong alignment on ULyraCharacterMovementComponent");
static_assert(sizeof(ULyraCharacterMovementComponent) == 0x0013D0, "Wrong size on ULyraCharacterMovementComponent");
static_assert(offsetof(ULyraCharacterMovementComponent, LastBlockedComponent) == 0x000F08, "Member 'ULyraCharacterMovementComponent::LastBlockedComponent' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, PenetrationOverlapCheckInflation) == 0x000F10, "Member 'ULyraCharacterMovementComponent::PenetrationOverlapCheckInflation' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, PantherCollisionRadius) == 0x000F38, "Member 'ULyraCharacterMovementComponent::PantherCollisionRadius' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, PantherPerchRadius) == 0x000F3C, "Member 'ULyraCharacterMovementComponent::PantherPerchRadius' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, LooseCheckMaxPositionErrorSquared) == 0x000F70, "Member 'ULyraCharacterMovementComponent::LooseCheckMaxPositionErrorSquared' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, AbilitySystemComponent) == 0x001070, "Member 'ULyraCharacterMovementComponent::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, bHasReplicatedAcceleration) == 0x001078, "Member 'ULyraCharacterMovementComponent::bHasReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, bForceJumpInitSpeed) == 0x001079, "Member 'ULyraCharacterMovementComponent::bForceJumpInitSpeed' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, CachedJumpZVelocity) == 0x00107C, "Member 'ULyraCharacterMovementComponent::CachedJumpZVelocity' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, CachedActorRotator) == 0x001080, "Member 'ULyraCharacterMovementComponent::CachedActorRotator' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, CachedMeshRelativeRotator) == 0x001098, "Member 'ULyraCharacterMovementComponent::CachedMeshRelativeRotator' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, CachedMeshRotator) == 0x0010B0, "Member 'ULyraCharacterMovementComponent::CachedMeshRotator' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, bEnableSimulateTurn) == 0x0010C8, "Member 'ULyraCharacterMovementComponent::bEnableSimulateTurn' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, bLinearBlending) == 0x0010C9, "Member 'ULyraCharacterMovementComponent::bLinearBlending' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, LinearBlendingTime) == 0x0010CC, "Member 'ULyraCharacterMovementComponent::LinearBlendingTime' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, TurnAnimAngle) == 0x0010D0, "Member 'ULyraCharacterMovementComponent::TurnAnimAngle' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, Stiffness) == 0x0010D4, "Member 'ULyraCharacterMovementComponent::Stiffness' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, LerpSpeed) == 0x0010D8, "Member 'ULyraCharacterMovementComponent::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, DeltaTurnAngle) == 0x0010DC, "Member 'ULyraCharacterMovementComponent::DeltaTurnAngle' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, SpringStateCache) == 0x0010E0, "Member 'ULyraCharacterMovementComponent::SpringStateCache' has a wrong offset!");
static_assert(offsetof(ULyraCharacterMovementComponent, CachedParams) == 0x0010EC, "Member 'ULyraCharacterMovementComponent::CachedParams' has a wrong offset!");

// Class LyraGame.LyraHealthComponent
// 0x0058 (0x0100 - 0x00A8)
class ULyraHealthComponent final : public UGameFrameworkComponent
{
public:
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMaxHealthChanged;                                // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeathStarted;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeathFinished;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraHealthSet*                         HealthSet;                                         // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELyraDeathState                               DeathState;                                        // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULyraHealthComponent* FindHealthComponent(const class AActor* Actor);

	void InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC);
	void OnRep_DeathState(ELyraDeathState OldDeathState);
	void UninitializeFromAbilitySystem();

	ELyraDeathState GetDeathState() const;
	float GetHealth() const;
	float GetHealthNormalized() const;
	float GetMaxHealth() const;
	bool IsDeadOrDying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHealthComponent">();
	}
	static class ULyraHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHealthComponent>();
	}
};
static_assert(alignof(ULyraHealthComponent) == 0x000008, "Wrong alignment on ULyraHealthComponent");
static_assert(sizeof(ULyraHealthComponent) == 0x000100, "Wrong size on ULyraHealthComponent");
static_assert(offsetof(ULyraHealthComponent, OnHealthChanged) == 0x0000A8, "Member 'ULyraHealthComponent::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(ULyraHealthComponent, OnMaxHealthChanged) == 0x0000B8, "Member 'ULyraHealthComponent::OnMaxHealthChanged' has a wrong offset!");
static_assert(offsetof(ULyraHealthComponent, OnDeathStarted) == 0x0000C8, "Member 'ULyraHealthComponent::OnDeathStarted' has a wrong offset!");
static_assert(offsetof(ULyraHealthComponent, OnDeathFinished) == 0x0000D8, "Member 'ULyraHealthComponent::OnDeathFinished' has a wrong offset!");
static_assert(offsetof(ULyraHealthComponent, AbilitySystemComponent) == 0x0000E8, "Member 'ULyraHealthComponent::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ULyraHealthComponent, HealthSet) == 0x0000F0, "Member 'ULyraHealthComponent::HealthSet' has a wrong offset!");
static_assert(offsetof(ULyraHealthComponent, DeathState) == 0x0000F8, "Member 'ULyraHealthComponent::DeathState' has a wrong offset!");

// Class LyraGame.LyraPawn
// 0x0020 (0x0340 - 0x0320)
class ALyraPawn final : public AModularPawn
{
public:
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         MyTeamID;                                          // 0x0328(0x0001)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x0330(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);
	void OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPawn">();
	}
	static class ALyraPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPawn>();
	}
};
static_assert(alignof(ALyraPawn) == 0x000008, "Wrong alignment on ALyraPawn");
static_assert(sizeof(ALyraPawn) == 0x000340, "Wrong size on ALyraPawn");
static_assert(offsetof(ALyraPawn, MyTeamID) == 0x000328, "Member 'ALyraPawn::MyTeamID' has a wrong offset!");
static_assert(offsetof(ALyraPawn, OnTeamChangedDelegate) == 0x000330, "Member 'ALyraPawn::OnTeamChangedDelegate' has a wrong offset!");

// Class LyraGame.LyraPawnExtensionComponent
// 0x0068 (0x0110 - 0x00A8)
class ULyraPawnExtensionComponent final : public UPawnComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             InGameAppearanceCaptureEvent;                      // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x30];                                      // 0x00C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraPawnData*                          PawnData;                                          // 0x00F8(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULyraPawnExtensionComponent* FindPawnExtensionComponent(const class AActor* Actor);

	void HandleAppearanceCaptureEvent(int64 RoleID, class UObject* SlateBrush);
	void HandleSettingScreenDestruct(class UObject* Args);
	void OnRep_PawnData();

	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPawnExtensionComponent">();
	}
	static class ULyraPawnExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPawnExtensionComponent>();
	}
};
static_assert(alignof(ULyraPawnExtensionComponent) == 0x000008, "Wrong alignment on ULyraPawnExtensionComponent");
static_assert(sizeof(ULyraPawnExtensionComponent) == 0x000110, "Wrong size on ULyraPawnExtensionComponent");
static_assert(offsetof(ULyraPawnExtensionComponent, InGameAppearanceCaptureEvent) == 0x0000B8, "Member 'ULyraPawnExtensionComponent::InGameAppearanceCaptureEvent' has a wrong offset!");
static_assert(offsetof(ULyraPawnExtensionComponent, PawnData) == 0x0000F8, "Member 'ULyraPawnExtensionComponent::PawnData' has a wrong offset!");
static_assert(offsetof(ULyraPawnExtensionComponent, AbilitySystemComponent) == 0x000100, "Member 'ULyraPawnExtensionComponent::AbilitySystemComponent' has a wrong offset!");

// Class LyraGame.TgfBattleSecurityComponent
// 0x00B0 (0x0158 - 0x00A8)
class UTgfBattleSecurityComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A8[0xB0];                                      // 0x00A8(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckActiveEffectBlocking(const class UTgfGameplayEffect* GameplayEffect, class ALyraCharacter* Target);
	bool CheckActiveSkillBlocking(const class ULyraGameplayAbility* GameplayAbility);
	void InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC);
	void UpdateActiveEffectCD(class UTgfGameplayEffect* GameplayEffect, class ALyraCharacter* Target);
	void UpdateActiveSkillCD(class ULyraGameplayAbility* GameplayAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfBattleSecurityComponent">();
	}
	static class UTgfBattleSecurityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfBattleSecurityComponent>();
	}
};
static_assert(alignof(UTgfBattleSecurityComponent) == 0x000008, "Wrong alignment on UTgfBattleSecurityComponent");
static_assert(sizeof(UTgfBattleSecurityComponent) == 0x000158, "Wrong size on UTgfBattleSecurityComponent");

// Class LyraGame.LyraCosmeticCheats
// 0x0000 (0x0028 - 0x0028)
class ULyraCosmeticCheats final : public UCheatManagerExtension
{
public:
	void AddCharacterPart(const class FString& AssetName, bool bSuppressNaturalParts);
	void AddCosmeticSplitPart(const class FString& AssetName);
	void ClearCharacterPartOverrides();
	void RemoveCosmeticSplitPart(const class FString& AssetName);
	void ReplaceCharacterPart(const class FString& AssetName, bool bSuppressNaturalParts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCosmeticCheats">();
	}
	static class ULyraCosmeticCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCosmeticCheats>();
	}
};
static_assert(alignof(ULyraCosmeticCheats) == 0x000008, "Wrong alignment on ULyraCosmeticCheats");
static_assert(sizeof(ULyraCosmeticCheats) == 0x000028, "Wrong size on ULyraCosmeticCheats");

// Class LyraGame.LyraCosmeticDeveloperSettings
// 0x0018 (0x0050 - 0x0038)
class ULyraCosmeticDeveloperSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	TArray<struct FLyraCharacterPart>             CheatCosmeticCharacterParts;                       // 0x0038(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	ECosmeticCheatMode                            CheatMode;                                         // 0x0048(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCosmeticDeveloperSettings">();
	}
	static class ULyraCosmeticDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCosmeticDeveloperSettings>();
	}
};
static_assert(alignof(ULyraCosmeticDeveloperSettings) == 0x000008, "Wrong alignment on ULyraCosmeticDeveloperSettings");
static_assert(sizeof(ULyraCosmeticDeveloperSettings) == 0x000050, "Wrong size on ULyraCosmeticDeveloperSettings");
static_assert(offsetof(ULyraCosmeticDeveloperSettings, CheatCosmeticCharacterParts) == 0x000038, "Member 'ULyraCosmeticDeveloperSettings::CheatCosmeticCharacterParts' has a wrong offset!");
static_assert(offsetof(ULyraCosmeticDeveloperSettings, CheatMode) == 0x000048, "Member 'ULyraCosmeticDeveloperSettings::CheatMode' has a wrong offset!");

// Class LyraGame.LyraPawnComponent_CharacterParts
// 0x0300 (0x03A8 - 0x00A8)
class ULyraPawnComponent_CharacterParts : public UPawnComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCharacterPartsChanged;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterPartsInitialized;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLyraCharacterPartList                 CharacterPartList;                                 // 0x00C8(0x0128)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FLyraCharacterPartList                 SuppressedPartList;                                // 0x01F0(0x0128)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x50];                                     // 0x0318(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLyraAnimBodyStyleSelectionSet         BodyMeshes;                                        // 0x0368(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FLyraAnimLayerSelectionSet             AnimLayers;                                        // 0x0388(0x0018)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLyraCharacterPartHandle AddCharacterPart(const struct FLyraCharacterPart& NewPart);
	void AddCharacterPartViaPart(const struct FLyraCharacterPart& NewPart);
	void ForceUseThirdPersonMesh(const struct FLyraCharacterPartHandle& Handle, bool bThirdPerson);
	class AActor* GetValidFirstCharacterPartActor();
	void InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC);
	void LinkDefaultAnimLayers();
	void OnPawnForceUseThirdPersonMesh(bool bThirdPerson);
	void RemoveAllCharacterParts();
	void RemoveCharacterPart(const struct FLyraCharacterPartHandle& Handle);
	bool RemoveCharacterPartMesh(ETgfCharaPart PartTypeToRemove);
	bool RemoveCharacterPartMeshForActorSpawn(ETgfCharaPart PartTypeToRemove);
	void RemoveCharacterPartViaPart(const struct FLyraCharacterPart& NewPart);
	void ToggleCharacterPartMeshVisible(const struct FLyraCharacterPartHandle& Handle, bool Visible);
	bool UpdateCharacterAllPartMesh(const struct FTgfCharaPartChangeConfig& NewPart);
	bool UpdateCharacterAllPartMeshForActorSpawn(const struct FTgfCharaPartSpawnActor& SpawnActorInfo);
	bool UpdateCharacterPart(const struct FLyraCharacterPartHandle& Handle, const struct FTgfCharaPartChangeConfig& NewPart);

	TArray<class AActor*> GetCharacterPartActors() const;
	struct FGameplayTagContainer GetCombinedTags(const struct FGameplayTag& RequiredPrefix) const;
	struct FGameplayTagContainer GetCombinedTagsRealTime(const struct FGameplayTag& RequiredPrefix) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPawnComponent_CharacterParts">();
	}
	static class ULyraPawnComponent_CharacterParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPawnComponent_CharacterParts>();
	}
};
static_assert(alignof(ULyraPawnComponent_CharacterParts) == 0x000008, "Wrong alignment on ULyraPawnComponent_CharacterParts");
static_assert(sizeof(ULyraPawnComponent_CharacterParts) == 0x0003A8, "Wrong size on ULyraPawnComponent_CharacterParts");
static_assert(offsetof(ULyraPawnComponent_CharacterParts, OnCharacterPartsChanged) == 0x0000A8, "Member 'ULyraPawnComponent_CharacterParts::OnCharacterPartsChanged' has a wrong offset!");
static_assert(offsetof(ULyraPawnComponent_CharacterParts, OnCharacterPartsInitialized) == 0x0000B8, "Member 'ULyraPawnComponent_CharacterParts::OnCharacterPartsInitialized' has a wrong offset!");
static_assert(offsetof(ULyraPawnComponent_CharacterParts, CharacterPartList) == 0x0000C8, "Member 'ULyraPawnComponent_CharacterParts::CharacterPartList' has a wrong offset!");
static_assert(offsetof(ULyraPawnComponent_CharacterParts, SuppressedPartList) == 0x0001F0, "Member 'ULyraPawnComponent_CharacterParts::SuppressedPartList' has a wrong offset!");
static_assert(offsetof(ULyraPawnComponent_CharacterParts, BodyMeshes) == 0x000368, "Member 'ULyraPawnComponent_CharacterParts::BodyMeshes' has a wrong offset!");
static_assert(offsetof(ULyraPawnComponent_CharacterParts, AnimLayers) == 0x000388, "Member 'ULyraPawnComponent_CharacterParts::AnimLayers' has a wrong offset!");

// Class LyraGame.LyraBotCheats
// 0x0000 (0x0028 - 0x0028)
class ULyraBotCheats final : public UCheatManagerExtension
{
public:
	void AddAIPlayers(int32 AddCnt);
	void RemoveAIPlayers(int32 RemoveCnt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraBotCheats">();
	}
	static class ULyraBotCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraBotCheats>();
	}
};
static_assert(alignof(ULyraBotCheats) == 0x000008, "Wrong alignment on ULyraBotCheats");
static_assert(sizeof(ULyraBotCheats) == 0x000028, "Wrong size on ULyraBotCheats");

// Class LyraGame.LyraDeveloperSettings
// 0x0038 (0x0070 - 0x0038)
class ULyraDeveloperSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	struct FPrimaryAssetId                        ExperienceOverride;                                // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBotCount;                                 // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideNumPlayerBotsToSpawn;                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPlayerBotsToAttack;                          // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestFullGameFlowInPIE;                            // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAlwaysPlayForceFeedback;                    // 0x0052(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipLoadingCosmeticBackgroundsInPIE;              // 0x0053(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLyraCheatToRun>                CheatsToRun;                                       // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          LogGameplayMessages;                               // 0x0068(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDeveloperSettings">();
	}
	static class ULyraDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraDeveloperSettings>();
	}
};
static_assert(alignof(ULyraDeveloperSettings) == 0x000008, "Wrong alignment on ULyraDeveloperSettings");
static_assert(sizeof(ULyraDeveloperSettings) == 0x000070, "Wrong size on ULyraDeveloperSettings");
static_assert(offsetof(ULyraDeveloperSettings, ExperienceOverride) == 0x000038, "Member 'ULyraDeveloperSettings::ExperienceOverride' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, bOverrideBotCount) == 0x000048, "Member 'ULyraDeveloperSettings::bOverrideBotCount' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, OverrideNumPlayerBotsToSpawn) == 0x00004C, "Member 'ULyraDeveloperSettings::OverrideNumPlayerBotsToSpawn' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, bAllowPlayerBotsToAttack) == 0x000050, "Member 'ULyraDeveloperSettings::bAllowPlayerBotsToAttack' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, bTestFullGameFlowInPIE) == 0x000051, "Member 'ULyraDeveloperSettings::bTestFullGameFlowInPIE' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, bShouldAlwaysPlayForceFeedback) == 0x000052, "Member 'ULyraDeveloperSettings::bShouldAlwaysPlayForceFeedback' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, bSkipLoadingCosmeticBackgroundsInPIE) == 0x000053, "Member 'ULyraDeveloperSettings::bSkipLoadingCosmeticBackgroundsInPIE' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, CheatsToRun) == 0x000058, "Member 'ULyraDeveloperSettings::CheatsToRun' has a wrong offset!");
static_assert(offsetof(ULyraDeveloperSettings, LogGameplayMessages) == 0x000068, "Member 'ULyraDeveloperSettings::LogGameplayMessages' has a wrong offset!");

// Class LyraGame.LyraWeaponPickupDefinition
// 0x0030 (0x0098 - 0x0068)
class ULyraWeaponPickupDefinition final : public ULyraPickupDefinition
{
public:
	struct FVector                                WeaponMeshOffset;                                  // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponMeshScale;                                   // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponPickupDefinition">();
	}
	static class ULyraWeaponPickupDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWeaponPickupDefinition>();
	}
};
static_assert(alignof(ULyraWeaponPickupDefinition) == 0x000008, "Wrong alignment on ULyraWeaponPickupDefinition");
static_assert(sizeof(ULyraWeaponPickupDefinition) == 0x000098, "Wrong size on ULyraWeaponPickupDefinition");
static_assert(offsetof(ULyraWeaponPickupDefinition, WeaponMeshOffset) == 0x000068, "Member 'ULyraWeaponPickupDefinition::WeaponMeshOffset' has a wrong offset!");
static_assert(offsetof(ULyraWeaponPickupDefinition, WeaponMeshScale) == 0x000080, "Member 'ULyraWeaponPickupDefinition::WeaponMeshScale' has a wrong offset!");

// Class LyraGame.TgfGameplayAbility_FromEquipment
// 0x0000 (0x0980 - 0x0980)
class UTgfGameplayAbility_FromEquipment : public UTgfGameplayAbility
{
public:
	class ULyraEquipmentInstance* GetAssociatedEquipment() const;
	class ULyraInventoryItemInstance* GetAssociatedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility_FromEquipment">();
	}
	static class UTgfGameplayAbility_FromEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility_FromEquipment>();
	}
};
static_assert(alignof(UTgfGameplayAbility_FromEquipment) == 0x000010, "Wrong alignment on UTgfGameplayAbility_FromEquipment");
static_assert(sizeof(UTgfGameplayAbility_FromEquipment) == 0x000980, "Wrong size on UTgfGameplayAbility_FromEquipment");

// Class LyraGame.AnimNotify_LyraContextEffects
// 0x0090 (0x00C8 - 0x0038)
class UAnimNotify_LyraContextEffects final : public UAnimNotify
{
public:
	struct FGameplayTag                           Effect;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FLyraContextEffectAnimNotifyVFXSettings VFXProperties;                                     // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FLyraContextEffectAnimNotifyAudioSettings AudioProperties;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         bAttached : 1;                                     // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPerformTrace : 1;                                 // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLyraContextEffectAnimNotifyTraceSettings TraceProperties;                                   // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LyraContextEffects">();
	}
	static class UAnimNotify_LyraContextEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LyraContextEffects>();
	}
};
static_assert(alignof(UAnimNotify_LyraContextEffects) == 0x000008, "Wrong alignment on UAnimNotify_LyraContextEffects");
static_assert(sizeof(UAnimNotify_LyraContextEffects) == 0x0000C8, "Wrong size on UAnimNotify_LyraContextEffects");
static_assert(offsetof(UAnimNotify_LyraContextEffects, Effect) == 0x000038, "Member 'UAnimNotify_LyraContextEffects::Effect' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LyraContextEffects, LocationOffset) == 0x000040, "Member 'UAnimNotify_LyraContextEffects::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LyraContextEffects, RotationOffset) == 0x000058, "Member 'UAnimNotify_LyraContextEffects::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LyraContextEffects, VFXProperties) == 0x000070, "Member 'UAnimNotify_LyraContextEffects::VFXProperties' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LyraContextEffects, AudioProperties) == 0x000088, "Member 'UAnimNotify_LyraContextEffects::AudioProperties' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LyraContextEffects, SocketName) == 0x000094, "Member 'UAnimNotify_LyraContextEffects::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LyraContextEffects, TraceProperties) == 0x0000A0, "Member 'UAnimNotify_LyraContextEffects::TraceProperties' has a wrong offset!");

// Class LyraGame.LyraActiveContextEffects
// 0x0048 (0x0070 - 0x0028)
class ULyraActiveContextEffects final : public UObject
{
public:
	struct FGameplayTag                           EffectTag;                                         // 0x0028(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Context;                                           // 0x0030(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     Sounds;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UNiagaraSystem*>                 NiagaraSystems;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraActiveContextEffects">();
	}
	static class ULyraActiveContextEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraActiveContextEffects>();
	}
};
static_assert(alignof(ULyraActiveContextEffects) == 0x000008, "Wrong alignment on ULyraActiveContextEffects");
static_assert(sizeof(ULyraActiveContextEffects) == 0x000070, "Wrong size on ULyraActiveContextEffects");
static_assert(offsetof(ULyraActiveContextEffects, EffectTag) == 0x000028, "Member 'ULyraActiveContextEffects::EffectTag' has a wrong offset!");
static_assert(offsetof(ULyraActiveContextEffects, Context) == 0x000030, "Member 'ULyraActiveContextEffects::Context' has a wrong offset!");
static_assert(offsetof(ULyraActiveContextEffects, Sounds) == 0x000050, "Member 'ULyraActiveContextEffects::Sounds' has a wrong offset!");
static_assert(offsetof(ULyraActiveContextEffects, NiagaraSystems) == 0x000060, "Member 'ULyraActiveContextEffects::NiagaraSystems' has a wrong offset!");

// Class LyraGame.LyraContextEffectsSettings
// 0x0050 (0x0088 - 0x0038)
class ULyraContextEffectsSettings final : public UDeveloperSettings
{
public:
	TMap<EPhysicalSurface, struct FGameplayTag>   SurfaceTypeToContextMap;                           // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraContextEffectsSettings">();
	}
	static class ULyraContextEffectsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraContextEffectsSettings>();
	}
};
static_assert(alignof(ULyraContextEffectsSettings) == 0x000008, "Wrong alignment on ULyraContextEffectsSettings");
static_assert(sizeof(ULyraContextEffectsSettings) == 0x000088, "Wrong size on ULyraContextEffectsSettings");
static_assert(offsetof(ULyraContextEffectsSettings, SurfaceTypeToContextMap) == 0x000038, "Member 'ULyraContextEffectsSettings::SurfaceTypeToContextMap' has a wrong offset!");

// Class LyraGame.LyraContextEffectsSubsystem
// 0x0050 (0x0080 - 0x0030)
class ULyraContextEffectsSubsystem final : public UWorldSubsystem
{
public:
	TMap<class AActor*, class ULyraContextEffectsSet*> ActiveActorEffectsMap;                             // 0x0030(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	bool GetContextFromSurfaceType(EPhysicalSurface PhysicalSurface, struct FGameplayTag* Context);
	void LoadAndAddContextEffectsLibraries(class AActor* OwningActor, const TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>>& ContextEffectsLibraries);
	void SpawnContextEffects(const class AActor* SpawningActor, class USceneComponent* AttachToComponent, const class FName AttachPoint, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const struct FGameplayTag& Effect, const struct FGameplayTagContainer& Contexts, TArray<class UAudioComponent*>* AudioOut, TArray<class UNiagaraComponent*>* NiagaraOut, const struct FVector& VFXScale, float AudioVolume, float AudioPitch);
	void UnloadAndRemoveContextEffectsLibraries(class AActor* OwningActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraContextEffectsSubsystem">();
	}
	static class ULyraContextEffectsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraContextEffectsSubsystem>();
	}
};
static_assert(alignof(ULyraContextEffectsSubsystem) == 0x000008, "Wrong alignment on ULyraContextEffectsSubsystem");
static_assert(sizeof(ULyraContextEffectsSubsystem) == 0x000080, "Wrong size on ULyraContextEffectsSubsystem");
static_assert(offsetof(ULyraContextEffectsSubsystem, ActiveActorEffectsMap) == 0x000030, "Member 'ULyraContextEffectsSubsystem::ActiveActorEffectsMap' has a wrong offset!");

// Class LyraGame.GameFeatureAction_AddAbilities
// 0x0060 (0x00D8 - 0x0078)
class UGameFeatureAction_AddAbilities final : public UGameFeatureAction_WorldActionBase
{
public:
	TArray<struct FGameFeatureAbilitiesEntry>     AbilitiesList;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x50];                                      // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddAbilities">();
	}
	static class UGameFeatureAction_AddAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddAbilities>();
	}
};
static_assert(alignof(UGameFeatureAction_AddAbilities) == 0x000008, "Wrong alignment on UGameFeatureAction_AddAbilities");
static_assert(sizeof(UGameFeatureAction_AddAbilities) == 0x0000D8, "Wrong size on UGameFeatureAction_AddAbilities");
static_assert(offsetof(UGameFeatureAction_AddAbilities, AbilitiesList) == 0x000078, "Member 'UGameFeatureAction_AddAbilities::AbilitiesList' has a wrong offset!");

// Class LyraGame.GameFeatureAction_AddInputBinding
// 0x0060 (0x00D8 - 0x0078)
class UGameFeatureAction_AddInputBinding final : public UGameFeatureAction_WorldActionBase
{
public:
	TArray<TSoftObjectPtr<class ULyraInputConfig>> InputConfigs;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x50];                                      // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddInputBinding">();
	}
	static class UGameFeatureAction_AddInputBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddInputBinding>();
	}
};
static_assert(alignof(UGameFeatureAction_AddInputBinding) == 0x000008, "Wrong alignment on UGameFeatureAction_AddInputBinding");
static_assert(sizeof(UGameFeatureAction_AddInputBinding) == 0x0000D8, "Wrong size on UGameFeatureAction_AddInputBinding");
static_assert(offsetof(UGameFeatureAction_AddInputBinding, InputConfigs) == 0x000078, "Member 'UGameFeatureAction_AddInputBinding::InputConfigs' has a wrong offset!");

// Class LyraGame.GameFeatureAction_AddInputContextMapping
// 0x0060 (0x00D8 - 0x0078)
class UGameFeatureAction_AddInputContextMapping final : public UGameFeatureAction_WorldActionBase
{
public:
	TArray<struct FInputMappingContextAndPriority> InputMappings;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x50];                                      // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddInputContextMapping">();
	}
	static class UGameFeatureAction_AddInputContextMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddInputContextMapping>();
	}
};
static_assert(alignof(UGameFeatureAction_AddInputContextMapping) == 0x000008, "Wrong alignment on UGameFeatureAction_AddInputContextMapping");
static_assert(sizeof(UGameFeatureAction_AddInputContextMapping) == 0x0000D8, "Wrong size on UGameFeatureAction_AddInputContextMapping");
static_assert(offsetof(UGameFeatureAction_AddInputContextMapping, InputMappings) == 0x000078, "Member 'UGameFeatureAction_AddInputContextMapping::InputMappings' has a wrong offset!");

// Class LyraGame.GameFeatureAction_SplitscreenConfig
// 0x0018 (0x0090 - 0x0078)
class UGameFeatureAction_SplitscreenConfig final : public UGameFeatureAction_WorldActionBase
{
public:
	bool                                          bDisableSplitscreen;                               // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x17];                                      // 0x0079(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_SplitscreenConfig">();
	}
	static class UGameFeatureAction_SplitscreenConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_SplitscreenConfig>();
	}
};
static_assert(alignof(UGameFeatureAction_SplitscreenConfig) == 0x000008, "Wrong alignment on UGameFeatureAction_SplitscreenConfig");
static_assert(sizeof(UGameFeatureAction_SplitscreenConfig) == 0x000090, "Wrong size on UGameFeatureAction_SplitscreenConfig");
static_assert(offsetof(UGameFeatureAction_SplitscreenConfig, bDisableSplitscreen) == 0x000078, "Member 'UGameFeatureAction_SplitscreenConfig::bDisableSplitscreen' has a wrong offset!");

// Class LyraGame.LyraGameFeature_HotfixManager
// 0x0008 (0x0030 - 0x0028)
class ULyraGameFeature_HotfixManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameFeature_HotfixManager">();
	}
	static class ULyraGameFeature_HotfixManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameFeature_HotfixManager>();
	}
};
static_assert(alignof(ULyraGameFeature_HotfixManager) == 0x000008, "Wrong alignment on ULyraGameFeature_HotfixManager");
static_assert(sizeof(ULyraGameFeature_HotfixManager) == 0x000030, "Wrong size on ULyraGameFeature_HotfixManager");

// Class LyraGame.LyraBotCreationComponent
// 0x0038 (0x00E0 - 0x00A8)
class ULyraBotCreationComponent : public UGameStateComponent
{
public:
	int32                                         NumBotsToCreate;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RandomBotNames;                                    // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAIController*>                  SpawnedBotList;                                    // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void CheatAddBot(int32 AddBotCnt);
	void CheatRemoveBot(int32 RemoveBotCnt);
	void MakeBotsAllDead();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraBotCreationComponent">();
	}
	static class ULyraBotCreationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraBotCreationComponent>();
	}
};
static_assert(alignof(ULyraBotCreationComponent) == 0x000008, "Wrong alignment on ULyraBotCreationComponent");
static_assert(sizeof(ULyraBotCreationComponent) == 0x0000E0, "Wrong size on ULyraBotCreationComponent");
static_assert(offsetof(ULyraBotCreationComponent, NumBotsToCreate) == 0x0000A8, "Member 'ULyraBotCreationComponent::NumBotsToCreate' has a wrong offset!");
static_assert(offsetof(ULyraBotCreationComponent, RandomBotNames) == 0x0000B0, "Member 'ULyraBotCreationComponent::RandomBotNames' has a wrong offset!");
static_assert(offsetof(ULyraBotCreationComponent, SpawnedBotList) == 0x0000D0, "Member 'ULyraBotCreationComponent::SpawnedBotList' has a wrong offset!");

// Class LyraGame.LyraExperienceDefinition
// 0x0048 (0x0078 - 0x0030)
class ULyraExperienceDefinition final : public UPrimaryDataAsset
{
public:
	TArray<class FString>                         GameFeaturesToEnable;                              // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class ULyraPawnData*                          DefaultPawnData;                                   // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGameFeatureAction*>             Actions;                                           // 0x0048(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ULyraExperienceActionSet*>       ActionSets;                                        // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ULyraExperienceActionSet*>       MobileActionSets;                                  // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraExperienceDefinition">();
	}
	static class ULyraExperienceDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraExperienceDefinition>();
	}
};
static_assert(alignof(ULyraExperienceDefinition) == 0x000008, "Wrong alignment on ULyraExperienceDefinition");
static_assert(sizeof(ULyraExperienceDefinition) == 0x000078, "Wrong size on ULyraExperienceDefinition");
static_assert(offsetof(ULyraExperienceDefinition, GameFeaturesToEnable) == 0x000030, "Member 'ULyraExperienceDefinition::GameFeaturesToEnable' has a wrong offset!");
static_assert(offsetof(ULyraExperienceDefinition, DefaultPawnData) == 0x000040, "Member 'ULyraExperienceDefinition::DefaultPawnData' has a wrong offset!");
static_assert(offsetof(ULyraExperienceDefinition, Actions) == 0x000048, "Member 'ULyraExperienceDefinition::Actions' has a wrong offset!");
static_assert(offsetof(ULyraExperienceDefinition, ActionSets) == 0x000058, "Member 'ULyraExperienceDefinition::ActionSets' has a wrong offset!");
static_assert(offsetof(ULyraExperienceDefinition, MobileActionSets) == 0x000068, "Member 'ULyraExperienceDefinition::MobileActionSets' has a wrong offset!");

// Class LyraGame.LyraExperienceManagerComponent
// 0x0078 (0x0120 - 0x00A8)
class ULyraExperienceManagerComponent final : public UGameStateComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraExperienceDefinition*              CurrentExperience;                                 // 0x00B0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentExperience();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraExperienceManagerComponent">();
	}
	static class ULyraExperienceManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraExperienceManagerComponent>();
	}
};
static_assert(alignof(ULyraExperienceManagerComponent) == 0x000008, "Wrong alignment on ULyraExperienceManagerComponent");
static_assert(sizeof(ULyraExperienceManagerComponent) == 0x000120, "Wrong size on ULyraExperienceManagerComponent");
static_assert(offsetof(ULyraExperienceManagerComponent, CurrentExperience) == 0x0000B0, "Member 'ULyraExperienceManagerComponent::CurrentExperience' has a wrong offset!");

// Class LyraGame.LyraGameState
// 0x0098 (0x0380 - 0x02E8)
class ALyraGameState : public AModularGameStateBase
{
public:
	uint8                                         Pad_2E8[0x20];                                     // 0x02E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OptionIds;                                         // 0x0308(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	ETgfMatchType                                 MatchType;                                         // 0x0318(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapId;                                             // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateAdded;                                // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 BattleId;                                          // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBattleIdRep;                                     // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULyraExperienceManagerComponent*        ExperienceManagerComponent;                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraPlayerSpawningManagerComponent*    PlayerSpawningManagerComponent;                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerFPS;                                         // 0x0370(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           RecorderPlayerState;                               // 0x0378(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddOption(int32 ID);
	void ClearAllDeadPlayers();
	float GetReplicatedWorldTimeSeconds();
	void MulticastMessageToClients(const struct FLyraVerbMessage& Message);
	void MulticastReliableMessageToClients(const struct FLyraVerbMessage& Message);
	void OnRep_BattleId();
	void OnRep_MatchType();
	void OnRep_RecorderPlayerState();
	void RemoveOption(int32 ID);
	void SetMatchType(ETgfMatchType NewMatchType);

	class ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;
	float GetServerFPS() const;
	bool HasAllOptions(const TArray<int32>& IDs) const;
	bool HasAnyOption(const TArray<int32>& IDs) const;
	bool HasOption(int32 ID) const;
	bool IsHomelandMatchType() const;
	bool IsPvpMatchType() const;
	bool IsPVPSingleMatchType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameState">();
	}
	static class ALyraGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraGameState>();
	}
};
static_assert(alignof(ALyraGameState) == 0x000008, "Wrong alignment on ALyraGameState");
static_assert(sizeof(ALyraGameState) == 0x000380, "Wrong size on ALyraGameState");
static_assert(offsetof(ALyraGameState, OptionIds) == 0x000308, "Member 'ALyraGameState::OptionIds' has a wrong offset!");
static_assert(offsetof(ALyraGameState, MatchType) == 0x000318, "Member 'ALyraGameState::MatchType' has a wrong offset!");
static_assert(offsetof(ALyraGameState, MapId) == 0x00031C, "Member 'ALyraGameState::MapId' has a wrong offset!");
static_assert(offsetof(ALyraGameState, OnPlayerStateAdded) == 0x000320, "Member 'ALyraGameState::OnPlayerStateAdded' has a wrong offset!");
static_assert(offsetof(ALyraGameState, BattleId) == 0x000330, "Member 'ALyraGameState::BattleId' has a wrong offset!");
static_assert(offsetof(ALyraGameState, OnBattleIdRep) == 0x000340, "Member 'ALyraGameState::OnBattleIdRep' has a wrong offset!");
static_assert(offsetof(ALyraGameState, ExperienceManagerComponent) == 0x000350, "Member 'ALyraGameState::ExperienceManagerComponent' has a wrong offset!");
static_assert(offsetof(ALyraGameState, AbilitySystemComponent) == 0x000358, "Member 'ALyraGameState::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ALyraGameState, PlayerSpawningManagerComponent) == 0x000360, "Member 'ALyraGameState::PlayerSpawningManagerComponent' has a wrong offset!");
static_assert(offsetof(ALyraGameState, ServerFPS) == 0x000370, "Member 'ALyraGameState::ServerFPS' has a wrong offset!");
static_assert(offsetof(ALyraGameState, RecorderPlayerState) == 0x000378, "Member 'ALyraGameState::RecorderPlayerState' has a wrong offset!");

// Class LyraGame.LyraHotfixManager
// 0x0038 (0x0270 - 0x0238)
class ULyraHotfixManager final : public UOnlineHotfixManager
{
public:
	uint8                                         Pad_238[0x38];                                     // 0x0238(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHotfixManager">();
	}
	static class ULyraHotfixManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHotfixManager>();
	}
};
static_assert(alignof(ULyraHotfixManager) == 0x000008, "Wrong alignment on ULyraHotfixManager");
static_assert(sizeof(ULyraHotfixManager) == 0x000270, "Wrong size on ULyraHotfixManager");

// Class LyraGame.LyraRuntimeOptions
// 0x0000 (0x0038 - 0x0038)
class ULyraRuntimeOptions final : public URuntimeOptionsBase
{
public:
	static class ULyraRuntimeOptions* GetRuntimeOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraRuntimeOptions">();
	}
	static class ULyraRuntimeOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraRuntimeOptions>();
	}
};
static_assert(alignof(ULyraRuntimeOptions) == 0x000008, "Wrong alignment on ULyraRuntimeOptions");
static_assert(sizeof(ULyraRuntimeOptions) == 0x000038, "Wrong size on ULyraRuntimeOptions");

// Class LyraGame.LyraAimSensitivityData
// 0x0050 (0x0080 - 0x0030)
class ULyraAimSensitivityData final : public UPrimaryDataAsset
{
public:
	TMap<ELyraGamepadSensitivity, float>          SensitivityMap;                                    // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAimSensitivityData">();
	}
	static class ULyraAimSensitivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAimSensitivityData>();
	}
};
static_assert(alignof(ULyraAimSensitivityData) == 0x000008, "Wrong alignment on ULyraAimSensitivityData");
static_assert(sizeof(ULyraAimSensitivityData) == 0x000080, "Wrong size on ULyraAimSensitivityData");
static_assert(offsetof(ULyraAimSensitivityData, SensitivityMap) == 0x000030, "Member 'ULyraAimSensitivityData::SensitivityMap' has a wrong offset!");

// Class LyraGame.LyraInputConfig
// 0x0020 (0x0050 - 0x0030)
class ULyraInputConfig final : public UDataAsset
{
public:
	TArray<struct FLyraInputAction>               NativeInputActions;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FLyraInputAction>               AbilityInputActions;                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	const class UInputAction* FindAbilityInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;
	const class UInputAction* FindNativeInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputConfig">();
	}
	static class ULyraInputConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputConfig>();
	}
};
static_assert(alignof(ULyraInputConfig) == 0x000008, "Wrong alignment on ULyraInputConfig");
static_assert(sizeof(ULyraInputConfig) == 0x000050, "Wrong size on ULyraInputConfig");
static_assert(offsetof(ULyraInputConfig, NativeInputActions) == 0x000030, "Member 'ULyraInputConfig::NativeInputActions' has a wrong offset!");
static_assert(offsetof(ULyraInputConfig, AbilityInputActions) == 0x000040, "Member 'ULyraInputConfig::AbilityInputActions' has a wrong offset!");

// Class LyraGame.LyraInputModifierDeadZone
// 0x0010 (0x0038 - 0x0028)
class ULyraInputModifierDeadZone final : public UInputModifier
{
public:
	EDeadZoneType                                 Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperThreshold;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeadzoneStick                                DeadzoneStick;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierDeadZone">();
	}
	static class ULyraInputModifierDeadZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierDeadZone>();
	}
};
static_assert(alignof(ULyraInputModifierDeadZone) == 0x000008, "Wrong alignment on ULyraInputModifierDeadZone");
static_assert(sizeof(ULyraInputModifierDeadZone) == 0x000038, "Wrong size on ULyraInputModifierDeadZone");
static_assert(offsetof(ULyraInputModifierDeadZone, Type) == 0x000028, "Member 'ULyraInputModifierDeadZone::Type' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierDeadZone, UpperThreshold) == 0x00002C, "Member 'ULyraInputModifierDeadZone::UpperThreshold' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierDeadZone, DeadzoneStick) == 0x000030, "Member 'ULyraInputModifierDeadZone::DeadzoneStick' has a wrong offset!");

// Class LyraGame.LyraInputModifierAimInversion
// 0x0000 (0x0028 - 0x0028)
class ULyraInputModifierAimInversion final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierAimInversion">();
	}
	static class ULyraInputModifierAimInversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierAimInversion>();
	}
};
static_assert(alignof(ULyraInputModifierAimInversion) == 0x000008, "Wrong alignment on ULyraInputModifierAimInversion");
static_assert(sizeof(ULyraInputModifierAimInversion) == 0x000028, "Wrong size on ULyraInputModifierAimInversion");

// Class LyraGame.InputModifierSensitivityScaling
// 0x0008 (0x0030 - 0x0028)
class UInputModifierSensitivityScaling final : public UInputModifier
{
public:
	float                                         SensitivityScale;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputModifierSensitivityScaling">();
	}
	static class UInputModifierSensitivityScaling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputModifierSensitivityScaling>();
	}
};
static_assert(alignof(UInputModifierSensitivityScaling) == 0x000008, "Wrong alignment on UInputModifierSensitivityScaling");
static_assert(sizeof(UInputModifierSensitivityScaling) == 0x000030, "Wrong size on UInputModifierSensitivityScaling");
static_assert(offsetof(UInputModifierSensitivityScaling, SensitivityScale) == 0x000028, "Member 'UInputModifierSensitivityScaling::SensitivityScale' has a wrong offset!");

// Class LyraGame.MappableConfigPairHelper
// 0x0000 (0x0028 - 0x0028)
class UMappableConfigPairHelper final : public UObject
{
public:
	static void RegisterPair(const struct FMappableConfigPair& Pair);
	static void UnregisterPair(const struct FMappableConfigPair& Pair);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MappableConfigPairHelper">();
	}
	static class UMappableConfigPairHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMappableConfigPairHelper>();
	}
};
static_assert(alignof(UMappableConfigPairHelper) == 0x000008, "Wrong alignment on UMappableConfigPairHelper");
static_assert(sizeof(UMappableConfigPairHelper) == 0x000028, "Wrong size on UMappableConfigPairHelper");

// Class LyraGame.TgfGameplayAbility_Interact
// 0x0070 (0x09F0 - 0x0980)
class UTgfGameplayAbility_Interact : public UTgfGameplayAbility
{
public:
	TArray<struct FInteractionOption>             CurrentOptions;                                    // 0x0980(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UIndicatorDescriptor*>           Indicators;                                        // 0x0990(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector                                LastTraceEnd;                                      // 0x09A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionScanRate;                               // 0x09B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionScanRange;                              // 0x09BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DefaultInteractionWidgetClass;                     // 0x09C0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void TriggerInteraction();
	void UpdateInteractions(const TArray<struct FInteractionOption>& InteractiveOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfGameplayAbility_Interact">();
	}
	static class UTgfGameplayAbility_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfGameplayAbility_Interact>();
	}
};
static_assert(alignof(UTgfGameplayAbility_Interact) == 0x000010, "Wrong alignment on UTgfGameplayAbility_Interact");
static_assert(sizeof(UTgfGameplayAbility_Interact) == 0x0009F0, "Wrong size on UTgfGameplayAbility_Interact");
static_assert(offsetof(UTgfGameplayAbility_Interact, CurrentOptions) == 0x000980, "Member 'UTgfGameplayAbility_Interact::CurrentOptions' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_Interact, Indicators) == 0x000990, "Member 'UTgfGameplayAbility_Interact::Indicators' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_Interact, LastTraceEnd) == 0x0009A0, "Member 'UTgfGameplayAbility_Interact::LastTraceEnd' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_Interact, InteractionScanRate) == 0x0009B8, "Member 'UTgfGameplayAbility_Interact::InteractionScanRate' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_Interact, InteractionScanRange) == 0x0009BC, "Member 'UTgfGameplayAbility_Interact::InteractionScanRange' has a wrong offset!");
static_assert(offsetof(UTgfGameplayAbility_Interact, DefaultInteractionWidgetClass) == 0x0009C0, "Member 'UTgfGameplayAbility_Interact::DefaultInteractionWidgetClass' has a wrong offset!");

// Class LyraGame.AbilityTask_GrantNearbyInteraction
// 0x0060 (0x00E0 - 0x0080)
class UAbilityTask_GrantNearbyInteraction final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x60];                                      // 0x0080(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(class UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_GrantNearbyInteraction">();
	}
	static class UAbilityTask_GrantNearbyInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_GrantNearbyInteraction>();
	}
};
static_assert(alignof(UAbilityTask_GrantNearbyInteraction) == 0x000008, "Wrong alignment on UAbilityTask_GrantNearbyInteraction");
static_assert(sizeof(UAbilityTask_GrantNearbyInteraction) == 0x0000E0, "Wrong size on UAbilityTask_GrantNearbyInteraction");

// Class LyraGame.InventoryFragment_EquippableItem
// 0x0008 (0x0030 - 0x0028)
class UInventoryFragment_EquippableItem final : public ULyraInventoryItemFragment
{
public:
	TSubclassOf<class ULyraEquipmentDefinition>   EquipmentDefinition;                               // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_EquippableItem">();
	}
	static class UInventoryFragment_EquippableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_EquippableItem>();
	}
};
static_assert(alignof(UInventoryFragment_EquippableItem) == 0x000008, "Wrong alignment on UInventoryFragment_EquippableItem");
static_assert(sizeof(UInventoryFragment_EquippableItem) == 0x000030, "Wrong size on UInventoryFragment_EquippableItem");
static_assert(offsetof(UInventoryFragment_EquippableItem, EquipmentDefinition) == 0x000028, "Member 'UInventoryFragment_EquippableItem::EquipmentDefinition' has a wrong offset!");

// Class LyraGame.InventoryFragment_QuickBarIcon
// 0x01C8 (0x01F0 - 0x0028)
class UInventoryFragment_QuickBarIcon final : public ULyraInventoryItemFragment
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0030(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            AmmoBrush;                                         // 0x0100(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayNameWhenEquipped;                           // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_QuickBarIcon">();
	}
	static class UInventoryFragment_QuickBarIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_QuickBarIcon>();
	}
};
static_assert(alignof(UInventoryFragment_QuickBarIcon) == 0x000010, "Wrong alignment on UInventoryFragment_QuickBarIcon");
static_assert(sizeof(UInventoryFragment_QuickBarIcon) == 0x0001F0, "Wrong size on UInventoryFragment_QuickBarIcon");
static_assert(offsetof(UInventoryFragment_QuickBarIcon, Brush) == 0x000030, "Member 'UInventoryFragment_QuickBarIcon::Brush' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_QuickBarIcon, AmmoBrush) == 0x000100, "Member 'UInventoryFragment_QuickBarIcon::AmmoBrush' has a wrong offset!");
static_assert(offsetof(UInventoryFragment_QuickBarIcon, DisplayNameWhenEquipped) == 0x0001D0, "Member 'UInventoryFragment_QuickBarIcon::DisplayNameWhenEquipped' has a wrong offset!");

// Class LyraGame.Pickupable
// 0x0000 (0x0028 - 0x0028)
class IPickupable final : public IInterface
{
public:
	struct FInventoryPickup GetPickupInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pickupable">();
	}
	static class IPickupable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPickupable>();
	}
};
static_assert(alignof(IPickupable) == 0x000008, "Wrong alignment on IPickupable");
static_assert(sizeof(IPickupable) == 0x000028, "Wrong size on IPickupable");

// Class LyraGame.LyraInventoryFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULyraInventoryFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const class ULyraInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, TSubclassOf<class ULyraInventoryItemFragment> FragmentClass);
	static bool IsTwoHandWeapon(ETgfEquipSubType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInventoryFunctionLibrary">();
	}
	static class ULyraInventoryFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInventoryFunctionLibrary>();
	}
};
static_assert(alignof(ULyraInventoryFunctionLibrary) == 0x000008, "Wrong alignment on ULyraInventoryFunctionLibrary");
static_assert(sizeof(ULyraInventoryFunctionLibrary) == 0x000028, "Wrong size on ULyraInventoryFunctionLibrary");

// Class LyraGame.TgfInventoryItemInstance
// 0x0260 (0x0410 - 0x01B0)
class UTgfInventoryItemInstance final : public ULyraInventoryItemInstance
{
public:
	FMulticastInlineDelegateProperty_             DisplayAffixUpdate;                                // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfEquipAttrItem>              EquipAttrItems;                                    // 0x01D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTgfEquipAttrItem>              HoldAttrItems;                                     // 0x01E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FLyraAbilitySet_GrantedHandles         EquipGrantedHandles;                               // 0x01F0(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLyraAbilitySet_GrantedHandles         HoldGrantedHandles;                                // 0x0270(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ULyraAbilitySet*>                EquipAbilitySets;                                  // 0x02F0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ULyraAbilitySet*>                HoldAbilitySets;                                   // 0x0300(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FTgfEquipGearsetItem>           EquipGearsetItems;                                 // 0x0310(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          Equipped;                                          // 0x0320(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Held;                                              // 0x0321(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_322[0x6];                                      // 0x0322(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETgfActorCareer>                       CareerRestricts;                                   // 0x0328(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ETgfBattleElement                             BattleElement;                                     // 0x0338(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RestrictLevel;                                     // 0x033C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DurabilityPoint;                                   // 0x0340(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxDurabilityPoint;                                // 0x0344(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CorruptionId;                                      // 0x0348(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount;                                         // 0x034C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AdditionalAmmoRecover;                             // 0x0350(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocked;                                         // 0x0354(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GearLevel;                                         // 0x0358(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Type_id;                                           // 0x035C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAffixDisplayConfig>            Buffes;                                            // 0x0360(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAffixDisplayConfig>            MainBasicBuff;                                     // 0x0370(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAffixDisplayConfig>            TopAffixs;                                         // 0x0380(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAffixDisplayConfig>            GemAffixs;                                         // 0x0390(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAffixDisplayConfig>            GearSetAffixs;                                     // 0x03A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FItemGemConfig                         GemConfig;                                         // 0x03B0(0x0018)(Net, Protected, NativeAccessSpecifierProtected)
	int64                                         RoleGuid;                                          // 0x03C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FactionId;                                         // 0x03D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTgfPlayerIDKey>                Ownership;                                         // 0x03D8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTgfPlayerIDKey                        HeirloomOwner;                                     // 0x03E8(0x0010)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          Affix_display_data_attached;                       // 0x03F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTgfDItemBuffer                        DItemBuffer;                                       // 0x0400(0x0010)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void AddAdditionalAmmoRecover(int32 DeltaRecover);
	void AddDeltaAmmo(int32 DeltaAmmo);
	void AffixDisplayConfigAttached();
	void GetAffixDisplayConfig(TArray<struct FAffixDisplayConfig>* Out, TArray<struct FAffixDisplayConfig>* MainBasic, TArray<struct FAffixDisplayConfig>* TopAffix, TArray<struct FAffixDisplayConfig>* Gem, TArray<struct FAffixDisplayConfig>* GearSet);
	int32 GetCorruptionId();
	int32 GetGearLevel();
	struct FTgfPlayerIDKey GetHeirloomOwner();
	TArray<struct FTgfPlayerIDKey> GetOwnership();
	int32 GetTypeId();
	bool IsAffixDisplayConfigAttached();
	void OnRep_AmmoCount();
	void OnRep_DItemBuffer();
	void OnRep_DurabilityChange();
	void OnRep_TypeId();
	void SetEquiped(bool bEquipped);
	void SetHeld(bool bHeld);

	int32 GetAmmoCount() const;
	int32 GetAutoAmmoRecover() const;
	ETgfBattleElement GetBattleElement() const;
	int32 GetDurabilityPoint() const;
	const TArray<struct FTgfEquipAttrItem> GetEquipAttrItems() const;
	const struct FItemGemConfig GetGemConfig() const;
	const TArray<struct FTgfEquipAttrItem> GetHoldAttrItems() const;
	int32 GetLoosePoint() const;
	int32 GetMaxDurabilityPoint() const;
	int32 GetRestrictLevel() const;
	int64 GetRoleGuid() const;
	int32 GetTeamId() const;
	bool HasDurabilityPoint() const;
	bool IsEquipped() const;
	bool IsHeld() const;
	bool IsLockedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemInstance">();
	}
	static class UTgfInventoryItemInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemInstance>();
	}
};
static_assert(alignof(UTgfInventoryItemInstance) == 0x000008, "Wrong alignment on UTgfInventoryItemInstance");
static_assert(sizeof(UTgfInventoryItemInstance) == 0x000410, "Wrong size on UTgfInventoryItemInstance");
static_assert(offsetof(UTgfInventoryItemInstance, DisplayAffixUpdate) == 0x0001B0, "Member 'UTgfInventoryItemInstance::DisplayAffixUpdate' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, EquipAttrItems) == 0x0001D0, "Member 'UTgfInventoryItemInstance::EquipAttrItems' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, HoldAttrItems) == 0x0001E0, "Member 'UTgfInventoryItemInstance::HoldAttrItems' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, EquipGrantedHandles) == 0x0001F0, "Member 'UTgfInventoryItemInstance::EquipGrantedHandles' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, HoldGrantedHandles) == 0x000270, "Member 'UTgfInventoryItemInstance::HoldGrantedHandles' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, EquipAbilitySets) == 0x0002F0, "Member 'UTgfInventoryItemInstance::EquipAbilitySets' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, HoldAbilitySets) == 0x000300, "Member 'UTgfInventoryItemInstance::HoldAbilitySets' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, EquipGearsetItems) == 0x000310, "Member 'UTgfInventoryItemInstance::EquipGearsetItems' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, Equipped) == 0x000320, "Member 'UTgfInventoryItemInstance::Equipped' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, Held) == 0x000321, "Member 'UTgfInventoryItemInstance::Held' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, CareerRestricts) == 0x000328, "Member 'UTgfInventoryItemInstance::CareerRestricts' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, BattleElement) == 0x000338, "Member 'UTgfInventoryItemInstance::BattleElement' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, RestrictLevel) == 0x00033C, "Member 'UTgfInventoryItemInstance::RestrictLevel' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, DurabilityPoint) == 0x000340, "Member 'UTgfInventoryItemInstance::DurabilityPoint' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, MaxDurabilityPoint) == 0x000344, "Member 'UTgfInventoryItemInstance::MaxDurabilityPoint' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, CorruptionId) == 0x000348, "Member 'UTgfInventoryItemInstance::CorruptionId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, AmmoCount) == 0x00034C, "Member 'UTgfInventoryItemInstance::AmmoCount' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, AdditionalAmmoRecover) == 0x000350, "Member 'UTgfInventoryItemInstance::AdditionalAmmoRecover' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, bIsLocked) == 0x000354, "Member 'UTgfInventoryItemInstance::bIsLocked' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, GearLevel) == 0x000358, "Member 'UTgfInventoryItemInstance::GearLevel' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, Type_id) == 0x00035C, "Member 'UTgfInventoryItemInstance::Type_id' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, Buffes) == 0x000360, "Member 'UTgfInventoryItemInstance::Buffes' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, MainBasicBuff) == 0x000370, "Member 'UTgfInventoryItemInstance::MainBasicBuff' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, TopAffixs) == 0x000380, "Member 'UTgfInventoryItemInstance::TopAffixs' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, GemAffixs) == 0x000390, "Member 'UTgfInventoryItemInstance::GemAffixs' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, GearSetAffixs) == 0x0003A0, "Member 'UTgfInventoryItemInstance::GearSetAffixs' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, GemConfig) == 0x0003B0, "Member 'UTgfInventoryItemInstance::GemConfig' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, RoleGuid) == 0x0003C8, "Member 'UTgfInventoryItemInstance::RoleGuid' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, FactionId) == 0x0003D0, "Member 'UTgfInventoryItemInstance::FactionId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, Ownership) == 0x0003D8, "Member 'UTgfInventoryItemInstance::Ownership' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, HeirloomOwner) == 0x0003E8, "Member 'UTgfInventoryItemInstance::HeirloomOwner' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, Affix_display_data_attached) == 0x0003F8, "Member 'UTgfInventoryItemInstance::Affix_display_data_attached' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemInstance, DItemBuffer) == 0x000400, "Member 'UTgfInventoryItemInstance::DItemBuffer' has a wrong offset!");

// Class LyraGame.LyraVerbMessageHelpers
// 0x0000 (0x0028 - 0x0028)
class ULyraVerbMessageHelpers final : public UBlueprintFunctionLibrary
{
public:
	static struct FLyraVerbMessage CueParametersToVerbMessage(const struct FGameplayCueParameters& Params_0);
	static class APawn* GetPawnFromObject(class UObject* Object);
	static class APlayerController* GetPlayerControllerFromObject(class UObject* Object);
	static class APlayerState* GetPlayerStateFromObject(class UObject* Object);
	static struct FGameplayCueParameters VerbMessageToCueParameters(const struct FLyraVerbMessage& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraVerbMessageHelpers">();
	}
	static class ULyraVerbMessageHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraVerbMessageHelpers>();
	}
};
static_assert(alignof(ULyraVerbMessageHelpers) == 0x000008, "Wrong alignment on ULyraVerbMessageHelpers");
static_assert(sizeof(ULyraVerbMessageHelpers) == 0x000028, "Wrong size on ULyraVerbMessageHelpers");

// Class LyraGame.NavMeshGenerationVolume
// 0x0000 (0x02D0 - 0x02D0)
class ANavMeshGenerationVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshGenerationVolume">();
	}
	static class ANavMeshGenerationVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavMeshGenerationVolume>();
	}
};
static_assert(alignof(ANavMeshGenerationVolume) == 0x000008, "Wrong alignment on ANavMeshGenerationVolume");
static_assert(sizeof(ANavMeshGenerationVolume) == 0x0002D0, "Wrong size on ANavMeshGenerationVolume");

// Class LyraGame.LyraPlatformSpecificRenderingSettings
// 0x0038 (0x0078 - 0x0040)
class ULyraPlatformSpecificRenderingSettings final : public UPlatformSettings
{
public:
	class FString                                 DefaultDeviceProfileSuffix;                        // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraQualityDeviceProfileVariant> UserFacingDeviceProfileOptions;                    // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bSupportsGranularVideoQualitySettings;             // 0x0060(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsAutomaticVideoQualityBenchmark;           // 0x0061(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELyraFramePacingMode                          FramePacingMode;                                   // 0x0062(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MobileFrameRateLimits;                             // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlatformSpecificRenderingSettings">();
	}
	static class ULyraPlatformSpecificRenderingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPlatformSpecificRenderingSettings>();
	}
};
static_assert(alignof(ULyraPlatformSpecificRenderingSettings) == 0x000008, "Wrong alignment on ULyraPlatformSpecificRenderingSettings");
static_assert(sizeof(ULyraPlatformSpecificRenderingSettings) == 0x000078, "Wrong size on ULyraPlatformSpecificRenderingSettings");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, DefaultDeviceProfileSuffix) == 0x000040, "Member 'ULyraPlatformSpecificRenderingSettings::DefaultDeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, UserFacingDeviceProfileOptions) == 0x000050, "Member 'ULyraPlatformSpecificRenderingSettings::UserFacingDeviceProfileOptions' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, bSupportsGranularVideoQualitySettings) == 0x000060, "Member 'ULyraPlatformSpecificRenderingSettings::bSupportsGranularVideoQualitySettings' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, bSupportsAutomaticVideoQualityBenchmark) == 0x000061, "Member 'ULyraPlatformSpecificRenderingSettings::bSupportsAutomaticVideoQualityBenchmark' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, FramePacingMode) == 0x000062, "Member 'ULyraPlatformSpecificRenderingSettings::FramePacingMode' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, MobileFrameRateLimits) == 0x000068, "Member 'ULyraPlatformSpecificRenderingSettings::MobileFrameRateLimits' has a wrong offset!");

// Class LyraGame.LyraPerformanceSettings
// 0x0030 (0x0068 - 0x0038)
class ULyraPerformanceSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	struct FPerPlatformSettings                   PerPlatformSettings;                               // 0x0038(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<int32>                                 DesktopFrameRateLimits;                            // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLyraPerformanceStatGroup>      UserFacingPerformanceStats;                        // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerformanceSettings">();
	}
	static class ULyraPerformanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerformanceSettings>();
	}
};
static_assert(alignof(ULyraPerformanceSettings) == 0x000008, "Wrong alignment on ULyraPerformanceSettings");
static_assert(sizeof(ULyraPerformanceSettings) == 0x000068, "Wrong size on ULyraPerformanceSettings");
static_assert(offsetof(ULyraPerformanceSettings, PerPlatformSettings) == 0x000038, "Member 'ULyraPerformanceSettings::PerPlatformSettings' has a wrong offset!");
static_assert(offsetof(ULyraPerformanceSettings, DesktopFrameRateLimits) == 0x000048, "Member 'ULyraPerformanceSettings::DesktopFrameRateLimits' has a wrong offset!");
static_assert(offsetof(ULyraPerformanceSettings, UserFacingPerformanceStats) == 0x000058, "Member 'ULyraPerformanceSettings::UserFacingPerformanceStats' has a wrong offset!");

// Class LyraGame.LyraPerformanceStatSubsystem
// 0x0010 (0x0040 - 0x0030)
class ULyraPerformanceStatSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double GetCachedStat(ELyraDisplayablePerformanceStat Stat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerformanceStatSubsystem">();
	}
	static class ULyraPerformanceStatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerformanceStatSubsystem>();
	}
};
static_assert(alignof(ULyraPerformanceStatSubsystem) == 0x000008, "Wrong alignment on ULyraPerformanceStatSubsystem");
static_assert(sizeof(ULyraPerformanceStatSubsystem) == 0x000040, "Wrong size on ULyraPerformanceStatSubsystem");

// Class LyraGame.PhysicalMaterialWithTags
// 0x0020 (0x00A0 - 0x0080)
class UPhysicalMaterialWithTags final : public UPhysicalMaterial
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalMaterialWithTags">();
	}
	static class UPhysicalMaterialWithTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalMaterialWithTags>();
	}
};
static_assert(alignof(UPhysicalMaterialWithTags) == 0x000008, "Wrong alignment on UPhysicalMaterialWithTags");
static_assert(sizeof(UPhysicalMaterialWithTags) == 0x0000A0, "Wrong size on UPhysicalMaterialWithTags");
static_assert(offsetof(UPhysicalMaterialWithTags, Tags) == 0x000080, "Member 'UPhysicalMaterialWithTags::Tags' has a wrong offset!");

// Class LyraGame.LyraCheatManager
// 0x0000 (0x0088 - 0x0088)
class ULyraCheatManager final : public UCheatManager
{
public:
	void AddTagToSelf(const class FString& TagName);
	void CancelActivatedAbilities();
	void Cheat(const class FString& Msg);
	void CheatAll(const class FString& Msg);
	void CycleAbilitySystemDebug();
	void CycleDebugCameras();
	void DamageSelf(float DamageAmount);
	void DamageSelfDestruct();
	void HealSelf(float HealAmount);
	void HealTarget(float HealAmount);
	void PlayNextGame();
	void RemoveTagFromSelf(const class FString& TagName);
	void SetInteractionOutlineWeight(float Weight);
	void ToggleFixedCamera();
	void UnlimitedHealth(int32 Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraCheatManager">();
	}
	static class ULyraCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraCheatManager>();
	}
};
static_assert(alignof(ULyraCheatManager) == 0x000008, "Wrong alignment on ULyraCheatManager");
static_assert(sizeof(ULyraCheatManager) == 0x000088, "Wrong size on ULyraCheatManager");

// Class LyraGame.LyraDebugCameraController
// 0x0000 (0x09E0 - 0x09E0)
class ALyraDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraDebugCameraController">();
	}
	static class ALyraDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraDebugCameraController>();
	}
};
static_assert(alignof(ALyraDebugCameraController) == 0x000008, "Wrong alignment on ALyraDebugCameraController");
static_assert(sizeof(ALyraDebugCameraController) == 0x0009E0, "Wrong size on ALyraDebugCameraController");

// Class LyraGame.LyraPlayerBotController
// 0x0020 (0x03E0 - 0x03C0)
class ALyraPlayerBotController : public AModularAIController
{
public:
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	class APlayerState*                           LastSeenPlayerState;                               // 0x03D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPlayerStateChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);
	void UpdateTeamAttitude(class UAIPerceptionComponent* AIPerception);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerBotController">();
	}
	static class ALyraPlayerBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerBotController>();
	}
};
static_assert(alignof(ALyraPlayerBotController) == 0x000008, "Wrong alignment on ALyraPlayerBotController");
static_assert(sizeof(ALyraPlayerBotController) == 0x0003E0, "Wrong size on ALyraPlayerBotController");
static_assert(offsetof(ALyraPlayerBotController, OnTeamChangedDelegate) == 0x0003C8, "Member 'ALyraPlayerBotController::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ALyraPlayerBotController, LastSeenPlayerState) == 0x0003D8, "Member 'ALyraPlayerBotController::LastSeenPlayerState' has a wrong offset!");

// Class LyraGame.LyraReplayPlayerController
// 0x0000 (0x0920 - 0x0920)
class ALyraReplayPlayerController final : public ALyraPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraReplayPlayerController">();
	}
	static class ALyraReplayPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraReplayPlayerController>();
	}
};
static_assert(alignof(ALyraReplayPlayerController) == 0x000008, "Wrong alignment on ALyraReplayPlayerController");
static_assert(sizeof(ALyraReplayPlayerController) == 0x000920, "Wrong size on ALyraReplayPlayerController");

// Class LyraGame.LyraPlayerStart
// 0x0040 (0x0308 - 0x02C8)
class ALyraPlayerStart final : public APlayerStart
{
public:
	class AController*                            ClaimingController;                                // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpirationCheckInterval;                           // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  StartPointTags;                                    // 0x02D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWaitingPoint;                                     // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeathPoint;                                       // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfPlayerSceneTag                            PlayerSceneTag;                                    // 0x0302(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_303[0x5];                                      // 0x0303(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDeathPoint() const;
	bool IsWaitingPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerStart">();
	}
	static class ALyraPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerStart>();
	}
};
static_assert(alignof(ALyraPlayerStart) == 0x000008, "Wrong alignment on ALyraPlayerStart");
static_assert(sizeof(ALyraPlayerStart) == 0x000308, "Wrong size on ALyraPlayerStart");
static_assert(offsetof(ALyraPlayerStart, ClaimingController) == 0x0002C8, "Member 'ALyraPlayerStart::ClaimingController' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStart, ExpirationCheckInterval) == 0x0002D0, "Member 'ALyraPlayerStart::ExpirationCheckInterval' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStart, StartPointTags) == 0x0002D8, "Member 'ALyraPlayerStart::StartPointTags' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStart, bWaitingPoint) == 0x000300, "Member 'ALyraPlayerStart::bWaitingPoint' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStart, bDeathPoint) == 0x000301, "Member 'ALyraPlayerStart::bDeathPoint' has a wrong offset!");
static_assert(offsetof(ALyraPlayerStart, PlayerSceneTag) == 0x000302, "Member 'ALyraPlayerStart::PlayerSceneTag' has a wrong offset!");

// Class LyraGame.LyraPlayerStartSetGroup
// 0x0018 (0x02B0 - 0x0298)
class ALyraPlayerStartSetGroup final : public AActor
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlayerStartSetGroup">();
	}
	static class ALyraPlayerStartSetGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraPlayerStartSetGroup>();
	}
};
static_assert(alignof(ALyraPlayerStartSetGroup) == 0x000008, "Wrong alignment on ALyraPlayerStartSetGroup");
static_assert(sizeof(ALyraPlayerStartSetGroup) == 0x0002B0, "Wrong size on ALyraPlayerStartSetGroup");

// Class LyraGame.AsyncAction_QueryReplays
// 0x0030 (0x0060 - 0x0030)
class UAsyncAction_QueryReplays final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             QueryComplete;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULyraReplayList*                        ResultList;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_QueryReplays* QueryReplays(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_QueryReplays">();
	}
	static class UAsyncAction_QueryReplays* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_QueryReplays>();
	}
};
static_assert(alignof(UAsyncAction_QueryReplays) == 0x000008, "Wrong alignment on UAsyncAction_QueryReplays");
static_assert(sizeof(UAsyncAction_QueryReplays) == 0x000060, "Wrong size on UAsyncAction_QueryReplays");
static_assert(offsetof(UAsyncAction_QueryReplays, QueryComplete) == 0x000030, "Member 'UAsyncAction_QueryReplays::QueryComplete' has a wrong offset!");
static_assert(offsetof(UAsyncAction_QueryReplays, ResultList) == 0x000040, "Member 'UAsyncAction_QueryReplays::ResultList' has a wrong offset!");

// Class LyraGame.LyraReplayListEntry
// 0x0040 (0x0068 - 0x0028)
class ULyraReplayListEntry final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTimespan GetDuration() const;
	class FString GetFriendlyName() const;
	bool GetIsLive() const;
	int32 GetNumViewers() const;
	struct FDateTime GetTimestamp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraReplayListEntry">();
	}
	static class ULyraReplayListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraReplayListEntry>();
	}
};
static_assert(alignof(ULyraReplayListEntry) == 0x000008, "Wrong alignment on ULyraReplayListEntry");
static_assert(sizeof(ULyraReplayListEntry) == 0x000068, "Wrong size on ULyraReplayListEntry");

// Class LyraGame.LyraReplayList
// 0x0010 (0x0038 - 0x0028)
class ULyraReplayList final : public UObject
{
public:
	TArray<class ULyraReplayListEntry*>           Results;                                           // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraReplayList">();
	}
	static class ULyraReplayList* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraReplayList>();
	}
};
static_assert(alignof(ULyraReplayList) == 0x000008, "Wrong alignment on ULyraReplayList");
static_assert(sizeof(ULyraReplayList) == 0x000038, "Wrong size on ULyraReplayList");
static_assert(offsetof(ULyraReplayList, Results) == 0x000028, "Member 'ULyraReplayList::Results' has a wrong offset!");

// Class LyraGame.LyraSettingKeyboardInput
// 0x0170 (0x02D8 - 0x0168)
class ULyraSettingKeyboardInput final : public UGameSettingValue
{
public:
	uint8                                         Pad_168[0x170];                                    // 0x0168(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeBinding(int32 InKeyBindSlot, const struct FKey& NewKey);
	struct FEnhancedActionKeyMapping SetData(const struct FEnhancedActionKeyMapping& BaseMapping, const class UPlayerMappableInputConfig* InOwningConfig, int32 InKeyBindSlot);

	void GetAllMappedActionsFromKey(int32 InKeyBindSlot, const struct FKey& Key, TArray<class FName>* OutActionNames) const;
	struct FKey GetKey() const;
	class FText GetPrimaryKeyText() const;
	class FText GetSettingDescription() const;
	class FText GetSettingDisplayName() const;
	class FName GetSettingName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingKeyboardInput">();
	}
	static class ULyraSettingKeyboardInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingKeyboardInput>();
	}
};
static_assert(alignof(ULyraSettingKeyboardInput) == 0x000008, "Wrong alignment on ULyraSettingKeyboardInput");
static_assert(sizeof(ULyraSettingKeyboardInput) == 0x0002D8, "Wrong size on ULyraSettingKeyboardInput");

// Class LyraGame.LyraSettingValueDiscrete_Language
// 0x0010 (0x0178 - 0x0168)
class ULyraSettingValueDiscrete_Language final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_Language">();
	}
	static class ULyraSettingValueDiscrete_Language* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_Language>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_Language) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_Language");
static_assert(sizeof(ULyraSettingValueDiscrete_Language) == 0x000178, "Wrong size on ULyraSettingValueDiscrete_Language");

// Class LyraGame.LyraSettingValueDiscrete_OverallQuality
// 0x0020 (0x0188 - 0x0168)
class ULyraSettingValueDiscrete_OverallQuality final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_OverallQuality">();
	}
	static class ULyraSettingValueDiscrete_OverallQuality* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_OverallQuality>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_OverallQuality) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_OverallQuality");
static_assert(sizeof(ULyraSettingValueDiscrete_OverallQuality) == 0x000188, "Wrong size on ULyraSettingValueDiscrete_OverallQuality");

// Class LyraGame.LyraSettingValueDiscrete_PerfStat
// 0x0028 (0x0190 - 0x0168)
class ULyraSettingValueDiscrete_PerfStat final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x28];                                     // 0x0168(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_PerfStat">();
	}
	static class ULyraSettingValueDiscrete_PerfStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_PerfStat>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_PerfStat) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_PerfStat");
static_assert(sizeof(ULyraSettingValueDiscrete_PerfStat) == 0x000190, "Wrong size on ULyraSettingValueDiscrete_PerfStat");

// Class LyraGame.LyraSettingValueDiscrete_Resolution
// 0x0048 (0x01B0 - 0x0168)
class ULyraSettingValueDiscrete_Resolution final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x48];                                     // 0x0168(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAppropriateDiscreteOptionIndex();
	TArray<class FText> GetAppropriateDiscreteOptions();
	void Initialize();
	void SetAppropriateDiscreteOptionByIndex(int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_Resolution">();
	}
	static class ULyraSettingValueDiscrete_Resolution* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_Resolution>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_Resolution) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_Resolution");
static_assert(sizeof(ULyraSettingValueDiscrete_Resolution) == 0x0001B0, "Wrong size on ULyraSettingValueDiscrete_Resolution");

// Class LyraGame.LyraSettingsLocal
// 0x03A0 (0x0518 - 0x0178)
class ULyraSettingsLocal final : public UGameUserSettings
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELyraDisplayablePerformanceStat, ELyraStatDisplayMode> DisplayStatList;                                   // 0x0180(0x0050)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x18];                                     // 0x01D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayGamma;                                      // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FOV;                                               // 0x01EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFirstRunDPCache;                                  // 0x01F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F1[0x3];                                      // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrameRateLimit_OnBattery;                          // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrameRateLimit_InMenu;                             // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrameRateLimit_WhenBackgrounded;                   // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MobileFrameRateLimit;                              // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x6C];                                     // 0x0204(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DesiredUserChosenDeviceProfileSuffix;              // 0x0270(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentAppliedDeviceProfileOverrideSuffix;         // 0x0280(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 UserChosenDeviceProfileSuffix;                     // 0x0290(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDesiredHeadphoneMode;                             // 0x02B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHeadphoneMode;                                 // 0x02B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseHDRAudioMode;                                  // 0x02BA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioOutputDeviceId;                               // 0x02C0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x48];                                     // 0x02D0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverallVolume;                                     // 0x0318(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MusicVolume;                                       // 0x031C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundFXVolume;                                     // 0x0320(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVoiceChat;                                        // 0x0324(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bChatMode;                                         // 0x0325(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MicrophoneVolume;                                  // 0x0328(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeakerVolume;                                     // 0x032C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DialogueVolume;                                    // 0x0330(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VoiceChatVolume;                                   // 0x0334(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class USoundControlBus*>    ControlBusMap;                                     // 0x0338(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class USoundControlBusMix*                    ControlBusMix;                                     // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSoundControlBusMixLoaded;                         // 0x0390(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SafeZoneScale;                                     // 0x0394(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ControllerPlatform;                                // 0x0398(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ControllerPreset;                                  // 0x03A0(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InputConfigName;                                   // 0x03A8(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadedMappableConfigPair>      RegisteredInputConfigs;                            // 0x03B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FKey>                CustomKeyboardConfig;                              // 0x03C0(0x0050)(Config, NativeAccessSpecifierPrivate)
	bool                                          bIsLiveMode;                                       // 0x0410(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCameraShakesByMoving;                             // 0x0411(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSaveKilledScreenshot;                             // 0x0412(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_413[0x5];                                      // 0x0413(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 KilledScreenshotPath;                              // 0x0418(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStorageLimit                                 KilledScreenshotStorageLimit;                      // 0x0428(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKilledScreenshotAutoDelete;                       // 0x0429(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldAutoRecordReplays;                          // 0x042A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42B[0x1];                                      // 0x042B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfReplaysToKeep;                             // 0x042C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x38];                                     // 0x0430(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFirstRun;                                       // 0x0468(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverallSettingLevel;                               // 0x046C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FTGFDeviceProfileThreshold> CachedDeviceThresholds;                            // 0x0470(0x0050)(Config, NativeAccessSpecifierPrivate)
	struct FTGFDPDefaultSettings                  CachedDPDefaultSettings;                           // 0x04C0(0x0030)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         GILevelDownShift;                                  // 0x04F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ShadowLevelDownShift;                              // 0x04F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsVirtualShadowOption;                            // 0x04F8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserSettingShadowQuality;                          // 0x04FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUserSettingTonemapSharpnessOption;              // 0x0500(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedUserSettingTonemapSharpness;                 // 0x0504(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TGFSSMode;                                         // 0x0508(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UserSettingSharpness;                              // 0x050C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUserSettingNaniteAndVSMEnabled;                   // 0x0510(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUserSettingNanite;                                // 0x0511(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUserSettingVSM;                                   // 0x0512(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUserSettingFrameGeneration;                       // 0x0513(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyScalabilitySettings();
	void BindDisplayMonitorChangedDelegate(TSoftObjectPtr<class UUserWidget> Window);
	void BindVideoSettingModifiedDelegate(TSoftObjectPtr<class UUserWidget> Window);
	int32 GetFrameRateLimitIndex();
	int32 GetResolutionOptionIndex();
	TArray<class FText> GetResolutionOptions();
	TArray<class FText> GetSSModeOptions();
	void InitVolume();
	bool IsDisplayMonitorChanged();
	void OnAllModuleLoaded();
	int32 OnFullScreenModeDirty();
	void OnPostEngineInit();
	void OnTGFActivateApp(bool bActivate);
	void OnViewportCreated();
	void ResetKeybindingsToDefault(class ULyraLocalPlayer* LocalPlayer);
	void ResetToDPDefaultSettings();
	void RunAutoBenchmark(bool bSaveImmediately);
	void RunAutoBenchmarkIfNecessary();
	void SetAntiAliasingQualityByIndex(const int32& Param_Index);
	void SetAudioOutputDeviceId(const class FString& InAudioOutputDeviceId);
	void SetCameraShakesByMoving(bool NewValue);
	void SetChatMode(bool IsAllOpen);
	void SetControllerPlatform(const class FName InControllerPlatform);
	void SetDesiredDeviceProfileQualitySuffix(const class FString& InDesiredSuffix);
	void SetDialogueVolume(float InVolume);
	void SetDisplayGamma(float InGamma);
	void SetDLSSEnabled(bool bEnable);
	void SetFOV(float InFOV);
	void SetFrameRateLimit_Always(float NewLimitFPS);
	void SetFrameRateLimit_InMenu(float NewLimitFPS);
	void SetFrameRateLimit_OnBattery(float NewLimitFPS);
	void SetFrameRateLimit_WhenBackgrounded(float NewLimitFPS);
	void SetFrameRateLimitByIndex(const int32& InIndex);
	void SetFSREnabled(bool bEnable);
	void SetGlobalIlluminationQualityByIndex(const int32& Param_Index);
	void SetHDRAudioModeEnabled(bool bEnabled);
	void SetHeadphoneModeEnabled(bool bEnabled);
	void SetIsLiveMode(bool NewValue);
	void SetKilledScreenshotAutoDelete(bool NewValue);
	void SetKilledScreenshotPath(const class FString& NewValue);
	void SetKilledScreenshotStorageLimit(EStorageLimit NewValue);
	void SetMicrophoneVolume(float InVolume);
	void SetMusicVolume(float InVolume);
	void SetNumberOfReplaysToKeep(int32 InNumberOfReplays);
	void SetOverallVolume(float InVolume);
	void SetPostProcessQualityByIndex(const int32& Param_Index);
	void SetReflectionQualityByIndex(const int32& Param_Index);
	void SetSafeZone(float Value);
	void SetSaveKillScreenshot(bool NewValue);
	void SetShouldAutoRecordReplays(bool bEnabled);
	void SetSoundFXVolume(float InVolume);
	void SetSpeakerVolume(float InVolume);
	void SetSSModeByIndex(const int32& InEnumIndex);
	void SetSuperSamplingMode(const ETGFSSMode& SSMode);
	void SetTextureQualityByIndex(const int32& Param_Index);
	void SetTGFOverallScalabilityLevelByIndex(const int32& Param_Index);
	void SetTGFResolutionByIndex(const int32& Param_Index);
	void SetTGFWindowModeByIndex(const int32& Mode);
	void SetViewDistanceQualityByIndex(const int32& Param_Index);
	void SetVisualEffectQualityByIndex(const int32& Param_Index);
	void SetVoiceChat(bool IsOn);
	void SetVoiceChatVolume(float InVolume);
	void SetXeSSEnabled(bool bEnable);
	void SyncDisplayMonitorIndex();
	void UnBindDisplayMonitorChangedDelegate(TSoftObjectPtr<class UUserWidget> Window);
	void UnBindVideoSettingModifiedDelegate(TSoftObjectPtr<class UUserWidget> Window);

	bool CanModifyHeadphoneModeEnabled() const;
	bool CanRunAutoBenchmark() const;
	const TArray<struct FLoadedMappableConfigPair> GetAllRegisteredInputConfigs() const;
	class FString GetAudioOutputDeviceId() const;
	bool GetCameraShakesByMoving() const;
	bool GetChatMode() const;
	class FName GetControllerPlatform() const;
	const TMap<class FName, struct FKey> GetCustomPlayerInputConfig() const;
	class FString GetDefaultKilledScreenshotPath() const;
	float GetDefaultSharpness() const;
	class FString GetDesiredDeviceProfileQualitySuffix() const;
	float GetDialogueVolume() const;
	float GetDisplayGamma() const;
	int32 GetDLSSModeIndex() const;
	float GetFOV() const;
	float GetFrameRateLimit_Always() const;
	float GetFrameRateLimit_InMenu() const;
	float GetFrameRateLimit_OnBattery() const;
	float GetFrameRateLimit_WhenBackgrounded() const;
	TArray<class FText> GetFrameRateLimitListText() const;
	const class UPlayerMappableInputConfig* GetInputConfigByName(class FName ConfigName) const;
	bool GetIsLiveMode() const;
	bool GetKilledScreenshotAutoDelete() const;
	class FString GetKilledScreenshotPath() const;
	EStorageLimit GetKilledScreenshotStorageLimit() const;
	int32 GetKilledScreenshotStorageLimitIndex() const;
	float GetMaxResolutionScale() const;
	float GetMicrophoneVolume() const;
	float GetMinResolutionScale() const;
	float GetMusicVolume() const;
	int32 GetNumberOfReplaysToKeep() const;
	int32 GetOverallLevel() const;
	float GetOverallVolume() const;
	float GetSafeZone() const;
	bool GetSaveKillScreenshot() const;
	float GetSoundFXVolume() const;
	float GetSpeakerVolume() const;
	ETGFSSMode GetSuperSamplingMode() const;
	struct FIntPoint GetSystemResolution() const;
	bool GetVoiceChat() const;
	float GetVoiceChatVolume() const;
	bool IsDLSSEnabled() const;
	bool IsFSREnabled() const;
	bool IsHDRAudioModeEnabled() const;
	bool IsHeadphoneModeEnabled() const;
	bool IsSafeZoneSet() const;
	bool IsXeSSEnabled() const;
	bool ShouldAutoRecordReplays() const;
	bool ShouldRunAutoBenchmarkAtStartup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingsLocal">();
	}
	static class ULyraSettingsLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingsLocal>();
	}
};
static_assert(alignof(ULyraSettingsLocal) == 0x000008, "Wrong alignment on ULyraSettingsLocal");
static_assert(sizeof(ULyraSettingsLocal) == 0x000518, "Wrong size on ULyraSettingsLocal");
static_assert(offsetof(ULyraSettingsLocal, DisplayStatList) == 0x000180, "Member 'ULyraSettingsLocal::DisplayStatList' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, DisplayGamma) == 0x0001E8, "Member 'ULyraSettingsLocal::DisplayGamma' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FOV) == 0x0001EC, "Member 'ULyraSettingsLocal::FOV' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bFirstRunDPCache) == 0x0001F0, "Member 'ULyraSettingsLocal::bFirstRunDPCache' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FrameRateLimit_OnBattery) == 0x0001F4, "Member 'ULyraSettingsLocal::FrameRateLimit_OnBattery' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FrameRateLimit_InMenu) == 0x0001F8, "Member 'ULyraSettingsLocal::FrameRateLimit_InMenu' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FrameRateLimit_WhenBackgrounded) == 0x0001FC, "Member 'ULyraSettingsLocal::FrameRateLimit_WhenBackgrounded' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MobileFrameRateLimit) == 0x000200, "Member 'ULyraSettingsLocal::MobileFrameRateLimit' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, DesiredUserChosenDeviceProfileSuffix) == 0x000270, "Member 'ULyraSettingsLocal::DesiredUserChosenDeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CurrentAppliedDeviceProfileOverrideSuffix) == 0x000280, "Member 'ULyraSettingsLocal::CurrentAppliedDeviceProfileOverrideSuffix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, UserChosenDeviceProfileSuffix) == 0x000290, "Member 'ULyraSettingsLocal::UserChosenDeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bDesiredHeadphoneMode) == 0x0002B8, "Member 'ULyraSettingsLocal::bDesiredHeadphoneMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUseHeadphoneMode) == 0x0002B9, "Member 'ULyraSettingsLocal::bUseHeadphoneMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUseHDRAudioMode) == 0x0002BA, "Member 'ULyraSettingsLocal::bUseHDRAudioMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, AudioOutputDeviceId) == 0x0002C0, "Member 'ULyraSettingsLocal::AudioOutputDeviceId' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OverallVolume) == 0x000318, "Member 'ULyraSettingsLocal::OverallVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MusicVolume) == 0x00031C, "Member 'ULyraSettingsLocal::MusicVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, SoundFXVolume) == 0x000320, "Member 'ULyraSettingsLocal::SoundFXVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bVoiceChat) == 0x000324, "Member 'ULyraSettingsLocal::bVoiceChat' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bChatMode) == 0x000325, "Member 'ULyraSettingsLocal::bChatMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MicrophoneVolume) == 0x000328, "Member 'ULyraSettingsLocal::MicrophoneVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, SpeakerVolume) == 0x00032C, "Member 'ULyraSettingsLocal::SpeakerVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, DialogueVolume) == 0x000330, "Member 'ULyraSettingsLocal::DialogueVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, VoiceChatVolume) == 0x000334, "Member 'ULyraSettingsLocal::VoiceChatVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControlBusMap) == 0x000338, "Member 'ULyraSettingsLocal::ControlBusMap' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControlBusMix) == 0x000388, "Member 'ULyraSettingsLocal::ControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bSoundControlBusMixLoaded) == 0x000390, "Member 'ULyraSettingsLocal::bSoundControlBusMixLoaded' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, SafeZoneScale) == 0x000394, "Member 'ULyraSettingsLocal::SafeZoneScale' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControllerPlatform) == 0x000398, "Member 'ULyraSettingsLocal::ControllerPlatform' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControllerPreset) == 0x0003A0, "Member 'ULyraSettingsLocal::ControllerPreset' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, InputConfigName) == 0x0003A8, "Member 'ULyraSettingsLocal::InputConfigName' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, RegisteredInputConfigs) == 0x0003B0, "Member 'ULyraSettingsLocal::RegisteredInputConfigs' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CustomKeyboardConfig) == 0x0003C0, "Member 'ULyraSettingsLocal::CustomKeyboardConfig' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bIsLiveMode) == 0x000410, "Member 'ULyraSettingsLocal::bIsLiveMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bCameraShakesByMoving) == 0x000411, "Member 'ULyraSettingsLocal::bCameraShakesByMoving' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bSaveKilledScreenshot) == 0x000412, "Member 'ULyraSettingsLocal::bSaveKilledScreenshot' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, KilledScreenshotPath) == 0x000418, "Member 'ULyraSettingsLocal::KilledScreenshotPath' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, KilledScreenshotStorageLimit) == 0x000428, "Member 'ULyraSettingsLocal::KilledScreenshotStorageLimit' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bKilledScreenshotAutoDelete) == 0x000429, "Member 'ULyraSettingsLocal::bKilledScreenshotAutoDelete' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bShouldAutoRecordReplays) == 0x00042A, "Member 'ULyraSettingsLocal::bShouldAutoRecordReplays' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, NumberOfReplaysToKeep) == 0x00042C, "Member 'ULyraSettingsLocal::NumberOfReplaysToKeep' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bIsFirstRun) == 0x000468, "Member 'ULyraSettingsLocal::bIsFirstRun' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OverallSettingLevel) == 0x00046C, "Member 'ULyraSettingsLocal::OverallSettingLevel' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CachedDeviceThresholds) == 0x000470, "Member 'ULyraSettingsLocal::CachedDeviceThresholds' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CachedDPDefaultSettings) == 0x0004C0, "Member 'ULyraSettingsLocal::CachedDPDefaultSettings' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, GILevelDownShift) == 0x0004F0, "Member 'ULyraSettingsLocal::GILevelDownShift' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ShadowLevelDownShift) == 0x0004F4, "Member 'ULyraSettingsLocal::ShadowLevelDownShift' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bIsVirtualShadowOption) == 0x0004F8, "Member 'ULyraSettingsLocal::bIsVirtualShadowOption' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, UserSettingShadowQuality) == 0x0004FC, "Member 'ULyraSettingsLocal::UserSettingShadowQuality' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bIsUserSettingTonemapSharpnessOption) == 0x000500, "Member 'ULyraSettingsLocal::bIsUserSettingTonemapSharpnessOption' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CachedUserSettingTonemapSharpness) == 0x000504, "Member 'ULyraSettingsLocal::CachedUserSettingTonemapSharpness' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, TGFSSMode) == 0x000508, "Member 'ULyraSettingsLocal::TGFSSMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, UserSettingSharpness) == 0x00050C, "Member 'ULyraSettingsLocal::UserSettingSharpness' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUserSettingNaniteAndVSMEnabled) == 0x000510, "Member 'ULyraSettingsLocal::bUserSettingNaniteAndVSMEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUserSettingNanite) == 0x000511, "Member 'ULyraSettingsLocal::bUserSettingNanite' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUserSettingVSM) == 0x000512, "Member 'ULyraSettingsLocal::bUserSettingVSM' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUserSettingFrameGeneration) == 0x000513, "Member 'ULyraSettingsLocal::bUserSettingFrameGeneration' has a wrong offset!");

// Class LyraGame.LyraSettingsShared
// 0x0188 (0x01B0 - 0x0028)
class ULyraSettingsShared final : public USaveGame
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EColorBlindMode                               ColorBlindMode;                                    // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ColorBlindStrength;                                // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceFeedbackEnabled;                             // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadMoveStickDeadZone;                          // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadLookStickDeadZone;                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerHapticsEnabled;                            // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerPullUsesHapticThreshold;                   // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TriggerHapticStrength;                             // 0x0056(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TriggerHapticStartPosition;                        // 0x0057(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableSubtitles;                                  // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELyraAllowBackgroundAudioSetting              AllowAudioInBackground;                            // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PendingCulture;                                    // 0x0060(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MouseSensitivity_NonSmooth;                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        TargetingMultiplier_NonSmooth;                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertVerticalAxis;                               // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertHorizontalAxis;                             // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowTeamInvite;                                  // 0x008A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowPrivateChat;                                 // 0x008B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowAttributeRange;                               // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOpenOperationTips;                                // 0x008D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowWeaponOperationTips;                          // 0x008E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInventorySee;                                     // 0x008F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESocialPermission                             PrivateRoomInvitePermission;                       // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bChargeSkillMethod;                                // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSquatDownMethod;                                  // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMouseTargetingMethod;                             // 0x0093(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETgfEquipQuality>                      InventoryAutoQuality;                              // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         DailyLoginCheck;                                   // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MoonInterationTime;                                // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 CheckedActivities;                                 // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 AttributeTalents;                                  // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, class FString>            ProcessingTaskMap;                                 // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<int64>                                 InventoryOpened;                                   // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int64>                                 MithrilInventoryOpened;                            // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FInventoryTalentsTipsData> InventoryTalentTips;                               // 0x0140(0x0050)(NativeAccessSpecifierPrivate)
	TArray<int64>                                 InventoryTalentTipsGuids;                          // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	ELyraGamepadSensitivity                       GamepadLookSensitivityPreset;                      // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELyraGamepadSensitivity                       GamepadTargetingSensitivityPreset;                 // 0x01A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraLocalPlayer*                       OwningPlayer;                                      // 0x01A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetAllowAudioInBackgroundSetting(ELyraAllowBackgroundAudioSetting NewValue);
	void SetAllowPrivateChat(bool NewValue);
	void SetAllowTeamInvite(bool NewValue);
	void SetChargeSkillMethod(bool NewValue);
	void SetCheckedActivities(const TArray<int32>& Activities);
	void SetColorBlindMode(EColorBlindMode InMode);
	void SetColorBlindStrength(int32 InColorBlindStrength);
	void SetDailyLoginCheck(int32 NewValue);
	void SetForceFeedbackEnabled(const bool NewValue);
	void SetGamepadLookStickDeadZone(const float NewValue);
	void SetGamepadMoveStickDeadZone(const float NewValue);
	void SetGamepadTargetingSensitivityPreset(ELyraGamepadSensitivity NewValue);
	void SetInventoryAutoQuality(const TArray<ETgfEquipQuality>& NewValue);
	void SetInventoryOpened(const TArray<int64>& NewValue);
	void SetInventorySee(bool NewValue);
	void SetInventoryTalentTips(int32 Key, const TArray<int64>& NewValue);
	void SetInvertHorizontalAxis(bool NewValue);
	void SetInvertVerticalAxis(bool NewValue);
	void SetLookSensitivityPreset(ELyraGamepadSensitivity NewValue);
	void SetMithrilInventoryOpened(const TArray<int64>& NewValue);
	void SetMoonInterationTime(int32 NewValue);
	void SetMouseSensitivityNonSmooth(double NewValue);
	void SetMouseTargetingMethod(bool NewValue);
	void SetOpenOperationTips(bool NewValue);
	void SetPrivateRoomInvitePermission(int32 NewValue);
	void SetProcessingTaskIds(const class FString& LocalUserKey, const TArray<int32>& TaskIds);
	void SetShowAttributeRange(bool NewValue);
	void SetShowWeaponOperationTips(bool NewValue);
	void SetSquatDownMethod(bool NewValue);
	void SetSubtitlesEnabled(bool Value);
	void SetTalents(const TArray<int32>& Talents);
	void SetTargetingMultiplierNonSmooth(double NewValue);
	void SetTriggerHapticsEnabled(const bool NewValue);
	void SetTriggerHapticStartPosition(const uint8 NewValue);
	void SetTriggerHapticStrength(const uint8 NewValue);
	void SetTriggerPullUsesHapticThreshold(const bool NewValue);

	ELyraAllowBackgroundAudioSetting GetAllowAudioInBackgroundSetting() const;
	bool GetAllowPrivateChat() const;
	bool GetAllowTeamInvite() const;
	const TArray<int32> GetAttributeTalents() const;
	bool GetChargeSkillMethod() const;
	const TArray<int32> GetCheckedActivities() const;
	EColorBlindMode GetColorBlindMode() const;
	int32 GetColorBlindStrength() const;
	int32 GetDailyLoginCheck() const;
	bool GetForceFeedbackEnabled() const;
	ELyraGamepadSensitivity GetGamepadLookSensitivityPreset() const;
	float GetGamepadLookStickDeadZone() const;
	float GetGamepadMoveStickDeadZone() const;
	ELyraGamepadSensitivity GetGamepadTargetingSensitivityPreset() const;
	const TArray<ETgfEquipQuality> GetInventoryAutoQuality() const;
	const TArray<int64> GetInventoryOpened() const;
	bool GetInventorySee() const;
	const TArray<int64> GetInventoryTalentTips(int32 Key) const;
	bool GetInvertHorizontalAxis() const;
	bool GetInvertVerticalAxis() const;
	const TArray<int64> GetMithrilInventoryOpened() const;
	int32 GetMoonInterationTime() const;
	double GetMouseSensitivityNonSmooth() const;
	bool GetMouseTargetingMethod() const;
	bool GetOpenOperationTips() const;
	ESocialPermission GetPrivateRoomInvitePermission() const;
	int32 GetPrivateRoomInvitePermissionIndex() const;
	TArray<int32> GetProcessingTaskIds(const class FString& LocalUserKey) const;
	bool GetShowAttributeRange() const;
	bool GetShowWeaponOperationTips() const;
	bool GetSquatDownMethod() const;
	bool GetSubtitlesEnabled() const;
	double GetTargetingMultiplierNonSmooth() const;
	bool GetTriggerHapticsEnabled() const;
	uint8 GetTriggerHapticStartPosition() const;
	uint8 GetTriggerHapticStrength() const;
	bool GetTriggerPullUsesHapticThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingsShared">();
	}
	static class ULyraSettingsShared* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingsShared>();
	}
};
static_assert(alignof(ULyraSettingsShared) == 0x000008, "Wrong alignment on ULyraSettingsShared");
static_assert(sizeof(ULyraSettingsShared) == 0x0001B0, "Wrong size on ULyraSettingsShared");
static_assert(offsetof(ULyraSettingsShared, ColorBlindMode) == 0x000040, "Member 'ULyraSettingsShared::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, ColorBlindStrength) == 0x000044, "Member 'ULyraSettingsShared::ColorBlindStrength' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bForceFeedbackEnabled) == 0x000048, "Member 'ULyraSettingsShared::bForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadMoveStickDeadZone) == 0x00004C, "Member 'ULyraSettingsShared::GamepadMoveStickDeadZone' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadLookStickDeadZone) == 0x000050, "Member 'ULyraSettingsShared::GamepadLookStickDeadZone' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bTriggerHapticsEnabled) == 0x000054, "Member 'ULyraSettingsShared::bTriggerHapticsEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bTriggerPullUsesHapticThreshold) == 0x000055, "Member 'ULyraSettingsShared::bTriggerPullUsesHapticThreshold' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, TriggerHapticStrength) == 0x000056, "Member 'ULyraSettingsShared::TriggerHapticStrength' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, TriggerHapticStartPosition) == 0x000057, "Member 'ULyraSettingsShared::TriggerHapticStartPosition' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bEnableSubtitles) == 0x000058, "Member 'ULyraSettingsShared::bEnableSubtitles' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, AllowAudioInBackground) == 0x000059, "Member 'ULyraSettingsShared::AllowAudioInBackground' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, PendingCulture) == 0x000060, "Member 'ULyraSettingsShared::PendingCulture' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, MouseSensitivity_NonSmooth) == 0x000078, "Member 'ULyraSettingsShared::MouseSensitivity_NonSmooth' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, TargetingMultiplier_NonSmooth) == 0x000080, "Member 'ULyraSettingsShared::TargetingMultiplier_NonSmooth' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bInvertVerticalAxis) == 0x000088, "Member 'ULyraSettingsShared::bInvertVerticalAxis' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bInvertHorizontalAxis) == 0x000089, "Member 'ULyraSettingsShared::bInvertHorizontalAxis' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bAllowTeamInvite) == 0x00008A, "Member 'ULyraSettingsShared::bAllowTeamInvite' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bAllowPrivateChat) == 0x00008B, "Member 'ULyraSettingsShared::bAllowPrivateChat' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bShowAttributeRange) == 0x00008C, "Member 'ULyraSettingsShared::bShowAttributeRange' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bOpenOperationTips) == 0x00008D, "Member 'ULyraSettingsShared::bOpenOperationTips' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bShowWeaponOperationTips) == 0x00008E, "Member 'ULyraSettingsShared::bShowWeaponOperationTips' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bInventorySee) == 0x00008F, "Member 'ULyraSettingsShared::bInventorySee' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, PrivateRoomInvitePermission) == 0x000090, "Member 'ULyraSettingsShared::PrivateRoomInvitePermission' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bChargeSkillMethod) == 0x000091, "Member 'ULyraSettingsShared::bChargeSkillMethod' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bSquatDownMethod) == 0x000092, "Member 'ULyraSettingsShared::bSquatDownMethod' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bMouseTargetingMethod) == 0x000093, "Member 'ULyraSettingsShared::bMouseTargetingMethod' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, InventoryAutoQuality) == 0x000098, "Member 'ULyraSettingsShared::InventoryAutoQuality' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, DailyLoginCheck) == 0x0000A8, "Member 'ULyraSettingsShared::DailyLoginCheck' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, MoonInterationTime) == 0x0000AC, "Member 'ULyraSettingsShared::MoonInterationTime' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, CheckedActivities) == 0x0000B0, "Member 'ULyraSettingsShared::CheckedActivities' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, AttributeTalents) == 0x0000C0, "Member 'ULyraSettingsShared::AttributeTalents' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, ProcessingTaskMap) == 0x0000D0, "Member 'ULyraSettingsShared::ProcessingTaskMap' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, InventoryOpened) == 0x000120, "Member 'ULyraSettingsShared::InventoryOpened' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, MithrilInventoryOpened) == 0x000130, "Member 'ULyraSettingsShared::MithrilInventoryOpened' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, InventoryTalentTips) == 0x000140, "Member 'ULyraSettingsShared::InventoryTalentTips' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, InventoryTalentTipsGuids) == 0x000190, "Member 'ULyraSettingsShared::InventoryTalentTipsGuids' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadLookSensitivityPreset) == 0x0001A0, "Member 'ULyraSettingsShared::GamepadLookSensitivityPreset' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadTargetingSensitivityPreset) == 0x0001A1, "Member 'ULyraSettingsShared::GamepadTargetingSensitivityPreset' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, OwningPlayer) == 0x0001A8, "Member 'ULyraSettingsShared::OwningPlayer' has a wrong offset!");

// Class LyraGame.LyraSafeZoneEditor
// 0x0050 (0x0438 - 0x03E8)
class ULyraSafeZoneEditor final : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_3E8[0x20];                                     // 0x03E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanCancel;                                        // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0xF];                                      // 0x0409(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        Switcher_SafeZoneMessage;                          // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonRichTextBlock*                   RichText_Default;                                  // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Back;                                       // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Done;                                       // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBackClicked();
	void HandleDoneClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSafeZoneEditor">();
	}
	static class ULyraSafeZoneEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSafeZoneEditor>();
	}
};
static_assert(alignof(ULyraSafeZoneEditor) == 0x000008, "Wrong alignment on ULyraSafeZoneEditor");
static_assert(sizeof(ULyraSafeZoneEditor) == 0x000438, "Wrong size on ULyraSafeZoneEditor");
static_assert(offsetof(ULyraSafeZoneEditor, bCanCancel) == 0x000408, "Member 'ULyraSafeZoneEditor::bCanCancel' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, Switcher_SafeZoneMessage) == 0x000418, "Member 'ULyraSafeZoneEditor::Switcher_SafeZoneMessage' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, RichText_Default) == 0x000420, "Member 'ULyraSafeZoneEditor::RichText_Default' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, Button_Back) == 0x000428, "Member 'ULyraSafeZoneEditor::Button_Back' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, Button_Done) == 0x000430, "Member 'ULyraSafeZoneEditor::Button_Done' has a wrong offset!");

// Class LyraGame.TgfActorStatisticComponent
// 0x01E8 (0x0290 - 0x00A8)
class UTgfActorStatisticComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A8[0x1E0];                                     // 0x00A8(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class ALyraPlayerState*                       PlayerState;                                       // 0x0288(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddFloatStat(ETgfActorFloatStatisticType Type, double Value);
	void AddIntStat(ETgfActorIntStatisticType Type, int32 TypeId, int32 Value);
	void AddRelationIntStat(ETgfActorRelationStatisticType Type, const class FString& OpenID, int32 Value);
	void FillOssLogPlayerInteraction(class ALyraCharacter* SourceCharacter, const class FString& InHandleTargetName, const struct FVector& InHandleLocation, int32 ItemId);
	double GetFloatStat(ETgfActorFloatStatisticType Type);
	int32 GetIntStat(ETgfActorIntStatisticType Type, int32 TypeId);
	int32 GetRelationIntStat(ETgfActorRelationStatisticType Type, const class FString& OpenID);
	void RefreshStartTime();
	void SetFloatStat(ETgfActorFloatStatisticType Type, double Value);
	void SetIntStat(ETgfActorIntStatisticType Type, int32 TypeId, int32 Value);
	void SetRelationIntStat(ETgfActorRelationStatisticType Type, const class FString& OpenID, int32 Value);
	void UpdateAlivingTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfActorStatisticComponent">();
	}
	static class UTgfActorStatisticComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfActorStatisticComponent>();
	}
};
static_assert(alignof(UTgfActorStatisticComponent) == 0x000008, "Wrong alignment on UTgfActorStatisticComponent");
static_assert(sizeof(UTgfActorStatisticComponent) == 0x000290, "Wrong size on UTgfActorStatisticComponent");
static_assert(offsetof(UTgfActorStatisticComponent, PlayerState) == 0x000288, "Member 'UTgfActorStatisticComponent::PlayerState' has a wrong offset!");

// Class LyraGame.LyraActorUtilities
// 0x0000 (0x0028 - 0x0028)
class ULyraActorUtilities final : public UBlueprintFunctionLibrary
{
public:
	static EBlueprintExposedNetMode SwitchOnNetMode(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraActorUtilities">();
	}
	static class ULyraActorUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraActorUtilities>();
	}
};
static_assert(alignof(ULyraActorUtilities) == 0x000008, "Wrong alignment on ULyraActorUtilities");
static_assert(sizeof(ULyraActorUtilities) == 0x000028, "Wrong size on ULyraActorUtilities");

// Class LyraGame.LyraGameData
// 0x0090 (0x00C0 - 0x0030)
class ULyraGameData final : public UPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DamageGameplayEffect_SetByCaller;                  // 0x0030(0x0030)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HealGameplayEffect_SetByCaller;                    // 0x0060(0x0030)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DynamicTagGameplayEffect;                          // 0x0090(0x0030)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameData">();
	}
	static class ULyraGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameData>();
	}
};
static_assert(alignof(ULyraGameData) == 0x000008, "Wrong alignment on ULyraGameData");
static_assert(sizeof(ULyraGameData) == 0x0000C0, "Wrong size on ULyraGameData");
static_assert(offsetof(ULyraGameData, DamageGameplayEffect_SetByCaller) == 0x000030, "Member 'ULyraGameData::DamageGameplayEffect_SetByCaller' has a wrong offset!");
static_assert(offsetof(ULyraGameData, HealGameplayEffect_SetByCaller) == 0x000060, "Member 'ULyraGameData::HealGameplayEffect_SetByCaller' has a wrong offset!");
static_assert(offsetof(ULyraGameData, DynamicTagGameplayEffect) == 0x000090, "Member 'ULyraGameData::DynamicTagGameplayEffect' has a wrong offset!");

// Class LyraGame.LyraGameEngine
// 0x0000 (0x1000 - 0x1000)
class ULyraGameEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameEngine">();
	}
	static class ULyraGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameEngine>();
	}
};
static_assert(alignof(ULyraGameEngine) == 0x000008, "Wrong alignment on ULyraGameEngine");
static_assert(sizeof(ULyraGameEngine) == 0x001000, "Wrong size on ULyraGameEngine");

// Class LyraGame.LyraGameSession
// 0x0000 (0x02B0 - 0x02B0)
class ALyraGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameSession">();
	}
	static class ALyraGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraGameSession>();
	}
};
static_assert(alignof(ALyraGameSession) == 0x000008, "Wrong alignment on ALyraGameSession");
static_assert(sizeof(ALyraGameSession) == 0x0002B0, "Wrong size on ALyraGameSession");

// Class LyraGame.LyraSystemStatics
// 0x0000 (0x0028 - 0x0028)
class ULyraSystemStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UActorComponent*> FindComponentsByClass(class AActor* TargetActor, TSubclassOf<class UActorComponent> ComponentClass, bool bIncludeChildActors);
	static struct FPrimaryAssetId GetPrimaryAssetIdFromUserFacingExperienceName(const class FString& AdvertisedExperienceID);
	static TSoftObjectPtr<class UObject> GetTypedSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId, TSubclassOf<class UObject> ExpectedAssetType);
	static void PlayNextGame(const class UObject* WorldContextObject);
	static void SetColorParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const struct FLinearColor& ParameterValue, bool bIncludeChildActors);
	static void SetScalarParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const float ParameterValue, bool bIncludeChildActors);
	static void SetVectorParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const struct FVector& ParameterValue, bool bIncludeChildActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSystemStatics">();
	}
	static class ULyraSystemStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSystemStatics>();
	}
};
static_assert(alignof(ULyraSystemStatics) == 0x000008, "Wrong alignment on ULyraSystemStatics");
static_assert(sizeof(ULyraSystemStatics) == 0x000028, "Wrong size on ULyraSystemStatics");

// Class LyraGame.AsyncAction_ObserveTeam
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_ObserveTeam final : public UCancellableAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_ObserveTeam* ObserveTeam(class UObject* TeamAgent);

	void OnWatchedAgentChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_ObserveTeam">();
	}
	static class UAsyncAction_ObserveTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_ObserveTeam>();
	}
};
static_assert(alignof(UAsyncAction_ObserveTeam) == 0x000008, "Wrong alignment on UAsyncAction_ObserveTeam");
static_assert(sizeof(UAsyncAction_ObserveTeam) == 0x000050, "Wrong size on UAsyncAction_ObserveTeam");
static_assert(offsetof(UAsyncAction_ObserveTeam, OnTeamChanged) == 0x000030, "Member 'UAsyncAction_ObserveTeam::OnTeamChanged' has a wrong offset!");

// Class LyraGame.LyraTeamCheats
// 0x0000 (0x0028 - 0x0028)
class ULyraTeamCheats final : public UCheatManagerExtension
{
public:
	void CycleTeam();
	void ListTeams();
	void SetTeam(int32 TeamId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamCheats">();
	}
	static class ULyraTeamCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTeamCheats>();
	}
};
static_assert(alignof(ULyraTeamCheats) == 0x000008, "Wrong alignment on ULyraTeamCheats");
static_assert(sizeof(ULyraTeamCheats) == 0x000028, "Wrong size on ULyraTeamCheats");

// Class LyraGame.LyraTeamDisplayAsset
// 0x0108 (0x0138 - 0x0030)
class ULyraTeamDisplayAsset final : public UDataAsset
{
public:
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        ColorParameters;                                   // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UTexture*>            TextureParameters;                                 // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   TeamShortName;                                     // 0x0120(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void ApplyToActor(class AActor* TargetActor, bool bIncludeChildActors);
	void ApplyToMaterial(class UMaterialInstanceDynamic* Material);
	void ApplyToMeshComponent(class UMeshComponent* MeshComponent);
	void ApplyToNiagaraComponent(class UNiagaraComponent* NiagaraComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamDisplayAsset">();
	}
	static class ULyraTeamDisplayAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTeamDisplayAsset>();
	}
};
static_assert(alignof(ULyraTeamDisplayAsset) == 0x000008, "Wrong alignment on ULyraTeamDisplayAsset");
static_assert(sizeof(ULyraTeamDisplayAsset) == 0x000138, "Wrong size on ULyraTeamDisplayAsset");
static_assert(offsetof(ULyraTeamDisplayAsset, ScalarParameters) == 0x000030, "Member 'ULyraTeamDisplayAsset::ScalarParameters' has a wrong offset!");
static_assert(offsetof(ULyraTeamDisplayAsset, ColorParameters) == 0x000080, "Member 'ULyraTeamDisplayAsset::ColorParameters' has a wrong offset!");
static_assert(offsetof(ULyraTeamDisplayAsset, TextureParameters) == 0x0000D0, "Member 'ULyraTeamDisplayAsset::TextureParameters' has a wrong offset!");
static_assert(offsetof(ULyraTeamDisplayAsset, TeamShortName) == 0x000120, "Member 'ULyraTeamDisplayAsset::TeamShortName' has a wrong offset!");

// Class LyraGame.LyraTeamPrivateInfo
// 0x0000 (0x0408 - 0x0408)
class ALyraTeamPrivateInfo final : public ALyraTeamInfoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamPrivateInfo">();
	}
	static class ALyraTeamPrivateInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraTeamPrivateInfo>();
	}
};
static_assert(alignof(ALyraTeamPrivateInfo) == 0x000008, "Wrong alignment on ALyraTeamPrivateInfo");
static_assert(sizeof(ALyraTeamPrivateInfo) == 0x000408, "Wrong size on ALyraTeamPrivateInfo");

// Class LyraGame.LyraTeamStatics
// 0x0000 (0x0028 - 0x0028)
class ULyraTeamStatics final : public UBlueprintFunctionLibrary
{
public:
	static void FindTeamFromObject(const class UObject* Agent, bool* bIsPartOfTeam, int32* TeamId, class ULyraTeamDisplayAsset** DisplayAsset, bool bLogIfNotSet);
	static struct FLinearColor GetTeamColorWithFallback(class ULyraTeamDisplayAsset* DisplayAsset, class FName ParameterName, const struct FLinearColor& DefaultValue);
	static class ULyraTeamDisplayAsset* GetTeamDisplayAsset(const class UObject* WorldContextObject, int32 TeamId);
	static float GetTeamScalarWithFallback(class ULyraTeamDisplayAsset* DisplayAsset, class FName ParameterName, float DefaultValue);
	static class UTexture* GetTeamTextureWithFallback(class ULyraTeamDisplayAsset* DisplayAsset, class FName ParameterName, class UTexture* DefaultValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamStatics">();
	}
	static class ULyraTeamStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTeamStatics>();
	}
};
static_assert(alignof(ULyraTeamStatics) == 0x000008, "Wrong alignment on ULyraTeamStatics");
static_assert(sizeof(ULyraTeamStatics) == 0x000028, "Wrong size on ULyraTeamStatics");

// Class LyraGame.LyraTestControllerBootTest
// 0x0008 (0x0038 - 0x0030)
class ULyraTestControllerBootTest final : public UGauntletTestControllerBootTest
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTestControllerBootTest">();
	}
	static class ULyraTestControllerBootTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTestControllerBootTest>();
	}
};
static_assert(alignof(ULyraTestControllerBootTest) == 0x000008, "Wrong alignment on ULyraTestControllerBootTest");
static_assert(sizeof(ULyraTestControllerBootTest) == 0x000038, "Wrong size on ULyraTestControllerBootTest");

// Class LyraGame.LyraBoundActionButton
// 0x0010 (0x1540 - 0x1530)
class ULyraBoundActionButton final : public UCommonBoundActionButton
{
public:
	TSubclassOf<class UCommonButtonStyle>         KeyboardStyle;                                     // 0x1528(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommonButtonStyle>         GamepadStyle;                                      // 0x1530(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommonButtonStyle>         TouchStyle;                                        // 0x1538(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraBoundActionButton">();
	}
	static class ULyraBoundActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraBoundActionButton>();
	}
};
static_assert(alignof(ULyraBoundActionButton) == 0x000010, "Wrong alignment on ULyraBoundActionButton");
static_assert(sizeof(ULyraBoundActionButton) == 0x001540, "Wrong size on ULyraBoundActionButton");
static_assert(offsetof(ULyraBoundActionButton, KeyboardStyle) == 0x001528, "Member 'ULyraBoundActionButton::KeyboardStyle' has a wrong offset!");
static_assert(offsetof(ULyraBoundActionButton, GamepadStyle) == 0x001530, "Member 'ULyraBoundActionButton::GamepadStyle' has a wrong offset!");
static_assert(offsetof(ULyraBoundActionButton, TouchStyle) == 0x001538, "Member 'ULyraBoundActionButton::TouchStyle' has a wrong offset!");

// Class LyraGame.LyraTabButtonInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraTabButtonInterface final : public IInterface
{
public:
	void SetTabLabelInfo(const struct FLyraTabDescriptor& TabDescriptor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTabButtonInterface">();
	}
	static class ILyraTabButtonInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraTabButtonInterface>();
	}
};
static_assert(alignof(ILyraTabButtonInterface) == 0x000008, "Wrong alignment on ILyraTabButtonInterface");
static_assert(sizeof(ILyraTabButtonInterface) == 0x000028, "Wrong size on ILyraTabButtonInterface");

// Class LyraGame.LyraWidgetFactory
// 0x0000 (0x0028 - 0x0028)
class ULyraWidgetFactory : public UObject
{
public:
	TSubclassOf<class UUserWidget> FindWidgetClassForData(const class UObject* Data) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWidgetFactory">();
	}
	static class ULyraWidgetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWidgetFactory>();
	}
};
static_assert(alignof(ULyraWidgetFactory) == 0x000008, "Wrong alignment on ULyraWidgetFactory");
static_assert(sizeof(ULyraWidgetFactory) == 0x000028, "Wrong size on ULyraWidgetFactory");

// Class LyraGame.LyraWidgetFactory_Class
// 0x0050 (0x0078 - 0x0028)
class ULyraWidgetFactory_Class final : public ULyraWidgetFactory
{
public:
	TMap<TSoftClassPtr<class UClass>, TSubclassOf<class UUserWidget>> EntryWidgetForClass;                               // 0x0028(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWidgetFactory_Class">();
	}
	static class ULyraWidgetFactory_Class* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWidgetFactory_Class>();
	}
};
static_assert(alignof(ULyraWidgetFactory_Class) == 0x000008, "Wrong alignment on ULyraWidgetFactory_Class");
static_assert(sizeof(ULyraWidgetFactory_Class) == 0x000078, "Wrong size on ULyraWidgetFactory_Class");
static_assert(offsetof(ULyraWidgetFactory_Class, EntryWidgetForClass) == 0x000028, "Member 'ULyraWidgetFactory_Class::EntryWidgetForClass' has a wrong offset!");

// Class LyraGame.LyraConfirmationScreen
// 0x0040 (0x0428 - 0x03E8)
class ULyraConfirmationScreen final : public UCommonGameDialog
{
public:
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonTextBlock*                       Text_Title;                                        // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonRichTextBlock*                   RichText_Description;                              // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicEntryBox*                       EntryBox_Buttons;                                  // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonBorder*                          Border_TapToCloseZone;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    CancelAction;                                      // 0x0418(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	struct FEventReply HandleTapToCloseZoneMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraConfirmationScreen">();
	}
	static class ULyraConfirmationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraConfirmationScreen>();
	}
};
static_assert(alignof(ULyraConfirmationScreen) == 0x000008, "Wrong alignment on ULyraConfirmationScreen");
static_assert(sizeof(ULyraConfirmationScreen) == 0x000428, "Wrong size on ULyraConfirmationScreen");
static_assert(offsetof(ULyraConfirmationScreen, Text_Title) == 0x0003F8, "Member 'ULyraConfirmationScreen::Text_Title' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, RichText_Description) == 0x000400, "Member 'ULyraConfirmationScreen::RichText_Description' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, EntryBox_Buttons) == 0x000408, "Member 'ULyraConfirmationScreen::EntryBox_Buttons' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, Border_TapToCloseZone) == 0x000410, "Member 'ULyraConfirmationScreen::Border_TapToCloseZone' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, CancelAction) == 0x000418, "Member 'ULyraConfirmationScreen::CancelAction' has a wrong offset!");

// Class LyraGame.LyraLoadingScreenSubsystem
// 0x0018 (0x0048 - 0x0030)
class ULyraLoadingScreenSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLoadingScreenWidgetChanged;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                LoadingScreenWidgetClass;                          // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetLoadingScreenContentWidget(TSubclassOf<class UUserWidget> NewWidgetClass);

	TSubclassOf<class UUserWidget> GetLoadingScreenContentWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraLoadingScreenSubsystem">();
	}
	static class ULyraLoadingScreenSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraLoadingScreenSubsystem>();
	}
};
static_assert(alignof(ULyraLoadingScreenSubsystem) == 0x000008, "Wrong alignment on ULyraLoadingScreenSubsystem");
static_assert(sizeof(ULyraLoadingScreenSubsystem) == 0x000048, "Wrong size on ULyraLoadingScreenSubsystem");
static_assert(offsetof(ULyraLoadingScreenSubsystem, OnLoadingScreenWidgetChanged) == 0x000030, "Member 'ULyraLoadingScreenSubsystem::OnLoadingScreenWidgetChanged' has a wrong offset!");
static_assert(offsetof(ULyraLoadingScreenSubsystem, LoadingScreenWidgetClass) == 0x000040, "Member 'ULyraLoadingScreenSubsystem::LoadingScreenWidgetClass' has a wrong offset!");

// Class LyraGame.ApplyFrontendPerfSettingsAction
// 0x0000 (0x0028 - 0x0028)
class UApplyFrontendPerfSettingsAction final : public UGameFeatureAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplyFrontendPerfSettingsAction">();
	}
	static class UApplyFrontendPerfSettingsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplyFrontendPerfSettingsAction>();
	}
};
static_assert(alignof(UApplyFrontendPerfSettingsAction) == 0x000008, "Wrong alignment on UApplyFrontendPerfSettingsAction");
static_assert(sizeof(UApplyFrontendPerfSettingsAction) == 0x000028, "Wrong size on UApplyFrontendPerfSettingsAction");

// Class LyraGame.LyraFrontendStateComponent
// 0x0098 (0x0140 - 0x00A8)
class ULyraFrontendStateComponent final : public UGameStateComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PressStartScreenClass;                             // 0x00B8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   MainScreenClass;                                   // 0x00E8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x28];                                     // 0x0118(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraFrontendStateComponent">();
	}
	static class ULyraFrontendStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraFrontendStateComponent>();
	}
};
static_assert(alignof(ULyraFrontendStateComponent) == 0x000008, "Wrong alignment on ULyraFrontendStateComponent");
static_assert(sizeof(ULyraFrontendStateComponent) == 0x000140, "Wrong size on ULyraFrontendStateComponent");
static_assert(offsetof(ULyraFrontendStateComponent, PressStartScreenClass) == 0x0000B8, "Member 'ULyraFrontendStateComponent::PressStartScreenClass' has a wrong offset!");
static_assert(offsetof(ULyraFrontendStateComponent, MainScreenClass) == 0x0000E8, "Member 'ULyraFrontendStateComponent::MainScreenClass' has a wrong offset!");

// Class LyraGame.LyraLobbyBackground
// 0x0030 (0x0060 - 0x0030)
class ULyraLobbyBackground final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  BackgroundLevel;                                   // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraLobbyBackground">();
	}
	static class ULyraLobbyBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraLobbyBackground>();
	}
};
static_assert(alignof(ULyraLobbyBackground) == 0x000008, "Wrong alignment on ULyraLobbyBackground");
static_assert(sizeof(ULyraLobbyBackground) == 0x000060, "Wrong size on ULyraLobbyBackground");
static_assert(offsetof(ULyraLobbyBackground, BackgroundLevel) == 0x000030, "Member 'ULyraLobbyBackground::BackgroundLevel' has a wrong offset!");

// Class LyraGame.IndicatorDescriptor
// 0x00C8 (0x00F0 - 0x0028)
class UIndicatorDescriptor final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bVisible;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClampToScreen;                                    // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowClampToScreenArrow;                           // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideScreenPosition;                           // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoRemoveWhenIndicatorComponentIsNull;           // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EActorCanvasProjectionMode                    ProjectionMode;                                    // 0x0035(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHorizontalAlignment                          HAlignment;                                        // 0x0036(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVerticalAlignment                            VAlignment;                                        // 0x0037(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Priority;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundingBoxAnchor;                                 // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ScreenSpaceOffset;                                 // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldPositionOffset;                               // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                DataObject;                                        // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        Component;                                         // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ComponentSocketName;                               // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   IndicatorWidgetClass;                              // 0x0098(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ULyraIndicatorManagerComponent> ManagerPtr;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoRemoveWhenIndicatorComponentIsNull(bool CanAutomaticallyRemove);
	void SetBoundingBoxAnchor(const struct FVector& InBoundingBoxAnchor);
	void SetClampToScreen(bool bValue);
	void SetComponentSocketName(class FName SocketName);
	void SetDataObject(class UObject* InDataObject);
	void SetDesiredVisibility(bool InVisible);
	void SetHAlign(EHorizontalAlignment InHAlignment);
	void SetIndicatorClass(TSoftClassPtr<class UClass> InIndicatorWidgetClass);
	void SetPriority(int32 InPriority);
	void SetProjectionMode(EActorCanvasProjectionMode InProjectionMode);
	void SetSceneComponent(class USceneComponent* InComponent);
	void SetScreenSpaceOffset(const struct FVector2D& Offset);
	void SetShowClampToScreenArrow(bool bValue);
	void SetVAlign(EVerticalAlignment InVAlignment);
	void SetWorldPositionOffset(const struct FVector& Offset);
	void UnregisterIndicator();

	bool GetAutoRemoveWhenIndicatorComponentIsNull() const;
	struct FVector GetBoundingBoxAnchor() const;
	bool GetClampToScreen() const;
	class FName GetComponentSocketName() const;
	class UObject* GetDataObject() const;
	EHorizontalAlignment GetHAlign() const;
	TSoftClassPtr<class UClass> GetIndicatorClass() const;
	bool GetIsVisible() const;
	int32 GetPriority() const;
	EActorCanvasProjectionMode GetProjectionMode() const;
	class USceneComponent* GetSceneComponent() const;
	struct FVector2D GetScreenSpaceOffset() const;
	bool GetShowClampToScreenArrow() const;
	EVerticalAlignment GetVAlign() const;
	struct FVector GetWorldPositionOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorDescriptor">();
	}
	static class UIndicatorDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIndicatorDescriptor>();
	}
};
static_assert(alignof(UIndicatorDescriptor) == 0x000008, "Wrong alignment on UIndicatorDescriptor");
static_assert(sizeof(UIndicatorDescriptor) == 0x0000F0, "Wrong size on UIndicatorDescriptor");
static_assert(offsetof(UIndicatorDescriptor, bVisible) == 0x000030, "Member 'UIndicatorDescriptor::bVisible' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bClampToScreen) == 0x000031, "Member 'UIndicatorDescriptor::bClampToScreen' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bShowClampToScreenArrow) == 0x000032, "Member 'UIndicatorDescriptor::bShowClampToScreenArrow' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bOverrideScreenPosition) == 0x000033, "Member 'UIndicatorDescriptor::bOverrideScreenPosition' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bAutoRemoveWhenIndicatorComponentIsNull) == 0x000034, "Member 'UIndicatorDescriptor::bAutoRemoveWhenIndicatorComponentIsNull' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ProjectionMode) == 0x000035, "Member 'UIndicatorDescriptor::ProjectionMode' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, HAlignment) == 0x000036, "Member 'UIndicatorDescriptor::HAlignment' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, VAlignment) == 0x000037, "Member 'UIndicatorDescriptor::VAlignment' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, Priority) == 0x000038, "Member 'UIndicatorDescriptor::Priority' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, BoundingBoxAnchor) == 0x000040, "Member 'UIndicatorDescriptor::BoundingBoxAnchor' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ScreenSpaceOffset) == 0x000058, "Member 'UIndicatorDescriptor::ScreenSpaceOffset' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, WorldPositionOffset) == 0x000068, "Member 'UIndicatorDescriptor::WorldPositionOffset' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, DataObject) == 0x000080, "Member 'UIndicatorDescriptor::DataObject' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, Component) == 0x000088, "Member 'UIndicatorDescriptor::Component' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ComponentSocketName) == 0x000090, "Member 'UIndicatorDescriptor::ComponentSocketName' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, IndicatorWidgetClass) == 0x000098, "Member 'UIndicatorDescriptor::IndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ManagerPtr) == 0x0000C8, "Member 'UIndicatorDescriptor::ManagerPtr' has a wrong offset!");

// Class LyraGame.IndicatorLibrary
// 0x0000 (0x0028 - 0x0028)
class UIndicatorLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ULyraIndicatorManagerComponent* GetIndicatorManagerComponent(class AController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorLibrary">();
	}
	static class UIndicatorLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIndicatorLibrary>();
	}
};
static_assert(alignof(UIndicatorLibrary) == 0x000008, "Wrong alignment on UIndicatorLibrary");
static_assert(sizeof(UIndicatorLibrary) == 0x000028, "Wrong size on UIndicatorLibrary");

// Class LyraGame.LyraGameViewportClient
// 0x0000 (0x03E0 - 0x03E0)
class ULyraGameViewportClient final : public UCommonGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameViewportClient">();
	}
	static class ULyraGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameViewportClient>();
	}
};
static_assert(alignof(ULyraGameViewportClient) == 0x000008, "Wrong alignment on ULyraGameViewportClient");
static_assert(sizeof(ULyraGameViewportClient) == 0x0003E0, "Wrong size on ULyraGameViewportClient");

// Class LyraGame.LyraHUDLayout
// 0x0030 (0x0420 - 0x03F0)
class ULyraHUDLayout final : public ULyraActivatableWidget
{
public:
	TSoftClassPtr<class UClass>                   EscapeMenuClass;                                   // 0x03F0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHUDLayout">();
	}
	static class ULyraHUDLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHUDLayout>();
	}
};
static_assert(alignof(ULyraHUDLayout) == 0x000008, "Wrong alignment on ULyraHUDLayout");
static_assert(sizeof(ULyraHUDLayout) == 0x000420, "Wrong size on ULyraHUDLayout");
static_assert(offsetof(ULyraHUDLayout, EscapeMenuClass) == 0x0003F0, "Member 'ULyraHUDLayout::EscapeMenuClass' has a wrong offset!");

// Class LyraGame.LyraJoystickWidget
// 0x0040 (0x0338 - 0x02F8)
class ULyraJoystickWidget final : public ULyraSimulatedInputWidget
{
public:
	float                                         StickRange;                                        // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 JoystickBackground;                                // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 JoystickForeground;                                // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNegateYAxis;                                      // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TouchOrigin;                                       // 0x0318(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              StickVector;                                       // 0x0328(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateSitckVector(const struct FVector2D& MoveStickOffset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraJoystickWidget">();
	}
	static class ULyraJoystickWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraJoystickWidget>();
	}
};
static_assert(alignof(ULyraJoystickWidget) == 0x000008, "Wrong alignment on ULyraJoystickWidget");
static_assert(sizeof(ULyraJoystickWidget) == 0x000338, "Wrong size on ULyraJoystickWidget");
static_assert(offsetof(ULyraJoystickWidget, StickRange) == 0x0002F8, "Member 'ULyraJoystickWidget::StickRange' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, JoystickBackground) == 0x000300, "Member 'ULyraJoystickWidget::JoystickBackground' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, JoystickForeground) == 0x000308, "Member 'ULyraJoystickWidget::JoystickForeground' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, bNegateYAxis) == 0x000310, "Member 'ULyraJoystickWidget::bNegateYAxis' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, TouchOrigin) == 0x000318, "Member 'ULyraJoystickWidget::TouchOrigin' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, StickVector) == 0x000328, "Member 'ULyraJoystickWidget::StickVector' has a wrong offset!");

// Class LyraGame.LyraTouchRegion
// 0x0008 (0x0300 - 0x02F8)
class ULyraTouchRegion final : public ULyraSimulatedInputWidget
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldSimulateInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTouchRegion">();
	}
	static class ULyraTouchRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTouchRegion>();
	}
};
static_assert(alignof(ULyraTouchRegion) == 0x000008, "Wrong alignment on ULyraTouchRegion");
static_assert(sizeof(ULyraTouchRegion) == 0x000300, "Wrong size on ULyraTouchRegion");

// Class LyraGame.LyraPerfStatWidgetBase
// 0x0010 (0x02D0 - 0x02C0)
class ULyraPerfStatWidgetBase final : public UCommonUserWidget
{
public:
	class ULyraPerformanceStatSubsystem*          CachedStatSubsystem;                               // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELyraDisplayablePerformanceStat               StatToDisplay;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double FetchStatValue();

	ELyraDisplayablePerformanceStat GetStatToDisplay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerfStatWidgetBase">();
	}
	static class ULyraPerfStatWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerfStatWidgetBase>();
	}
};
static_assert(alignof(ULyraPerfStatWidgetBase) == 0x000008, "Wrong alignment on ULyraPerfStatWidgetBase");
static_assert(sizeof(ULyraPerfStatWidgetBase) == 0x0002D0, "Wrong size on ULyraPerfStatWidgetBase");
static_assert(offsetof(ULyraPerfStatWidgetBase, CachedStatSubsystem) == 0x0002C0, "Member 'ULyraPerfStatWidgetBase::CachedStatSubsystem' has a wrong offset!");
static_assert(offsetof(ULyraPerfStatWidgetBase, StatToDisplay) == 0x0002C8, "Member 'ULyraPerfStatWidgetBase::StatToDisplay' has a wrong offset!");

// Class LyraGame.LyraUIMessaging
// 0x0070 (0x00A0 - 0x0030)
class ULyraUIMessaging final : public UCommonMessagingSubsystem
{
public:
	TSubclassOf<class UCommonGameDialog>          ConfirmationDialogClassPtr;                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommonGameDialog>          ErrorDialogClassPtr;                               // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ConfirmationDialogClass;                           // 0x0040(0x0030)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ErrorDialogClass;                                  // 0x0070(0x0030)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUIMessaging">();
	}
	static class ULyraUIMessaging* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUIMessaging>();
	}
};
static_assert(alignof(ULyraUIMessaging) == 0x000008, "Wrong alignment on ULyraUIMessaging");
static_assert(sizeof(ULyraUIMessaging) == 0x0000A0, "Wrong size on ULyraUIMessaging");
static_assert(offsetof(ULyraUIMessaging, ConfirmationDialogClassPtr) == 0x000030, "Member 'ULyraUIMessaging::ConfirmationDialogClassPtr' has a wrong offset!");
static_assert(offsetof(ULyraUIMessaging, ErrorDialogClassPtr) == 0x000038, "Member 'ULyraUIMessaging::ErrorDialogClassPtr' has a wrong offset!");
static_assert(offsetof(ULyraUIMessaging, ConfirmationDialogClass) == 0x000040, "Member 'ULyraUIMessaging::ConfirmationDialogClass' has a wrong offset!");
static_assert(offsetof(ULyraUIMessaging, ErrorDialogClass) == 0x000070, "Member 'ULyraUIMessaging::ErrorDialogClass' has a wrong offset!");

// Class LyraGame.HitMarkerConfirmationWidget
// 0x0210 (0x0360 - 0x0150)
class UHitMarkerConfirmationWidget final : public UWidget
{
public:
	float                                         HitNotifyDuration;                                 // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            PerHitMarkerImage;                                 // 0x0160(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FSlateBrush> PerHitMarkerZoneOverrideImages;                    // 0x0230(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            AnyHitsMarkerImage;                                // 0x0280(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMarkerConfirmationWidget">();
	}
	static class UHitMarkerConfirmationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMarkerConfirmationWidget>();
	}
};
static_assert(alignof(UHitMarkerConfirmationWidget) == 0x000010, "Wrong alignment on UHitMarkerConfirmationWidget");
static_assert(sizeof(UHitMarkerConfirmationWidget) == 0x000360, "Wrong size on UHitMarkerConfirmationWidget");
static_assert(offsetof(UHitMarkerConfirmationWidget, HitNotifyDuration) == 0x000150, "Member 'UHitMarkerConfirmationWidget::HitNotifyDuration' has a wrong offset!");
static_assert(offsetof(UHitMarkerConfirmationWidget, PerHitMarkerImage) == 0x000160, "Member 'UHitMarkerConfirmationWidget::PerHitMarkerImage' has a wrong offset!");
static_assert(offsetof(UHitMarkerConfirmationWidget, PerHitMarkerZoneOverrideImages) == 0x000230, "Member 'UHitMarkerConfirmationWidget::PerHitMarkerZoneOverrideImages' has a wrong offset!");
static_assert(offsetof(UHitMarkerConfirmationWidget, AnyHitsMarkerImage) == 0x000280, "Member 'UHitMarkerConfirmationWidget::AnyHitsMarkerImage' has a wrong offset!");

// Class LyraGame.LyraWeaponUserInterface
// 0x0008 (0x02C8 - 0x02C0)
class ULyraWeaponUserInterface final : public UCommonUserWidget
{
public:
	class ULyraWeaponInstance*                    CurrentInstance;                                   // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnWeaponChanged(class ULyraWeaponInstance* OldWeapon, class ULyraWeaponInstance* NewWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponUserInterface">();
	}
	static class ULyraWeaponUserInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWeaponUserInterface>();
	}
};
static_assert(alignof(ULyraWeaponUserInterface) == 0x000008, "Wrong alignment on ULyraWeaponUserInterface");
static_assert(sizeof(ULyraWeaponUserInterface) == 0x0002C8, "Wrong size on ULyraWeaponUserInterface");
static_assert(offsetof(ULyraWeaponUserInterface, CurrentInstance) == 0x0002C0, "Member 'ULyraWeaponUserInterface::CurrentInstance' has a wrong offset!");

// Class LyraGame.InventoryFragment_ReticleConfig
// 0x0010 (0x0038 - 0x0028)
class UInventoryFragment_ReticleConfig final : public ULyraInventoryItemFragment
{
public:
	TArray<TSubclassOf<class UTgfReticleWidgetBase>> ReticleWidgets;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFragment_ReticleConfig">();
	}
	static class UInventoryFragment_ReticleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFragment_ReticleConfig>();
	}
};
static_assert(alignof(UInventoryFragment_ReticleConfig) == 0x000008, "Wrong alignment on UInventoryFragment_ReticleConfig");
static_assert(sizeof(UInventoryFragment_ReticleConfig) == 0x000038, "Wrong size on UInventoryFragment_ReticleConfig");
static_assert(offsetof(UInventoryFragment_ReticleConfig, ReticleWidgets) == 0x000028, "Member 'UInventoryFragment_ReticleConfig::ReticleWidgets' has a wrong offset!");

// Class LyraGame.LyraGameplayAbility_RangedWeapon
// 0x0010 (0x0990 - 0x0980)
class ULyraGameplayAbility_RangedWeapon final : public UTgfGameplayAbility_FromEquipment
{
public:
	uint8                                         Pad_980[0x10];                                     // 0x0980(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRangedWeaponTargetDataReady(const struct FGameplayAbilityTargetDataHandle& TargetData);
	void StartRangedWeaponTargeting();

	class ULyraRangedWeaponInstance* GetWeaponInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayAbility_RangedWeapon">();
	}
	static class ULyraGameplayAbility_RangedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayAbility_RangedWeapon>();
	}
};
static_assert(alignof(ULyraGameplayAbility_RangedWeapon) == 0x000010, "Wrong alignment on ULyraGameplayAbility_RangedWeapon");
static_assert(sizeof(ULyraGameplayAbility_RangedWeapon) == 0x000990, "Wrong size on ULyraGameplayAbility_RangedWeapon");

// Class LyraGame.LyraWeaponInstance
// 0x0060 (0x0130 - 0x00D0)
class ULyraWeaponInstance : public ULyraEquipmentInstance
{
public:
	struct FLyraAnimLayerSelectionSet             EquippedAnimSet;                                   // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLyraAnimLayerSelectionSet             UneuippedAnimSet;                                  // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTgfWeaponEquipMontagesSet             EquipMontagesSet;                                  // 0x0100(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateFiringTime();

	float GetTimeSinceLastInteractedWith() const;
	TSubclassOf<class UAnimInstance> PickBestAnimLayer(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags) const;
	class UAnimMontage* PickBestEquipMontage(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponInstance">();
	}
	static class ULyraWeaponInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWeaponInstance>();
	}
};
static_assert(alignof(ULyraWeaponInstance) == 0x000008, "Wrong alignment on ULyraWeaponInstance");
static_assert(sizeof(ULyraWeaponInstance) == 0x000130, "Wrong size on ULyraWeaponInstance");
static_assert(offsetof(ULyraWeaponInstance, EquippedAnimSet) == 0x0000D0, "Member 'ULyraWeaponInstance::EquippedAnimSet' has a wrong offset!");
static_assert(offsetof(ULyraWeaponInstance, UneuippedAnimSet) == 0x0000E8, "Member 'ULyraWeaponInstance::UneuippedAnimSet' has a wrong offset!");
static_assert(offsetof(ULyraWeaponInstance, EquipMontagesSet) == 0x000100, "Member 'ULyraWeaponInstance::EquipMontagesSet' has a wrong offset!");

// Class LyraGame.LyraRangedWeaponInstance
// 0x02E0 (0x0410 - 0x0130)
class ULyraRangedWeaponInstance final : public ULyraWeaponInstance
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadExponent;                                    // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     HeatToSpreadCurve;                                 // 0x0140(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     HeatToHeatPerShotCurve;                            // 0x01C8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     HeatToCoolDownPerSecondCurve;                      // 0x0250(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpreadRecoveryCooldownDelay;                       // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowFirstShotAccuracy;                           // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadAngleMultiplier_Aiming;                      // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadAngleMultiplier_StandingStill;               // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionRate_StandingStill;                      // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingStillSpeedThreshold;                       // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingStillToMovingSpeedRange;                   // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadAngleMultiplier_Crouching;                   // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionRate_Crouching;                          // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadAngleMultiplier_JumpingOrFalling;            // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionRate_JumpingOrFalling;                   // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BulletsPerCartridge;                               // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDamageRange;                                    // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletTraceSweepRadius;                            // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     DistanceDamageFalloff;                             // 0x0310(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, float>              MaterialDamageMultiplier;                          // 0x0398(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraRangedWeaponInstance">();
	}
	static class ULyraRangedWeaponInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraRangedWeaponInstance>();
	}
};
static_assert(alignof(ULyraRangedWeaponInstance) == 0x000008, "Wrong alignment on ULyraRangedWeaponInstance");
static_assert(sizeof(ULyraRangedWeaponInstance) == 0x000410, "Wrong size on ULyraRangedWeaponInstance");
static_assert(offsetof(ULyraRangedWeaponInstance, SpreadExponent) == 0x000138, "Member 'ULyraRangedWeaponInstance::SpreadExponent' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, HeatToSpreadCurve) == 0x000140, "Member 'ULyraRangedWeaponInstance::HeatToSpreadCurve' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, HeatToHeatPerShotCurve) == 0x0001C8, "Member 'ULyraRangedWeaponInstance::HeatToHeatPerShotCurve' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, HeatToCoolDownPerSecondCurve) == 0x000250, "Member 'ULyraRangedWeaponInstance::HeatToCoolDownPerSecondCurve' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, SpreadRecoveryCooldownDelay) == 0x0002D8, "Member 'ULyraRangedWeaponInstance::SpreadRecoveryCooldownDelay' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, bAllowFirstShotAccuracy) == 0x0002DC, "Member 'ULyraRangedWeaponInstance::bAllowFirstShotAccuracy' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, SpreadAngleMultiplier_Aiming) == 0x0002E0, "Member 'ULyraRangedWeaponInstance::SpreadAngleMultiplier_Aiming' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, SpreadAngleMultiplier_StandingStill) == 0x0002E4, "Member 'ULyraRangedWeaponInstance::SpreadAngleMultiplier_StandingStill' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, TransitionRate_StandingStill) == 0x0002E8, "Member 'ULyraRangedWeaponInstance::TransitionRate_StandingStill' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, StandingStillSpeedThreshold) == 0x0002EC, "Member 'ULyraRangedWeaponInstance::StandingStillSpeedThreshold' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, StandingStillToMovingSpeedRange) == 0x0002F0, "Member 'ULyraRangedWeaponInstance::StandingStillToMovingSpeedRange' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, SpreadAngleMultiplier_Crouching) == 0x0002F4, "Member 'ULyraRangedWeaponInstance::SpreadAngleMultiplier_Crouching' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, TransitionRate_Crouching) == 0x0002F8, "Member 'ULyraRangedWeaponInstance::TransitionRate_Crouching' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, SpreadAngleMultiplier_JumpingOrFalling) == 0x0002FC, "Member 'ULyraRangedWeaponInstance::SpreadAngleMultiplier_JumpingOrFalling' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, TransitionRate_JumpingOrFalling) == 0x000300, "Member 'ULyraRangedWeaponInstance::TransitionRate_JumpingOrFalling' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, BulletsPerCartridge) == 0x000304, "Member 'ULyraRangedWeaponInstance::BulletsPerCartridge' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, MaxDamageRange) == 0x000308, "Member 'ULyraRangedWeaponInstance::MaxDamageRange' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, BulletTraceSweepRadius) == 0x00030C, "Member 'ULyraRangedWeaponInstance::BulletTraceSweepRadius' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, DistanceDamageFalloff) == 0x000310, "Member 'ULyraRangedWeaponInstance::DistanceDamageFalloff' has a wrong offset!");
static_assert(offsetof(ULyraRangedWeaponInstance, MaterialDamageMultiplier) == 0x000398, "Member 'ULyraRangedWeaponInstance::MaterialDamageMultiplier' has a wrong offset!");

// Class LyraGame.LyraWeaponSpawner
// 0x0048 (0x02E0 - 0x0298)
class ALyraWeaponSpawner final : public AActor
{
public:
	class ULyraWeaponPickupDefinition*            WeaponDefinition;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWeaponAvailable;                                // 0x02A0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownTime;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckExistingOverlapDelay;                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoolDownPercentage;                                // 0x02AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CollisionVolume;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PadMesh;                                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   WeaponMesh;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMeshRotationSpeed;                           // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x14];                                     // 0x02CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetDefaultStatFromItemDef(const TSubclassOf<class ULyraInventoryItemDefinition> WeaponItemClass, const struct FGameplayTag& StatTag);

	void AttemptPickUpWeapon(class APawn* Pawn);
	bool GiveWeapon(TSubclassOf<class ULyraInventoryItemDefinition> WeaponItemClass, class APawn* ReceivingPawn);
	void OnCoolDownTimerComplete();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepHitResult);
	void OnRep_WeaponAvailability();
	void PlayPickupEffects();
	void PlayRespawnEffects();
	void ResetCoolDown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWeaponSpawner">();
	}
	static class ALyraWeaponSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraWeaponSpawner>();
	}
};
static_assert(alignof(ALyraWeaponSpawner) == 0x000008, "Wrong alignment on ALyraWeaponSpawner");
static_assert(sizeof(ALyraWeaponSpawner) == 0x0002E0, "Wrong size on ALyraWeaponSpawner");
static_assert(offsetof(ALyraWeaponSpawner, WeaponDefinition) == 0x000298, "Member 'ALyraWeaponSpawner::WeaponDefinition' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, bIsWeaponAvailable) == 0x0002A0, "Member 'ALyraWeaponSpawner::bIsWeaponAvailable' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, CooldownTime) == 0x0002A4, "Member 'ALyraWeaponSpawner::CooldownTime' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, CheckExistingOverlapDelay) == 0x0002A8, "Member 'ALyraWeaponSpawner::CheckExistingOverlapDelay' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, CoolDownPercentage) == 0x0002AC, "Member 'ALyraWeaponSpawner::CoolDownPercentage' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, CollisionVolume) == 0x0002B0, "Member 'ALyraWeaponSpawner::CollisionVolume' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, PadMesh) == 0x0002B8, "Member 'ALyraWeaponSpawner::PadMesh' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, WeaponMesh) == 0x0002C0, "Member 'ALyraWeaponSpawner::WeaponMesh' has a wrong offset!");
static_assert(offsetof(ALyraWeaponSpawner, WeaponMeshRotationSpeed) == 0x0002C8, "Member 'ALyraWeaponSpawner::WeaponMeshRotationSpeed' has a wrong offset!");

// Class LyraGame.TgfWeaponAnimInstance
// 0x0000 (0x00E8 - 0x00E8)
class UTgfWeaponAnimInstance : public UTgfEquipmentInstance
{
public:
	void K2_OnRedrawWeapon();
	class UAnimMontage* PickBestWeaponInspectionAnimation(const struct FGameplayTagContainer& CosmeticTags);
	const class UAnimSequenceBase* PickIdleAnimation(const struct FGameplayTagContainer& CosmeticTags, bool* bIsRightIdle);

	TSubclassOf<class UAnimInstance> PickBestAnimLayer(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags) const;
	class UAnimMontage* PickBestEquipMontage(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags, bool* IsRight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWeaponAnimInstance">();
	}
	static class UTgfWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWeaponAnimInstance>();
	}
};
static_assert(alignof(UTgfWeaponAnimInstance) == 0x000008, "Wrong alignment on UTgfWeaponAnimInstance");
static_assert(sizeof(UTgfWeaponAnimInstance) == 0x0000E8, "Wrong size on UTgfWeaponAnimInstance");

// Class LyraGame.TgfWeaponInstance
// 0x0008 (0x00F0 - 0x00E8)
class UTgfWeaponInstance : public UTgfEquipmentInstance
{
public:
	ETgfStencilRef                                StencilRef;                                        // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfWeaponEquipType                           SkillEquipType;                                    // 0x00E9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWeaponHeld();
	void SetWeaponUnHeld();

	int32 GetAmmoCanAdd() const;
	int32 GetLeftAmmo() const;
	ETgfWeaponEquipType GetSkillEquipType() const;
	ETgfStencilRef GetStencilDef() const;
	bool IsHeld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfWeaponInstance">();
	}
	static class UTgfWeaponInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfWeaponInstance>();
	}
};
static_assert(alignof(UTgfWeaponInstance) == 0x000008, "Wrong alignment on UTgfWeaponInstance");
static_assert(sizeof(UTgfWeaponInstance) == 0x0000F0, "Wrong size on UTgfWeaponInstance");
static_assert(offsetof(UTgfWeaponInstance, StencilRef) == 0x0000E8, "Member 'UTgfWeaponInstance::StencilRef' has a wrong offset!");
static_assert(offsetof(UTgfWeaponInstance, SkillEquipType) == 0x0000E9, "Member 'UTgfWeaponInstance::SkillEquipType' has a wrong offset!");

}

