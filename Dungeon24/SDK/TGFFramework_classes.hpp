#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TGFFramework

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "TGFFramework_structs.hpp"


namespace SDK
{

// Class TGFFramework.ComboBoxText
// 0x14F0 (0x1640 - 0x0150)
class UComboBoxText final : public UWidget
{
public:
	TArray<class FText>                           DefaultOptions;                                    // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   SelectedOption;                                    // 0x0160(0x0018)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x0180(0x0660)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x07E0(0x0D50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x1530(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x1540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDownArrow;                                      // 0x1544(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGamepadNavigationMode;                       // 0x1545(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1546[0x2];                                     // 0x1546(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x1548(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x15A0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x15B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMenuPlacement                                Placement;                                         // 0x15B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15B6[0x2];                                     // 0x15B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& Item)>    OnGenerateWidgetEvent;                             // 0x15B8(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectionChanged;                                // 0x15C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpening;                                         // 0x15D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_15E8[0x58];                                    // 0x15E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOption(const class FText& Option);
	void ClearOptions();
	void ClearSelection();
	void OnOpeningEvent__DelegateSignature();
	void OnSelectionChangedEvent__DelegateSignature(const class FText& SelectedItem, int32 SelectedIndex, ESelectInfo SelectionType);
	void RefreshOptions();
	bool RemoveOption(const class FText& Option);
	void SetSelectedIndex(const int32 Param_Index);
	void SetSelectedOption(const class FText& Option);

	int32 FindOptionIndex(const class FText& Option) const;
	class FText GetOptionAtIndex(int32 Param_Index) const;
	int32 GetOptionCount() const;
	int32 GetSelectedIndex() const;
	class FText GetSelectedOption() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBoxText">();
	}
	static class UComboBoxText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBoxText>();
	}
};
static_assert(alignof(UComboBoxText) == 0x000010, "Wrong alignment on UComboBoxText");
static_assert(sizeof(UComboBoxText) == 0x001640, "Wrong size on UComboBoxText");
static_assert(offsetof(UComboBoxText, DefaultOptions) == 0x000150, "Member 'UComboBoxText::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UComboBoxText, SelectedOption) == 0x000160, "Member 'UComboBoxText::SelectedOption' has a wrong offset!");
static_assert(offsetof(UComboBoxText, WidgetStyle) == 0x000180, "Member 'UComboBoxText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxText, ItemStyle) == 0x0007E0, "Member 'UComboBoxText::ItemStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxText, ContentPadding) == 0x001530, "Member 'UComboBoxText::ContentPadding' has a wrong offset!");
static_assert(offsetof(UComboBoxText, MaxListHeight) == 0x001540, "Member 'UComboBoxText::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UComboBoxText, HasDownArrow) == 0x001544, "Member 'UComboBoxText::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UComboBoxText, EnableGamepadNavigationMode) == 0x001545, "Member 'UComboBoxText::EnableGamepadNavigationMode' has a wrong offset!");
static_assert(offsetof(UComboBoxText, Font) == 0x001548, "Member 'UComboBoxText::Font' has a wrong offset!");
static_assert(offsetof(UComboBoxText, ForegroundColor) == 0x0015A0, "Member 'UComboBoxText::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UComboBoxText, bIsFocusable) == 0x0015B4, "Member 'UComboBoxText::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UComboBoxText, Placement) == 0x0015B5, "Member 'UComboBoxText::Placement' has a wrong offset!");
static_assert(offsetof(UComboBoxText, OnGenerateWidgetEvent) == 0x0015B8, "Member 'UComboBoxText::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UComboBoxText, OnSelectionChanged) == 0x0015C8, "Member 'UComboBoxText::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UComboBoxText, OnOpening) == 0x0015D8, "Member 'UComboBoxText::OnOpening' has a wrong offset!");

// Class TGFFramework.CustomButton
// 0x0040 (0x0630 - 0x05F0)
class UCustomButton final : public UButton
{
public:
	FMulticastInlineDelegateProperty_             OnLeftClicked;                                     // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRightClicked;                                    // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoubleClicked;                                   // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_618[0x18];                                     // 0x0618(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomButton">();
	}
	static class UCustomButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomButton>();
	}
};
static_assert(alignof(UCustomButton) == 0x000010, "Wrong alignment on UCustomButton");
static_assert(sizeof(UCustomButton) == 0x000630, "Wrong size on UCustomButton");
static_assert(offsetof(UCustomButton, OnLeftClicked) == 0x0005E8, "Member 'UCustomButton::OnLeftClicked' has a wrong offset!");
static_assert(offsetof(UCustomButton, OnRightClicked) == 0x0005F8, "Member 'UCustomButton::OnRightClicked' has a wrong offset!");
static_assert(offsetof(UCustomButton, OnDoubleClicked) == 0x000608, "Member 'UCustomButton::OnDoubleClicked' has a wrong offset!");

// Class TGFFramework.CustomEditableText
// 0x0030 (0x0510 - 0x04E0)
class UCustomEditableText final : public UEditableText
{
public:
	FMulticastInlineDelegateProperty_             OnFocusReceived;                                   // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFocusLost;                                       // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomEditableTextFocusLost__DelegateSignature(const struct FFocusEvent& InFocusEvent);
	void OnCustomEditableTextFocusReceived__DelegateSignature(const struct FGeometry& MyGeometry, const struct FFocusEvent& InFocusEvent);
	struct FEventReply OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomEditableText">();
	}
	static class UCustomEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomEditableText>();
	}
};
static_assert(alignof(UCustomEditableText) == 0x000010, "Wrong alignment on UCustomEditableText");
static_assert(sizeof(UCustomEditableText) == 0x000510, "Wrong size on UCustomEditableText");
static_assert(offsetof(UCustomEditableText, OnFocusReceived) == 0x0004D8, "Member 'UCustomEditableText::OnFocusReceived' has a wrong offset!");
static_assert(offsetof(UCustomEditableText, OnFocusLost) == 0x0004E8, "Member 'UCustomEditableText::OnFocusLost' has a wrong offset!");

// Class TGFFramework.CustomRichTextBlock
// 0x0020 (0x0890 - 0x0870)
class UCustomRichTextBlock final : public URichTextBlock
{
public:
	FMulticastInlineDelegateProperty_             OnHyperlinkClickedEvent;                           // 0x0870(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHyperlinkMouseClickedEvent;                      // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomRichTextBlock">();
	}
	static class UCustomRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomRichTextBlock>();
	}
};
static_assert(alignof(UCustomRichTextBlock) == 0x000010, "Wrong alignment on UCustomRichTextBlock");
static_assert(sizeof(UCustomRichTextBlock) == 0x000890, "Wrong size on UCustomRichTextBlock");
static_assert(offsetof(UCustomRichTextBlock, OnHyperlinkClickedEvent) == 0x000870, "Member 'UCustomRichTextBlock::OnHyperlinkClickedEvent' has a wrong offset!");
static_assert(offsetof(UCustomRichTextBlock, OnHyperlinkMouseClickedEvent) == 0x000880, "Member 'UCustomRichTextBlock::OnHyperlinkMouseClickedEvent' has a wrong offset!");

// Class TGFFramework.CustomScrollBox
// 0x00D0 (0x0D70 - 0x0CA0)
class UCustomScrollBox final : public UScrollBox
{
public:
	struct FSlateBrush                            CursorBrush;                                       // 0x0CA0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomScrollBox">();
	}
	static class UCustomScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomScrollBox>();
	}
};
static_assert(alignof(UCustomScrollBox) == 0x000010, "Wrong alignment on UCustomScrollBox");
static_assert(sizeof(UCustomScrollBox) == 0x000D70, "Wrong size on UCustomScrollBox");
static_assert(offsetof(UCustomScrollBox, CursorBrush) == 0x000CA0, "Member 'UCustomScrollBox::CursorBrush' has a wrong offset!");

// Class TGFFramework.HorizontalToggleGroup
// 0x0018 (0x0190 - 0x0178)
class UHorizontalToggleGroup final : public UHorizontalBox
{
public:
	FMulticastInlineDelegateProperty_             OnToggleChanged;                                   // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UToggleGroup*                           MyToggleGroup;                                     // 0x0188(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetCurIndex();
	class UToggleGroup* GetToggleGroup();
	void NativeOnToggleChanged(int32 Param_Index);
	void ResetCurIndex();
	void SetCurIndex(int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorizontalToggleGroup">();
	}
	static class UHorizontalToggleGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorizontalToggleGroup>();
	}
};
static_assert(alignof(UHorizontalToggleGroup) == 0x000008, "Wrong alignment on UHorizontalToggleGroup");
static_assert(sizeof(UHorizontalToggleGroup) == 0x000190, "Wrong size on UHorizontalToggleGroup");
static_assert(offsetof(UHorizontalToggleGroup, OnToggleChanged) == 0x000178, "Member 'UHorizontalToggleGroup::OnToggleChanged' has a wrong offset!");
static_assert(offsetof(UHorizontalToggleGroup, MyToggleGroup) == 0x000188, "Member 'UHorizontalToggleGroup::MyToggleGroup' has a wrong offset!");

// Class TGFFramework.HyperlinkRichTextBlockDecorator
// 0x0778 (0x07A0 - 0x0028)
class UHyperlinkRichTextBlockDecorator : public URichTextBlockDecorator
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHyperlinkStyle                        DefaultHyperlinkStyle;                             // 0x0030(0x0750)(Edit, NativeAccessSpecifierPublic)
	class UDataTable*                             HyperlinkStyleSet;                                 // 0x0780(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_788[0x18];                                     // 0x0788(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HyperlinkRichTextBlockDecorator">();
	}
	static class UHyperlinkRichTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHyperlinkRichTextBlockDecorator>();
	}
};
static_assert(alignof(UHyperlinkRichTextBlockDecorator) == 0x000010, "Wrong alignment on UHyperlinkRichTextBlockDecorator");
static_assert(sizeof(UHyperlinkRichTextBlockDecorator) == 0x0007A0, "Wrong size on UHyperlinkRichTextBlockDecorator");
static_assert(offsetof(UHyperlinkRichTextBlockDecorator, DefaultHyperlinkStyle) == 0x000030, "Member 'UHyperlinkRichTextBlockDecorator::DefaultHyperlinkStyle' has a wrong offset!");
static_assert(offsetof(UHyperlinkRichTextBlockDecorator, HyperlinkStyleSet) == 0x000780, "Member 'UHyperlinkRichTextBlockDecorator::HyperlinkStyleSet' has a wrong offset!");

// Class TGFFramework.ImageRichTextBlockDecorator
// 0x0778 (0x07A0 - 0x0028)
class UImageRichTextBlockDecorator : public URichTextBlockDecorator
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHyperlinkStyle                        DefaultHyperlinkStyle;                             // 0x0030(0x0750)(Edit, NativeAccessSpecifierPublic)
	class UDataTable*                             ImageDataTable;                                    // 0x0780(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_788[0x18];                                     // 0x0788(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageRichTextBlockDecorator">();
	}
	static class UImageRichTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageRichTextBlockDecorator>();
	}
};
static_assert(alignof(UImageRichTextBlockDecorator) == 0x000010, "Wrong alignment on UImageRichTextBlockDecorator");
static_assert(sizeof(UImageRichTextBlockDecorator) == 0x0007A0, "Wrong size on UImageRichTextBlockDecorator");
static_assert(offsetof(UImageRichTextBlockDecorator, DefaultHyperlinkStyle) == 0x000030, "Member 'UImageRichTextBlockDecorator::DefaultHyperlinkStyle' has a wrong offset!");
static_assert(offsetof(UImageRichTextBlockDecorator, ImageDataTable) == 0x000780, "Member 'UImageRichTextBlockDecorator::ImageDataTable' has a wrong offset!");

// Class TGFFramework.TGFBaseFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTGFBaseFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool FileExists(const class FString& InPath);
	static void ForceGC();
	static class UClass* GetClassBySoftPath(const class FString& SoftPath);
	static TArray<class FName> GetDataTableRowNames(class UDataTable* DataTable);
	static class UEngineSubsystem* GetGameEngineSubsystem(TSubclassOf<class UEngineSubsystem> SubsystemClass);
	static class UGameInstance* GetGameInstance();
	static class UGameInstanceSubsystem* GetGameInstanceSubsystem(TSubclassOf<class UGameInstanceSubsystem> SubsystemClass);
	static bool GetIsEditor();
	static class FString ProjectContentDir();
	static class FString ProjectDir();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBaseFunctionLibrary">();
	}
	static class UTGFBaseFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBaseFunctionLibrary>();
	}
};
static_assert(alignof(UTGFBaseFunctionLibrary) == 0x000008, "Wrong alignment on UTGFBaseFunctionLibrary");
static_assert(sizeof(UTGFBaseFunctionLibrary) == 0x000028, "Wrong size on UTGFBaseFunctionLibrary");

// Class TGFFramework.TGFEventArgs
// 0x0000 (0x0028 - 0x0028)
class UTGFEventArgs : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFEventArgs">();
	}
	static class UTGFEventArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFEventArgs>();
	}
};
static_assert(alignof(UTGFEventArgs) == 0x000008, "Wrong alignment on UTGFEventArgs");
static_assert(sizeof(UTGFEventArgs) == 0x000028, "Wrong size on UTGFEventArgs");

// Class TGFFramework.TGFEventHandler
// 0x0020 (0x0048 - 0x0028)
class UTGFEventHandler final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             Delegate;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CommonDelegate;                                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFEventHandler">();
	}
	static class UTGFEventHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFEventHandler>();
	}
};
static_assert(alignof(UTGFEventHandler) == 0x000008, "Wrong alignment on UTGFEventHandler");
static_assert(sizeof(UTGFEventHandler) == 0x000048, "Wrong size on UTGFEventHandler");
static_assert(offsetof(UTGFEventHandler, Delegate) == 0x000028, "Member 'UTGFEventHandler::Delegate' has a wrong offset!");
static_assert(offsetof(UTGFEventHandler, CommonDelegate) == 0x000038, "Member 'UTGFEventHandler::CommonDelegate' has a wrong offset!");

// Class TGFFramework.TGFSubsystem
// 0x0000 (0x0030 - 0x0030)
class UTGFSubsystem : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSubsystem">();
	}
	static class UTGFSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSubsystem>();
	}
};
static_assert(alignof(UTGFSubsystem) == 0x000008, "Wrong alignment on UTGFSubsystem");
static_assert(sizeof(UTGFSubsystem) == 0x000030, "Wrong size on UTGFSubsystem");

// Class TGFFramework.TGFEventManager
// 0x0050 (0x0080 - 0x0030)
class UTGFEventManager final : public UTGFSubsystem
{
public:
	TMap<class FString, class UTGFEventHandler*>  Handlers;                                          // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	class UTGFEventHandler* GetEventHandler(const class FString& EventName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFEventManager">();
	}
	static class UTGFEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFEventManager>();
	}
};
static_assert(alignof(UTGFEventManager) == 0x000008, "Wrong alignment on UTGFEventManager");
static_assert(sizeof(UTGFEventManager) == 0x000080, "Wrong size on UTGFEventManager");
static_assert(offsetof(UTGFEventManager, Handlers) == 0x000030, "Member 'UTGFEventManager::Handlers' has a wrong offset!");

// Class TGFFramework.TGFFrameworkRuntimeSetting
// 0x0000 (0x0028 - 0x0028)
class UTGFFrameworkRuntimeSetting final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFFrameworkRuntimeSetting">();
	}
	static class UTGFFrameworkRuntimeSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFFrameworkRuntimeSetting>();
	}
};
static_assert(alignof(UTGFFrameworkRuntimeSetting) == 0x000008, "Wrong alignment on UTGFFrameworkRuntimeSetting");
static_assert(sizeof(UTGFFrameworkRuntimeSetting) == 0x000028, "Wrong size on UTGFFrameworkRuntimeSetting");

// Class TGFFramework.TGFLvStreamingNotifyArgs
// 0x0018 (0x0040 - 0x0028)
class UTGFLvStreamingNotifyArgs final : public UObject
{
public:
	class FString                                 LevelPath;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HallState;                                         // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFLvStreamingNotifyArgs">();
	}
	static class UTGFLvStreamingNotifyArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFLvStreamingNotifyArgs>();
	}
};
static_assert(alignof(UTGFLvStreamingNotifyArgs) == 0x000008, "Wrong alignment on UTGFLvStreamingNotifyArgs");
static_assert(sizeof(UTGFLvStreamingNotifyArgs) == 0x000040, "Wrong size on UTGFLvStreamingNotifyArgs");
static_assert(offsetof(UTGFLvStreamingNotifyArgs, LevelPath) == 0x000028, "Member 'UTGFLvStreamingNotifyArgs::LevelPath' has a wrong offset!");
static_assert(offsetof(UTGFLvStreamingNotifyArgs, HallState) == 0x000038, "Member 'UTGFLvStreamingNotifyArgs::HallState' has a wrong offset!");

// Class TGFFramework.TGFSceneFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTGFSceneFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ShowWorldActorByTag(bool bIsShow, const class FName& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSceneFunctionLibrary">();
	}
	static class UTGFSceneFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSceneFunctionLibrary>();
	}
};
static_assert(alignof(UTGFSceneFunctionLibrary) == 0x000008, "Wrong alignment on UTGFSceneFunctionLibrary");
static_assert(sizeof(UTGFSceneFunctionLibrary) == 0x000028, "Wrong size on UTGFSceneFunctionLibrary");

// Class TGFFramework.TGFService
// 0x0000 (0x0030 - 0x0030)
class UTGFService : public UTGFSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFService">();
	}
	static class UTGFService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFService>();
	}
};
static_assert(alignof(UTGFService) == 0x000008, "Wrong alignment on UTGFService");
static_assert(sizeof(UTGFService) == 0x000030, "Wrong size on UTGFService");

// Class TGFFramework.UserWidgetBase
// 0x0000 (0x0278 - 0x0278)
class UUserWidgetBase : public UUserWidget
{
public:
	class UUserWidget* LoadComponent(TSubclassOf<class UUserWidget> Param_Class, class UWidget* Parent);
	class UUserWidget* LoadComponentBySoftPath(const class FString& SoftPath, class UWidget* Parent);
	void SetLocText(class UWidget* Widget, const class FName TableId, const class FString& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetBase">();
	}
	static class UUserWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetBase>();
	}
};
static_assert(alignof(UUserWidgetBase) == 0x000008, "Wrong alignment on UUserWidgetBase");
static_assert(sizeof(UUserWidgetBase) == 0x000278, "Wrong size on UUserWidgetBase");

// Class TGFFramework.UserWidgetPanel
// 0x0008 (0x0280 - 0x0278)
class UUserWidgetPanel : public UUserWidgetBase
{
public:
	EZOrderType                                   MyOrderLayer;                                      // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUserInputFirst;                                   // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FEventReply OnUserKeyDown(const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnUserKeyUp(const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnUserMouseButtonDown(const struct FPointerEvent& MouseEvent);
	struct FEventReply OnUserMouseButtonUp(const struct FPointerEvent& MouseEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetPanel">();
	}
	static class UUserWidgetPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetPanel>();
	}
};
static_assert(alignof(UUserWidgetPanel) == 0x000008, "Wrong alignment on UUserWidgetPanel");
static_assert(sizeof(UUserWidgetPanel) == 0x000280, "Wrong size on UUserWidgetPanel");
static_assert(offsetof(UUserWidgetPanel, MyOrderLayer) == 0x000278, "Member 'UUserWidgetPanel::MyOrderLayer' has a wrong offset!");
static_assert(offsetof(UUserWidgetPanel, bUserInputFirst) == 0x000279, "Member 'UUserWidgetPanel::bUserInputFirst' has a wrong offset!");

// Class TGFFramework.TGFWindow
// 0x0038 (0x02B8 - 0x0280)
class UTGFWindow : public UUserWidgetPanel
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsFullScreen;                                      // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotFocus;                                      // 0x0289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEscapeToClose;                                    // 0x028A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B[0x1];                                      // 0x028B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MyOpenOrder;                                       // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              DefaultVisibility;                                 // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x1F];                                     // 0x0291(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUserWidget>             OpenFromWindow;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Close();
	class UTGFEventHandler* GetEventHandler(const class FString& EventName);
	class UTGFWindowManager* GetWindowManager();
	void HandleDisplayMonitorChanged();
	void HandleVideoSettingModifiedResult(const uint8& Type, const int32& ResultValue, bool bSuccessful);
	void ReceiveOnClose();
	void ReceiveOnHallStateChanged();
	void ReceiveOnOpen(class UTGFWindowArgs* Args);
	void ReceiveOnStreamingLevelReady(class UTGFLvStreamingNotifyArgs* Args);
	void ReceiveOnToggleFullScreen();
	void SetOpenFromWindow(class UUserWidget* FromWindow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFWindow">();
	}
	static class UTGFWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFWindow>();
	}
};
static_assert(alignof(UTGFWindow) == 0x000008, "Wrong alignment on UTGFWindow");
static_assert(sizeof(UTGFWindow) == 0x0002B8, "Wrong size on UTGFWindow");
static_assert(offsetof(UTGFWindow, IsFullScreen) == 0x000288, "Member 'UTGFWindow::IsFullScreen' has a wrong offset!");
static_assert(offsetof(UTGFWindow, bCannotFocus) == 0x000289, "Member 'UTGFWindow::bCannotFocus' has a wrong offset!");
static_assert(offsetof(UTGFWindow, bEscapeToClose) == 0x00028A, "Member 'UTGFWindow::bEscapeToClose' has a wrong offset!");
static_assert(offsetof(UTGFWindow, MyOpenOrder) == 0x00028C, "Member 'UTGFWindow::MyOpenOrder' has a wrong offset!");
static_assert(offsetof(UTGFWindow, DefaultVisibility) == 0x000290, "Member 'UTGFWindow::DefaultVisibility' has a wrong offset!");
static_assert(offsetof(UTGFWindow, OpenFromWindow) == 0x0002B0, "Member 'UTGFWindow::OpenFromWindow' has a wrong offset!");

// Class TGFFramework.TGFWindowArgs
// 0x0008 (0x0030 - 0x0028)
class UTGFWindowArgs : public UObject
{
public:
	EOpenWindowReason                             OWR;                                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFWindowArgs">();
	}
	static class UTGFWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFWindowArgs>();
	}
};
static_assert(alignof(UTGFWindowArgs) == 0x000008, "Wrong alignment on UTGFWindowArgs");
static_assert(sizeof(UTGFWindowArgs) == 0x000030, "Wrong size on UTGFWindowArgs");
static_assert(offsetof(UTGFWindowArgs, OWR) == 0x000028, "Member 'UTGFWindowArgs::OWR' has a wrong offset!");

// Class TGFFramework.TGFWindowOpenedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFWindowOpenedEvent final : public UTGFEventArgs
{
public:
	class UTGFWindow*                             Window;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFWindowOpenedEvent">();
	}
	static class UTGFWindowOpenedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFWindowOpenedEvent>();
	}
};
static_assert(alignof(UTGFWindowOpenedEvent) == 0x000008, "Wrong alignment on UTGFWindowOpenedEvent");
static_assert(sizeof(UTGFWindowOpenedEvent) == 0x000030, "Wrong size on UTGFWindowOpenedEvent");
static_assert(offsetof(UTGFWindowOpenedEvent, Window) == 0x000028, "Member 'UTGFWindowOpenedEvent::Window' has a wrong offset!");

// Class TGFFramework.TGFWindowManager
// 0x0028 (0x0058 - 0x0030)
class UTGFWindowManager final : public UTGFSubsystem
{
public:
	TArray<class UTGFWindow*>                     WindowStack;                                       // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACameraActor>            UICamera;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUiCamera;                                       // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  WorldCamera;                                       // 0x004C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentOpenOrder;                                  // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BindToggleFullScreenDelegate(TSoftObjectPtr<class UTGFWindow> Window);
	void CleanWindows();
	void CleanWindowWithout(const class FString& InClassName);
	bool CloseWindow(class UUserWidget* WindowPtr);
	bool CloseWindowBySoftPath(const class FString& SoftPath);
	class UTGFWindow* GetWindowBySoftPath(const class FString& SoftPath);
	bool IsUiCamera();
	void OnHallStateChanged();
	void OnUserKeyDownEvent(const struct FKeyEvent& InKeyEvent);
	void OnUserKeyUpEvent(const struct FKeyEvent& InKeyEvent);
	void OnUserMouseButtonDownEvent(const struct FPointerEvent& MouseEvent);
	void OnUserMouseButtonUpEvent(const struct FPointerEvent& MouseEvent);
	class UTGFWindow* OpenWindow(TSoftClassPtr<class UClass> WindowSoftClass, class UTGFWindowArgs* Args, bool bUnique);
	class UTGFWindow* OpenWindowBySoftPath(const class FString& SoftPath, class UTGFWindowArgs* Args, bool bUnique);
	void ToggleCameraRegistration(bool bRegister);
	void UnBindToggleFullScreenDelegate(TSoftObjectPtr<class UTGFWindow> Window);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFWindowManager">();
	}
	static class UTGFWindowManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFWindowManager>();
	}
};
static_assert(alignof(UTGFWindowManager) == 0x000008, "Wrong alignment on UTGFWindowManager");
static_assert(sizeof(UTGFWindowManager) == 0x000058, "Wrong size on UTGFWindowManager");
static_assert(offsetof(UTGFWindowManager, WindowStack) == 0x000030, "Member 'UTGFWindowManager::WindowStack' has a wrong offset!");
static_assert(offsetof(UTGFWindowManager, UICamera) == 0x000040, "Member 'UTGFWindowManager::UICamera' has a wrong offset!");
static_assert(offsetof(UTGFWindowManager, bIsUiCamera) == 0x000048, "Member 'UTGFWindowManager::bIsUiCamera' has a wrong offset!");
static_assert(offsetof(UTGFWindowManager, WorldCamera) == 0x00004C, "Member 'UTGFWindowManager::WorldCamera' has a wrong offset!");
static_assert(offsetof(UTGFWindowManager, CurrentOpenOrder) == 0x000054, "Member 'UTGFWindowManager::CurrentOpenOrder' has a wrong offset!");

// Class TGFFramework.ToggleData
// 0x0020 (0x0048 - 0x0028)
class UToggleData final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCheckBoxChanged(bool bIsChecked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleData">();
	}
	static class UToggleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleData>();
	}
};
static_assert(alignof(UToggleData) == 0x000008, "Wrong alignment on UToggleData");
static_assert(sizeof(UToggleData) == 0x000048, "Wrong size on UToggleData");

// Class TGFFramework.ToggleGroup
// 0x0068 (0x0090 - 0x0028)
class UToggleGroup final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UToggleData*>               ToggleMap;                                         // 0x0038(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleGroup">();
	}
	static class UToggleGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleGroup>();
	}
};
static_assert(alignof(UToggleGroup) == 0x000008, "Wrong alignment on UToggleGroup");
static_assert(sizeof(UToggleGroup) == 0x000090, "Wrong size on UToggleGroup");
static_assert(offsetof(UToggleGroup, ToggleMap) == 0x000038, "Member 'UToggleGroup::ToggleMap' has a wrong offset!");

// Class TGFFramework.UserWidgetBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserWidgetBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UUserWidget* CreateUserWidgetByPath(const class FString& Path, class UWorld* InWorld);
	static class UUserWidget* CreateUserWidgetBySoftPath(const class FString& SoftPath, class UWorld* InWorld);
	static class UUserWidget* FindUserWidgetBySoftPath(const class FString& SoftPath, bool bOpened, class UWorld* InWorld);
	static class UUserWidget* OpenUserWidgetBySoftPath(const class FString& SoftPath, bool bUnique);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetBlueprintLibrary">();
	}
	static class UUserWidgetBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetBlueprintLibrary>();
	}
};
static_assert(alignof(UUserWidgetBlueprintLibrary) == 0x000008, "Wrong alignment on UUserWidgetBlueprintLibrary");
static_assert(sizeof(UUserWidgetBlueprintLibrary) == 0x000028, "Wrong size on UUserWidgetBlueprintLibrary");

// Class TGFFramework.UserWidgetDelegates
// 0x0070 (0x00A0 - 0x0030)
class UUserWidgetDelegates final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             KeyDownDelegate;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             KeyUpDelegate;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MouseButtonDownDelegate;                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MouseButtonUpDelegate;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MouseWheelDelegate;                                // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             HyperlinkJumpDelegate;                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetDelegates">();
	}
	static class UUserWidgetDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetDelegates>();
	}
};
static_assert(alignof(UUserWidgetDelegates) == 0x000008, "Wrong alignment on UUserWidgetDelegates");
static_assert(sizeof(UUserWidgetDelegates) == 0x0000A0, "Wrong size on UUserWidgetDelegates");
static_assert(offsetof(UUserWidgetDelegates, KeyDownDelegate) == 0x000030, "Member 'UUserWidgetDelegates::KeyDownDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidgetDelegates, KeyUpDelegate) == 0x000040, "Member 'UUserWidgetDelegates::KeyUpDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidgetDelegates, MouseButtonDownDelegate) == 0x000050, "Member 'UUserWidgetDelegates::MouseButtonDownDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidgetDelegates, MouseButtonUpDelegate) == 0x000060, "Member 'UUserWidgetDelegates::MouseButtonUpDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidgetDelegates, MouseWheelDelegate) == 0x000070, "Member 'UUserWidgetDelegates::MouseWheelDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidgetDelegates, HyperlinkJumpDelegate) == 0x000080, "Member 'UUserWidgetDelegates::HyperlinkJumpDelegate' has a wrong offset!");

// Class TGFFramework.ImageCache
// 0x0020 (0x0048 - 0x0028)
class UImageCache final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 URL;                                               // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      Texture;                                           // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDownloadImageSuccess(class UTexture2DDynamic* InTexture);

	bool GetIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageCache">();
	}
	static class UImageCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageCache>();
	}
};
static_assert(alignof(UImageCache) == 0x000008, "Wrong alignment on UImageCache");
static_assert(sizeof(UImageCache) == 0x000048, "Wrong size on UImageCache");
static_assert(offsetof(UImageCache, bIsValid) == 0x000028, "Member 'UImageCache::bIsValid' has a wrong offset!");
static_assert(offsetof(UImageCache, URL) == 0x000030, "Member 'UImageCache::URL' has a wrong offset!");
static_assert(offsetof(UImageCache, Texture) == 0x000040, "Member 'UImageCache::Texture' has a wrong offset!");

// Class TGFFramework.UserWidgetImageCacheManager
// 0x00F8 (0x0128 - 0x0030)
class UUserWidgetImageCacheManager final : public UGameInstanceSubsystem
{
public:
	int64                                         CurrentUpdateHandler;                              // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UImageCache*>       ImageCacheMap;                                     // 0x0038(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FImageCacheUpdateHandlerArray> UpdateHandlerArrayMap;                             // 0x0088(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int64, struct FImageCacheUpdateCallback> ImageCacheUpdateCallbackMap;                       // 0x00D8(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetImageCacheManager">();
	}
	static class UUserWidgetImageCacheManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetImageCacheManager>();
	}
};
static_assert(alignof(UUserWidgetImageCacheManager) == 0x000008, "Wrong alignment on UUserWidgetImageCacheManager");
static_assert(sizeof(UUserWidgetImageCacheManager) == 0x000128, "Wrong size on UUserWidgetImageCacheManager");
static_assert(offsetof(UUserWidgetImageCacheManager, CurrentUpdateHandler) == 0x000030, "Member 'UUserWidgetImageCacheManager::CurrentUpdateHandler' has a wrong offset!");
static_assert(offsetof(UUserWidgetImageCacheManager, ImageCacheMap) == 0x000038, "Member 'UUserWidgetImageCacheManager::ImageCacheMap' has a wrong offset!");
static_assert(offsetof(UUserWidgetImageCacheManager, UpdateHandlerArrayMap) == 0x000088, "Member 'UUserWidgetImageCacheManager::UpdateHandlerArrayMap' has a wrong offset!");
static_assert(offsetof(UUserWidgetImageCacheManager, ImageCacheUpdateCallbackMap) == 0x0000D8, "Member 'UUserWidgetImageCacheManager::ImageCacheUpdateCallbackMap' has a wrong offset!");

}

