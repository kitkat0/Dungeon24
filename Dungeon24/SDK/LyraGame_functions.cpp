#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LyraGame

#include "Basic.hpp"

#include "LyraGame_classes.hpp"
#include "LyraGame_parameters.hpp"


namespace SDK
{

// Function LyraGame.TgfAbilityCheats.AddAbilitySet
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   AbilitySetId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::AddAbilitySet(int32 AbilitySetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "AddAbilitySet");

	Params::TgfAbilityCheats_AddAbilitySet Parms{};

	Parms.AbilitySetId = AbilitySetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.AddAttrValue
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AttrStr                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::AddAttrValue(const class FString& AttrStr, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "AddAttrValue");

	Params::TgfAbilityCheats_AddAttrValue Parms{};

	Parms.AttrStr = std::move(AttrStr);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.AddLooseGameplayTag
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FoundTagInServer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::AddLooseGameplayTag(const class FString& TagName, int32 Nums, bool NeedReplicated, bool FoundTagInServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "AddLooseGameplayTag");

	Params::TgfAbilityCheats_AddLooseGameplayTag Parms{};

	Parms.TagName = std::move(TagName);
	Parms.Nums = Nums;
	Parms.NeedReplicated = NeedReplicated;
	Parms.FoundTagInServer = FoundTagInServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.AttReady
// (Final, Exec, Native, Public)

void UTgfAbilityCheats::AttReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "AttReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.ClearAbilitySet
// (Final, Exec, Native, Public)

void UTgfAbilityCheats::ClearAbilitySet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "ClearAbilitySet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.GiveAbilitySet
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::GiveAbilitySet(const class FString& AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "GiveAbilitySet");

	Params::TgfAbilityCheats_GiveAbilitySet Parms{};

	Parms.AssetName = std::move(AssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.HPReady
// (Final, Exec, Native, Public)

void UTgfAbilityCheats::HPReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "HPReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.InjectInput
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InputStr                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::InjectInput(const class FString& InputStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "InjectInput");

	Params::TgfAbilityCheats_InjectInput Parms{};

	Parms.InputStr = std::move(InputStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.MulAttrValue
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AttrStr                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::MulAttrValue(const class FString& AttrStr, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "MulAttrValue");

	Params::TgfAbilityCheats_MulAttrValue Parms{};

	Parms.AttrStr = std::move(AttrStr);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.Rebirth
// (Final, Exec, Native, Public)

void UTgfAbilityCheats::Rebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "Rebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.RebirthLocation
// (Final, Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::RebirthLocation(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "RebirthLocation");

	Params::TgfAbilityCheats_RebirthLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.RemoveLooseGameplayTag
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FoundTagInServer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::RemoveLooseGameplayTag(const class FString& TagName, int32 Nums, bool NeedReplicated, bool FoundTagInServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "RemoveLooseGameplayTag");

	Params::TgfAbilityCheats_RemoveLooseGameplayTag Parms{};

	Parms.TagName = std::move(TagName);
	Parms.Nums = Nums;
	Parms.NeedReplicated = NeedReplicated;
	Parms.FoundTagInServer = FoundTagInServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.SetAttrValue
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AttrStr                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::SetAttrValue(const class FString& AttrStr, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "SetAttrValue");

	Params::TgfAbilityCheats_SetAttrValue Parms{};

	Parms.AttrStr = std::move(AttrStr);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.SetFirstLevel
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::SetFirstLevel(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "SetFirstLevel");

	Params::TgfAbilityCheats_SetFirstLevel Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.ShowAllTag
// (Final, Exec, Native, Public)

void UTgfAbilityCheats::ShowAllTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "ShowAllTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.ShowAllTagServer
// (Final, Exec, Native, Public)

void UTgfAbilityCheats::ShowAllTagServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "ShowAllTagServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.ToggleAuthIgnoreAbilitySystemCooldowns
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::ToggleAuthIgnoreAbilitySystemCooldowns(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "ToggleAuthIgnoreAbilitySystemCooldowns");

	Params::TgfAbilityCheats_ToggleAuthIgnoreAbilitySystemCooldowns Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.ToggleAuthIgnoreAbilitySystemCosts
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::ToggleAuthIgnoreAbilitySystemCosts(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "ToggleAuthIgnoreAbilitySystemCosts");

	Params::TgfAbilityCheats_ToggleAuthIgnoreAbilitySystemCosts Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.TriggerInput
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InputStr                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::TriggerInput(const class FString& InputStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "TriggerInput");

	Params::TgfAbilityCheats_TriggerInput Parms{};

	Parms.InputStr = std::move(InputStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.TriggerInputContinous
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InputStr                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::TriggerInputContinous(const class FString& InputStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "TriggerInputContinous");

	Params::TgfAbilityCheats_TriggerInputContinous Parms{};

	Parms.InputStr = std::move(InputStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityCheats.UseOldHit
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    UseOld                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilityCheats::UseOldHit(bool UseOld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAbilityCheats", "UseOldHit");

	Params::TgfAbilityCheats_UseOldHit Parms{};

	Parms.UseOld = UseOld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AbilityTask_WaitGameplayTagCountChanged.WaitGameplayTagCountChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyTriggerOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitGameplayTagCountChanged*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitGameplayTagCountChanged* UAbilityTask_WaitGameplayTagCountChanged::WaitGameplayTagCountChanged(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, class AActor* InOptionalExternalTarget, bool OnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitGameplayTagCountChanged", "WaitGameplayTagCountChanged");

	Params::AbilityTask_WaitGameplayTagCountChanged_WaitGameplayTagCountChanged Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Tag = std::move(Tag);
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;
	Parms.OnlyTriggerOnce = OnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInteractorBattleComponent.MulticastDamageEvent
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            DamageInstigatorTags                                   (Parm, NativeAccessSpecifierPublic)
// float                                   DamageValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInteractorBattleComponent::MulticastDamageEvent(class AActor* DamageInstigator, const struct FGameplayTagContainer& DamageInstigatorTags, float DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "MulticastDamageEvent");

	Params::TgfInteractorBattleComponent_MulticastDamageEvent Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.DamageInstigatorTags = std::move(DamageInstigatorTags);
	Parms.DamageValue = DamageValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInteractorBattleComponent.MulticastDeathEvent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInteractorBattleComponent::MulticastDeathEvent(class AActor* DamageInstigator, class AActor* DamageTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "MulticastDeathEvent");

	Params::TgfInteractorBattleComponent_MulticastDeathEvent Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.DamageTarget = DamageTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInteractorBattleComponent.OnHit
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInteractorBattleComponent::OnHit(class AActor* SrcActor, ETgfUseAttackType AttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "OnHit");

	Params::TgfInteractorBattleComponent_OnHit Parms{};

	Parms.SrcActor = SrcActor;
	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInteractorBattleComponent.OnRep_DeathState
// (Native, Protected)
// Parameters:
// ETgfDeathState                          OldDeathState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInteractorBattleComponent::OnRep_DeathState(ETgfDeathState OldDeathState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "OnRep_DeathState");

	Params::TgfInteractorBattleComponent_OnRep_DeathState Parms{};

	Parms.OldDeathState = OldDeathState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInteractorBattleComponent.TriggerDeath
// (Native, Public, BlueprintCallable)

void UTgfInteractorBattleComponent::TriggerDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "TriggerDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInteractorBattleComponent.GetCurrentHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfInteractorBattleComponent::GetCurrentHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "GetCurrentHP");

	Params::TgfInteractorBattleComponent_GetCurrentHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInteractorBattleComponent.GetDeadOrDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInteractorBattleComponent::GetDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "GetDeadOrDying");

	Params::TgfInteractorBattleComponent_GetDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInteractorBattleComponent.GetTotalHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfInteractorBattleComponent::GetTotalHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "GetTotalHP");

	Params::TgfInteractorBattleComponent_GetTotalHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInteractorBattleComponent.IsDeadOrDying
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInteractorBattleComponent::IsDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "IsDeadOrDying");

	Params::TgfInteractorBattleComponent_IsDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInteractorBattleComponent.IsEnableBattle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInteractorBattleComponent::IsEnableBattle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInteractorBattleComponent", "IsEnableBattle");

	Params::TgfInteractorBattleComponent_IsEnableBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterCheats.ForceSpectate
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    ToSpectate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::ForceSpectate(bool ToSpectate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "ForceSpectate");

	Params::TgfCharacterCheats_ForceSpectate Parms{};

	Parms.ToSpectate = ToSpectate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.HidePlayerNames
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::HidePlayerNames(bool Hide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "HidePlayerNames");

	Params::TgfCharacterCheats_HidePlayerNames Parms{};

	Parms.Hide = Hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.NetTest
// (Final, Exec, Native, Public)

void UTgfCharacterCheats::NetTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "NetTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.PrintActorMapStat
// (Final, Exec, Native, Public)

void UTgfCharacterCheats::PrintActorMapStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "PrintActorMapStat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.PrintCharacterName
// (Final, Exec, Native, Public)

void UTgfCharacterCheats::PrintCharacterName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "PrintCharacterName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.PrintCharaLocation
// (Final, Exec, Native, Public)

void UTgfCharacterCheats::PrintCharaLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "PrintCharaLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.ReinitCharaCareer
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CareerInt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::ReinitCharaCareer(int32 CareerInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "ReinitCharaCareer");

	Params::TgfCharacterCheats_ReinitCharaCareer Parms{};

	Parms.CareerInt = CareerInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetActorMapBounds
// (Final, Exec, Native, Public)
// Parameters:
// float                                   AIBound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TickBound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetActorMapBounds(float AIBound, float TickBound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetActorMapBounds");

	Params::TgfCharacterCheats_SetActorMapBounds Parms{};

	Parms.AIBound = AIBound;
	Parms.TickBound = TickBound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetCharaLocation
// (Final, Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetCharaLocation(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetCharaLocation");

	Params::TgfCharacterCheats_SetCharaLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetDisplayCareerAndRace
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CareerInt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RaceInt                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetDisplayCareerAndRace(int32 CareerInt, int32 RaceInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetDisplayCareerAndRace");

	Params::TgfCharacterCheats_SetDisplayCareerAndRace Parms{};

	Parms.CareerInt = CareerInt;
	Parms.RaceInt = RaceInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetFreeze
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bFreeze                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetFreeze(bool bFreeze)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetFreeze");

	Params::TgfCharacterCheats_SetFreeze Parms{};

	Parms.bFreeze = bFreeze;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetMithrilCharacter
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RemainingRebirthChance                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetMithrilCharacter(bool Value, int32 RemainingRebirthChance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetMithrilCharacter");

	Params::TgfCharacterCheats_SetMithrilCharacter Parms{};

	Parms.Value = Value;
	Parms.RemainingRebirthChance = RemainingRebirthChance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetPlayerSceneTag
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetPlayerSceneTag(int32 Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetPlayerSceneTag");

	Params::TgfCharacterCheats_SetPlayerSceneTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetPlayMontageDelay
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bOpenServerPlayDelay                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenClientBehind                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenClientAhead                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChaseMaxPing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetPlayMontageDelay(bool bOpenServerPlayDelay, float DelayTime, bool bOpenClientBehind, bool bOpenClientAhead, float ChaseMaxPing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetPlayMontageDelay");

	Params::TgfCharacterCheats_SetPlayMontageDelay Parms{};

	Parms.bOpenServerPlayDelay = bOpenServerPlayDelay;
	Parms.DelayTime = DelayTime;
	Parms.bOpenClientBehind = bOpenClientBehind;
	Parms.bOpenClientAhead = bOpenClientAhead;
	Parms.ChaseMaxPing = ChaseMaxPing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.ShowTeamId
// (Final, Exec, Native, Public)

void UTgfCharacterCheats::ShowTeamId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "ShowTeamId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SpawnActor
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ClassPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SpawnActor(const class FString& ClassPath, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SpawnActor");

	Params::TgfCharacterCheats_SpawnActor Parms{};

	Parms.ClassPath = std::move(ClassPath);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SpawnMonster
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ClassPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LootIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Dormant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SpawnMonster(const class FString& ClassPath, float Distance, int32 LootIndex, bool Dormant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SpawnMonster");

	Params::TgfCharacterCheats_SpawnMonster Parms{};

	Parms.ClassPath = std::move(ClassPath);
	Parms.Distance = Distance;
	Parms.LootIndex = LootIndex;
	Parms.Dormant = Dormant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.TestTryIncreaseAndCheckSecurityInvalidCount
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::TestTryIncreaseAndCheckSecurityInvalidCount(int32 Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "TestTryIncreaseAndCheckSecurityInvalidCount");

	Params::TgfCharacterCheats_TestTryIncreaseAndCheckSecurityInvalidCount Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.AddSkin
// (Final, Exec, Native, Public, Const)
// Parameters:
// int32                                   SkinType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::AddSkin(int32 SkinType, int32 SkinId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "AddSkin");

	Params::TgfCharacterCheats_AddSkin Parms{};

	Parms.SkinType = SkinType;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetFaceConfig
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetFaceConfig(const class FString& Param_Name, int32 Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetFaceConfig");

	Params::TgfCharacterCheats_SetFaceConfig Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetGender
// (Final, Exec, Native, Public, Const)
// Parameters:
// int32                                   Gender                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetGender(const int32 Gender) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetGender");

	Params::TgfCharacterCheats_SetGender Parms{};

	Parms.Gender = Gender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetPlayerName
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetPlayerName(const class FString& Param_Name) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetPlayerName");

	Params::TgfCharacterCheats_SetPlayerName Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterCheats.SetRace
// (Final, Exec, Native, Public, Const)
// Parameters:
// int32                                   Race                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterCheats::SetRace(const int32 Race) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterCheats", "SetRace");

	Params::TgfCharacterCheats_SetRace Parms{};

	Parms.Race = Race;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AbilityTask_MonitorMove.MonitorMove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Period                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldExecuteAtFirst                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_MonitorMove*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_MonitorMove* UAbilityTask_MonitorMove::MonitorMove(class UGameplayAbility* OwningAbility, class FName TaskName, bool bHasDuration, float Duration, float Period, bool bShouldExecuteAtFirst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_MonitorMove", "MonitorMove");

	Params::AbilityTask_MonitorMove_MonitorMove Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskName = TaskName;
	Parms.bHasDuration = bHasDuration;
	Parms.Duration = Duration;
	Parms.Period = Period;
	Parms.bShouldExecuteAtFirst = bShouldExecuteAtFirst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.RoleDisplayAttributeUtility.GetMaxHealth
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystem                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URoleDisplayAttributeUtility::GetMaxHealth(class ULyraAbilitySystemComponent* AbilitySystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoleDisplayAttributeUtility", "GetMaxHealth");

	Params::RoleDisplayAttributeUtility_GetMaxHealth Parms{};

	Parms.AbilitySystem = AbilitySystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.RoleDisplayAttributeUtility.SortRoleDisplayAttribute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FRoleDisplayAttribute>    Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRoleDisplayAttribute>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRoleDisplayAttribute> URoleDisplayAttributeUtility::SortRoleDisplayAttribute(const TArray<struct FRoleDisplayAttribute>& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoleDisplayAttributeUtility", "SortRoleDisplayAttribute");

	Params::RoleDisplayAttributeUtility_SortRoleDisplayAttribute Parms{};

	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AbilityTask_StateChangeMonitor.WaitMonitorStateChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerImmediately                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TriggerCounts                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_StateChangeMonitor*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_StateChangeMonitor* UAbilityTask_StateChangeMonitor::WaitMonitorStateChanged(class UGameplayAbility* OwningAbility, class FName TaskName, bool TriggerImmediately, int32 TriggerCounts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_StateChangeMonitor", "WaitMonitorStateChanged");

	Params::AbilityTask_StateChangeMonitor_WaitMonitorStateChanged Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskName = TaskName;
	Parms.TriggerImmediately = TriggerImmediately;
	Parms.TriggerCounts = TriggerCounts;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAtion_AppearanceDataListen.RegisterAppearanceDataListen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RoleID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAtion_AppearanceDataListen* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAtion_AppearanceDataListen* UAsyncAtion_AppearanceDataListen::RegisterAppearanceDataListen(class UObject* WorldContextObject, int64 RoleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAtion_AppearanceDataListen", "RegisterAppearanceDataListen");

	Params::AsyncAtion_AppearanceDataListen_RegisterAppearanceDataListen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RoleID = RoleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAtion_AppearanceDataListen.HandleOnAppearanceDataGet
// (Final, Native, Public)
// Parameters:
// int64                                   InRoleID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SlateBrush                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAtion_AppearanceDataListen::HandleOnAppearanceDataGet(int64 InRoleID, class UObject* SlateBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAtion_AppearanceDataListen", "HandleOnAppearanceDataGet");

	Params::AsyncAtion_AppearanceDataListen_HandleOnAppearanceDataGet Parms{};

	Parms.InRoleID = InRoleID;
	Parms.SlateBrush = SlateBrush;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.RuneSwordSkillHelperActor.GetOwnerPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ARuneSwordSkillHelperActor::GetOwnerPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuneSwordSkillHelperActor", "GetOwnerPawn");

	Params::RuneSwordSkillHelperActor_GetOwnerPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAnimNotifyState_MontagePlayRate.MontagePlayRateRevert
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAnimNotifyState_MontagePlayRate::MontagePlayRateRevert(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAnimNotifyState_MontagePlayRate", "MontagePlayRateRevert");

	Params::TgfAnimNotifyState_MontagePlayRate_MontagePlayRateRevert Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAnimNotifyState_MontagePlayRate.MontagePlayRateTakeEffect
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAnimNotifyState_MontagePlayRate::MontagePlayRateTakeEffect(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAnimNotifyState_MontagePlayRate", "MontagePlayRateTakeEffect");

	Params::TgfAnimNotifyState_MontagePlayRate_MontagePlayRateTakeEffect Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AbilityTask_TickMonitor.WaitMonitorSatisfied
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyTriggerOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_TickMonitor*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_TickMonitor* UAbilityTask_TickMonitor::WaitMonitorSatisfied(class UGameplayAbility* OwningAbility, class FName TaskName, bool OnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_TickMonitor", "WaitMonitorSatisfied");

	Params::AbilityTask_TickMonitor_WaitMonitorSatisfied Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskName = TaskName;
	Parms.OnlyTriggerOnce = OnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AbilityTask_WaitForInteractableTargets_ProjectileTrace.WaitForInteractableTargets_ProjectileTrace
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionProfileName            TraceProfile                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InteractionScanRate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetingLocationInfoParam_StartLocation                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ProjectileRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSimTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitForInteractableTargets_ProjectileTrace*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitForInteractableTargets_ProjectileTrace* UAbilityTask_WaitForInteractableTargets_ProjectileTrace::WaitForInteractableTargets_ProjectileTrace(class UGameplayAbility* OwningAbility, const struct FCollisionProfileName& TraceProfile, float InteractionScanRate, const struct FGameplayAbilityTargetingLocationInfo& Param_StartLocation, float ProjectileRadius, const struct FVector& LaunchVelocity, float MaxSimTime, ECollisionChannel TraceChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitForInteractableTargets_ProjectileTrace", "WaitForInteractableTargets_ProjectileTrace");

	Params::AbilityTask_WaitForInteractableTargets_ProjectileTrace_WaitForInteractableTargets_ProjectileTrace Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TraceProfile = std::move(TraceProfile);
	Parms.InteractionScanRate = InteractionScanRate;
	Parms.Param_StartLocation = std::move(Param_StartLocation);
	Parms.ProjectileRadius = ProjectileRadius;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.MaxSimTime = MaxSimTime;
	Parms.TraceChannel = TraceChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetBase.GetGameWidgetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfGameWidgetBase::GetGameWidgetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameWidgetBase", "GetGameWidgetCharacter");

	Params::TgfGameWidgetBase_GetGameWidgetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetBase.SetCustomCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameWidgetBase::SetCustomCharacter(class ALyraCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameWidgetBase", "SetCustomCharacter");

	Params::TgfGameWidgetBase_SetCustomCharacter Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameWidgetBase.GetLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* UTgfGameWidgetBase::GetLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameWidgetBase", "GetLyraAbilitySystemComponent");

	Params::TgfGameWidgetBase_GetLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetBase.GetLyraPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraPlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerController* UTgfGameWidgetBase::GetLyraPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameWidgetBase", "GetLyraPlayerController");

	Params::TgfGameWidgetBase_GetLyraPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetBase.GetSelfLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* UTgfGameWidgetBase::GetSelfLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameWidgetBase", "GetSelfLyraAbilitySystemComponent");

	Params::TgfGameWidgetBase_GetSelfLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetBase.GetTgfEquipmentManagerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfEquipmentManagerComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfEquipmentManagerComponent* UTgfGameWidgetBase::GetTgfEquipmentManagerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameWidgetBase", "GetTgfEquipmentManagerComponent");

	Params::TgfGameWidgetBase_GetTgfEquipmentManagerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDashBoardWidget.BP_OnApplyGECallback
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEffect*                  GE                                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::BP_OnApplyGECallback(class UAbilitySystemComponent* Target, const class UGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnApplyGECallback");

	Params::TgfDashBoardWidget_BP_OnApplyGECallback Parms{};

	Parms.Target = Target;
	Parms.GE = GE;
	Parms.ActiveHandle = std::move(ActiveHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfDashBoardWidget.BP_OnBuffAdd
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTgfGameplayEffect*               GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCnt                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::BP_OnBuffAdd(class UTgfGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle, float RemainTime, float TotalTime, int32 StackCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnBuffAdd");

	Params::TgfDashBoardWidget_BP_OnBuffAdd Parms{};

	Parms.GE = GE;
	Parms.ActiveHandle = std::move(ActiveHandle);
	Parms.RemainTime = RemainTime;
	Parms.TotalTime = TotalTime;
	Parms.StackCnt = StackCnt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfDashBoardWidget.BP_OnCastFailed
// (Event, Public, BlueprintEvent)
// Parameters:
// class UGameplayAbility*                 FailedGA                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FailedText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::BP_OnCastFailed(const class UGameplayAbility* FailedGA, const struct FGameplayTag& Tag, const class FString& FailedText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnCastFailed");

	Params::TgfDashBoardWidget_BP_OnCastFailed Parms{};

	Parms.FailedGA = FailedGA;
	Parms.Tag = std::move(Tag);
	Parms.FailedText = std::move(FailedText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfDashBoardWidget.BP_OnGEDurationChange
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FActiveGameplayEffectHandle      GEHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCnt                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::BP_OnGEDurationChange(const struct FActiveGameplayEffectHandle& GEHandle, float NewTime, float TotalTime, int32 StackCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnGEDurationChange");

	Params::TgfDashBoardWidget_BP_OnGEDurationChange Parms{};

	Parms.GEHandle = std::move(GEHandle);
	Parms.NewTime = NewTime;
	Parms.TotalTime = TotalTime;
	Parms.StackCnt = StackCnt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfDashBoardWidget.BP_OnGERemove
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FActiveGameplayEffectHandle      GEHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::BP_OnGERemove(const struct FActiveGameplayEffectHandle& GEHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnGERemove");

	Params::TgfDashBoardWidget_BP_OnGERemove Parms{};

	Parms.GEHandle = std::move(GEHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfDashBoardWidget.BP_OnListenedTagChange
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCnt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::BP_OnListenedTagChange(const struct FGameplayTag& Tag, int32 NewCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnListenedTagChange");

	Params::TgfDashBoardWidget_BP_OnListenedTagChange Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCnt = NewCnt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfDashBoardWidget.BP_OnViewTargetChanged
// (Event, Public, BlueprintEvent)

void UTgfDashBoardWidget::BP_OnViewTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "BP_OnViewTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfDashBoardWidget.CheckExistGE
// (Final, Native, Protected, BlueprintCallable)

void UTgfDashBoardWidget::CheckExistGE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "CheckExistGE");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDashBoardWidget.GetCareerAndRaceFromNecklace
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ETgfActorCareer                         OutCareer                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           OutRace                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfDashBoardWidget::GetCareerAndRaceFromNecklace(ETgfActorCareer* OutCareer, ETgfActorRace* OutRace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "GetCareerAndRaceFromNecklace");

	Params::TgfDashBoardWidget_GetCareerAndRaceFromNecklace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCareer != nullptr)
		*OutCareer = Parms.OutCareer;

	if (OutRace != nullptr)
		*OutRace = Parms.OutRace;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDashBoardWidget.GetCurMagic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDashBoardWidget::GetCurMagic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "GetCurMagic");

	Params::TgfDashBoardWidget_GetCurMagic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDashBoardWidget.GetHealthBarType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorCareer                         Career                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthBarType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthBarType UTgfDashBoardWidget::GetHealthBarType(ETgfActorCareer Career, ETgfActorRace Race)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "GetHealthBarType");

	Params::TgfDashBoardWidget_GetHealthBarType Parms{};

	Parms.Career = Career;
	Parms.Race = Race;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDashBoardWidget.GetMaxMagicFinal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDashBoardWidget::GetMaxMagicFinal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "GetMaxMagicFinal");

	Params::TgfDashBoardWidget_GetMaxMagicFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDashBoardWidget.GetTgfSkillGA
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             Tags                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UGameplayAbility*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGameplayAbility*> UTgfDashBoardWidget::GetTgfSkillGA(class ULyraAbilitySystemComponent* ASC, const TArray<struct FGameplayTag>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "GetTgfSkillGA");

	Params::TgfDashBoardWidget_GetTgfSkillGA Parms{};

	Parms.ASC = ASC;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDashBoardWidget.ListenTagChanged
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Container1                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Container2                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::ListenTagChanged(const struct FGameplayTagContainer& Container1, const struct FGameplayTagContainer& Container2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "ListenTagChanged");

	Params::TgfDashBoardWidget_ListenTagChanged Parms{};

	Parms.Container1 = std::move(Container1);
	Parms.Container2 = std::move(Container2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDashBoardWidget.OnChangeViewTarget
// (Final, Native, Private)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::OnChangeViewTarget(class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "OnChangeViewTarget");

	Params::TgfDashBoardWidget_OnChangeViewTarget Parms{};

	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDashBoardWidget.ResetListenedTags
// (Final, Native, Public, BlueprintCallable)

void UTgfDashBoardWidget::ResetListenedTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "ResetListenedTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDashBoardWidget.SetAttachCareer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfDashBoardWidget::SetAttachCareer(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDashBoardWidget", "SetAttachCareer");

	Params::TgfDashBoardWidget_SetAttachCareer Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapComponent.UpdateCharacterGravity
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           LocalPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultGravity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetGravity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapComponent::UpdateCharacterGravity(class AActor* LocalPawn, float DefaultGravity, float TargetGravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapComponent", "UpdateCharacterGravity");

	Params::ActorMapComponent_UpdateCharacterGravity Parms{};

	Parms.LocalPawn = LocalPawn;
	Parms.DefaultGravity = DefaultGravity;
	Parms.TargetGravity = TargetGravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapComponent.UpdateCharacterPlayerNameHeight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           LocalPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetComponent*                 PlayNameComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     LocationCurve                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapComponent::UpdateCharacterPlayerNameHeight(class AActor* LocalPawn, class UWidgetComponent* PlayNameComponent, class UCurveVector* LocationCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapComponent", "UpdateCharacterPlayerNameHeight");

	Params::ActorMapComponent_UpdateCharacterPlayerNameHeight Parms{};

	Parms.LocalPawn = LocalPawn;
	Parms.PlayNameComponent = PlayNameComponent;
	Parms.LocationCurve = LocationCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapComponent.CheckInDistanceToLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   XYDis                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZDis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorMapComponent::CheckInDistanceToLocalPlayer(float XYDis, float ZDis) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapComponent", "CheckInDistanceToLocalPlayer");

	Params::ActorMapComponent_CheckInDistanceToLocalPlayer Parms{};

	Parms.XYDis = XYDis;
	Parms.ZDis = ZDis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapComponent.GetLyraCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UActorMapComponent::GetLyraCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapComponent", "GetLyraCharacter");

	Params::ActorMapComponent_GetLyraCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.AddDeltaMonsterAINum
// (Final, Native, Public)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Total                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapSubsystem::AddDeltaMonsterAINum(int32 Delta, int32 Total)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "AddDeltaMonsterAINum");

	Params::ActorMapSubsystem_AddDeltaMonsterAINum Parms{};

	Parms.Delta = Delta;
	Parms.Total = Total;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapSubsystem.AddDeltaMonsterTickNum
// (Final, Native, Public)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Total                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapSubsystem::AddDeltaMonsterTickNum(int32 Delta, int32 Total)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "AddDeltaMonsterTickNum");

	Params::ActorMapSubsystem_AddDeltaMonsterTickNum Parms{};

	Parms.Delta = Delta;
	Parms.Total = Total;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapSubsystem.AddHero
// (Final, Native, Public)
// Parameters:
// class ALyraCharacter*                   Hero                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapSubsystem::AddHero(class ALyraCharacter* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "AddHero");

	Params::ActorMapSubsystem_AddHero Parms{};

	Parms.Hero = Hero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapSubsystem.CheckCharacterEnabled
// (Final, Native, Public)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Bound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorMapSubsystem::CheckCharacterEnabled(class ALyraCharacter* Character, float Bound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "CheckCharacterEnabled");

	Params::ActorMapSubsystem_CheckCharacterEnabled Parms{};

	Parms.Character = Character;
	Parms.Bound = Bound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.GetCurrentHeroNum
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActorMapSubsystem::GetCurrentHeroNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetCurrentHeroNum");

	Params::ActorMapSubsystem_GetCurrentHeroNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.RemoveHero
// (Final, Native, Public)
// Parameters:
// class ALyraCharacter*                   Hero                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapSubsystem::RemoveHero(class ALyraCharacter* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "RemoveHero");

	Params::ActorMapSubsystem_RemoveHero Parms{};

	Parms.Hero = Hero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapSubsystem.SetMonsterActorMapAIBound
// (Final, Native, Public)
// Parameters:
// float                                   Bound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapSubsystem::SetMonsterActorMapAIBound(float Bound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "SetMonsterActorMapAIBound");

	Params::ActorMapSubsystem_SetMonsterActorMapAIBound Parms{};

	Parms.Bound = Bound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapSubsystem.SetMonsterActorMapTickBound
// (Final, Native, Public)
// Parameters:
// float                                   Bound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMapSubsystem::SetMonsterActorMapTickBound(float Bound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "SetMonsterActorMapTickBound");

	Params::ActorMapSubsystem_SetMonsterActorMapTickBound Parms{};

	Parms.Bound = Bound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ActorMapSubsystem.GetMonsterActorMapAIBound
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorMapSubsystem::GetMonsterActorMapAIBound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetMonsterActorMapAIBound");

	Params::ActorMapSubsystem_GetMonsterActorMapAIBound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.GetMonsterActorMapTickBound
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorMapSubsystem::GetMonsterActorMapTickBound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetMonsterActorMapTickBound");

	Params::ActorMapSubsystem_GetMonsterActorMapTickBound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.GetMonsterAIEnableNum
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActorMapSubsystem::GetMonsterAIEnableNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetMonsterAIEnableNum");

	Params::ActorMapSubsystem_GetMonsterAIEnableNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.GetMonsterAITotalNum
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActorMapSubsystem::GetMonsterAITotalNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetMonsterAITotalNum");

	Params::ActorMapSubsystem_GetMonsterAITotalNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.GetMonsterTickEnableNum
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActorMapSubsystem::GetMonsterTickEnableNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetMonsterTickEnableNum");

	Params::ActorMapSubsystem_GetMonsterTickEnableNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ActorMapSubsystem.GetMonsterTickTotalNum
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActorMapSubsystem::GetMonsterTickTotalNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMapSubsystem", "GetMonsterTickTotalNum");

	Params::ActorMapSubsystem_GetMonsterTickTotalNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCheckBox.TgfOnCheckStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ECheckBoxState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheckBox::TgfOnCheckStateChanged(ECheckBoxState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheckBox", "TgfOnCheckStateChanged");

	Params::TgfCheckBox_TgfOnCheckStateChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetActorSimpleCollisionCylinderExtent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAIBlueprintHelperExLibrary::GetActorSimpleCollisionCylinderExtent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetActorSimpleCollisionCylinderExtent");

	Params::AIBlueprintHelperExLibrary_GetActorSimpleCollisionCylinderExtent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetActorSimpleCollisionHalfHeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBlueprintHelperExLibrary::GetActorSimpleCollisionHalfHeight(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetActorSimpleCollisionHalfHeight");

	Params::AIBlueprintHelperExLibrary_GetActorSimpleCollisionHalfHeight Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetActorSimpleCollisionRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBlueprintHelperExLibrary::GetActorSimpleCollisionRadius(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetActorSimpleCollisionRadius");

	Params::AIBlueprintHelperExLibrary_GetActorSimpleCollisionRadius Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetAISenseConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAISense>             SenseClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAISenseConfig*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAISenseConfig* UAIBlueprintHelperExLibrary::GetAISenseConfig(class AAIController* Controller, TSubclassOf<class UAISense> SenseClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetAISenseConfig");

	Params::AIBlueprintHelperExLibrary_GetAISenseConfig Parms{};

	Parms.Controller = Controller;
	Parms.SenseClass = SenseClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetAISenseHearingRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBlueprintHelperExLibrary::GetAISenseHearingRange(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetAISenseHearingRange");

	Params::AIBlueprintHelperExLibrary_GetAISenseHearingRange Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetAISenseSightPeripheralVisionAngleDegrees
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBlueprintHelperExLibrary::GetAISenseSightPeripheralVisionAngleDegrees(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetAISenseSightPeripheralVisionAngleDegrees");

	Params::AIBlueprintHelperExLibrary_GetAISenseSightPeripheralVisionAngleDegrees Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.GetAISenseSightRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBlueprintHelperExLibrary::GetAISenseSightRadius(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "GetAISenseSightRadius");

	Params::AIBlueprintHelperExLibrary_GetAISenseSightRadius Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AIBlueprintHelperExLibrary.PauseLogic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBrainComponent*                  BrainComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::PauseLogic(class UBrainComponent* BrainComponent, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "PauseLogic");

	Params::AIBlueprintHelperExLibrary_PauseLogic Parms{};

	Parms.BrainComponent = BrainComponent;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.RefreshAIPerceptionStimuliSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAISense>             Sense                                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::RefreshAIPerceptionStimuliSource(class UObject* WorldContextObject, TSubclassOf<class UAISense> Sense, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "RefreshAIPerceptionStimuliSource");

	Params::AIBlueprintHelperExLibrary_RefreshAIPerceptionStimuliSource Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sense = Sense;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.ResumeLogic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBrainComponent*                  BrainComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::ResumeLogic(class UBrainComponent* BrainComponent, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "ResumeLogic");

	Params::AIBlueprintHelperExLibrary_ResumeLogic Parms{};

	Parms.BrainComponent = BrainComponent;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.SetAISenseEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAISense>             SenseClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::SetAISenseEnabled(class AAIController* Controller, TSubclassOf<class UAISense> SenseClass, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "SetAISenseEnabled");

	Params::AIBlueprintHelperExLibrary_SetAISenseEnabled Parms{};

	Parms.Controller = Controller;
	Parms.SenseClass = SenseClass;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.SetAISenseHearingRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::SetAISenseHearingRange(class AAIController* Controller, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "SetAISenseHearingRange");

	Params::AIBlueprintHelperExLibrary_SetAISenseHearingRange Parms{};

	Parms.Controller = Controller;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.SetAISensesEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::SetAISensesEnabled(class AAIController* Controller, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "SetAISensesEnabled");

	Params::AIBlueprintHelperExLibrary_SetAISensesEnabled Parms{};

	Parms.Controller = Controller;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.SetAISenseSightPeripheralVisionAngleDegrees
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Degrees                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::SetAISenseSightPeripheralVisionAngleDegrees(class AAIController* Controller, float Degrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "SetAISenseSightPeripheralVisionAngleDegrees");

	Params::AIBlueprintHelperExLibrary_SetAISenseSightPeripheralVisionAngleDegrees Parms{};

	Parms.Controller = Controller;
	Parms.Degrees = Degrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.SetAISenseSightRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBlueprintHelperExLibrary::SetAISenseSightRadius(class AAIController* Controller, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "SetAISenseSightRadius");

	Params::AIBlueprintHelperExLibrary_SetAISenseSightRadius Parms{};

	Parms.Controller = Controller;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AIBlueprintHelperExLibrary.TestPathSync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PointA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PointB                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathExistanceQueryType                 PathQueryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartialPaths                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBlueprintHelperExLibrary::TestPathSync(class UObject* WorldContextObject, const struct FVector& PointA, const struct FVector& PointB, EPathExistanceQueryType PathQueryType, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool AllowPartialPaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIBlueprintHelperExLibrary", "TestPathSync");

	Params::AIBlueprintHelperExLibrary_TestPathSync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PointA = std::move(PointA);
	Parms.PointB = std::move(PointB);
	Parms.PathQueryType = PathQueryType;
	Parms.FilterClass = FilterClass;
	Parms.AllowPartialPaths = AllowPartialPaths;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.CheckFirstPerson
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentBlueprintLibrary::CheckFirstPerson(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "CheckFirstPerson");

	Params::TgfEquipmentBlueprintLibrary_CheckFirstPerson Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.DealEquipAddCondAttr
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class ALyraCharacter*                   Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpec>      GESpecToApply                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::DealEquipAddCondAttr(class ALyraCharacter* Instigator, class ALyraCharacter* Target, TArray<struct FGameplayEffectSpec>* GESpecToApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "DealEquipAddCondAttr");

	Params::TgfEquipmentBlueprintLibrary_DealEquipAddCondAttr Parms{};

	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GESpecToApply != nullptr)
		*GESpecToApply = std::move(Parms.GESpecToApply);
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.DealEquipRemoveCondAttr
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class ALyraCharacter*                   Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpec>      GESpecApplied                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::DealEquipRemoveCondAttr(class ALyraCharacter* Instigator, class ALyraCharacter* Target, TArray<struct FGameplayEffectSpec>* GESpecApplied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "DealEquipRemoveCondAttr");

	Params::TgfEquipmentBlueprintLibrary_DealEquipRemoveCondAttr Parms{};

	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GESpecApplied != nullptr)
		*GESpecApplied = std::move(Parms.GESpecApplied);
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.RestoreFOVConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               OriginMat                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReplaceMat                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::RestoreFOVConfig(class UMaterialInterface* OriginMat, class UMaterialInterface* ReplaceMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "RestoreFOVConfig");

	Params::TgfEquipmentBlueprintLibrary_RestoreFOVConfig Parms{};

	Parms.OriginMat = OriginMat;
	Parms.ReplaceMat = ReplaceMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.SetAllFOVConfigForCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::SetAllFOVConfigForCharacter(class USkeletalMeshComponent* Mesh, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "SetAllFOVConfigForCharacter");

	Params::TgfEquipmentBlueprintLibrary_SetAllFOVConfigForCharacter Parms{};

	Parms.Mesh = Mesh;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.SetAlphaConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               FxComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::SetAlphaConfig(class UFXSystemComponent* FxComp, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "SetAlphaConfig");

	Params::TgfEquipmentBlueprintLibrary_SetAlphaConfig Parms{};

	Parms.FxComp = FxComp;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.SetFOVConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               FxComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::SetFOVConfig(class UFXSystemComponent* FxComp, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "SetFOVConfig");

	Params::TgfEquipmentBlueprintLibrary_SetFOVConfig Parms{};

	Parms.FxComp = FxComp;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.SetFOVConfigWithCheckBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               FxComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::SetFOVConfigWithCheckBP(class AActor* Target, class UFXSystemComponent* FxComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "SetFOVConfigWithCheckBP");

	Params::TgfEquipmentBlueprintLibrary_SetFOVConfigWithCheckBP Parms{};

	Parms.Target = Target;
	Parms.FxComp = FxComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.SetFOVMeshConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::SetFOVMeshConfig(class UMeshComponent* MeshComp, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "SetFOVMeshConfig");

	Params::TgfEquipmentBlueprintLibrary_SetFOVMeshConfig Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentBlueprintLibrary.SetFOVMeshConfigWithCheckBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentBlueprintLibrary::SetFOVMeshConfigWithCheckBP(class AActor* Target, class UMeshComponent* MeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEquipmentBlueprintLibrary", "SetFOVMeshConfigWithCheckBP");

	Params::TgfEquipmentBlueprintLibrary_SetFOVMeshConfigWithCheckBP Parms{};

	Parms.Target = Target;
	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AsyncAction_UntilItemReadyForPaint.UntilEquipmentReadyForPaint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentWrapper*             Equipment                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_UntilItemReadyForPaint*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_UntilItemReadyForPaint* UAsyncAction_UntilItemReadyForPaint::UntilEquipmentReadyForPaint(class UObject* WorldContextObject, class UTgfEquipmentWrapper* Equipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_UntilItemReadyForPaint", "UntilEquipmentReadyForPaint");

	Params::AsyncAction_UntilItemReadyForPaint_UntilEquipmentReadyForPaint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Equipment = Equipment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_UntilItemReadyForPaint.UntilInventoryItemReadyForPaint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_UntilItemReadyForPaint*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_UntilItemReadyForPaint* UAsyncAction_UntilItemReadyForPaint::UntilInventoryItemReadyForPaint(class UObject* WorldContextObject, class UTgfInventoryItemWrapper* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_UntilItemReadyForPaint", "UntilInventoryItemReadyForPaint");

	Params::AsyncAction_UntilItemReadyForPaint_UntilInventoryItemReadyForPaint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_InventoryItemRightClickOverride.Create
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             InventoryContext                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_InventoryItemRightClickOverride*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_InventoryItemRightClickOverride* UAsyncAction_InventoryItemRightClickOverride::Create(class UObject* WorldContextObject, class UTgfInventoryWrapper* InventoryContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_InventoryItemRightClickOverride", "Create");

	Params::AsyncAction_InventoryItemRightClickOverride_Create Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InventoryContext = InventoryContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper.GetMaxHealth
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfInventoryRoleWrapper::GetMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetMaxHealth");

	Params::TgfInventoryRoleWrapper_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper.GetRoleAttributeValue
// (Native, Public, BlueprintCallable)
// Parameters:
// EnRoleDisplayAttribueID                 Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfInventoryRoleWrapper::GetRoleAttributeValue(EnRoleDisplayAttribueID Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetRoleAttributeValue");

	Params::TgfInventoryRoleWrapper_GetRoleAttributeValue Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper.GetTalentOfFirstLevelAttribute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfFirstLevelAttrDataAsset*      DataAsset                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         Career                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               ConditionalAttr                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTgfCareerTalentCfgItem>  Configs                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfInventoryRoleWrapper::GetTalentOfFirstLevelAttribute(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, const struct FGameplayAttribute& ConditionalAttr, TArray<struct FTgfCareerTalentCfgItem>* Configs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetTalentOfFirstLevelAttribute");

	Params::TgfInventoryRoleWrapper_GetTalentOfFirstLevelAttribute Parms{};

	Parms.DataAsset = DataAsset;
	Parms.Career = Career;
	Parms.Race = Race;
	Parms.ConditionalAttr = std::move(ConditionalAttr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configs != nullptr)
		*Configs = std::move(Parms.Configs);
}


// Function LyraGame.TgfInventoryRoleWrapper.GetTalentsOfAttribute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EnRoleDisplayAttribueID                 Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Talents                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           OpenedTalents                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfInventoryRoleWrapper::GetTalentsOfAttribute(EnRoleDisplayAttribueID Type_id, TArray<int32>* Talents, TArray<int32>* OpenedTalents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetTalentsOfAttribute");

	Params::TgfInventoryRoleWrapper_GetTalentsOfAttribute Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Talents != nullptr)
		*Talents = std::move(Parms.Talents);

	if (OpenedTalents != nullptr)
		*OpenedTalents = std::move(Parms.OpenedTalents);
}


// Function LyraGame.TgfInventoryRoleWrapper.GetOwningCharacter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfInventoryRoleWrapper::GetOwningCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetOwningCharacter");

	Params::TgfInventoryRoleWrapper_GetOwningCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper.GetSkillE
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfGameplayAbility*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfGameplayAbility* UTgfInventoryRoleWrapper::GetSkillE() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetSkillE");

	Params::TgfInventoryRoleWrapper_GetSkillE Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper.GetSkillQ
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfGameplayAbility*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfGameplayAbility* UTgfInventoryRoleWrapper::GetSkillQ() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper", "GetSkillQ");

	Params::TgfInventoryRoleWrapper_GetSkillQ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_InventoryItemLeftClickOverride.Create
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             InventoryContext                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_InventoryItemLeftClickOverride*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_InventoryItemLeftClickOverride* UAsyncAction_InventoryItemLeftClickOverride::Create(class UObject* WorldContextObject, class UTgfInventoryWrapper* InventoryContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_InventoryItemLeftClickOverride", "Create");

	Params::AsyncAction_InventoryItemLeftClickOverride_Create Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InventoryContext = InventoryContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AudioObstacleDetectionComponent.SetOneShotObstructionAndOcclusion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     SpeakerComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           IgnoredActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioObstacleDetectionComponent::SetOneShotObstructionAndOcclusion(class UAkComponent* SpeakerComponent, const class AActor* IgnoredActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioObstacleDetectionComponent", "SetOneShotObstructionAndOcclusion");

	Params::AudioObstacleDetectionComponent_SetOneShotObstructionAndOcclusion Parms{};

	Parms.SpeakerComponent = SpeakerComponent;
	Parms.IgnoredActor = IgnoredActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AudioObstacleDetectionComponent.OneShotDiffractionDetection
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UAudioObstacleDetectionComponent::OneShotDiffractionDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioObstacleDetectionComponent", "OneShotDiffractionDetection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AudioObstacleDetectionComponent.OnListenerActorChange
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioObstacleDetectionComponent::OnListenerActorChange(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioObstacleDetectionComponent", "OnListenerActorChange");

	Params::AudioObstacleDetectionComponent_OnListenerActorChange Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AudioObstacleDetectionComponent.SetDiffractionSoundPoints
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     SpeakerComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioObstacleDetectionComponent::SetDiffractionSoundPoints(class UAkComponent* SpeakerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioObstacleDetectionComponent", "SetDiffractionSoundPoints");

	Params::AudioObstacleDetectionComponent_SetDiffractionSoundPoints Parms{};

	Parms.SpeakerComponent = SpeakerComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AudioObstacleDetectionComponent.SetOcclusion
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     SpeakerComponent                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioObstacleDetectionComponent::SetOcclusion(const class UAkComponent* SpeakerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioObstacleDetectionComponent", "SetOcclusion");

	Params::AudioObstacleDetectionComponent_SetOcclusion Parms{};

	Parms.SpeakerComponent = SpeakerComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AudioObstacleDetectionComponent.ShowDebug
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UAudioObstacleDetectionComponent::ShowDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioObstacleDetectionComponent", "ShowDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCursorPayloadFunctions.DiscardCursorPayload
// (Final, Native, Static, Public, BlueprintCallable)

void UTgfCursorPayloadFunctions::DiscardCursorPayload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfCursorPayloadFunctions", "DiscardCursorPayload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCursorPayloadFunctions.InstigateCursorPayload
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               DragDropOperation                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UTgfCursorPayloadFunctions::InstigateCursorPayload(const struct FPointerEvent& MouseEvent, class UDragDropOperation* DragDropOperation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfCursorPayloadFunctions", "InstigateCursorPayload");

	Params::TgfCursorPayloadFunctions_InstigateCursorPayload Parms{};

	Parms.MouseEvent = std::move(MouseEvent);
	Parms.DragDropOperation = DragDropOperation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsBpFuncLibrary.FillOssLogPlayerInteraction
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InTargetName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsBpFuncLibrary::FillOssLogPlayerInteraction(class ALyraCharacter* InCharacter, const class FString& InTargetName, const struct FVector& InLocation, int32 ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleDsBpFuncLibrary", "FillOssLogPlayerInteraction");

	Params::BattleDsBpFuncLibrary_FillOssLogPlayerInteraction Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InTargetName = std::move(InTargetName);
	Parms.InLocation = std::move(InLocation);
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.GameOver
// (Final, Native, Public, BlueprintCallable)

void UBattleDsUtility::GameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "GameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.GetCurrentUserCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattleDsUtility::GetCurrentUserCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "GetCurrentUserCount");

	Params::BattleDsUtility_GetCurrentUserCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.GetFlawlessTrialLevelArgs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    _Flawless                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _WinningStreak                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bRewardsAvailable                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::GetFlawlessTrialLevelArgs(bool* _Flawless, int32* _WinningStreak, bool* _bRewardsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "GetFlawlessTrialLevelArgs");

	Params::BattleDsUtility_GetFlawlessTrialLevelArgs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_Flawless != nullptr)
		*_Flawless = Parms._Flawless;

	if (_WinningStreak != nullptr)
		*_WinningStreak = Parms._WinningStreak;

	if (_bRewardsAvailable != nullptr)
		*_bRewardsAvailable = Parms._bRewardsAvailable;
}


// Function LyraGame.BattleDsUtility.GetHomelandLevelArgs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int64                                   _LastMoonEyeInteractionTimeStamp                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   _CurrentCycleTimeStamp                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   _CycleLength                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::GetHomelandLevelArgs(int64* _LastMoonEyeInteractionTimeStamp, int64* _CurrentCycleTimeStamp, int64* _CycleLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "GetHomelandLevelArgs");

	Params::BattleDsUtility_GetHomelandLevelArgs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_LastMoonEyeInteractionTimeStamp != nullptr)
		*_LastMoonEyeInteractionTimeStamp = Parms._LastMoonEyeInteractionTimeStamp;

	if (_CurrentCycleTimeStamp != nullptr)
		*_CurrentCycleTimeStamp = Parms._CurrentCycleTimeStamp;

	if (_CycleLength != nullptr)
		*_CycleLength = Parms._CycleLength;
}


// Function LyraGame.BattleDsUtility.GetTotalUserCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattleDsUtility::GetTotalUserCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "GetTotalUserCount");

	Params::BattleDsUtility_GetTotalUserCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.GetWaitingRoomTimeout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleDsUtility::GetWaitingRoomTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "GetWaitingRoomTimeout");

	Params::BattleDsUtility_GetWaitingRoomTimeout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.HasNextFloor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleDsUtility::HasNextFloor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "HasNextFloor");

	Params::BattleDsUtility_HasNextFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.InitGameMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Map_id                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Game_timeout                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsIndependentMapMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattleDsUtility::InitGameMap(int32 Map_id, int32 Game_timeout, bool IsIndependentMapMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "InitGameMap");

	Params::BattleDsUtility_InitGameMap Parms{};

	Parms.Map_id = Map_id;
	Parms.Game_timeout = Game_timeout;
	Parms.IsIndependentMapMode = IsIndependentMapMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.InitPlayerGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::InitPlayerGameData(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "InitPlayerGameData");

	Params::BattleDsUtility_InitPlayerGameData Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.IsOptionArgsInit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleDsUtility::IsOptionArgsInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "IsOptionArgsInit");

	Params::BattleDsUtility_IsOptionArgsInit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.IsPlayerGameOver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleDsUtility::IsPlayerGameOver(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "IsPlayerGameOver");

	Params::BattleDsUtility_IsPlayerGameOver Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.IsRoomReady
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleDsUtility::IsRoomReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "IsRoomReady");

	Params::BattleDsUtility_IsRoomReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.OnMapFinish
// (Final, Native, Public, BlueprintCallable)

void UBattleDsUtility::OnMapFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "OnMapFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.OptionArgs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int32> UBattleDsUtility::OptionArgs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "OptionArgs");

	Params::BattleDsUtility_OptionArgs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleDsUtility.PlayerDeadPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSmallBackpackActive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::PlayerDeadPlayerState(class APlayerState* PlayerState, bool bSmallBackpackActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "PlayerDeadPlayerState");

	Params::BattleDsUtility_PlayerDeadPlayerState Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bSmallBackpackActive = bSmallBackpackActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.PlayerUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::PlayerUseItem(class APlayerState* PlayerState, int32 ItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "PlayerUseItem");

	Params::BattleDsUtility_PlayerUseItem Parms{};

	Parms.PlayerState = PlayerState;
	Parms.ItemId = ItemId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.PVPGameWinTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Faction_id                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::PVPGameWinTeam(int32 Faction_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "PVPGameWinTeam");

	Params::BattleDsUtility_PVPGameWinTeam Parms{};

	Parms.Faction_id = Faction_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleDsUtility.PVPGameWinTeamRound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Round_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Faction_id                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDsUtility::PVPGameWinTeamRound(int32 Round_id, int32 Faction_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleDsUtility", "PVPGameWinTeamRound");

	Params::BattleDsUtility_PVPGameWinTeamRound Parms{};

	Parms.Round_id = Round_id;
	Parms.Faction_id = Faction_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.BP_ApplyGameplayEffectToASCTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameplayEffectLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle ULyraGameplayAbility::BP_ApplyGameplayEffectToASCTarget(class UAbilitySystemComponent* Target, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "BP_ApplyGameplayEffectToASCTarget");

	Params::LyraGameplayAbility_BP_ApplyGameplayEffectToASCTarget Parms{};

	Parms.Target = Target;
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.GameplayEffectLevel = GameplayEffectLevel;
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.ChangeActivationGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELyraAbilityActivationGroup             NewGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraGameplayAbility::ChangeActivationGroup(ELyraAbilityActivationGroup NewGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "ChangeActivationGroup");

	Params::LyraGameplayAbility_ChangeActivationGroup Parms{};

	Parms.NewGroup = NewGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.ClearCameraMode
// (Final, Native, Public, BlueprintCallable)

void ULyraGameplayAbility::ClearCameraMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "ClearCameraMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.ClearCameraModeFromServer
// (Final, Native, Public, BlueprintCallable)

void ULyraGameplayAbility::ClearCameraModeFromServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "ClearCameraModeFromServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.K2_ApplyGameplayEffectSpecToASCTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        EffectSpecHandle                                       (ConstParm, Parm, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle ULyraGameplayAbility::K2_ApplyGameplayEffectSpecToASCTarget(const struct FGameplayEffectSpecHandle& EffectSpecHandle, class UAbilitySystemComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "K2_ApplyGameplayEffectSpecToASCTarget");

	Params::LyraGameplayAbility_K2_ApplyGameplayEffectSpecToASCTarget Parms{};

	Parms.EffectSpecHandle = std::move(EffectSpecHandle);
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.K2_OnAbilityAdded
// (Event, Protected, BlueprintEvent)

void ULyraGameplayAbility::K2_OnAbilityAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "K2_OnAbilityAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraGameplayAbility.K2_OnAbilityRemoved
// (Event, Protected, BlueprintEvent)

void ULyraGameplayAbility::K2_OnAbilityRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "K2_OnAbilityRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraGameplayAbility.K2_OnPawnAvatarSet
// (Event, Protected, BlueprintEvent)

void ULyraGameplayAbility::K2_OnPawnAvatarSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "K2_OnPawnAvatarSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraGameplayAbility.OnCameraModeDelayTimeFinish
// (Final, Native, Public)

void ULyraGameplayAbility::OnCameraModeDelayTimeFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "OnCameraModeDelayTimeFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.PickBestCastSkillMontage
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            CosmeticTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETgfMontageEntryType                    EntryType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     FindMontage                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraGameplayAbility::PickBestCastSkillMontage(const struct FGameplayTagContainer& CosmeticTag, ETgfMontageEntryType EntryType, class UAnimMontage** FindMontage, class FName* SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "PickBestCastSkillMontage");

	Params::LyraGameplayAbility_PickBestCastSkillMontage Parms{};

	Parms.CosmeticTag = std::move(CosmeticTag);
	Parms.EntryType = EntryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FindMontage != nullptr)
		*FindMontage = Parms.FindMontage;

	if (SectionName != nullptr)
		*SectionName = Parms.SectionName;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.PickBestCastSkillMontage_FilteredWithTag
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            CosmeticTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     FilterTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfMontageEntryType                    EntryType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     FindMontage                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraGameplayAbility::PickBestCastSkillMontage_FilteredWithTag(const struct FGameplayTagContainer& CosmeticTag, const struct FGameplayTag& FilterTag, ETgfMontageEntryType EntryType, class UAnimMontage** FindMontage, class FName* SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "PickBestCastSkillMontage_FilteredWithTag");

	Params::LyraGameplayAbility_PickBestCastSkillMontage_FilteredWithTag Parms{};

	Parms.CosmeticTag = std::move(CosmeticTag);
	Parms.FilterTag = std::move(FilterTag);
	Parms.EntryType = EntryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FindMontage != nullptr)
		*FindMontage = Parms.FindMontage;

	if (SectionName != nullptr)
		*SectionName = Parms.SectionName;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.ReceiveInputPressed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayAbilityActivationInfo   ActivationInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::ReceiveInputPressed(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilityActivationInfo& ActivationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "ReceiveInputPressed");

	Params::LyraGameplayAbility_ReceiveInputPressed Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.ActivationInfo = std::move(ActivationInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraGameplayAbility.ReceiveInputReleased
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayAbilityActivationInfo   ActivationInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::ReceiveInputReleased(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilityActivationInfo& ActivationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "ReceiveInputReleased");

	Params::LyraGameplayAbility_ReceiveInputReleased Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.ActivationInfo = std::move(ActivationInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraGameplayAbility.RemoveGameplayEffectFromOwnerExcludedAssetTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ExcludedTags                                           (Parm, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::RemoveGameplayEffectFromOwnerExcludedAssetTags(const struct FGameplayTagContainer& ExcludedTags, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "RemoveGameplayEffectFromOwnerExcludedAssetTags");

	Params::LyraGameplayAbility_RemoveGameplayEffectFromOwnerExcludedAssetTags Parms{};

	Parms.ExcludedTags = std::move(ExcludedTags);
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.SetAutoRecoverCameraMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      CameraMode                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::SetAutoRecoverCameraMode(TSubclassOf<class ULyraCameraMode> CameraMode, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "SetAutoRecoverCameraMode");

	Params::LyraGameplayAbility_SetAutoRecoverCameraMode Parms{};

	Parms.CameraMode = CameraMode;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.SetCameraMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      CameraMode                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::SetCameraMode(TSubclassOf<class ULyraCameraMode> CameraMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "SetCameraMode");

	Params::LyraGameplayAbility_SetCameraMode Parms{};

	Parms.CameraMode = CameraMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.SetCameraModeFromServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      CameraMode                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::SetCameraModeFromServer(TSubclassOf<class ULyraCameraMode> CameraMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "SetCameraModeFromServer");

	Params::LyraGameplayAbility_SetCameraModeFromServer Parms{};

	Parms.CameraMode = CameraMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility.CanChangeActivationGroup
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// ELyraAbilityActivationGroup             NewGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraGameplayAbility::CanChangeActivationGroup(ELyraAbilityActivationGroup NewGroup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "CanChangeActivationGroup");

	Params::LyraGameplayAbility_CanChangeActivationGroup Parms{};

	Parms.NewGroup = NewGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.GetControllerFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* ULyraGameplayAbility::GetControllerFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "GetControllerFromActorInfo");

	Params::LyraGameplayAbility_GetControllerFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.GetHeroComponentFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraHeroComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraHeroComponent* ULyraGameplayAbility::GetHeroComponentFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "GetHeroComponentFromActorInfo");

	Params::LyraGameplayAbility_GetHeroComponentFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.GetLyraAbilitySystemComponentFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ULyraGameplayAbility::GetLyraAbilitySystemComponentFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "GetLyraAbilitySystemComponentFromActorInfo");

	Params::LyraGameplayAbility_GetLyraAbilitySystemComponentFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.GetLyraCharacterFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* ULyraGameplayAbility::GetLyraCharacterFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "GetLyraCharacterFromActorInfo");

	Params::LyraGameplayAbility_GetLyraCharacterFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.GetLyraPlayerControllerFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraPlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerController* ULyraGameplayAbility::GetLyraPlayerControllerFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "GetLyraPlayerControllerFromActorInfo");

	Params::LyraGameplayAbility_GetLyraPlayerControllerFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility.ScriptOnAbilityFailedToActivate
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FGameplayTagContainer            FailedReason                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraGameplayAbility::ScriptOnAbilityFailedToActivate(const struct FGameplayTagContainer& FailedReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility", "ScriptOnAbilityFailedToActivate");

	Params::LyraGameplayAbility_ScriptOnAbilityFailedToActivate Parms{};

	Parms.FailedReason = std::move(FailedReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAbility.ApplyAOEGameplayEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraTeamComparison                     TeamRestrict                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALyraCharacter*>           AppliedActors                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FTgfApplyAOEExtraParam           ExtraParams                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfGameplayAbility::ApplyAOEGameplayEffect(TArray<class AActor*>& Actors, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 MaxNum, ELyraTeamComparison TeamRestrict, TArray<class ALyraCharacter*>* AppliedActors, const struct FTgfApplyAOEExtraParam& ExtraParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "ApplyAOEGameplayEffect");

	Params::TgfGameplayAbility_ApplyAOEGameplayEffect Parms{};

	Parms.Actors = std::move(Actors);
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.MaxNum = MaxNum;
	Parms.TeamRestrict = TeamRestrict;
	Parms.ExtraParams = std::move(ExtraParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	if (AppliedActors != nullptr)
		*AppliedActors = std::move(Parms.AppliedActors);
}


// Function LyraGame.TgfGameplayAbility.ApplyGameplayEffectToOwnerWithTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameplayEffectLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UTgfGameplayAbility::ApplyGameplayEffectToOwnerWithTags(const struct FGameplayTagContainer& Tags, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "ApplyGameplayEffectToOwnerWithTags");

	Params::TgfGameplayAbility_ApplyGameplayEffectToOwnerWithTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.GameplayEffectLevel = GameplayEffectLevel;
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.ApplyGameplayEffectToTargetWithTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle Target                                                 (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameplayEffectLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UTgfGameplayAbility::ApplyGameplayEffectToTargetWithTags(const struct FGameplayTagContainer& Tags, const struct FGameplayAbilityTargetDataHandle& Target, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "ApplyGameplayEffectToTargetWithTags");

	Params::TgfGameplayAbility_ApplyGameplayEffectToTargetWithTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.Target = std::move(Target);
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.GameplayEffectLevel = GameplayEffectLevel;
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.ApplyGameplayEffectWithTags
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAbility::ApplyGameplayEffectWithTags(const struct FGameplayTagContainer& Tags, const TDelegate<void()>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "ApplyGameplayEffectWithTags");

	Params::TgfGameplayAbility_ApplyGameplayEffectWithTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility.CheckAbilityTaskMonitorSatisfied
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CheckAbilityTaskMonitorSatisfied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CheckAbilityTaskMonitorSatisfied");

	Params::TgfGameplayAbility_CheckAbilityTaskMonitorSatisfied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.CheckValidFromInputTag
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CheckValidFromInputTag(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CheckValidFromInputTag");

	Params::TgfGameplayAbility_CheckValidFromInputTag Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.CommitSubAbilityCost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   OutMagicCost                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEffect*                  CostGE                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               CostAttribute                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreCostCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CommitSubAbilityCost(float& OutMagicCost, const class UGameplayEffect* CostGE, const struct FGameplayAttribute& CostAttribute, bool IgnoreCostCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CommitSubAbilityCost");

	Params::TgfGameplayAbility_CommitSubAbilityCost Parms{};

	Parms.OutMagicCost = OutMagicCost;
	Parms.CostGE = CostGE;
	Parms.CostAttribute = std::move(CostAttribute);
	Parms.IgnoreCostCheck = IgnoreCostCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutMagicCost = Parms.OutMagicCost;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.DisperseActiveBuff
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            HighPriorityTags                                       (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::DisperseActiveBuff(TArray<class AActor*>& Actors, const struct FGameplayTag& Tag, const struct FGameplayTagContainer& HighPriorityTags, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "DisperseActiveBuff");

	Params::TgfGameplayAbility_DisperseActiveBuff Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Tag = std::move(Tag);
	Parms.HighPriorityTags = std::move(HighPriorityTags);
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetCollectableActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTgfCollectableActorInfo> OutActorInfos                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CheckAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreBlock                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAbility::GetCollectableActors(TArray<struct FTgfCollectableActorInfo>* OutActorInfos, class AActor* SourceActor, float Radius, float CheckAngle, ETraceTypeQuery TraceChannel, bool bIgnoreBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetCollectableActors");

	Params::TgfGameplayAbility_GetCollectableActors Parms{};

	Parms.SourceActor = SourceActor;
	Parms.Radius = Radius;
	Parms.CheckAngle = CheckAngle;
	Parms.TraceChannel = TraceChannel;
	Parms.bIgnoreBlock = bIgnoreBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActorInfos != nullptr)
		*OutActorInfos = std::move(Parms.OutActorInfos);
}


// Function LyraGame.TgfGameplayAbility.GetCooldownTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UTgfGameplayAbility::GetCooldownTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetCooldownTag");

	Params::TgfGameplayAbility_GetCooldownTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetCooldownTimeDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfGameplayAbility::GetCooldownTimeDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetCooldownTimeDuration");

	Params::TgfGameplayAbility_GetCooldownTimeDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetSkillWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIgnoreTagCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfSkillWidgetBase*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfSkillWidgetBase* UTgfGameplayAbility::GetSkillWidget(bool bIgnoreTagCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetSkillWidget");

	Params::TgfGameplayAbility_GetSkillWidget Parms{};

	Parms.bIgnoreTagCheck = bIgnoreTagCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetSpecGA
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameplayAbility*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayAbility* UTgfGameplayAbility::GetSpecGA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetSpecGA");

	Params::TgfGameplayAbility_GetSpecGA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.K2_CheckValidFromInputTag
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::K2_CheckValidFromInputTag(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "K2_CheckValidFromInputTag");

	Params::TgfGameplayAbility_K2_CheckValidFromInputTag Parms{};

	Parms.InputTag = std::move(InputTag);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.MakeEffectContextSimple
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle UTgfGameplayAbility::MakeEffectContextSimple()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "MakeEffectContextSimple");

	Params::TgfGameplayAbility_MakeEffectContextSimple Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.MatchCoolDownTagBySpecHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::MatchCoolDownTagBySpecHandle(const struct FGameplayEffectSpecHandle& SpecHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "MatchCoolDownTagBySpecHandle");

	Params::TgfGameplayAbility_MatchCoolDownTagBySpecHandle Parms{};

	Parms.SpecHandle = std::move(SpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.PostEndAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGameplayAbility*                 ActivatedAbility                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAbility::PostEndAbility(class UGameplayAbility* ActivatedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "PostEndAbility");

	Params::TgfGameplayAbility_PostEndAbility Parms{};

	Parms.ActivatedAbility = ActivatedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility.RegisterEndAbilityCallback
// (Final, Native, Public, BlueprintCallable)

void UTgfGameplayAbility::RegisterEndAbilityCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "RegisterEndAbilityCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility.CheckAdditionCooldownTags
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            AdditionalTags                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CheckAdditionCooldownTags(const struct FGameplayTagContainer& AdditionalTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CheckAdditionCooldownTags");

	Params::TgfGameplayAbility_CheckAdditionCooldownTags Parms{};

	Parms.AdditionalTags = std::move(AdditionalTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.CheckEquipmentInstanceRestrict
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          SourceObject                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 AbilityInstance                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CheckEquipmentInstanceRestrict(const class UObject* SourceObject, const class UGameplayAbility* AbilityInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CheckEquipmentInstanceRestrict");

	Params::TgfGameplayAbility_CheckEquipmentInstanceRestrict Parms{};

	Parms.SourceObject = SourceObject;
	Parms.AbilityInstance = AbilityInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.CheckEquipmentInstanceValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          TargetObject                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CheckEquipmentInstanceValid(const class UObject* TargetObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CheckEquipmentInstanceValid");

	Params::TgfGameplayAbility_CheckEquipmentInstanceValid Parms{};

	Parms.TargetObject = TargetObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.CheckSubAbilityCost
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  CostGE                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     FailedTag                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::CheckSubAbilityCost(const class UGameplayEffect* CostGE, struct FGameplayTag* FailedTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "CheckSubAbilityCost");

	Params::TgfGameplayAbility_CheckSubAbilityCost Parms{};

	Parms.CostGE = CostGE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailedTag != nullptr)
		*FailedTag = std::move(Parms.FailedTag);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetAnotherEquipmentInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ULyraEquipmentInstance*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraEquipmentInstance* UTgfGameplayAbility::GetAnotherEquipmentInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetAnotherEquipmentInstance");

	Params::TgfGameplayAbility_GetAnotherEquipmentInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetSourceEquipmentInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ULyraEquipmentInstance*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraEquipmentInstance* UTgfGameplayAbility::GetSourceEquipmentInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetSourceEquipmentInstance");

	Params::TgfGameplayAbility_GetSourceEquipmentInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.GetWeaponHandType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponHandType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponHandType UTgfGameplayAbility::GetWeaponHandType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "GetWeaponHandType");

	Params::TgfGameplayAbility_GetWeaponHandType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.HasTalentTag
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// struct FGameplayTag                     TagToCheck                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::HasTalentTag(const struct FGameplayTag& TagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "HasTalentTag");

	Params::TgfGameplayAbility_HasTalentTag Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.IsCharacterStateValid
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::IsCharacterStateValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "IsCharacterStateValid");

	Params::TgfGameplayAbility_IsCharacterStateValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.IsCurrentActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::IsCurrentActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "IsCurrentActive");

	Params::TgfGameplayAbility_IsCurrentActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.IsUsingWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSubType                        EquipSubType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::IsUsingWeapon(ETgfEquipSubType EquipSubType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "IsUsingWeapon");

	Params::TgfGameplayAbility_IsUsingWeapon Parms{};

	Parms.EquipSubType = EquipSubType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.K2_GetCooldownGameplayEffect
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UGameplayEffect*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayEffect* UTgfGameplayAbility::K2_GetCooldownGameplayEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "K2_GetCooldownGameplayEffect");

	Params::TgfGameplayAbility_K2_GetCooldownGameplayEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility.K2_PostCheckCooldown
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAbility::K2_PostCheckCooldown(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, bool CheckResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility", "K2_PostCheckCooldown");

	Params::TgfGameplayAbility_K2_PostCheckCooldown Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Handle = std::move(Handle);
	Parms.CheckResult = CheckResult;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.AddItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryManagerComponent*    Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ClassName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleUtility::AddItem(class UTgfInventoryManagerComponent* Component, int32 ItemId, int32 Nums, const class FString& ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "AddItem");

	Params::BattleUtility_AddItem Parms{};

	Parms.Component = Component;
	Parms.ItemId = ItemId;
	Parms.Nums = Nums;
	Parms.ClassName = std::move(ClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BattleUtility.CreateItemInstanceForLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCnt                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ClassName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryItemInstance*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTgfInventoryItemInstance*> UBattleUtility::CreateItemInstanceForLobby(class AActor* Owner, int32 ItemId, int32 ItemCnt, const class FString& ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "CreateItemInstanceForLobby");

	Params::BattleUtility_CreateItemInstanceForLobby Parms{};

	Parms.Owner = Owner;
	Parms.ItemId = ItemId;
	Parms.ItemCnt = ItemCnt;
	Parms.ClassName = std::move(ClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.GetEquipSubtype
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSubType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSubType UBattleUtility::GetEquipSubtype(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetEquipSubtype");

	Params::BattleUtility_GetEquipSubtype Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.GetEquipType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponEquipType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponEquipType UBattleUtility::GetEquipType(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetEquipType");

	Params::BattleUtility_GetEquipType Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.GetMatchedCareers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ETgfEquipSubType                        EquipType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ETgfActorCareer>                 ActorCareer                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleUtility::GetMatchedCareers(ETgfEquipSubType EquipType, TArray<ETgfActorCareer>* ActorCareer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetMatchedCareers");

	Params::BattleUtility_GetMatchedCareers Parms{};

	Parms.EquipType = EquipType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActorCareer != nullptr)
		*ActorCareer = std::move(Parms.ActorCareer);

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.GetTalentOfFirstLevelAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfFirstLevelAttrDataAsset*      DataAsset                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         Career                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               ConditionalAttr                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTgfCareerTalentCfgItem>  Configs                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBattleUtility::GetTalentOfFirstLevelAttribute(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, const struct FGameplayAttribute& ConditionalAttr, TArray<struct FTgfCareerTalentCfgItem>* Configs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetTalentOfFirstLevelAttribute");

	Params::BattleUtility_GetTalentOfFirstLevelAttribute Parms{};

	Parms.DataAsset = DataAsset;
	Parms.Career = Career;
	Parms.Race = Race;
	Parms.ConditionalAttr = std::move(ConditionalAttr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configs != nullptr)
		*Configs = std::move(Parms.Configs);
}


// Function LyraGame.BattleUtility.GetTalentOfGameplayTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTgfCareerTalentCfgItem>  Talents                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TagToCheck                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfCareerTalentCfgItem          OutTalent                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleUtility::GetTalentOfGameplayTag(const TArray<struct FTgfCareerTalentCfgItem>& Talents, const struct FGameplayTag& TagToCheck, struct FTgfCareerTalentCfgItem* OutTalent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetTalentOfGameplayTag");

	Params::BattleUtility_GetTalentOfGameplayTag Parms{};

	Parms.Talents = std::move(Talents);
	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTalent != nullptr)
		*OutTalent = std::move(Parms.OutTalent);

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.GetTalents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfFirstLevelAttrDataAsset*      DataAsset                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         Career                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTgfCareerTalentCfgItem>  Configs                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBattleUtility::GetTalents(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, TArray<struct FTgfCareerTalentCfgItem>* Configs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetTalents");

	Params::BattleUtility_GetTalents Parms{};

	Parms.DataAsset = DataAsset;
	Parms.Career = Career;
	Parms.Race = Race;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configs != nullptr)
		*Configs = std::move(Parms.Configs);
}


// Function LyraGame.BattleUtility.GetTalentsWithOrder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfFirstLevelAttrDataAsset*      DataAsset                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         Career                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTgfCareerTalentCfgItem>  Configs                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBattleUtility::GetTalentsWithOrder(const class UTgfFirstLevelAttrDataAsset* DataAsset, ETgfActorCareer Career, ETgfActorRace Race, TArray<struct FTgfCareerTalentCfgItem>* Configs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetTalentsWithOrder");

	Params::BattleUtility_GetTalentsWithOrder Parms{};

	Parms.DataAsset = DataAsset;
	Parms.Career = Career;
	Parms.Race = Race;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configs != nullptr)
		*Configs = std::move(Parms.Configs);
}


// Function LyraGame.BattleUtility.GetUExcelLoaderTgfConfigExcelConstConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UExcelLoaderTgfConfigExcelConstConfig*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UExcelLoaderTgfConfigExcelConstConfig* UBattleUtility::GetUExcelLoaderTgfConfigExcelConstConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "GetUExcelLoaderTgfConfigExcelConstConfig");

	Params::BattleUtility_GetUExcelLoaderTgfConfigExcelConstConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.IsEquipMatchLeftWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfInventoryItemDefinition>Main_weapon                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSubType                        Left_type                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleUtility::IsEquipMatchLeftWeapon(TSubclassOf<class UTgfInventoryItemDefinition> Main_weapon, ETgfEquipSubType Left_type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "IsEquipMatchLeftWeapon");

	Params::BattleUtility_IsEquipMatchLeftWeapon Parms{};

	Parms.Main_weapon = Main_weapon;
	Parms.Left_type = Left_type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.Loot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SourceName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserKey                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APlayerState*>             PlayerStates                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class APlayerState*                     LootPlayerState                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ClassName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LootType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryItemInstance*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTgfInventoryItemInstance*> UBattleUtility::Loot(class AActor* Owner, const class FString& SourceName, const class FString& UserKey, const TArray<class APlayerState*>& PlayerStates, class APlayerState* LootPlayerState, const class FString& ClassName, int32 LootType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "Loot");

	Params::BattleUtility_Loot Parms{};

	Parms.Owner = Owner;
	Parms.SourceName = std::move(SourceName);
	Parms.UserKey = std::move(UserKey);
	Parms.PlayerStates = std::move(PlayerStates);
	Parms.LootPlayerState = LootPlayerState;
	Parms.ClassName = std::move(ClassName);
	Parms.LootType = LootType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BattleUtility.MatchCareer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETgfEquipSubType                        EquipType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         ActorCareer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleUtility::MatchCareer(ETgfEquipSubType EquipType, ETgfActorCareer ActorCareer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleUtility", "MatchCareer");

	Params::BattleUtility_MatchCareer Parms{};

	Parms.EquipType = EquipType;
	Parms.ActorCareer = ActorCareer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.BTTask_BlackboardObserve.RegisterObserve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   KeyID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_BlackboardObserve::RegisterObserve(uint8 KeyID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_BlackboardObserve", "RegisterObserve");

	Params::BTTask_BlackboardObserve_RegisterObserve Parms{};

	Parms.KeyID = KeyID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.BTTask_BlackboardObserve.UnregisterObserve
// (Final, Native, Public, BlueprintCallable)

void UBTTask_BlackboardObserve::UnregisterObserve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_BlackboardObserve", "UnregisterObserve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.CharacterSelectionComponent.ClearCustomnTraceStartPos
// (Final, Native, Public, BlueprintCallable)

void UCharacterSelectionComponent::ClearCustomnTraceStartPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectionComponent", "ClearCustomnTraceStartPos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.CharacterSelectionComponent.ClearFilterCallback
// (Final, Native, Public, BlueprintCallable)

void UCharacterSelectionComponent::ClearFilterCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectionComponent", "ClearFilterCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.CharacterSelectionComponent.SetCustomnTraceStartPos
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       InGetTraceStartPosDelegate                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSelectionComponent::SetCustomnTraceStartPos(TDelegate<void()> InGetTraceStartPosDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectionComponent", "SetCustomnTraceStartPos");

	Params::CharacterSelectionComponent_SetCustomnTraceStartPos Parms{};

	Parms.InGetTraceStartPosDelegate = InGetTraceStartPosDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.CharacterSelectionComponent.SetFilterCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class AActor* Actor)>    InOnShouldActorSelected                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSelectionComponent::SetFilterCallback(TDelegate<void(class AActor* Actor)> InOnShouldActorSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectionComponent", "SetFilterCallback");

	Params::CharacterSelectionComponent_SetFilterCallback Parms{};

	Parms.InOnShouldActorSelected = InOnShouldActorSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.CharacterSelectionComponent.GetTraceStartPos
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// class AController*                      Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterSelectionComponent::GetTraceStartPos(const class AController* Controller) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectionComponent", "GetTraceStartPos");

	Params::CharacterSelectionComponent_GetTraceStartPos Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.CharacterSelectionComponent.IsActorValid
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSelectionComponent::IsActorValid(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectionComponent", "IsActorValid");

	Params::CharacterSelectionComponent_IsActorValid Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfComboBoxString.TgfOnOpening
// (Native, Event, Public, BlueprintEvent)

void UTgfComboBoxString::TgfOnOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfComboBoxString", "TgfOnOpening");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfComboBoxString.TgfOnSelectionChanged
// (Native, Event, Public, BlueprintEvent)

void UTgfComboBoxString::TgfOnSelectionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfComboBoxString", "TgfOnSelectionChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.DataUtility.FindFragmentByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>Item_class                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemFragment>Fragment_class                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULyraInventoryItemFragment* ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraInventoryItemFragment* UDataUtility::FindFragmentByClass(TSubclassOf<class ULyraInventoryItemDefinition> Item_class, TSubclassOf<class ULyraInventoryItemFragment> Fragment_class)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "FindFragmentByClass");

	Params::DataUtility_FindFragmentByClass Parms{};

	Parms.Item_class = Item_class;
	Parms.Fragment_class = Fragment_class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetBestFitDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>SourceDef                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> UDataUtility::GetBestFitDefinition(TSubclassOf<class ULyraInventoryItemDefinition> SourceDef, int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetBestFitDefinition");

	Params::DataUtility_GetBestFitDefinition Parms{};

	Parms.SourceDef = SourceDef;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetClassDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Param_Class                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDataUtility::GetClassDefaultObject(class UClass* Param_Class)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetClassDefaultObject");

	Params::DataUtility_GetClassDefaultObject Parms{};

	Parms.Param_Class = Param_Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetDataUtilityInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataUtility*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataUtility* UDataUtility::GetDataUtilityInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetDataUtilityInstance");

	Params::DataUtility_GetDataUtilityInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetFacadeItemPosOffset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDataUtility::GetFacadeItemPosOffset(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetFacadeItemPosOffset");

	Params::DataUtility_GetFacadeItemPosOffset Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetFacadeItemRotator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDataUtility::GetFacadeItemRotator(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetFacadeItemRotator");

	Params::DataUtility_GetFacadeItemRotator Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetFacadeItemScale
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDataUtility::GetFacadeItemScale(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetFacadeItemScale");

	Params::DataUtility_GetFacadeItemScale Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetHeadFrameDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfItemHeadFrameDefinition      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfItemHeadFrameDefinition UDataUtility::GetHeadFrameDefinition(int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetHeadFrameDefinition");

	Params::DataUtility_GetHeadFrameDefinition Parms{};

	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetPreviewSkinDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>SourceDef                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> UDataUtility::GetPreviewSkinDefinition(TSubclassOf<class ULyraInventoryItemDefinition> SourceDef, int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetPreviewSkinDefinition");

	Params::DataUtility_GetPreviewSkinDefinition Parms{};

	Parms.SourceDef = SourceDef;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetSkinDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>SourceDef                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> UDataUtility::GetSkinDefinition(TSubclassOf<class ULyraInventoryItemDefinition> SourceDef, int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "GetSkinDefinition");

	Params::DataUtility_GetSkinDefinition Parms{};

	Parms.SourceDef = SourceDef;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.IsFacadeItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataUtility::IsFacadeItem(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "IsFacadeItem");

	Params::DataUtility_IsFacadeItem Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.IsGearGemInstItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataUtility::IsGearGemInstItem(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "IsGearGemInstItem");

	Params::DataUtility_IsGearGemInstItem Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.IsRoleItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataUtility::IsRoleItem(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "IsRoleItem");

	Params::DataUtility_IsRoleItem Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.IsSkinItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataUtility::IsSkinItem(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "IsSkinItem");

	Params::DataUtility_IsSkinItem Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.IsVirtualItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataUtility::IsVirtualItem(int32 Type_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataUtility", "IsVirtualItem");

	Params::DataUtility_IsVirtualItem Parms{};

	Parms.Type_id = Type_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetAbilitySetClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULyraAbilitySet*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraAbilitySet* UDataUtility::GetAbilitySetClass(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataUtility", "GetAbilitySetClass");

	Params::DataUtility_GetAbilitySetClass Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetEquipClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EquipId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfEquipmentDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfEquipmentDefinition> UDataUtility::GetEquipClass(int32 EquipId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataUtility", "GetEquipClass");

	Params::DataUtility_GetEquipClass Parms{};

	Parms.EquipId = EquipId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetItemClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfInventoryItemDefinition> UDataUtility::GetItemClass(int32 ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataUtility", "GetItemClass");

	Params::DataUtility_GetItemClass Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DataUtility.GetItemSkinSetClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UItemSkinSet*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UItemSkinSet* UDataUtility::GetItemSkinSetClass(int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataUtility", "GetItemSkinSetClass");

	Params::DataUtility_GetItemSkinSetClass Parms{};

	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_CurSoulEnergy
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_CurSoulEnergy(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_CurSoulEnergy");

	Params::TgfSoulEnergyAttributeSet_OnRep_CurSoulEnergy Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_MaxSoulEnergyBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_MaxSoulEnergyBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_MaxSoulEnergyBase");

	Params::TgfSoulEnergyAttributeSet_OnRep_MaxSoulEnergyBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_MaxSoulEnergyPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_MaxSoulEnergyPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_MaxSoulEnergyPercent");

	Params::TgfSoulEnergyAttributeSet_OnRep_MaxSoulEnergyPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_SoulEnergyGenerateRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_SoulEnergyGenerateRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_SoulEnergyGenerateRate");

	Params::TgfSoulEnergyAttributeSet_OnRep_SoulEnergyGenerateRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_SoulEnergyOnHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_SoulEnergyOnHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_SoulEnergyOnHit");

	Params::TgfSoulEnergyAttributeSet_OnRep_SoulEnergyOnHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_SoulEnergyOnHurt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_SoulEnergyOnHurt(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_SoulEnergyOnHurt");

	Params::TgfSoulEnergyAttributeSet_OnRep_SoulEnergyOnHurt Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.OnRep_SoulEnergyOnKill
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSoulEnergyAttributeSet::OnRep_SoulEnergyOnKill(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "OnRep_SoulEnergyOnKill");

	Params::TgfSoulEnergyAttributeSet_OnRep_SoulEnergyOnKill Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.GetMaxSoulEnergyFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfSoulEnergyAttributeSet::GetMaxSoulEnergyFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "GetMaxSoulEnergyFinal");

	Params::TgfSoulEnergyAttributeSet_GetMaxSoulEnergyFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSoulEnergyAttributeSet.IsFullSEP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfSoulEnergyAttributeSet::IsFullSEP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSoulEnergyAttributeSet", "IsFullSEP");

	Params::TgfSoulEnergyAttributeSet_IsFullSEP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DeathZone.BroadCastSpawnPortalMessage
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   BluePortalSpawned                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RedPortalSpawned                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ShadowPortalSpawned                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeathZone::BroadCastSpawnPortalMessage(int32 BluePortalSpawned, int32 RedPortalSpawned, int32 ShadowPortalSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "BroadCastSpawnPortalMessage");

	Params::DeathZone_BroadCastSpawnPortalMessage Parms{};

	Parms.BluePortalSpawned = BluePortalSpawned;
	Parms.RedPortalSpawned = RedPortalSpawned;
	Parms.ShadowPortalSpawned = ShadowPortalSpawned;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.DeathZone.Generate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDeathZoneDiscRuntimeInstance>OutDiscs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ADeathZone::Generate(TArray<struct FDeathZoneDiscRuntimeInstance>* OutDiscs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "Generate");

	Params::DeathZone_Generate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDiscs != nullptr)
		*OutDiscs = std::move(Parms.OutDiscs);
}


// Function LyraGame.DeathZone.GetSpawnPortalInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSpawnedPortalsInfo              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSpawnedPortalsInfo ADeathZone::GetSpawnPortalInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "GetSpawnPortalInfo");

	Params::DeathZone_GetSpawnPortalInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DeathZone.PickPortalPlacementsWithinRange
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   NumPortals                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CircleOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CircleRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PotentialPlacements                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            bPortalVisited                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FPortalSpawnInfo>         OutPortalInfos                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           SpawnTime                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPortalType                             PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeathZone::PickPortalPlacementsWithinRange(int32 NumPortals, const struct FVector& CircleOrigin, float CircleRadius, TArray<struct FVector>* PotentialPlacements, TArray<bool>* bPortalVisited, TArray<struct FPortalSpawnInfo>* OutPortalInfos, const TArray<float>& SpawnTime, EPortalType PortalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "PickPortalPlacementsWithinRange");

	Params::DeathZone_PickPortalPlacementsWithinRange Parms{};

	Parms.NumPortals = NumPortals;
	Parms.CircleOrigin = std::move(CircleOrigin);
	Parms.CircleRadius = CircleRadius;
	Parms.SpawnTime = std::move(SpawnTime);
	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PotentialPlacements != nullptr)
		*PotentialPlacements = std::move(Parms.PotentialPlacements);

	if (bPortalVisited != nullptr)
		*bPortalVisited = std::move(Parms.bPortalVisited);

	if (OutPortalInfos != nullptr)
		*OutPortalInfos = std::move(Parms.OutPortalInfos);
}


// Function LyraGame.DeathZone.PickPortalPlacementsWithinRangeWithProbability
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   NumPortals                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CircleOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CircleRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PotentialPlacements                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            bPortalVisited                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FPortalSpawnInfo>         OutPortalInfos                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FPortalSpawnConfig>       SpawnTime                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPortalType                             PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeathZone::PickPortalPlacementsWithinRangeWithProbability(int32 NumPortals, const struct FVector& CircleOrigin, float CircleRadius, TArray<struct FVector>* PotentialPlacements, TArray<bool>* bPortalVisited, TArray<struct FPortalSpawnInfo>* OutPortalInfos, const TArray<struct FPortalSpawnConfig>& SpawnTime, EPortalType PortalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "PickPortalPlacementsWithinRangeWithProbability");

	Params::DeathZone_PickPortalPlacementsWithinRangeWithProbability Parms{};

	Parms.NumPortals = NumPortals;
	Parms.CircleOrigin = std::move(CircleOrigin);
	Parms.CircleRadius = CircleRadius;
	Parms.SpawnTime = std::move(SpawnTime);
	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PotentialPlacements != nullptr)
		*PotentialPlacements = std::move(Parms.PotentialPlacements);

	if (bPortalVisited != nullptr)
		*bPortalVisited = std::move(Parms.bPortalVisited);

	if (OutPortalInfos != nullptr)
		*OutPortalInfos = std::move(Parms.OutPortalInfos);
}


// Function LyraGame.DeathZone.PickPortalPlacementsWithinRangeWithSpawnConfigs
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   NumPortals                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CircleOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CircleRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PotentialPlacements                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            bPortalVisited                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FPortalSpawnInfo>         OutPortalInfos                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FPortalSpawnConfig>       SpawnConfigs                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ADeathZone::PickPortalPlacementsWithinRangeWithSpawnConfigs(int32 NumPortals, const struct FVector& CircleOrigin, float CircleRadius, TArray<struct FVector>* PotentialPlacements, TArray<bool>* bPortalVisited, TArray<struct FPortalSpawnInfo>* OutPortalInfos, const TArray<struct FPortalSpawnConfig>& SpawnConfigs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "PickPortalPlacementsWithinRangeWithSpawnConfigs");

	Params::DeathZone_PickPortalPlacementsWithinRangeWithSpawnConfigs Parms{};

	Parms.NumPortals = NumPortals;
	Parms.CircleOrigin = std::move(CircleOrigin);
	Parms.CircleRadius = CircleRadius;
	Parms.SpawnConfigs = std::move(SpawnConfigs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PotentialPlacements != nullptr)
		*PotentialPlacements = std::move(Parms.PotentialPlacements);

	if (bPortalVisited != nullptr)
		*bPortalVisited = std::move(Parms.bPortalVisited);

	if (OutPortalInfos != nullptr)
		*OutPortalInfos = std::move(Parms.OutPortalInfos);
}


// Function LyraGame.DeathZone.SpawnOnePortalOrScroll
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// EPortalType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               PortalClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ADeathZone::SpawnOnePortalOrScroll(EPortalType Type, const struct FTransform& Transform, TSubclassOf<class AActor> PortalClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "SpawnOnePortalOrScroll");

	Params::DeathZone_SpawnOnePortalOrScroll Parms{};

	Parms.Type = Type;
	Parms.Transform = std::move(Transform);
	Parms.PortalClass = PortalClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.DeathZone.SpawnPortalAndScrolls
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDeathZoneDiscRuntimeInstance    CurrentDisc                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// double                                  CurrentTimeDuration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeathZone::SpawnPortalAndScrolls(struct FDeathZoneDiscRuntimeInstance& CurrentDisc, double CurrentTimeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "SpawnPortalAndScrolls");

	Params::DeathZone_SpawnPortalAndScrolls Parms{};

	Parms.CurrentDisc = std::move(CurrentDisc);
	Parms.CurrentTimeDuration = CurrentTimeDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CurrentDisc = std::move(Parms.CurrentDisc);
}


// Function LyraGame.DeathZone.GetAllPortalLocations
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPortalType                             PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> ADeathZone::GetAllPortalLocations(EPortalType PortalType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "GetAllPortalLocations");

	Params::DeathZone_GetAllPortalLocations Parms{};

	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DeathZone.GetAvailablePortalNums
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPortalType                             PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeathZone::GetAvailablePortalNums(EPortalType PortalType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "GetAvailablePortalNums");

	Params::DeathZone_GetAvailablePortalNums Parms{};

	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DeathZone.GetDiscDefinitionByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDeathZoneDisc             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDeathZoneDisc ADeathZone::GetDiscDefinitionByIndex(int32 Param_Index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "GetDiscDefinitionByIndex");

	Params::DeathZone_GetDiscDefinitionByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.DeathZone.RandomPointInCircle
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D ADeathZone::RandomPointInCircle(const struct FVector2D& Center, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathZone", "RandomPointInCircle");

	Params::DeathZone_RandomPointInCircle Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility_MontageCamera.OnDeactivateEventReceived
// (Final, Native, Public)
// Parameters:
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void UTgfGameplayAbility_MontageCamera::OnDeactivateEventReceived(const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_MontageCamera", "OnDeactivateEventReceived");

	Params::TgfGameplayAbility_MontageCamera_OnDeactivateEventReceived Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AsyncAction_ExperienceReady.WaitForExperienceReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_ExperienceReady*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_ExperienceReady* UAsyncAction_ExperienceReady::WaitForExperienceReady(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_ExperienceReady", "WaitForExperienceReady");

	Params::AsyncAction_ExperienceReady_WaitForExperienceReady Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorWidgetInterface.BindIndicator
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UIndicatorDescriptor*             Indicator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIndicatorWidgetInterface::BindIndicator(class UIndicatorDescriptor* Indicator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorWidgetInterface", "BindIndicator");

	Params::IndicatorWidgetInterface_BindIndicator Parms{};

	Parms.Indicator = Indicator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorWidgetInterface.UnbindIndicator
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UIndicatorDescriptor*             Indicator                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIndicatorWidgetInterface::UnbindIndicator(const class UIndicatorDescriptor* Indicator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorWidgetInterface", "UnbindIndicator");

	Params::IndicatorWidgetInterface_UnbindIndicator Parms{};

	Parms.Indicator = Indicator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEnviromentEquipmentSubsystem.InsertToTorchArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TorchActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEnviromentEquipmentSubsystem::InsertToTorchArray(class AActor* TorchActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEnviromentEquipmentSubsystem", "InsertToTorchArray");

	Params::TgfEnviromentEquipmentSubsystem_InsertToTorchArray Parms{};

	Parms.TorchActor = TorchActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraNumberPopComponent.AddNumberPop
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraNumberPopRequest            NewRequest                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraNumberPopComponent::AddNumberPop(const struct FLyraNumberPopRequest& NewRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraNumberPopComponent", "AddNumberPop");

	Params::LyraNumberPopComponent_AddNumberPop Parms{};

	Parms.NewRequest = std::move(NewRequest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.InGameTaskFunctionLibrary.InGameReportClientTaskProgressValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETGFInGameRookieTaskType                RookieTaskType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameTaskFunctionLibrary::InGameReportClientTaskProgressValue(ETGFInGameRookieTaskType RookieTaskType, int64 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InGameTaskFunctionLibrary", "InGameReportClientTaskProgressValue");

	Params::InGameTaskFunctionLibrary_InGameReportClientTaskProgressValue Parms{};

	Parms.RookieTaskType = RookieTaskType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.InGameTaskFunctionLibrary.InGameReportClientTaskProgressValueWithCharacterParam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETGFInGameRookieTaskType                RookieTaskType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameTaskFunctionLibrary::InGameReportClientTaskProgressValueWithCharacterParam(ETGFInGameRookieTaskType RookieTaskType, int64 Value, class ALyraCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InGameTaskFunctionLibrary", "InGameReportClientTaskProgressValueWithCharacterParam");

	Params::InGameTaskFunctionLibrary_InGameReportClientTaskProgressValueWithCharacterParam Parms{};

	Parms.RookieTaskType = RookieTaskType;
	Parms.Value = Value;
	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.InGameTaskFunctionLibrary.InGameReportDeathTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Death                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameTaskFunctionLibrary::InGameReportDeathTask(class AActor* Killer, class AActor* Death)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InGameTaskFunctionLibrary", "InGameReportDeathTask");

	Params::InGameTaskFunctionLibrary_InGameReportDeathTask Parms{};

	Parms.Killer = Killer;
	Parms.Death = Death;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.InGameTaskFunctionLibrary.InGameReportInteractorTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsLootable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Destroyer                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractorTarget                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameTaskFunctionLibrary::InGameReportInteractorTask(bool bIsLootable, class AActor* Destroyer, class AActor* InteractorTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InGameTaskFunctionLibrary", "InGameReportInteractorTask");

	Params::InGameTaskFunctionLibrary_InGameReportInteractorTask Parms{};

	Parms.bIsLootable = bIsLootable;
	Parms.Destroyer = Destroyer;
	Parms.InteractorTarget = InteractorTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayEventAsyncAction.WaitForGameplayEventToCharaOrInteractor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfGameplayEventAsyncAction*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfGameplayEventAsyncAction* UTgfGameplayEventAsyncAction::WaitForGameplayEventToCharaOrInteractor(const class UObject* WorldContext, class AActor* Actor, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameplayEventAsyncAction", "WaitForGameplayEventToCharaOrInteractor");

	Params::TgfGameplayEventAsyncAction_WaitForGameplayEventToCharaOrInteractor Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Actor = Actor;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction LyraGame.TgfGameplayEventAsyncAction.EventReceivedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FGameplayTag                     ReceivedTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfGameplayEventAsyncAction::EventReceivedDelegate__DelegateSignature(const struct FGameplayTag& ReceivedTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayEventAsyncAction", "EventReceivedDelegate__DelegateSignature");

	Params::TgfGameplayEventAsyncAction_EventReceivedDelegate__DelegateSignature Parms{};

	Parms.ReceivedTag = std::move(ReceivedTag);
	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraEquipmentInstance.K2_OnEquipped
// (Event, Protected, BlueprintEvent)

void ULyraEquipmentInstance::K2_OnEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "K2_OnEquipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraEquipmentInstance.K2_OnUnequipped
// (Event, Protected, BlueprintEvent)

void ULyraEquipmentInstance::K2_OnUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "K2_OnUnequipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraEquipmentInstance.OnRep_Instance
// (Final, Native, Protected)

void ULyraEquipmentInstance::OnRep_Instance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "OnRep_Instance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentInstance.GetEquipDef
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    NeedSkined                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraEquipmentDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraEquipmentDefinition> ULyraEquipmentInstance::GetEquipDef(bool NeedSkined) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetEquipDef");

	Params::LyraEquipmentInstance_GetEquipDef Parms{};

	Parms.NeedSkined = NeedSkined;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetEquipId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraEquipmentInstance::GetEquipId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetEquipId");

	Params::LyraEquipmentInstance_GetEquipId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetEquipSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSubType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSubType ULyraEquipmentInstance::GetEquipSubtype() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetEquipSubtype");

	Params::LyraEquipmentInstance_GetEquipSubtype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetEquipType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponEquipType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponEquipType ULyraEquipmentInstance::GetEquipType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetEquipType");

	Params::LyraEquipmentInstance_GetEquipType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraEquipmentInstance::GetInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetInventory");

	Params::LyraEquipmentInstance_GetInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetOwnerAbilitySystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ULyraEquipmentInstance::GetOwnerAbilitySystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetOwnerAbilitySystem");

	Params::LyraEquipmentInstance_GetOwnerAbilitySystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ULyraEquipmentInstance::GetPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetPawn");

	Params::LyraEquipmentInstance_GetPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.GetTypedPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APawn>                PawnType                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ULyraEquipmentInstance::GetTypedPawn(TSubclassOf<class APawn> PawnType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "GetTypedPawn");

	Params::LyraEquipmentInstance_GetTypedPawn Parms{};

	Parms.PawnType = PawnType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentInstance.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraEquipmentInstance::IsEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentInstance", "IsEquipped");

	Params::LyraEquipmentInstance_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.AddItemDefinitionToEquipmentWithSlot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    TargetEquipmentComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::AddItemDefinitionToEquipmentWithSlot(TSubclassOf<class ULyraInventoryItemDefinition> ItemDefinition, class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "AddItemDefinitionToEquipmentWithSlot");

	Params::ItemFunctionLibrary_AddItemDefinitionToEquipmentWithSlot Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.TargetEquipmentComp = TargetEquipmentComp;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.CheckDistance
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemFunctionLibrary::CheckDistance(const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "CheckDistance");

	Params::ItemFunctionLibrary_CheckDistance Parms{};

	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.DiscardItem
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams)
// Parameters:
// struct FTgfInventoryOperationItemSource Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::DiscardItem(const struct FTgfInventoryOperationItemSource& Source, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "DiscardItem");

	Params::ItemFunctionLibrary_DiscardItem Parms{};

	Parms.Source = std::move(Source);
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.DropItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FTgfInventoryOperationItemSource Source                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::DropItem(const struct FTgfInventoryOperationItemSource& Source, class ALyraCharacter* Character, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "DropItem");

	Params::ItemFunctionLibrary_DropItem Parms{};

	Parms.Source = std::move(Source);
	Parms.Character = Character;
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.DropItemToWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ULyraInventoryItemInstance*       Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemFunctionLibrary::DropItemToWorld(class ULyraInventoryItemInstance* Item, const class ALyraCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "DropItemToWorld");

	Params::ItemFunctionLibrary_DropItemToWorld Parms{};

	Parms.Item = Item;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.ExchangeEquipsWithSlots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfEquipmentManagerComponent*    TargetEquipmentComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::ExchangeEquipsWithSlots(class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot Slot1, ETgfEquipSlot Slot2, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "ExchangeEquipsWithSlots");

	Params::ItemFunctionLibrary_ExchangeEquipsWithSlots Parms{};

	Parms.TargetEquipmentComp = TargetEquipmentComp;
	Parms.Slot1 = Slot1;
	Parms.Slot2 = Slot2;
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.ExchangeItemsToInventory
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<struct FTgfInventoryOperationItemSource>Source                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::ExchangeItemsToInventory(const TArray<struct FTgfInventoryOperationItemSource>& Source, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "ExchangeItemsToInventory");

	Params::ItemFunctionLibrary_ExchangeItemsToInventory Parms{};

	Parms.Source = std::move(Source);
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.ExchangeItemToEquipmentFromLoot
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FTgfInventoryOperationItemSource Source                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    TargetEquipmentComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           TargetSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryManagerComponent*    TargetInventoryComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryManagerComponent*    SourceInventoryComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    SourceEquipmentComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        FromPoint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           FromEquipSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::ExchangeItemToEquipmentFromLoot(const struct FTgfInventoryOperationItemSource& Source, class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot TargetSlot, class UTgfInventoryManagerComponent* TargetInventoryComp, class UTgfInventoryManagerComponent* SourceInventoryComp, class UTgfEquipmentManagerComponent* SourceEquipmentComp, const struct FIntPoint& FromPoint, ETgfEquipSlot FromEquipSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "ExchangeItemToEquipmentFromLoot");

	Params::ItemFunctionLibrary_ExchangeItemToEquipmentFromLoot Parms{};

	Parms.Source = std::move(Source);
	Parms.TargetEquipmentComp = TargetEquipmentComp;
	Parms.TargetSlot = TargetSlot;
	Parms.TargetInventoryComp = TargetInventoryComp;
	Parms.SourceInventoryComp = SourceInventoryComp;
	Parms.SourceEquipmentComp = SourceEquipmentComp;
	Parms.FromPoint = std::move(FromPoint);
	Parms.FromEquipSlot = FromEquipSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.ExchangeItemToEquipmentWithSlot
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FTgfInventoryOperationItemSource Source                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    TargetEquipmentComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    SourceEquipmentComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryManagerComponent*    SourceInventoryComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::ExchangeItemToEquipmentWithSlot(const struct FTgfInventoryOperationItemSource& Source, class UTgfEquipmentManagerComponent* TargetEquipmentComp, ETgfEquipSlot Slot, class UTgfEquipmentManagerComponent* SourceEquipmentComp, class UTgfInventoryManagerComponent* SourceInventoryComp, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "ExchangeItemToEquipmentWithSlot");

	Params::ItemFunctionLibrary_ExchangeItemToEquipmentWithSlot Parms{};

	Parms.Source = std::move(Source);
	Parms.TargetEquipmentComp = TargetEquipmentComp;
	Parms.Slot = Slot;
	Parms.SourceEquipmentComp = SourceEquipmentComp;
	Parms.SourceInventoryComp = SourceInventoryComp;
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.ExchangeItemToInventory
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FTgfInventoryOperationItemSource Source                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UTgfInventoryManagerComponent*    TargetInventoryComp                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::ExchangeItemToInventory(const struct FTgfInventoryOperationItemSource& Source, class UTgfInventoryManagerComponent* TargetInventoryComp, ELyraInventoryType InventoryType, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "ExchangeItemToInventory");

	Params::ItemFunctionLibrary_ExchangeItemToInventory Parms{};

	Parms.Source = std::move(Source);
	Parms.TargetInventoryComp = TargetInventoryComp;
	Parms.InventoryType = InventoryType;
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.FindItemInCompList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemFunctionLibrary::FindItemInCompList(class ULyraInventoryItemInstance* ItemInstance, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "FindItemInCompList");

	Params::ItemFunctionLibrary_FindItemInCompList Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.GetAllCompList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ALyraCharacter*>           CharacterList                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ATgfStaticInteraction*>    InteractorList                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::GetAllCompList(const TArray<class ALyraCharacter*>& CharacterList, const TArray<class ATgfStaticInteraction*>& InteractorList, TArray<class UTgfInventoryManagerComponent*>* InventoryCompList, TArray<class UTgfEquipmentManagerComponent*>* EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "GetAllCompList");

	Params::ItemFunctionLibrary_GetAllCompList Parms{};

	Parms.CharacterList = std::move(CharacterList);
	Parms.InteractorList = std::move(InteractorList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InventoryCompList != nullptr)
		*InventoryCompList = std::move(Parms.InventoryCompList);

	if (EquipmentCompList != nullptr)
		*EquipmentCompList = std::move(Parms.EquipmentCompList);
}


// Function LyraGame.ItemFunctionLibrary.GetInventoryLootState
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FTgfInventoryLootState           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FTgfInventoryLootState UItemFunctionLibrary::GetInventoryLootState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "GetInventoryLootState");

	Params::ItemFunctionLibrary_GetInventoryLootState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.GetLootVaildDistance
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemFunctionLibrary::GetLootVaildDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "GetLootVaildDistance");

	Params::ItemFunctionLibrary_GetLootVaildDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.MergeGemToItem
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemInstance*        Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemInstance*        GemItem                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraAbilitySystemComponent*      OwnerABS                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ETgfEquipAttrParseType                  AttrParseType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           Equipment                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::MergeGemToItem(class UTgfInventoryItemInstance* Item, class UTgfInventoryItemInstance* GemItem, class ULyraAbilitySystemComponent* OwnerABS, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList, ETgfEquipAttrParseType AttrParseType, class ULyraEquipmentInstance* Equipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "MergeGemToItem");

	Params::ItemFunctionLibrary_MergeGemToItem Parms{};

	Parms.Item = Item;
	Parms.GemItem = GemItem;
	Parms.OwnerABS = OwnerABS;
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);
	Parms.AttrParseType = AttrParseType;
	Parms.Equipment = Equipment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.MergeItemInstance
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraInventoryItemInstance*       TargetItemInstance                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfInventoryOperationItemSource Source                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryManagerComponent*>InventoryCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentCompList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::MergeItemInstance(class ULyraInventoryItemInstance* TargetItemInstance, const struct FTgfInventoryOperationItemSource& Source, const TArray<class UTgfInventoryManagerComponent*>& InventoryCompList, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentCompList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "MergeItemInstance");

	Params::ItemFunctionLibrary_MergeItemInstance Parms{};

	Parms.TargetItemInstance = TargetItemInstance;
	Parms.Source = std::move(Source);
	Parms.InventoryCompList = std::move(InventoryCompList);
	Parms.EquipmentCompList = std::move(EquipmentCompList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.MoveAnotherCharacterEquipmentAndInventoryToSelf
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearEquipped                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::MoveAnotherCharacterEquipmentAndInventoryToSelf(class AActor* Target, bool bClearEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "MoveAnotherCharacterEquipmentAndInventoryToSelf");

	Params::ItemFunctionLibrary_MoveAnotherCharacterEquipmentAndInventoryToSelf Parms{};

	Parms.Target = Target;
	Parms.bClearEquipped = bClearEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.PickUpItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfInventoryItemDefinition>ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemFunctionLibrary::PickUpItem(TSubclassOf<class UTgfInventoryItemDefinition> ItemDefinition, class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "PickUpItem");

	Params::ItemFunctionLibrary_PickUpItem Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.RemoveSelfAllPvPItems
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UItemFunctionLibrary::RemoveSelfAllPvPItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "RemoveSelfAllPvPItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.SetStealTarget
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::SetStealTarget(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "SetStealTarget");

	Params::ItemFunctionLibrary_SetStealTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.StealItemSimple
// (Final, Native, Public, BlueprintCallable)

void UItemFunctionLibrary::StealItemSimple()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "StealItemSimple");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.StealItemSimpleResultNotifyClient
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReasonTxt                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemFunctionLibrary::StealItemSimpleResultNotifyClient(bool Success, const class FString& ReasonTxt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "StealItemSimpleResultNotifyClient");

	Params::ItemFunctionLibrary_StealItemSimpleResultNotifyClient Parms{};

	Parms.Success = Success;
	Parms.ReasonTxt = std::move(ReasonTxt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.ItemFunctionLibrary.CanRemoveEquipment
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           EquipmentInstance                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    EquipmentManager                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemFunctionLibrary::CanRemoveEquipment(class ULyraEquipmentInstance* EquipmentInstance, const class UTgfEquipmentManagerComponent* EquipmentManager, class FText* OutFailReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "CanRemoveEquipment");

	Params::ItemFunctionLibrary_CanRemoveEquipment Parms{};

	Parms.EquipmentInstance = EquipmentInstance;
	Parms.EquipmentManager = EquipmentManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.CanRemoveItemFromEquipmentList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentManagerComponent*>EquipmentManagers                                      (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemFunctionLibrary::CanRemoveItemFromEquipmentList(class ULyraInventoryItemInstance* ItemInstance, const TArray<class UTgfEquipmentManagerComponent*>& EquipmentManagers, class FText* OutFailReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "CanRemoveItemFromEquipmentList");

	Params::ItemFunctionLibrary_CanRemoveItemFromEquipmentList Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.EquipmentManagers = std::move(EquipmentManagers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.ItemFunctionLibrary.FindBestEquipSlotForItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    EquipmentManager                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseAutoFillConfig                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UItemFunctionLibrary::FindBestEquipSlotForItem(class ULyraInventoryItemInstance* ItemInstance, const class UTgfEquipmentManagerComponent* EquipmentManager, bool bUseAutoFillConfig) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemFunctionLibrary", "FindBestEquipSlotForItem");

	Params::ItemFunctionLibrary_FindBestEquipSlotForItem Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.EquipmentManager = EquipmentManager;
	Parms.bUseAutoFillConfig = bUseAutoFillConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.StaticCreateInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemInstance>InstanceType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraInventoryManagerComponent::StaticCreateInstance(class AActor* Owner, TSubclassOf<class ULyraInventoryItemDefinition> ItemClass, int32 StackCount, TSubclassOf<class ULyraInventoryItemInstance> InstanceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraInventoryManagerComponent", "StaticCreateInstance");

	Params::LyraInventoryManagerComponent_StaticCreateInstance Parms{};

	Parms.Owner = Owner;
	Parms.ItemClass = ItemClass;
	Parms.StackCount = StackCount;
	Parms.InstanceType = InstanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.AddItemDefinition
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumToAdd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::AddItemDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType, int32 NumToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "AddItemDefinition");

	Params::LyraInventoryManagerComponent_AddItemDefinition Parms{};

	Parms.ItemDef = ItemDef;
	Parms.InventoryType = InventoryType;
	Parms.NumToAdd = NumToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.AddItemDefinitionAuth
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumToAdd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::AddItemDefinitionAuth(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType, int32 NumToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "AddItemDefinitionAuth");

	Params::LyraInventoryManagerComponent_AddItemDefinitionAuth Parms{};

	Parms.ItemDef = ItemDef;
	Parms.InventoryType = InventoryType;
	Parms.NumToAdd = NumToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.AddItemInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::AddItemInstance(class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "AddItemInstance");

	Params::LyraInventoryManagerComponent_AddItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.AddItemInstanceAuth
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::AddItemInstanceAuth(class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "AddItemInstanceAuth");

	Params::LyraInventoryManagerComponent_AddItemInstanceAuth Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.AddItemInstanceWithAutoStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::AddItemInstanceWithAutoStack(class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "AddItemInstanceWithAutoStack");

	Params::LyraInventoryManagerComponent_AddItemInstanceWithAutoStack Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.ClearAllInventory
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULyraInventoryManagerComponent::ClearAllInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "ClearAllInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.OnRep_InventoryList
// (Native, Protected)

void ULyraInventoryManagerComponent::OnRep_InventoryList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "OnRep_InventoryList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.RemoveItemByDefinition
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumToConsume                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::RemoveItemByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "RemoveItemByDefinition");

	Params::LyraInventoryManagerComponent_RemoveItemByDefinition Parms{};

	Parms.ItemDef = ItemDef;
	Parms.NumToConsume = NumToConsume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.RemoveItemByDefinitionAuth
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumToConsume                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::RemoveItemByDefinitionAuth(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "RemoveItemByDefinitionAuth");

	Params::LyraInventoryManagerComponent_RemoveItemByDefinitionAuth Parms{};

	Parms.ItemDef = ItemDef;
	Parms.NumToConsume = NumToConsume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.RemoveItemInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::RemoveItemInstance(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "RemoveItemInstance");

	Params::LyraInventoryManagerComponent_RemoveItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.UpdateItemInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryManagerComponent::UpdateItemInstance(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "UpdateItemInstance");

	Params::LyraInventoryManagerComponent_UpdateItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryManagerComponent.CanAddItemDefinition
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryManagerComponent::CanAddItemDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType, int32 StackCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "CanAddItemDefinition");

	Params::LyraInventoryManagerComponent_CanAddItemDefinition Parms{};

	Parms.ItemDef = ItemDef;
	Parms.InventoryType = InventoryType;
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.CanAddItemInstance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      LyraInventoryType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryManagerComponent::CanAddItemInstance(class ULyraInventoryItemInstance* Instance, ELyraInventoryType LyraInventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "CanAddItemInstance");

	Params::LyraInventoryManagerComponent_CanAddItemInstance Parms{};

	Parms.Instance = Instance;
	Parms.LyraInventoryType = LyraInventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.CanAddItemInstances
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>AddInstances                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ELyraInventoryType                      LyraInventoryType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryManagerComponent::CanAddItemInstances(const TArray<class ULyraInventoryItemInstance*>& AddInstances, ELyraInventoryType LyraInventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "CanAddItemInstances");

	Params::LyraInventoryManagerComponent_CanAddItemInstances Parms{};

	Parms.AddInstances = std::move(AddInstances);
	Parms.LyraInventoryType = LyraInventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.CreateInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraInventoryManagerComponent::CreateInstance(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass, int32 StackCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "CreateInstance");

	Params::LyraInventoryManagerComponent_CreateInstance Parms{};

	Parms.ItemClass = ItemClass;
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.FindFirstItemByDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraInventoryManagerComponent::FindFirstItemByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "FindFirstItemByDefinition");

	Params::LyraInventoryManagerComponent_FindFirstItemByDefinition Parms{};

	Parms.ItemDef = ItemDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.GetAllEntries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FLyraInventoryEntry>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FLyraInventoryEntry> ULyraInventoryManagerComponent::GetAllEntries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "GetAllEntries");

	Params::LyraInventoryManagerComponent_GetAllEntries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULyraInventoryItemInstance*> ULyraInventoryManagerComponent::GetAllItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "GetAllItems");

	Params::LyraInventoryManagerComponent_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.GetAllSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraInventoryManagerComponent::GetAllSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "GetAllSize");

	Params::LyraInventoryManagerComponent_GetAllSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.GetEntryIndexByItemInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraInventoryManagerComponent::GetEntryIndexByItemInstance(class ULyraInventoryItemInstance* ItemInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "GetEntryIndexByItemInstance");

	Params::LyraInventoryManagerComponent_GetEntryIndexByItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.GetItemByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraInventoryManagerComponent::GetItemByIndex(int32 Param_Index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "GetItemByIndex");

	Params::LyraInventoryManagerComponent_GetItemByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.GetTotalItemCountByDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraInventoryManagerComponent::GetTotalItemCountByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "GetTotalItemCountByDefinition");

	Params::LyraInventoryManagerComponent_GetTotalItemCountByDefinition Parms{};

	Parms.ItemDef = ItemDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryManagerComponent.HasEmptyInventory
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        Position                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryManagerComponent::HasEmptyInventory(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass, struct FIntPoint* Position, ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryManagerComponent", "HasEmptyInventory");

	Params::LyraInventoryManagerComponent_HasEmptyInventory Parms{};

	Parms.ItemClass = ItemClass;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Position != nullptr)
		*Position = std::move(Parms.Position);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInGameServiceComponent.IsGameServerLogin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInGameServiceComponent::IsGameServerLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInGameServiceComponent", "IsGameServerLogin");

	Params::TgfInGameServiceComponent_IsGameServerLogin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAIController.GetDebugInfoString
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALyraAIController::GetDebugInfoString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAIController", "GetDebugInfoString");

	Params::LyraAIController_GetDebugInfoString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAIController.OnRep_MyTeamID
// (Final, Native, Private)
// Parameters:
// struct FGenericTeamId                   OldTeamID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraAIController::OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAIController", "OnRep_MyTeamID");

	Params::LyraAIController_OnRep_MyTeamID Parms{};

	Parms.OldTeamID = std::move(OldTeamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentWrapper.GetEquipmentDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfEquipmentDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfEquipmentDefinition> UTgfEquipmentWrapper::GetEquipmentDefinition(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentWrapper", "GetEquipmentDefinition");

	Params::TgfEquipmentWrapper_GetEquipmentDefinition Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentWrapper.GetEquipmentDefinitionObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfEquipmentDefinition*    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfEquipmentDefinition* UTgfEquipmentWrapper::GetEquipmentDefinitionObject(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentWrapper", "GetEquipmentDefinitionObject");

	Params::TgfEquipmentWrapper_GetEquipmentDefinitionObject Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentWrapper.GetEquipSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSubType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSubType UTgfEquipmentWrapper::GetEquipSubtype() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentWrapper", "GetEquipSubtype");

	Params::TgfEquipmentWrapper_GetEquipSubtype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentWrapper.GetItemDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfInventoryItemDefinition> UTgfEquipmentWrapper::GetItemDefinition(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentWrapper", "GetItemDefinition");

	Params::TgfEquipmentWrapper_GetItemDefinition Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentWrapper.GetItemDefinitionObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfInventoryItemDefinition*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfInventoryItemDefinition* UTgfEquipmentWrapper::GetItemDefinitionObject(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentWrapper", "GetItemDefinitionObject");

	Params::TgfEquipmentWrapper_GetItemDefinitionObject Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentWrapper.GetWeaponEquipType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponEquipType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponEquipType UTgfEquipmentWrapper::GetWeaponEquipType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentWrapper", "GetWeaponEquipType");

	Params::TgfEquipmentWrapper_GetWeaponEquipType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.BatchSetMainMeshScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AlternateValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPawnMaterialManagerComponent::BatchSetMainMeshScalarParameterValue(class FName ParameterName, float AlternateValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "BatchSetMainMeshScalarParameterValue");

	Params::TgfPawnMaterialManagerComponent_BatchSetMainMeshScalarParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.AlternateValue = AlternateValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.BatchSetMainMeshVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AlternateValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPawnMaterialManagerComponent::BatchSetMainMeshVectorParameterValue(class FName ParameterName, const struct FVector& AlternateValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "BatchSetMainMeshVectorParameterValue");

	Params::TgfPawnMaterialManagerComponent_BatchSetMainMeshVectorParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.AlternateValue = std::move(AlternateValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.OnMaterialUpdatedAfter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETgfCharaMatStateType                   NewStateType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfCharaMatStateType                   OldStateType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPawnMaterialManagerComponent::OnMaterialUpdatedAfter(ETgfCharaMatStateType NewStateType, ETgfCharaMatStateType OldStateType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "OnMaterialUpdatedAfter");

	Params::TgfPawnMaterialManagerComponent_OnMaterialUpdatedAfter Parms{};

	Parms.NewStateType = NewStateType;
	Parms.OldStateType = OldStateType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfPawnMaterialManagerComponent.OnMaterialUpdatedBefore
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETgfCharaMatStateType                   NewStateType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfCharaMatStateType                   OldStateType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPawnMaterialManagerComponent::OnMaterialUpdatedBefore(ETgfCharaMatStateType NewStateType, ETgfCharaMatStateType OldStateType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "OnMaterialUpdatedBefore");

	Params::TgfPawnMaterialManagerComponent_OnMaterialUpdatedBefore Parms{};

	Parms.NewStateType = NewStateType;
	Parms.OldStateType = OldStateType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfPawnMaterialManagerComponent.RevertOverlayMaterial
// (Native, Public, BlueprintCallable)

void UTgfPawnMaterialManagerComponent::RevertOverlayMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "RevertOverlayMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.RevertToOriginalSkin
// (Native, Public, BlueprintCallable)

void UTgfPawnMaterialManagerComponent::RevertToOriginalSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "RevertToOriginalSkin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.SwitchToDynamicMaterials
// (Final, Native, Public, BlueprintCallable)

void UTgfPawnMaterialManagerComponent::SwitchToDynamicMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "SwitchToDynamicMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.SwitchToSpecificSkin
// (Final, Native, Public, BlueprintCallable)

void UTgfPawnMaterialManagerComponent::SwitchToSpecificSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "SwitchToSpecificSkin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.SwitchToSpecifiedOverlayMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// ETgfPawnOverlayMaterialType             MIType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPawnMaterialManagerComponent::SwitchToSpecifiedOverlayMaterial(ETgfPawnOverlayMaterialType MIType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "SwitchToSpecifiedOverlayMaterial");

	Params::TgfPawnMaterialManagerComponent_SwitchToSpecifiedOverlayMaterial Parms{};

	Parms.MIType = MIType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.UpdateMaterialState
// (Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharaMatStateType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPawnMaterialManagerComponent::UpdateMaterialState(ETgfCharaMatStateType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "UpdateMaterialState");

	Params::TgfPawnMaterialManagerComponent_UpdateMaterialState Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.ContainsMaterialState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfCharaMatStateType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfPawnMaterialManagerComponent::ContainsMaterialState(ETgfCharaMatStateType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "ContainsMaterialState");

	Params::TgfPawnMaterialManagerComponent_ContainsMaterialState Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.FindTagByStateType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfCharaMatStateType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UTgfPawnMaterialManagerComponent::FindTagByStateType(ETgfCharaMatStateType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "FindTagByStateType");

	Params::TgfPawnMaterialManagerComponent_FindTagByStateType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.GetStateType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfCharaMatStateType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfCharaMatStateType UTgfPawnMaterialManagerComponent::GetStateType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "GetStateType");

	Params::TgfPawnMaterialManagerComponent_GetStateType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfPawnMaterialManagerComponent.GetStateTypeByTag
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfCharaMatStateType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfCharaMatStateType UTgfPawnMaterialManagerComponent::GetStateTypeByTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPawnMaterialManagerComponent", "GetStateTypeByTag");

	Params::TgfPawnMaterialManagerComponent_GetStateTypeByTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.BatchSetScalarParameterValue
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AlternateValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache>AvatarAlternateMaterials                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache>EquipmentAlternateMaterials                            (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfCharacterMaterialManagerComponent::BatchSetScalarParameterValue(class FName ParameterName, float AlternateValue, TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache>& AvatarAlternateMaterials, TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache>& EquipmentAlternateMaterials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "BatchSetScalarParameterValue");

	Params::TgfCharacterMaterialManagerComponent_BatchSetScalarParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.AlternateValue = AlternateValue;
	Parms.AvatarAlternateMaterials = std::move(AvatarAlternateMaterials);
	Parms.EquipmentAlternateMaterials = std::move(EquipmentAlternateMaterials);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	AvatarAlternateMaterials = std::move(Parms.AvatarAlternateMaterials);
	EquipmentAlternateMaterials = std::move(Parms.EquipmentAlternateMaterials);
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.BatchSetVectorParameterValue
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AlternateValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache>AvatarAlternateMaterials                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache>EquipmentAlternateMaterials                            (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfCharacterMaterialManagerComponent::BatchSetVectorParameterValue(class FName ParameterName, const struct FVector& AlternateValue, TMap<ETgfCharaPart, struct FUTgfCharacterBodyMaterialCache>& AvatarAlternateMaterials, TMap<class UMeshComponent*, struct FUTgfCharacterEquipmentMaterialCache>& EquipmentAlternateMaterials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "BatchSetVectorParameterValue");

	Params::TgfCharacterMaterialManagerComponent_BatchSetVectorParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.AlternateValue = std::move(AlternateValue);
	Parms.AvatarAlternateMaterials = std::move(AvatarAlternateMaterials);
	Parms.EquipmentAlternateMaterials = std::move(EquipmentAlternateMaterials);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	AvatarAlternateMaterials = std::move(Parms.AvatarAlternateMaterials);
	EquipmentAlternateMaterials = std::move(Parms.EquipmentAlternateMaterials);
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.CreateAndSetCharacterDynamicMaterials
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMaterialManagerComponent::CreateAndSetCharacterDynamicMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "CreateAndSetCharacterDynamicMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.RemoveOverlayMaterial
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMaterialManagerComponent::RemoveOverlayMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "RemoveOverlayMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.SetAllNiagaraAndLightNewActiveOnWeapons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CheckValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMaterialManagerComponent::SetAllNiagaraAndLightNewActiveOnWeapons(bool CheckValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "SetAllNiagaraAndLightNewActiveOnWeapons");

	Params::TgfCharacterMaterialManagerComponent_SetAllNiagaraAndLightNewActiveOnWeapons Parms{};

	Parms.CheckValue = CheckValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.SetCloakType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharacterMaterialCloakType          NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMaterialManagerComponent::SetCloakType(ETgfCharacterMaterialCloakType NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "SetCloakType");

	Params::TgfCharacterMaterialManagerComponent_SetCloakType Parms{};

	Parms.NewType = NewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.SwitchSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                SkinMat                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMaterialManagerComponent::SwitchSkin(class UMaterialInstance* SkinMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "SwitchSkin");

	Params::TgfCharacterMaterialManagerComponent_SwitchSkin Parms{};

	Parms.SkinMat = SkinMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.SwitchToCloakingSkin
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMaterialManagerComponent::SwitchToCloakingSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "SwitchToCloakingSkin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.SwitchToFadeOutSkin
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMaterialManagerComponent::SwitchToFadeOutSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "SwitchToFadeOutSkin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMaterialManagerComponent.UpdateCloakLerpValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   LerpValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMaterialManagerComponent::UpdateCloakLerpValue(float LerpValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMaterialManagerComponent", "UpdateCloakLerpValue");

	Params::TgfCharacterMaterialManagerComponent_UpdateCloakLerpValue Parms{};

	Parms.LerpValue = LerpValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemWrapper.GetCorruptionId
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetCorruptionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetCorruptionId");

	Params::TgfInventoryItemWrapper_GetCorruptionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetDurabilityPoint
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetDurabilityPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetDurabilityPoint");

	Params::TgfInventoryItemWrapper_GetDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetMaxDurabilityPoint
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetMaxDurabilityPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetMaxDurabilityPoint");

	Params::TgfInventoryItemWrapper_GetMaxDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetOwners
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTgfPlayerIDKey>          Owners                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfInventoryItemWrapper::GetOwners(TArray<struct FTgfPlayerIDKey>* Owners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetOwners");

	Params::TgfInventoryItemWrapper_GetOwners Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Owners != nullptr)
		*Owners = std::move(Parms.Owners);
}


// Function LyraGame.TgfInventoryItemWrapper.GetPolishingCount
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetPolishingCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetPolishingCount");

	Params::TgfInventoryItemWrapper_GetPolishingCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetSkinId
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetSkinId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetSkinId");

	Params::TgfInventoryItemWrapper_GetSkinId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.HasDurabilityPoint
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::HasDurabilityPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "HasDurabilityPoint");

	Params::TgfInventoryItemWrapper_HasDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.IsHeirloom
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::IsHeirloom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "IsHeirloom");

	Params::TgfInventoryItemWrapper_IsHeirloom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.IsMyHeirloom
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::IsMyHeirloom(class AActor* SelfActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "IsMyHeirloom");

	Params::TgfInventoryItemWrapper_IsMyHeirloom Parms{};

	Parms.SelfActor = SelfActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.IsSameItem
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfInventoryItemWrapper*         AnotherItem                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::IsSameItem(class UTgfInventoryItemWrapper* AnotherItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "IsSameItem");

	Params::TgfInventoryItemWrapper_IsSameItem Parms{};

	Parms.AnotherItem = AnotherItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.IsTargetInventory
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::IsTargetInventory(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "IsTargetInventory");

	Params::TgfInventoryItemWrapper_IsTargetInventory Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.IsTeammateInventory
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ViewCharacter                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::IsTeammateInventory(class AActor* ViewCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "IsTeammateInventory");

	Params::TgfInventoryItemWrapper_IsTeammateInventory Parms{};

	Parms.ViewCharacter = ViewCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.OnAffixDisplayDataUpdate
// (Native, Protected)

void UTgfInventoryItemWrapper::OnAffixDisplayDataUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "OnAffixDisplayDataUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemWrapper.SpawnEquipmentActorsWithAttachTarget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USceneComponent*                  AttachTarget                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutSpawnedActors                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAttachToLeft                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedSkin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryItemWrapper::SpawnEquipmentActorsWithAttachTarget(class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors, bool bAttachToLeft, bool NeedSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "SpawnEquipmentActorsWithAttachTarget");

	Params::TgfInventoryItemWrapper_SpawnEquipmentActorsWithAttachTarget Parms{};

	Parms.AttachTarget = AttachTarget;
	Parms.bAttachToLeft = bAttachToLeft;
	Parms.NeedSkin = NeedSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnedActors != nullptr)
		*OutSpawnedActors = std::move(Parms.OutSpawnedActors);
}


// Function LyraGame.TgfInventoryItemWrapper.CanDivide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::CanDivide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "CanDivide");

	Params::TgfInventoryItemWrapper_CanDivide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.FindFragmentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemFragment>FragmentClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULyraInventoryItemFragment* ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraInventoryItemFragment* UTgfInventoryItemWrapper::FindFragmentByClass(TSubclassOf<class ULyraInventoryItemFragment> FragmentClass, bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "FindFragmentByClass");

	Params::TgfInventoryItemWrapper_FindFragmentByClass Parms{};

	Parms.FragmentClass = FragmentClass;
	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetAffixDisplayConfig
// (Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<struct FAffixDisplayConfig>      Base                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      Main                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      Top                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      Gem                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      GearSet                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfInventoryItemWrapper::GetAffixDisplayConfig(TArray<struct FAffixDisplayConfig>* Base, TArray<struct FAffixDisplayConfig>* Main, TArray<struct FAffixDisplayConfig>* Top, TArray<struct FAffixDisplayConfig>* Gem, TArray<struct FAffixDisplayConfig>* GearSet) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetAffixDisplayConfig");

	Params::TgfInventoryItemWrapper_GetAffixDisplayConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Base != nullptr)
		*Base = std::move(Parms.Base);

	if (Main != nullptr)
		*Main = std::move(Parms.Main);

	if (Top != nullptr)
		*Top = std::move(Parms.Top);

	if (Gem != nullptr)
		*Gem = std::move(Parms.Gem);

	if (GearSet != nullptr)
		*GearSet = std::move(Parms.GearSet);
}


// Function LyraGame.TgfInventoryItemWrapper.GetEquipmentDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfEquipmentDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfEquipmentDefinition> UTgfInventoryItemWrapper::GetEquipmentDefinition(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetEquipmentDefinition");

	Params::TgfInventoryItemWrapper_GetEquipmentDefinition Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetEquipmentDefinitionObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfEquipmentDefinition*    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfEquipmentDefinition* UTgfInventoryItemWrapper::GetEquipmentDefinitionObject(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetEquipmentDefinitionObject");

	Params::TgfInventoryItemWrapper_GetEquipmentDefinitionObject Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetEquipSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSubType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSubType UTgfInventoryItemWrapper::GetEquipSubtype() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetEquipSubtype");

	Params::TgfInventoryItemWrapper_GetEquipSubtype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetExpireTimepoint
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetExpireTimepoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetExpireTimepoint");

	Params::TgfInventoryItemWrapper_GetExpireTimepoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetGemData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTGFProtoTgfDItemGem*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTGFProtoTgfDItemGem* UTgfInventoryItemWrapper::GetGemData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetGemData");

	Params::TgfInventoryItemWrapper_GetGemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetGuid
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetGuid");

	Params::TgfInventoryItemWrapper_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetIdleAnimation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         OffhandItem                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            WithTags                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsRightIdle                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimSequenceBase*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimSequenceBase* UTgfInventoryItemWrapper::GetIdleAnimation(class UTgfInventoryItemWrapper* OffhandItem, const struct FGameplayTagContainer& WithTags, bool* bIsRightIdle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetIdleAnimation");

	Params::TgfInventoryItemWrapper_GetIdleAnimation Parms{};

	Parms.OffhandItem = OffhandItem;
	Parms.WithTags = std::move(WithTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsRightIdle != nullptr)
		*bIsRightIdle = Parms.bIsRightIdle;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetItemDefinition
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfInventoryItemDefinition> UTgfInventoryItemWrapper::GetItemDefinition(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetItemDefinition");

	Params::TgfInventoryItemWrapper_GetItemDefinition Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetItemDefinitionObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfInventoryItemDefinition*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfInventoryItemDefinition* UTgfInventoryItemWrapper::GetItemDefinitionObject(bool bIsSkin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetItemDefinitionObject");

	Params::TgfInventoryItemWrapper_GetItemDefinitionObject Parms{};

	Parms.bIsSkin = bIsSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetItemSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryItemWrapper::GetItemSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetItemSize");

	Params::TgfInventoryItemWrapper_GetItemSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetStackCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetStackCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetStackCount");

	Params::TgfInventoryItemWrapper_GetStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetTypeId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemWrapper::GetTypeId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetTypeId");

	Params::TgfInventoryItemWrapper_GetTypeId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.GetWeaponEquipType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponEquipType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponEquipType UTgfInventoryItemWrapper::GetWeaponEquipType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "GetWeaponEquipType");

	Params::TgfInventoryItemWrapper_GetWeaponEquipType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemWrapper.IsTheSameAs
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemWrapper::IsTheSameAs(class UTgfInventoryItemWrapper* Other) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemWrapper", "IsTheSameAs");

	Params::TgfInventoryItemWrapper_IsTheSameAs Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCheatComponent.ActivateAllEscapeDevices
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ActivateAllEscapeDevices(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ActivateAllEscapeDevices");

	Params::TgfCheatComponent_ActivateAllEscapeDevices Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddBlockingLootSlot
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfEquipmentManagerComponent*    EquipmentComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddBlockingLootSlot(class UTgfEquipmentManagerComponent* EquipmentComponent, int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddBlockingLootSlot");

	Params::TgfCheatComponent_AddBlockingLootSlot Parms{};

	Parms.EquipmentComponent = EquipmentComponent;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddGearsetLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfEquipmentManagerComponent*    EquipmentComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GearsetId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DeltaLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddGearsetLevel(class UTgfEquipmentManagerComponent* EquipmentComponent, int32 GearsetId, int32 DeltaLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddGearsetLevel");

	Params::TgfCheatComponent_AddGearsetLevel Parms{};

	Parms.EquipmentComponent = EquipmentComponent;
	Parms.GearsetId = GearsetId;
	Parms.DeltaLevel = DeltaLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddItemDefinition
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfInventoryManagerComponent*    InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumToAdd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddItemDefinition(class UTgfInventoryManagerComponent* InventoryComponent, TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddItemDefinition");

	Params::TgfCheatComponent_AddItemDefinition Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.ItemDef = ItemDef;
	Parms.NumToAdd = NumToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddLooseGameplayTag
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddLooseGameplayTag(class ULyraAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& GameplayTag, int32 Nums, bool NeedReplicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddLooseGameplayTag");

	Params::TgfCheatComponent_AddLooseGameplayTag Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.GameplayTag = std::move(GameplayTag);
	Parms.Nums = Nums;
	Parms.NeedReplicated = NeedReplicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddLooseGameplayTagWithFString
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddLooseGameplayTagWithFString(class ULyraAbilitySystemComponent* AbilitySystemComponent, const class FString& TagName, int32 Nums, bool NeedReplicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddLooseGameplayTagWithFString");

	Params::TgfCheatComponent_AddLooseGameplayTagWithFString Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.TagName = std::move(TagName);
	Parms.Nums = Nums;
	Parms.NeedReplicated = NeedReplicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddLootItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfInventoryManagerComponent*    InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddLootItem(class UTgfInventoryManagerComponent* InventoryComponent, int32 ItemId, int32 Nums)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddLootItem");

	Params::TgfCheatComponent_AddLootItem Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.ItemId = ItemId;
	Parms.Nums = Nums;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.AddPlayerBots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   AddCnt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::AddPlayerBots(int32 AddCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "AddPlayerBots");

	Params::TgfCheatComponent_AddPlayerBots Parms{};

	Parms.AddCnt = AddCnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ClearAbility
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ClearAbility(class ULyraAbilitySystemComponent* AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ClearAbility");

	Params::TgfCheatComponent_ClearAbility Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ClearAllGearsetLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfEquipmentManagerComponent*    EquipmentComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ClearAllGearsetLevel(class UTgfEquipmentManagerComponent* EquipmentComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ClearAllGearsetLevel");

	Params::TgfCheatComponent_ClearAllGearsetLevel Parms{};

	Parms.EquipmentComponent = EquipmentComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ClientSetPlayMontagePlay
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bOpenServerPlayDelay                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenClientBehind                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenClientAhead                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChaseMaxPing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ClientSetPlayMontagePlay(bool bOpenServerPlayDelay, float DelayTime, bool bOpenClientBehind, bool bOpenClientAhead, float ChaseMaxPing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ClientSetPlayMontagePlay");

	Params::TgfCheatComponent_ClientSetPlayMontagePlay Parms{};

	Parms.bOpenServerPlayDelay = bOpenServerPlayDelay;
	Parms.DelayTime = DelayTime;
	Parms.bOpenClientBehind = bOpenClientBehind;
	Parms.bOpenClientAhead = bOpenClientAhead;
	Parms.ChaseMaxPing = ChaseMaxPing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ClientShowPortalLocations
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FVector>                  Locations                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ClientShowPortalLocations(const TArray<struct FVector>& Locations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ClientShowPortalLocations");

	Params::TgfCheatComponent_ClientShowPortalLocations Parms{};

	Parms.Locations = std::move(Locations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.DealAttrValue
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               GPAttr                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModOp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::DealAttrValue(class ULyraAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& GPAttr, float Value, EGameplayModOp ModOp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "DealAttrValue");

	Params::TgfCheatComponent_DealAttrValue Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.GPAttr = std::move(GPAttr);
	Parms.Value = Value;
	Parms.ModOp = ModOp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.DsQuitGame
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::DsQuitGame(class APlayerState* PlayerState, int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "DsQuitGame");

	Params::TgfCheatComponent_DsQuitGame Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.EndCurrentPhase
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::EndCurrentPhase(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "EndCurrentPhase");

	Params::TgfCheatComponent_EndCurrentPhase Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ForceGC
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    FullPurge                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ForceGC(bool FullPurge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ForceGC");

	Params::TgfCheatComponent_ForceGC Parms{};

	Parms.FullPurge = FullPurge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.FreezeSelf
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFreeze                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::FreezeSelf(class ALyraCharacter* Character, bool bFreeze)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "FreezeSelf");

	Params::TgfCheatComponent_FreezeSelf Parms{};

	Parms.Character = Character;
	Parms.bFreeze = bFreeze;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.GiveAbility
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::GiveAbility(class ULyraAbilitySystemComponent* AbilitySystemComponent, const class FString& AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "GiveAbility");

	Params::TgfCheatComponent_GiveAbility Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.AssetName = std::move(AssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.MultiWorldTravel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           MapPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::MultiWorldTravel(const class FString& MapPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "MultiWorldTravel");

	Params::TgfCheatComponent_MultiWorldTravel Parms{};

	Parms.MapPath = std::move(MapPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.PrintActorMapLog
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int32                                   ActorNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AIEnableNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AITotalNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TickEnableNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TickTotalNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AIBound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TickBound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::PrintActorMapLog(int32 ActorNum, int32 AIEnableNum, int32 AITotalNum, int32 TickEnableNum, int32 TickTotalNum, float AIBound, float TickBound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "PrintActorMapLog");

	Params::TgfCheatComponent_PrintActorMapLog Parms{};

	Parms.ActorNum = ActorNum;
	Parms.AIEnableNum = AIEnableNum;
	Parms.AITotalNum = AITotalNum;
	Parms.TickEnableNum = TickEnableNum;
	Parms.TickTotalNum = TickTotalNum;
	Parms.AIBound = AIBound;
	Parms.TickBound = TickBound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.PrintActorMapRPC
// (Net, NetReliable, Native, Event, Public, NetServer)

void UTgfCheatComponent::PrintActorMapRPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "PrintActorMapRPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.RebirthSelf
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALyraCharacter*                   LyraCharacter                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::RebirthSelf(class ALyraCharacter* LyraCharacter, class ULyraAbilitySystemComponent* AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "RebirthSelf");

	Params::TgfCheatComponent_RebirthSelf Parms{};

	Parms.LyraCharacter = LyraCharacter;
	Parms.AbilitySystemComponent = AbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.RecoverAmmo
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::RecoverAmmo(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "RecoverAmmo");

	Params::TgfCheatComponent_RecoverAmmo Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ReinitCharaCareer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         Career                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ReinitCharaCareer(class ALyraCharacter* Character, ETgfActorCareer Career)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ReinitCharaCareer");

	Params::TgfCheatComponent_ReinitCharaCareer Parms{};

	Parms.Character = Character;
	Parms.Career = Career;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.RemoveItemByDefinition
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UTgfInventoryManagerComponent*    InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumToRemove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::RemoveItemByDefinition(class UTgfInventoryManagerComponent* InventoryComponent, TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 NumToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "RemoveItemByDefinition");

	Params::TgfCheatComponent_RemoveItemByDefinition Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.ItemDef = ItemDef;
	Parms.NumToRemove = NumToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.RemoveLooseGameplayTag
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::RemoveLooseGameplayTag(class ULyraAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& GameplayTag, int32 Nums, bool NeedReplicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "RemoveLooseGameplayTag");

	Params::TgfCheatComponent_RemoveLooseGameplayTag Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.GameplayTag = std::move(GameplayTag);
	Parms.Nums = Nums;
	Parms.NeedReplicated = NeedReplicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.RemoveLooseGameplayTagWithFString
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ULyraAbilitySystemComponent*      AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::RemoveLooseGameplayTagWithFString(class ULyraAbilitySystemComponent* AbilitySystemComponent, const class FString& TagName, int32 Nums, bool NeedReplicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "RemoveLooseGameplayTagWithFString");

	Params::TgfCheatComponent_RemoveLooseGameplayTagWithFString Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.TagName = std::move(TagName);
	Parms.Nums = Nums;
	Parms.NeedReplicated = NeedReplicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.RemovePlayerBots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   RemoveCnt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::RemovePlayerBots(int32 RemoveCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "RemovePlayerBots");

	Params::TgfCheatComponent_RemovePlayerBots Parms{};

	Parms.RemoveCnt = RemoveCnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ResizeInventory
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class UTgfInventoryManagerComponent*    InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ResizeInventory(class UTgfInventoryManagerComponent* InventoryComponent, const struct FIntPoint& Size, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ResizeInventory");

	Params::TgfCheatComponent_ResizeInventory Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.Size = std::move(Size);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ServerSetPlayMontagePlay
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bOpenServerPlayDelay                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenClientBehind                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenClientAhead                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChaseMaxPing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ServerSetPlayMontagePlay(bool bOpenServerPlayDelay, float DelayTime, bool bOpenClientBehind, bool bOpenClientAhead, float ChaseMaxPing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ServerSetPlayMontagePlay");

	Params::TgfCheatComponent_ServerSetPlayMontagePlay Parms{};

	Parms.bOpenServerPlayDelay = bOpenServerPlayDelay;
	Parms.DelayTime = DelayTime;
	Parms.bOpenClientBehind = bOpenClientBehind;
	Parms.bOpenClientAhead = bOpenClientAhead;
	Parms.ChaseMaxPing = ChaseMaxPing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SetActorMapBounds
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   AIBound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TickBound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SetActorMapBounds(float AIBound, float TickBound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SetActorMapBounds");

	Params::TgfCheatComponent_SetActorMapBounds Parms{};

	Parms.AIBound = AIBound;
	Parms.TickBound = TickBound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SetDeathZoneEnabled
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SetDeathZoneEnabled(class UWorld* World, int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SetDeathZoneEnabled");

	Params::TgfCheatComponent_SetDeathZoneEnabled Parms{};

	Parms.World = World;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SetMithrilCharacter
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RemainingRebirthChance                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SetMithrilCharacter(class ALyraCharacter* Character, bool Value, int32 Level, int32 RemainingRebirthChance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SetMithrilCharacter");

	Params::TgfCheatComponent_SetMithrilCharacter Parms{};

	Parms.Character = Character;
	Parms.Value = Value;
	Parms.Level = Level;
	Parms.RemainingRebirthChance = RemainingRebirthChance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SetPlayerSceneTag
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SetPlayerSceneTag(class ALyraCharacter* Character, int32 Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SetPlayerSceneTag");

	Params::TgfCheatComponent_SetPlayerSceneTag Parms{};

	Parms.Character = Character;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ShowAllTagServer
// (Net, NetReliable, Native, Event, Public, NetServer)

void UTgfCheatComponent::ShowAllTagServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ShowAllTagServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ShowGoblinThief
// (Net, NetReliable, Native, Event, Public, NetServer)

void UTgfCheatComponent::ShowGoblinThief()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ShowGoblinThief");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ShowPortalLocations
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ShowPortalLocations(int32 PortalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ShowPortalLocations");

	Params::TgfCheatComponent_ShowPortalLocations Parms{};

	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SpawnActor
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// TSubclassOf<class AActor>               Param_Class                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SpawnActor(TSubclassOf<class AActor> Param_Class, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SpawnActor");

	Params::TgfCheatComponent_SpawnActor Parms{};

	Parms.Param_Class = Param_Class;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SpawnAllEscapeDevices
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SpawnAllEscapeDevices(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SpawnAllEscapeDevices");

	Params::TgfCheatComponent_SpawnAllEscapeDevices Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SpawnAllPortalsAndScrolls
// (Net, NetReliable, Native, Event, Public, NetServer)

void UTgfCheatComponent::SpawnAllPortalsAndScrolls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SpawnAllPortalsAndScrolls");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SpawnMonster
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// TSubclassOf<class ALyraCharacter>       Param_Class                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LootIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Dormant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SpawnMonster(TSubclassOf<class ALyraCharacter> Param_Class, const struct FVector& Position, int32 LootIndex, bool Dormant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SpawnMonster");

	Params::TgfCheatComponent_SpawnMonster Parms{};

	Parms.Param_Class = Param_Class;
	Parms.Position = std::move(Position);
	Parms.LootIndex = LootIndex;
	Parms.Dormant = Dormant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.SpawnOnePortal
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// int32                                   PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::SpawnOnePortal(int32 PortalType, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "SpawnOnePortal");

	Params::TgfCheatComponent_SpawnOnePortal Parms{};

	Parms.PortalType = PortalType;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.TeleportChara
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTgfCheatComponent::TeleportChara(class APawn* Pawn, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "TeleportChara");

	Params::TgfCheatComponent_TeleportChara Parms{};

	Parms.Pawn = Pawn;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.ToggleIgnoreAbilitySystemArg
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::ToggleIgnoreAbilitySystemArg(int32 Type, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "ToggleIgnoreAbilitySystemArg");

	Params::TgfCheatComponent_ToggleIgnoreAbilitySystemArg Parms{};

	Parms.Type = Type;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.TryIncreaseAndCheckSecurityInvalidCount
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALyraPlayerController*            PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::TryIncreaseAndCheckSecurityInvalidCount(class ALyraPlayerController* PC, int32 Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "TryIncreaseAndCheckSecurityInvalidCount");

	Params::TgfCheatComponent_TryIncreaseAndCheckSecurityInvalidCount Parms{};

	Parms.PC = PC;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCheatComponent.WaitingRoomCountdown
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCheatComponent::WaitingRoomCountdown(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCheatComponent", "WaitingRoomCountdown");

	Params::TgfCheatComponent_WaitingRoomCountdown Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraContextEffectsInterface.AnimMotionEffect
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             bone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MotionEffect                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RotationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitSuccess                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Contexts                                               (Parm, NativeAccessSpecifierPublic)
// struct FVector                          VFXScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioPitch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ILyraContextEffectsInterface::AnimMotionEffect(const class FName bone, const struct FGameplayTag& MotionEffect, class USceneComponent* StaticMeshComponent, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const class UAnimSequenceBase* AnimationSequence, const bool bHitSuccess, const struct FHitResult& HitResult, const struct FGameplayTagContainer& Contexts, const struct FVector& VFXScale, float AudioVolume, float AudioPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsInterface", "AnimMotionEffect");

	Params::LyraContextEffectsInterface_AnimMotionEffect Parms{};

	Parms.bone = bone;
	Parms.MotionEffect = std::move(MotionEffect);
	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.AnimationSequence = AnimationSequence;
	Parms.bHitSuccess = bHitSuccess;
	Parms.HitResult = std::move(HitResult);
	Parms.Contexts = std::move(Contexts);
	Parms.VFXScale = std::move(VFXScale);
	Parms.AudioVolume = AudioVolume;
	Parms.AudioPitch = AudioPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfHeadCosmeticDataAsset.UpdateHeadResConfigWithTemplateID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InTemplateID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfHeadResConfig                InHeadResConfig                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTgfHeadResConfig                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfHeadResConfig UTgfHeadCosmeticDataAsset::UpdateHeadResConfigWithTemplateID(int32 InTemplateID, const struct FTgfHeadResConfig& InHeadResConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfHeadCosmeticDataAsset", "UpdateHeadResConfigWithTemplateID");

	Params::TgfHeadCosmeticDataAsset_UpdateHeadResConfigWithTemplateID Parms{};

	Parms.InTemplateID = InTemplateID;
	Parms.InHeadResConfig = std::move(InHeadResConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponBase.K2_OnFOVConfigChanged
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ALyraWeaponBase::K2_OnFOVConfigChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "K2_OnFOVConfigChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraWeaponBase.K2_OnWeaponVisibleChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Visiblity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraWeaponBase::K2_OnWeaponVisibleChanged(bool Visiblity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "K2_OnWeaponVisibleChanged");

	Params::LyraWeaponBase_K2_OnWeaponVisibleChanged Parms{};

	Parms.Visiblity = Visiblity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraWeaponBase.OnRep_Held
// (Final, Native, Protected)
// Parameters:
// bool                                    OldHeld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraWeaponBase::OnRep_Held(bool OldHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "OnRep_Held");

	Params::LyraWeaponBase_OnRep_Held Parms{};

	Parms.OldHeld = OldHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponBase.ReceiveOnHeld
// (Event, Protected, BlueprintEvent)

void ALyraWeaponBase::ReceiveOnHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "ReceiveOnHeld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraWeaponBase.ReceiveOnSpawn
// (Event, Protected, BlueprintEvent)

void ALyraWeaponBase::ReceiveOnSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "ReceiveOnSpawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraWeaponBase.ReceiveOnUnHeld
// (Event, Protected, BlueprintEvent)

void ALyraWeaponBase::ReceiveOnUnHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "ReceiveOnUnHeld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraWeaponBase.SetEquipmentInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfEquipmentInstance*            Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraWeaponBase::SetEquipmentInstance(class UTgfEquipmentInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "SetEquipmentInstance");

	Params::LyraWeaponBase_SetEquipmentInstance Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponBase.GetEquipmentInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfEquipmentInstance*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfEquipmentInstance* ALyraWeaponBase::GetEquipmentInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponBase", "GetEquipmentInstance");

	Params::LyraWeaponBase_GetEquipmentInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFCombatZoneComponent.Initialize
// (Final, Native, Public, BlueprintCallable)

void UTGFCombatZoneComponent::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFCombatZoneComponent", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TGFCombatZoneComponent.IsInside
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTGFCombatZoneComponent::IsInside(const struct FVector& InPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFCombatZoneComponent", "IsInside");

	Params::TGFCombatZoneComponent_IsInside Parms{};

	Parms.InPoint = std::move(InPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AbilityTargetDataFromPassiveMoveInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTgfGameplayAbilityTargetingPassiveMoveInfoPassiveMoveInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UTgfAbilitySystemBlueprintLibrary::AbilityTargetDataFromPassiveMoveInfo(const struct FTgfGameplayAbilityTargetingPassiveMoveInfo& PassiveMoveInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AbilityTargetDataFromPassiveMoveInfo");

	Params::TgfAbilitySystemBlueprintLibrary_AbilityTargetDataFromPassiveMoveInfo Parms{};

	Parms.PassiveMoveInfo = std::move(PassiveMoveInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AddFullWeaponAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AddFullWeaponAmmo(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AddFullWeaponAmmo");

	Params::TgfAbilitySystemBlueprintLibrary_AddFullWeaponAmmo Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AddGameplayEffectContextSourceObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     GECH                                                   (Parm, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AddGameplayEffectContextSourceObject(const struct FGameplayEffectContextHandle& GECH, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AddGameplayEffectContextSourceObject");

	Params::TgfAbilitySystemBlueprintLibrary_AddGameplayEffectContextSourceObject Parms{};

	Parms.GECH = std::move(GECH);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AddItemByDef
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ClassName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AddItemByDef(class AActor* Target, TSubclassOf<class UTgfInventoryItemDefinition> ItemDef, int32 Num, const class FString& ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AddItemByDef");

	Params::TgfAbilitySystemBlueprintLibrary_AddItemByDef Parms{};

	Parms.Target = Target;
	Parms.ItemDef = ItemDef;
	Parms.Num = Num;
	Parms.ClassName = std::move(ClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AddWeaponAmmoByCountWithoutCostItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AddWeaponAmmoByCountWithoutCostItem(class AActor* InActor, bool Right, int32 AddCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AddWeaponAmmoByCountWithoutCostItem");

	Params::TgfAbilitySystemBlueprintLibrary_AddWeaponAmmoByCountWithoutCostItem Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;
	Parms.AddCount = AddCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AfterApplyGEWithSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpec>      GESpecApplied                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AfterApplyGEWithSpec(class AActor* Instigator, class AActor* Target, TArray<struct FGameplayEffectSpec>* GESpecApplied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AfterApplyGEWithSpec");

	Params::TgfAbilitySystemBlueprintLibrary_AfterApplyGEWithSpec Parms{};

	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GESpecApplied != nullptr)
		*GESpecApplied = std::move(Parms.GESpecApplied);
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AmmoAutoRecoverByInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemInstance*        Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::AmmoAutoRecoverByInstance(class AActor* InActor, class UTgfInventoryItemInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AmmoAutoRecoverByInstance");

	Params::TgfAbilitySystemBlueprintLibrary_AmmoAutoRecoverByInstance Parms{};

	Parms.InActor = InActor;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AmmoAutoRecoverBySlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ChangeSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AmmoAutoRecoverBySlot(class AActor* InActor, ETgfWeaponChangeSlot ChangeSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AmmoAutoRecoverBySlot");

	Params::TgfAbilitySystemBlueprintLibrary_AmmoAutoRecoverBySlot Parms{};

	Parms.InActor = InActor;
	Parms.ChangeSlot = ChangeSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AmmoClearByInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemInstance*        Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::AmmoClearByInstance(class AActor* InActor, class UTgfInventoryItemInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AmmoClearByInstance");

	Params::TgfAbilitySystemBlueprintLibrary_AmmoClearByInstance Parms{};

	Parms.InActor = InActor;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.ApplyAOEWithGA
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   Targets                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraTeamComparison                     TeamRestrict                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALyraCharacter*>           AppliedActors                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 SourceGA                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfApplyAOEExtraParam           ExtraParams                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::ApplyAOEWithGA(class AActor* Source, TArray<class AActor*>& Targets, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 MaxNum, ELyraTeamComparison TeamRestrict, TArray<class ALyraCharacter*>* AppliedActors, class UGameplayAbility* SourceGA, const struct FTgfApplyAOEExtraParam& ExtraParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "ApplyAOEWithGA");

	Params::TgfAbilitySystemBlueprintLibrary_ApplyAOEWithGA Parms{};

	Parms.Source = Source;
	Parms.Targets = std::move(Targets);
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.MaxNum = MaxNum;
	Parms.TeamRestrict = TeamRestrict;
	Parms.SourceGA = SourceGA;
	Parms.ExtraParams = std::move(ExtraParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Targets = std::move(Parms.Targets);

	if (AppliedActors != nullptr)
		*AppliedActors = std::move(Parms.AppliedActors);
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.ApplyGE
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ASCInstigator                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ASCHitActor                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     GECH                                                   (Parm, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UGameplayEffect>>GEs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   DamageRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WeaponAttack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::ApplyGE(class AActor* Instigator, class AActor* Target, class UAbilitySystemComponent* ASCInstigator, class UAbilitySystemComponent* ASCHitActor, const struct FGameplayEffectContextHandle& GECH, const TArray<TSubclassOf<class UGameplayEffect>>& GEs, float DamageRate, float WeaponAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "ApplyGE");

	Params::TgfAbilitySystemBlueprintLibrary_ApplyGE Parms{};

	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.ASCInstigator = ASCInstigator;
	Parms.ASCHitActor = ASCHitActor;
	Parms.GECH = std::move(GECH);
	Parms.GEs = std::move(GEs);
	Parms.DamageRate = DamageRate;
	Parms.WeaponAttack = WeaponAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.ApplyHitValueAndInterrupt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   HitValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InterruptGEClass                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Src                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Trg                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TargetIsPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanCauseInterrupt                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::ApplyHitValueAndInterrupt(float HitValue, const struct FGameplayEffectContextHandle& InEffectContext, TSubclassOf<class UGameplayEffect> InterruptGEClass, class UAbilitySystemComponent* Src, class UAbilitySystemComponent* Trg, bool TargetIsPlayer, bool CanCauseInterrupt, float Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "ApplyHitValueAndInterrupt");

	Params::TgfAbilitySystemBlueprintLibrary_ApplyHitValueAndInterrupt Parms{};

	Parms.HitValue = HitValue;
	Parms.InEffectContext = std::move(InEffectContext);
	Parms.InterruptGEClass = InterruptGEClass;
	Parms.Src = Src;
	Parms.Trg = Trg;
	Parms.TargetIsPlayer = TargetIsPlayer;
	Parms.CanCauseInterrupt = CanCauseInterrupt;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.AutoFillAdditionalWeaponSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   LyraCharacter                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSubType                        WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::AutoFillAdditionalWeaponSlot(class ALyraCharacter* LyraCharacter, ETgfEquipSubType WeaponType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "AutoFillAdditionalWeaponSlot");

	Params::TgfAbilitySystemBlueprintLibrary_AutoFillAdditionalWeaponSlot Parms{};

	Parms.LyraCharacter = LyraCharacter;
	Parms.WeaponType = WeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.BeforeApplyGEWithSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpec>      GESpecToApply                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::BeforeApplyGEWithSpec(class AActor* Instigator, class AActor* Target, TArray<struct FGameplayEffectSpec>* GESpecToApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "BeforeApplyGEWithSpec");

	Params::TgfAbilitySystemBlueprintLibrary_BeforeApplyGEWithSpec Parms{};

	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GESpecToApply != nullptr)
		*GESpecToApply = std::move(Parms.GESpecToApply);
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CalcHitValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TrgActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Guarded                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideAtk                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideDef                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::CalcHitValue(class AActor* SrcActor, class AActor* TrgActor, ETgfUseAttackType AttackType, bool Guarded, float OverrideAtk, float OverrideDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CalcHitValue");

	Params::TgfAbilitySystemBlueprintLibrary_CalcHitValue Parms{};

	Parms.SrcActor = SrcActor;
	Parms.TrgActor = TrgActor;
	Parms.AttackType = AttackType;
	Parms.Guarded = Guarded;
	Parms.OverrideAtk = OverrideAtk;
	Parms.OverrideDef = OverrideDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CanBeTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InputActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CanBeTarget(class AActor* InputActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CanBeTarget");

	Params::TgfAbilitySystemBlueprintLibrary_CanBeTarget Parms{};

	Parms.InputActor = InputActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CapsuleTraceMultiWithHeightLimit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NotHigherThanCenter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NotLowerThanCenter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CapsuleTraceMultiWithHeightLimit(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, float HalfHeight, float NotHigherThanCenter, float NotLowerThanCenter, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CapsuleTraceMultiWithHeightLimit");

	Params::TgfAbilitySystemBlueprintLibrary_CapsuleTraceMultiWithHeightLimit Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.NotHigherThanCenter = NotHigherThanCenter;
	Parms.NotLowerThanCenter = NotLowerThanCenter;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CheckCanReload
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CheckCanReload(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CheckCanReload");

	Params::TgfAbilitySystemBlueprintLibrary_CheckCanReload Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CheckGuardedProjectile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CheckGuardedProjectile(class AActor* HitActor, struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CheckGuardedProjectile");

	Params::TgfAbilitySystemBlueprintLibrary_CheckGuardedProjectile Parms{};

	Parms.HitActor = HitActor;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CheckHasAbility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     InAbilityClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CheckHasAbility(class AActor* Actor, TSubclassOf<class UGameplayAbility> InAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CheckHasAbility");

	Params::TgfAbilitySystemBlueprintLibrary_CheckHasAbility Parms{};

	Parms.Actor = Actor;
	Parms.InAbilityClass = InAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CheckNeedSnap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CheckNeedSnap(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CheckNeedSnap");

	Params::TgfAbilitySystemBlueprintLibrary_CheckNeedSnap Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CheckNeedTriggerReload
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CheckNeedTriggerReload(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CheckNeedTriggerReload");

	Params::TgfAbilitySystemBlueprintLibrary_CheckNeedTriggerReload Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.CheckVisibilityToLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     VisibleTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::CheckVisibilityToLocalPlayer(class AActor* TargetActor, const struct FGameplayTag& VisibleTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "CheckVisibilityToLocalPlayer");

	Params::TgfAbilitySystemBlueprintLibrary_CheckVisibilityToLocalPlayer Parms{};

	Parms.TargetActor = TargetActor;
	Parms.VisibleTag = std::move(VisibleTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.ConsumeItemByWeaponInHand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::ConsumeItemByWeaponInHand(class AActor* InActor, bool Right, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "ConsumeItemByWeaponInHand");

	Params::TgfAbilitySystemBlueprintLibrary_ConsumeItemByWeaponInHand Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.DisperseActiveBuff
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            HighPriorityTags                                       (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::DisperseActiveBuff(TArray<class AActor*>& Actors, const struct FGameplayTag& Tag, const struct FGameplayTagContainer& HighPriorityTags, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "DisperseActiveBuff");

	Params::TgfAbilitySystemBlueprintLibrary_DisperseActiveBuff Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Tag = std::move(Tag);
	Parms.HighPriorityTags = std::move(HighPriorityTags);
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.DoFullReload
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::DoFullReload(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "DoFullReload");

	Params::TgfAbilitySystemBlueprintLibrary_DoFullReload Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.DropAllAdditionalInventoryItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULyraInventoryItemInstance*>Items                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::DropAllAdditionalInventoryItem(class AActor* Target, TArray<class ULyraInventoryItemInstance*>* Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "DropAllAdditionalInventoryItem");

	Params::TgfAbilitySystemBlueprintLibrary_DropAllAdditionalInventoryItem Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Items != nullptr)
		*Items = std::move(Parms.Items);
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextAddExtraParam
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// struct FTgfGameplayEffectExtraParam     InExtraParam                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::EffectContextAddExtraParam(const struct FGameplayEffectContextHandle& InEffectContext, const struct FTgfGameplayEffectExtraParam& InExtraParam, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextAddExtraParam");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextAddExtraParam Parms{};

	Parms.InEffectContext = std::move(InEffectContext);
	Parms.InExtraParam = std::move(InExtraParam);
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextAddInstigator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::EffectContextAddInstigator(const struct FGameplayEffectContextHandle& EffectContext, class AActor* InInstigator, class AActor* InEffectCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextAddInstigator");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextAddInstigator Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetAbility
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// const class UGameplayAbility*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UGameplayAbility* UTgfAbilitySystemBlueprintLibrary::EffectContextGetAbility(const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetAbility");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetAbility Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetAbilityInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// const class UGameplayAbility*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UGameplayAbility* UTgfAbilitySystemBlueprintLibrary::EffectContextGetAbilityInstance(const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetAbilityInstance");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetAbilityInstance Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetCriticalRandomValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::EffectContextGetCriticalRandomValue(const struct FGameplayEffectContextHandle& InEffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetCriticalRandomValue");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetCriticalRandomValue Parms{};

	Parms.InEffectContext = std::move(InEffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetExtraParam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// const struct FTgfGameplayEffectExtraParamReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FTgfGameplayEffectExtraParam UTgfAbilitySystemBlueprintLibrary::EffectContextGetExtraParam(const struct FGameplayEffectContextHandle& InEffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetExtraParam");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetExtraParam Parms{};

	Parms.InEffectContext = std::move(InEffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetHitValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::EffectContextGetHitValue(const struct FGameplayEffectContextHandle& InEffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetHitValue");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetHitValue Parms{};

	Parms.InEffectContext = std::move(InEffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetNormalWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::EffectContextGetNormalWeight(const struct FGameplayEffectContextHandle& InEffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetNormalWeight");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetNormalWeight Parms{};

	Parms.InEffectContext = std::move(InEffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextGetTangentWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::EffectContextGetTangentWeight(const struct FGameplayEffectContextHandle& InEffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextGetTangentWeight");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextGetTangentWeight Parms{};

	Parms.InEffectContext = std::move(InEffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextHasExtraParam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::EffectContextHasExtraParam(const struct FGameplayEffectContextHandle& InEffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextHasExtraParam");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextHasExtraParam Parms{};

	Parms.InEffectContext = std::move(InEffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextSetCriticalRandomValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::EffectContextSetCriticalRandomValue(const struct FGameplayEffectContextHandle& InEffectContext, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextSetCriticalRandomValue");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextSetCriticalRandomValue Parms{};

	Parms.InEffectContext = std::move(InEffectContext);
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextSetDirectionWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   InNormalWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTangentWeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::EffectContextSetDirectionWeight(const struct FGameplayEffectContextHandle& InEffectContext, float InNormalWeight, float InTangentWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextSetDirectionWeight");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextSetDirectionWeight Parms{};

	Parms.InEffectContext = std::move(InEffectContext);
	Parms.InNormalWeight = InNormalWeight;
	Parms.InTangentWeight = InTangentWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextSetHitValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     InEffectContext                                        (Parm, NativeAccessSpecifierPublic)
// float                                   InHitValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::EffectContextSetHitValue(const struct FGameplayEffectContextHandle& InEffectContext, float InHitValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextSetHitValue");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextSetHitValue Parms{};

	Parms.InEffectContext = std::move(InEffectContext);
	Parms.InHitValue = InHitValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.EffectContextSetSourceAbility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 GameplayAbility                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::EffectContextSetSourceAbility(const struct FGameplayEffectContextHandle& EffectContext, const class UGameplayAbility* GameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "EffectContextSetSourceAbility");

	Params::TgfAbilitySystemBlueprintLibrary_EffectContextSetSourceAbility Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.GameplayAbility = GameplayAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.FindBackStabActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewForward                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewPos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BackDegree                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HDegree                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VDegree                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfAbilitySystemBlueprintLibrary::FindBackStabActor(class AActor* SrcActor, const struct FVector& ViewForward, const struct FVector& ViewPos, float BackDegree, float HDegree, float VDegree, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "FindBackStabActor");

	Params::TgfAbilitySystemBlueprintLibrary_FindBackStabActor Parms{};

	Parms.SrcActor = SrcActor;
	Parms.ViewForward = std::move(ViewForward);
	Parms.ViewPos = std::move(ViewPos);
	Parms.BackDegree = BackDegree;
	Parms.HDegree = HDegree;
	Parms.VDegree = VDegree;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.FindDefaultComponentByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               InActorClass                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      InComponentClass                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UTgfAbilitySystemBlueprintLibrary::FindDefaultComponentByClass(const TSubclassOf<class AActor> InActorClass, const TSubclassOf<class UActorComponent> InComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "FindDefaultComponentByClass");

	Params::TgfAbilitySystemBlueprintLibrary_FindDefaultComponentByClass Parms{};

	Parms.InActorClass = InActorClass;
	Parms.InComponentClass = InComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.FindProperGroundPos
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NowPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CheckDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTgfAbilitySystemBlueprintLibrary::FindProperGroundPos(const class UObject* WorldContextObject, const struct FVector& NowPos, float CheckDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "FindProperGroundPos");

	Params::TgfAbilitySystemBlueprintLibrary_FindProperGroundPos Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NowPos = std::move(NowPos);
	Parms.CheckDepth = CheckDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetActiveGameplayEffectHandleByClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfGameplayEffect>   GEClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      OutHandle                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::GetActiveGameplayEffectHandleByClass(class AActor* Target, TSubclassOf<class UTgfGameplayEffect> GEClass, struct FActiveGameplayEffectHandle* OutHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectHandleByClass");

	Params::TgfAbilitySystemBlueprintLibrary_GetActiveGameplayEffectHandleByClass Parms{};

	Parms.Target = Target;
	Parms.GEClass = GEClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandle != nullptr)
		*OutHandle = std::move(Parms.OutHandle);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetAllMatchingTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagsToMatch                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            MatchResult                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::GetAllMatchingTags(class ULyraAbilitySystemComponent* ASC, const struct FGameplayTagContainer& TagsToMatch, struct FGameplayTagContainer* MatchResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetAllMatchingTags");

	Params::TgfAbilitySystemBlueprintLibrary_GetAllMatchingTags Parms{};

	Parms.ASC = ASC;
	Parms.TagsToMatch = std::move(TagsToMatch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MatchResult != nullptr)
		*MatchResult = std::move(Parms.MatchResult);
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetAmmoItemCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAbilitySystemBlueprintLibrary::GetAmmoItemCount(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetAmmoItemCount");

	Params::TgfAbilitySystemBlueprintLibrary_GetAmmoItemCount Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetAmmoItemCountBySlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAbilitySystemBlueprintLibrary::GetAmmoItemCountBySlot(class AActor* InActor, ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetAmmoItemCountBySlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetAmmoItemCountBySlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetAnimDriveProjectileTemplateByEquipSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   DefaultProjectileTemplate                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ATgfProjectileBase> UTgfAbilitySystemBlueprintLibrary::GetAnimDriveProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetAnimDriveProjectileTemplateByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetAnimDriveProjectileTemplateByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;
	Parms.DefaultProjectileTemplate = DefaultProjectileTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutResult != nullptr)
		*bOutResult = Parms.bOutResult;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetAttackRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetAttackRate(class AActor* SrcActor, float DefaultRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetAttackRate");

	Params::TgfAbilitySystemBlueprintLibrary_GetAttackRate Parms{};

	Parms.SrcActor = SrcActor;
	Parms.DefaultRate = DefaultRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetAttackWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetAttackWeight(class AActor* SrcActor, ETgfUseAttackType AttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetAttackWeight");

	Params::TgfAbilitySystemBlueprintLibrary_GetAttackWeight Parms{};

	Parms.SrcActor = SrcActor;
	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetConsoleVariableSourceByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfAbilitySystemBlueprintLibrary::GetConsoleVariableSourceByName(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetConsoleVariableSourceByName");

	Params::TgfAbilitySystemBlueprintLibrary_GetConsoleVariableSourceByName Parms{};

	Parms.VariableName = std::move(VariableName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetControllerFromGameplayCueParameters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UTgfAbilitySystemBlueprintLibrary::GetControllerFromGameplayCueParameters(const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetControllerFromGameplayCueParameters");

	Params::TgfAbilitySystemBlueprintLibrary_GetControllerFromGameplayCueParameters Parms{};

	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetCoolDownCountDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetCoolDownCountDuration(class AActor* SrcActor, float DefaultDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetCoolDownCountDuration");

	Params::TgfAbilitySystemBlueprintLibrary_GetCoolDownCountDuration Parms{};

	Parms.SrcActor = SrcActor;
	Parms.DefaultDuration = DefaultDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetCurrentCharacterState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     CharacterStateTag                                      (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::GetCurrentCharacterState(class ALyraCharacter* InActor, struct FGameplayTag* CharacterStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetCurrentCharacterState");

	Params::TgfAbilitySystemBlueprintLibrary_GetCurrentCharacterState Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CharacterStateTag != nullptr)
		*CharacterStateTag = std::move(Parms.CharacterStateTag);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetCurrentHandEquipInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* UTgfAbilitySystemBlueprintLibrary::GetCurrentHandEquipInstance(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetCurrentHandEquipInstance");

	Params::TgfAbilitySystemBlueprintLibrary_GetCurrentHandEquipInstance Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetCurrentHandEquipSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UTgfAbilitySystemBlueprintLibrary::GetCurrentHandEquipSlot(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetCurrentHandEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetCurrentHandEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetCurrentWeaponDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfWeaponDefinition*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfWeaponDefinition* UTgfAbilitySystemBlueprintLibrary::GetCurrentWeaponDefinition(class AActor* InActor, bool Right, int32 IgnoreIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetCurrentWeaponDefinition");

	Params::TgfAbilitySystemBlueprintLibrary_GetCurrentWeaponDefinition Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;
	Parms.IgnoreIndex = IgnoreIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetCurrentWeaponFirstActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfAbilitySystemBlueprintLibrary::GetCurrentWeaponFirstActor(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetCurrentWeaponFirstActor");

	Params::TgfAbilitySystemBlueprintLibrary_GetCurrentWeaponFirstActor Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetDamageSourceDir
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   OutAngle                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     EffectContext                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::GetDamageSourceDir(float* OutAngle, const struct FGameplayEffectContextHandle& EffectContext, class AActor* Instigator, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetDamageSourceDir");

	Params::TgfAbilitySystemBlueprintLibrary_GetDamageSourceDir Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAngle != nullptr)
		*OutAngle = Parms.OutAngle;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetDefendValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Guarded                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetDefendValue(class AActor* SrcActor, bool Guarded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetDefendValue");

	Params::TgfAbilitySystemBlueprintLibrary_GetDefendValue Parms{};

	Parms.SrcActor = SrcActor;
	Parms.Guarded = Guarded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetDisplayQualityByEquipSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipQuality                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipQuality UTgfAbilitySystemBlueprintLibrary::GetDisplayQualityByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetDisplayQualityByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetDisplayQualityByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetEquipSkeletalMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraEquipmentInstance*           EquipInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UTgfAbilitySystemBlueprintLibrary::GetEquipSkeletalMesh(class ULyraEquipmentInstance* EquipInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetEquipSkeletalMesh");

	Params::TgfAbilitySystemBlueprintLibrary_GetEquipSkeletalMesh Parms{};

	Parms.EquipInstance = EquipInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetInventoryItemInstanceByEquipSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* UTgfAbilitySystemBlueprintLibrary::GetInventoryItemInstanceByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetInventoryItemInstanceByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetInventoryItemInstanceByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetMontageRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfMontageRateType                     RateType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetMontageRate(class AActor* SrcActor, ETgfMontageRateType RateType, float DefaultRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetMontageRate");

	Params::TgfAbilitySystemBlueprintLibrary_GetMontageRate Parms{};

	Parms.SrcActor = SrcActor;
	Parms.RateType = RateType;
	Parms.DefaultRate = DefaultRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetMoveActorNotifyDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetMoveActorNotifyDuration(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetMoveActorNotifyDuration");

	Params::TgfAbilitySystemBlueprintLibrary_GetMoveActorNotifyDuration Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetNoHitProjectileTemplateByEquipSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   DefaultProjectileTemplate                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ATgfProjectileBase> UTgfAbilitySystemBlueprintLibrary::GetNoHitProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetNoHitProjectileTemplateByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetNoHitProjectileTemplateByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;
	Parms.DefaultProjectileTemplate = DefaultProjectileTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutResult != nullptr)
		*bOutResult = Parms.bOutResult;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetNormalProjectileTemplateByEquipSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   DefaultProjectileTemplate                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ATgfProjectileBase> UTgfAbilitySystemBlueprintLibrary::GetNormalProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetNormalProjectileTemplateByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetNormalProjectileTemplateByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;
	Parms.DefaultProjectileTemplate = DefaultProjectileTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutResult != nullptr)
		*bOutResult = Parms.bOutResult;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetSharedDPH
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   DPH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActualNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSharedNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDPHRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetSharedDPH(float DPH, int32 ActualNum, float MinSharedNum, float MinDPHRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetSharedDPH");

	Params::TgfAbilitySystemBlueprintLibrary_GetSharedDPH Parms{};

	Parms.DPH = DPH;
	Parms.ActualNum = ActualNum;
	Parms.MinSharedNum = MinSharedNum;
	Parms.MinDPHRate = MinDPHRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetSnapNotifyDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetSnapNotifyDuration(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetSnapNotifyDuration");

	Params::TgfAbilitySystemBlueprintLibrary_GetSnapNotifyDuration Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetTaggedProjectile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ProjectileTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   DefaultProjectileTemplate                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ATgfProjectileBase> UTgfAbilitySystemBlueprintLibrary::GetTaggedProjectile(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, const struct FGameplayTag& ProjectileTag, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetTaggedProjectile");

	Params::TgfAbilitySystemBlueprintLibrary_GetTaggedProjectile Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;
	Parms.ProjectileTag = std::move(ProjectileTag);
	Parms.DefaultProjectileTemplate = DefaultProjectileTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutResult != nullptr)
		*bOutResult = Parms.bOutResult;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetTargetDataPassiveMoveInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTgfGameplayAbilityTargetData_PassiveMoveReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FTgfGameplayAbilityTargetData_PassiveMove UTgfAbilitySystemBlueprintLibrary::GetTargetDataPassiveMoveInfo(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetTargetDataPassiveMoveInfo");

	Params::TgfAbilitySystemBlueprintLibrary_GetTargetDataPassiveMoveInfo Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetTrackProjectileTemplateByEquipSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   DefaultProjectileTemplate                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATgfProjectileBase>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ATgfProjectileBase> UTgfAbilitySystemBlueprintLibrary::GetTrackProjectileTemplateByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex, TSubclassOf<class ATgfProjectileBase> DefaultProjectileTemplate, bool* bOutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetTrackProjectileTemplateByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetTrackProjectileTemplateByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;
	Parms.DefaultProjectileTemplate = DefaultProjectileTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutResult != nullptr)
		*bOutResult = Parms.bOutResult;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetVulnerFactorRawValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagContainer                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetVulnerFactorRawValue(class AActor* SrcActor, const struct FGameplayTagContainer& TagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetVulnerFactorRawValue");

	Params::TgfAbilitySystemBlueprintLibrary_GetVulnerFactorRawValue Parms{};

	Parms.SrcActor = SrcActor;
	Parms.TagContainer = std::move(TagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponAmmoType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponAmmoType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponAmmoType UTgfAbilitySystemBlueprintLibrary::GetWeaponAmmoType(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponAmmoType");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponAmmoType Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAbilitySystemBlueprintLibrary::GetWeaponAttack(class AActor* SrcActor, ETgfUseAttackType AttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponAttack");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponAttack Parms{};

	Parms.SrcActor = SrcActor;
	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponCurAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAbilitySystemBlueprintLibrary::GetWeaponCurAmmo(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponCurAmmo");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponCurAmmo Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponCurAmmoBySlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAbilitySystemBlueprintLibrary::GetWeaponCurAmmoBySlot(class AActor* InActor, ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponCurAmmoBySlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponCurAmmoBySlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponDefinitionByEquipSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfWeaponDefinition*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfWeaponDefinition* UTgfAbilitySystemBlueprintLibrary::GetWeaponDefinitionByEquipSlot(class AActor* InActor, ETgfEquipSlot Slot, int32 IgnoreIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponDefinitionByEquipSlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponDefinitionByEquipSlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponInventoryItemInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemInstance*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryItemInstance* UTgfAbilitySystemBlueprintLibrary::GetWeaponInventoryItemInstance(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponInventoryItemInstance");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponInventoryItemInstance Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponMaxAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAbilitySystemBlueprintLibrary::GetWeaponMaxAmmo(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponMaxAmmo");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponMaxAmmo Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.GetWeaponMaxAmmoBySlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAbilitySystemBlueprintLibrary::GetWeaponMaxAmmoBySlot(class AActor* InActor, ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "GetWeaponMaxAmmoBySlot");

	Params::TgfAbilitySystemBlueprintLibrary_GetWeaponMaxAmmoBySlot Parms{};

	Parms.InActor = InActor;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.HasAllMatchingGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            GameplayTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::HasAllMatchingGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "HasAllMatchingGameplayTags");

	Params::TgfAbilitySystemBlueprintLibrary_HasAllMatchingGameplayTags Parms{};

	Parms.Actor = Actor;
	Parms.GameplayTags = std::move(GameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.HasAnyMatchingGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            GameplayTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::HasAnyMatchingGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "HasAnyMatchingGameplayTags");

	Params::TgfAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags Parms{};

	Parms.Actor = Actor;
	Parms.GameplayTags = std::move(GameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsAbilityFromCurrentHand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfGameplayAbility*              Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsAbilityFromCurrentHand(class AActor* InActor, class UTgfGameplayAbility* Ability, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsAbilityFromCurrentHand");

	Params::TgfAbilitySystemBlueprintLibrary_IsAbilityFromCurrentHand Parms{};

	Parms.InActor = InActor;
	Parms.Ability = Ability;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsCharacterState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     CharacterStateTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsCharacterState(class ALyraCharacter* InActor, const struct FGameplayTag& CharacterStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsCharacterState");

	Params::TgfAbilitySystemBlueprintLibrary_IsCharacterState Parms{};

	Parms.InActor = InActor;
	Parms.CharacterStateTag = std::move(CharacterStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsCritical
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          SrcABS                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          TrgABS                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CriticalRandom                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsCritical(class UAbilitySystemComponent* SrcABS, class UAbilitySystemComponent* TrgABS, float CriticalRandom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsCritical");

	Params::TgfAbilitySystemBlueprintLibrary_IsCritical Parms{};

	Parms.SrcABS = SrcABS;
	Parms.TrgABS = TrgABS;
	Parms.CriticalRandom = CriticalRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsEquipLocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTgfEquipmentManagerComponent*    EquipmentManager                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           EquipIns                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsEquipLocked(const class UTgfEquipmentManagerComponent* EquipmentManager, const class ULyraEquipmentInstance* EquipIns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsEquipLocked");

	Params::TgfAbilitySystemBlueprintLibrary_IsEquipLocked Parms{};

	Parms.EquipmentManager = EquipmentManager;
	Parms.EquipIns = EquipIns;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsHPFull
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsHPFull(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsHPFull");

	Params::TgfAbilitySystemBlueprintLibrary_IsHPFull Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsInstigatorSummonSourceLocallyControlled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsInstigatorSummonSourceLocallyControlled(const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsInstigatorSummonSourceLocallyControlled");

	Params::TgfAbilitySystemBlueprintLibrary_IsInstigatorSummonSourceLocallyControlled Parms{};

	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsNaturalEnergyEmpty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsNaturalEnergyEmpty(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsNaturalEnergyEmpty");

	Params::TgfAbilitySystemBlueprintLibrary_IsNaturalEnergyEmpty Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsNormalCharacterState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsNormalCharacterState(class ALyraCharacter* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsNormalCharacterState");

	Params::TgfAbilitySystemBlueprintLibrary_IsNormalCharacterState Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsSoulEnergyFull
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsSoulEnergyFull(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsSoulEnergyFull");

	Params::TgfAbilitySystemBlueprintLibrary_IsSoulEnergyFull Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IsWhichHandWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::IsWhichHandWeapon(class AActor* InActor, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IsWhichHandWeapon");

	Params::TgfAbilitySystemBlueprintLibrary_IsWhichHandWeapon Parms{};

	Parms.InActor = InActor;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.IterateAvailableSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfEquipmentManagerComponent*    EquipmentManager                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Step                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ETgfWeaponChangeSlot>            SlotList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UTgfAbilitySystemBlueprintLibrary::IterateAvailableSlot(const class UTgfEquipmentManagerComponent* EquipmentManager, int32 Step, const TArray<ETgfWeaponChangeSlot>& SlotList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "IterateAvailableSlot");

	Params::TgfAbilitySystemBlueprintLibrary_IterateAvailableSlot Parms{};

	Parms.EquipmentManager = EquipmentManager;
	Parms.Step = Step;
	Parms.SlotList = std::move(SlotList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.MakeGESpecHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UGameplayEffect>      GameplayEffectDef                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     GECH                                                   (Parm, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UTgfAbilitySystemBlueprintLibrary::MakeGESpecHandle(TSubclassOf<class UGameplayEffect> GameplayEffectDef, const struct FGameplayEffectContextHandle& GECH, float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "MakeGESpecHandle");

	Params::TgfAbilitySystemBlueprintLibrary_MakeGESpecHandle Parms{};

	Parms.GameplayEffectDef = GameplayEffectDef;
	Parms.GECH = std::move(GECH);
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.RecoverAllSlotWeaponAmmoWithoutCostItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::RecoverAllSlotWeaponAmmoWithoutCostItem(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "RecoverAllSlotWeaponAmmoWithoutCostItem");

	Params::TgfAbilitySystemBlueprintLibrary_RecoverAllSlotWeaponAmmoWithoutCostItem Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.RecoverSlotWeaponAmmoWithoutCostItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ChangeSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::RecoverSlotWeaponAmmoWithoutCostItem(class AActor* InActor, ETgfWeaponChangeSlot ChangeSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "RecoverSlotWeaponAmmoWithoutCostItem");

	Params::TgfAbilitySystemBlueprintLibrary_RecoverSlotWeaponAmmoWithoutCostItem Parms{};

	Parms.InActor = InActor;
	Parms.ChangeSlot = ChangeSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.ReturnMagicCost
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      ReturnMagicGEClass                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Src                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CostValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::ReturnMagicCost(TSubclassOf<class UGameplayEffect> ReturnMagicGEClass, class UAbilitySystemComponent* Src, float CostValue, const struct FGameplayEffectContextHandle& EffectContext, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "ReturnMagicCost");

	Params::TgfAbilitySystemBlueprintLibrary_ReturnMagicCost Parms{};

	Parms.ReturnMagicGEClass = ReturnMagicGEClass;
	Parms.Src = Src;
	Parms.CostValue = CostValue;
	Parms.EffectContext = std::move(EffectContext);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.SendClearAdditionalInventoryEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedDrop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::SendClearAdditionalInventoryEvent(class ALyraCharacter* Character, bool bNeedDrop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "SendClearAdditionalInventoryEvent");

	Params::TgfAbilitySystemBlueprintLibrary_SendClearAdditionalInventoryEvent Parms{};

	Parms.Character = Character;
	Parms.bNeedDrop = bNeedDrop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.SendCommonGameEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InstigatorEvent                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TargetEvent                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpec>      GESpecToApply                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::SendCommonGameEvent(const struct FGameplayTag& InstigatorEvent, const struct FGameplayTag& TargetEvent, class AActor* Instigator, class AActor* Target, const TArray<struct FGameplayEffectSpec>& GESpecToApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "SendCommonGameEvent");

	Params::TgfAbilitySystemBlueprintLibrary_SendCommonGameEvent Parms{};

	Parms.InstigatorEvent = std::move(InstigatorEvent);
	Parms.TargetEvent = std::move(TargetEvent);
	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.GESpecToApply = std::move(GESpecToApply);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.SendGameplayEventToCharaOrInteract
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::SendGameplayEventToCharaOrInteract(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "SendGameplayEventToCharaOrInteract");

	Params::TgfAbilitySystemBlueprintLibrary_SendGameplayEventToCharaOrInteract Parms{};

	Parms.Actor = Actor;
	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.ShouldHitValueInterrupt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanCauseInterrupt                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TargetIsPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasDefence                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasCharging                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasUninterruptible                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAbilitySystemBlueprintLibrary::ShouldHitValueInterrupt(const class UObject* WorldContextObject, float HitValue, bool CanCauseInterrupt, bool TargetIsPlayer, bool HasDefence, bool HasCharging, bool HasUninterruptible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "ShouldHitValueInterrupt");

	Params::TgfAbilitySystemBlueprintLibrary_ShouldHitValueInterrupt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.HitValue = HitValue;
	Parms.CanCauseInterrupt = CanCauseInterrupt;
	Parms.TargetIsPlayer = TargetIsPlayer;
	Parms.HasDefence = HasDefence;
	Parms.HasCharging = HasCharging;
	Parms.HasUninterruptible = HasUninterruptible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.TestRootMotion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::TestRootMotion(class ALyraCharacter* InActor, const struct FVector& TargetLocation, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "TestRootMotion");

	Params::TgfAbilitySystemBlueprintLibrary_TestRootMotion Parms{};

	Parms.InActor = InActor;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilitySystemBlueprintLibrary.UseWeaponAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UseCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAbilitySystemBlueprintLibrary::UseWeaponAmmo(class AActor* InActor, int32 UseCount, bool Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilitySystemBlueprintLibrary", "UseWeaponAmmo");

	Params::TgfAbilitySystemBlueprintLibrary_UseWeaponAmmo Parms{};

	Parms.InActor = InActor;
	Parms.UseCount = UseCount;
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityTask_WaitGameplayEvent.WaitGameplayEventWithTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Param_OptionalExternalTarget                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyTriggerOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyMatchExact                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfAbilityTask_WaitGameplayEvent*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAbilityTask_WaitGameplayEvent* UTgfAbilityTask_WaitGameplayEvent::WaitGameplayEventWithTime(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& EventTags, class AActor* Param_OptionalExternalTarget, bool OnlyTriggerOnce, bool OnlyMatchExact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilityTask_WaitGameplayEvent", "WaitGameplayEventWithTime");

	Params::TgfAbilityTask_WaitGameplayEvent_WaitGameplayEventWithTime Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.EventTags = std::move(EventTags);
	Parms.Param_OptionalExternalTarget = Param_OptionalExternalTarget;
	Parms.OnlyTriggerOnce = OnlyTriggerOnce;
	Parms.OnlyMatchExact = OnlyMatchExact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraDevelopmentStatics.CanPlayerBotsAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraDevelopmentStatics::CanPlayerBotsAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraDevelopmentStatics", "CanPlayerBotsAttack");

	Params::LyraDevelopmentStatics_CanPlayerBotsAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraDevelopmentStatics.ForceGarbageCollection
// (Final, Native, Static, Public, BlueprintCallable)

void ULyraDevelopmentStatics::ForceGarbageCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraDevelopmentStatics", "ForceGarbageCollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraDevelopmentStatics.ShouldLoadCosmeticBackgrounds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraDevelopmentStatics::ShouldLoadCosmeticBackgrounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraDevelopmentStatics", "ShouldLoadCosmeticBackgrounds");

	Params::LyraDevelopmentStatics_ShouldLoadCosmeticBackgrounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraDevelopmentStatics.ShouldSkipDirectlyToGameplay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraDevelopmentStatics::ShouldSkipDirectlyToGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraDevelopmentStatics", "ShouldSkipDirectlyToGameplay");

	Params::LyraDevelopmentStatics_ShouldSkipDirectlyToGameplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilityTask_WaitMoving.WaitMoving
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovingCheckParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UTgfAbilityTask_WaitMoving*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAbilityTask_WaitMoving* UTgfAbilityTask_WaitMoving::WaitMoving(class UGameplayAbility* OwningAbility, const struct FMovingCheckParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilityTask_WaitMoving", "WaitMoving");

	Params::TgfAbilityTask_WaitMoving_WaitMoving Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfActorCustomDepthStencilManagerComponent.SetCustomStencilTypeAndValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfStencilTypeBaseValue                StencilType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Recursively                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorCustomDepthStencilManagerComponent::SetCustomStencilTypeAndValue(ETgfStencilTypeBaseValue StencilType, bool bSet, int32 Subtype, class UPrimitiveComponent* TargetMesh, bool Recursively)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorCustomDepthStencilManagerComponent", "SetCustomStencilTypeAndValue");

	Params::TgfActorCustomDepthStencilManagerComponent_SetCustomStencilTypeAndValue Parms{};

	Parms.StencilType = StencilType;
	Parms.bSet = bSet;
	Parms.Subtype = Subtype;
	Parms.TargetMesh = TargetMesh;
	Parms.Recursively = Recursively;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorCustomDepthStencilManagerComponent.SetCustomStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfStencilRef                          StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorCustomDepthStencilManagerComponent::SetCustomStencilValue(ETgfStencilRef StencilValue, bool bSet, class UPrimitiveComponent* TargetMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorCustomDepthStencilManagerComponent", "SetCustomStencilValue");

	Params::TgfActorCustomDepthStencilManagerComponent_SetCustomStencilValue Parms{};

	Parms.StencilValue = StencilValue;
	Parms.bSet = bSet;
	Parms.TargetMesh = TargetMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorCustomDepthStencilManagerComponent.SetCustomStencilValueByRealValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorCustomDepthStencilManagerComponent::SetCustomStencilValueByRealValue(class UPrimitiveComponent* TargetMesh, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorCustomDepthStencilManagerComponent", "SetCustomStencilValueByRealValue");

	Params::TgfActorCustomDepthStencilManagerComponent_SetCustomStencilValueByRealValue Parms{};

	Parms.TargetMesh = TargetMesh;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorCustomDepthStencilManagerComponent.SetStencilSubtypeValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfStencilTypeBaseValue                StencilType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfActorCustomDepthStencilManagerComponent::SetStencilSubtypeValue(ETgfStencilTypeBaseValue StencilType, int32 Value, bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorCustomDepthStencilManagerComponent", "SetStencilSubtypeValue");

	Params::TgfActorCustomDepthStencilManagerComponent_SetStencilSubtypeValue Parms{};

	Parms.StencilType = StencilType;
	Parms.Value = Value;
	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfActorCustomDepthStencilManagerComponent.GetCurrentStencilValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfActorCustomDepthStencilManagerComponent::GetCurrentStencilValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorCustomDepthStencilManagerComponent", "GetCurrentStencilValue");

	Params::TgfActorCustomDepthStencilManagerComponent_GetCurrentStencilValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_ObserveTeamColors.ObserveTeamColors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_ObserveTeamColors*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_ObserveTeamColors* UAsyncAction_ObserveTeamColors::ObserveTeamColors(class UObject* TeamAgent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_ObserveTeamColors", "ObserveTeamColors");

	Params::AsyncAction_ObserveTeamColors_ObserveTeamColors Parms{};

	Parms.TeamAgent = TeamAgent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_ObserveTeamColors.OnDisplayAssetChanged
// (Final, Native, Private)
// Parameters:
// class ULyraTeamDisplayAsset*            DisplayAsset                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_ObserveTeamColors::OnDisplayAssetChanged(const class ULyraTeamDisplayAsset* DisplayAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_ObserveTeamColors", "OnDisplayAssetChanged");

	Params::AsyncAction_ObserveTeamColors_OnDisplayAssetChanged Parms{};

	Parms.DisplayAsset = DisplayAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AsyncAction_ObserveTeamColors.OnWatchedAgentChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_ObserveTeamColors::OnWatchedAgentChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_ObserveTeamColors", "OnWatchedAgentChangedTeam");

	Params::AsyncAction_ObserveTeamColors_OnWatchedAgentChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamSubsystem.AddTeamTagStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamSubsystem::AddTeamTagStack(int32 TeamId, const struct FGameplayTag& Tag, int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "AddTeamTagStack");

	Params::LyraTeamSubsystem_AddTeamTagStack Parms{};

	Parms.TeamId = TeamId;
	Parms.Tag = std::move(Tag);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamSubsystem.GetEffectiveTeamDisplayAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ViewerTeamAgent                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraTeamDisplayAsset*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraTeamDisplayAsset* ULyraTeamSubsystem::GetEffectiveTeamDisplayAsset(int32 TeamId, class UObject* ViewerTeamAgent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetEffectiveTeamDisplayAsset");

	Params::LyraTeamSubsystem_GetEffectiveTeamDisplayAsset Parms{};

	Parms.TeamId = TeamId;
	Parms.ViewerTeamAgent = ViewerTeamAgent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetOwnPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraPlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerController* ULyraTeamSubsystem::GetOwnPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetOwnPlayer");

	Params::LyraTeamSubsystem_GetOwnPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetPlayersInTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALyraPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ALyraPlayerState*> ULyraTeamSubsystem::GetPlayersInTeam(int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetPlayersInTeam");

	Params::LyraTeamSubsystem_GetPlayersInTeam Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetPlayerStatesWithSameTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALyraPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ALyraPlayerState*> ULyraTeamSubsystem::GetPlayerStatesWithSameTeam(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetPlayerStatesWithSameTeam");

	Params::LyraTeamSubsystem_GetPlayerStatesWithSameTeam Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetPlayersWithSameTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALyraPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ALyraPlayerState*> ULyraTeamSubsystem::GetPlayersWithSameTeam(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetPlayersWithSameTeam");

	Params::LyraTeamSubsystem_GetPlayersWithSameTeam Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetTeamDisplayAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ViewerTeamId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraTeamDisplayAsset*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraTeamDisplayAsset* ULyraTeamSubsystem::GetTeamDisplayAsset(int32 TeamId, int32 ViewerTeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetTeamDisplayAsset");

	Params::LyraTeamSubsystem_GetTeamDisplayAsset Parms{};

	Parms.TeamId = TeamId;
	Parms.ViewerTeamId = ViewerTeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetTeamMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALyraPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ALyraPlayerState*> ULyraTeamSubsystem::GetTeamMembers(int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetTeamMembers");

	Params::LyraTeamSubsystem_GetTeamMembers Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.RemoveTeamTagStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamSubsystem::RemoveTeamTagStack(int32 TeamId, const struct FGameplayTag& Tag, int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "RemoveTeamTagStack");

	Params::LyraTeamSubsystem_RemoveTeamTagStack Parms{};

	Parms.TeamId = TeamId;
	Parms.Tag = std::move(Tag);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamSubsystem.CompareTeams
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// class UObject*                          A                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          B                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamIdA                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamIdB                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraTeamComparison                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraTeamComparison ULyraTeamSubsystem::CompareTeams(const class UObject* A, const class UObject* B, int32* TeamIdA, int32* TeamIdB) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "CompareTeams");

	Params::LyraTeamSubsystem_CompareTeams Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TeamIdA != nullptr)
		*TeamIdA = Parms.TeamIdA;

	if (TeamIdB != nullptr)
		*TeamIdB = Parms.TeamIdB;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.DoesTeamExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTeamSubsystem::DoesTeamExist(int32 TeamId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "DoesTeamExist");

	Params::LyraTeamSubsystem_DoesTeamExist Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.FindTeamFromActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// class UObject*                          TestActor                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPartOfTeam                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamSubsystem::FindTeamFromActor(const class UObject* TestActor, bool* bIsPartOfTeam, int32* TeamId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "FindTeamFromActor");

	Params::LyraTeamSubsystem_FindTeamFromActor Parms{};

	Parms.TestActor = TestActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsPartOfTeam != nullptr)
		*bIsPartOfTeam = Parms.bIsPartOfTeam;

	if (TeamId != nullptr)
		*TeamId = Parms.TeamId;
}


// Function LyraGame.LyraTeamSubsystem.GetTeamIDs
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> ULyraTeamSubsystem::GetTeamIDs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetTeamIDs");

	Params::LyraTeamSubsystem_GetTeamIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.GetTeamTagStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraTeamSubsystem::GetTeamTagStackCount(int32 TeamId, const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "GetTeamTagStackCount");

	Params::LyraTeamSubsystem_GetTeamTagStackCount Parms{};

	Parms.TeamId = TeamId;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamSubsystem.TeamHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTeamSubsystem::TeamHasTag(int32 TeamId, const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamSubsystem", "TeamHasTag");

	Params::LyraTeamSubsystem_TeamHasTag Parms{};

	Parms.TeamId = TeamId;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAnimNotifyState_GameplayTag.NeedDealTag
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAnimNotifyState_GameplayTag::NeedDealTag(class USkeletalMeshComponent* MeshComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAnimNotifyState_GameplayTag", "NeedDealTag");

	Params::TgfAnimNotifyState_GameplayTag_NeedDealTag Parms{};

	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamInfoBase.OnRep_TeamId
// (Final, Native, Private)

void ALyraTeamInfoBase::OnRep_TeamId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamInfoBase", "OnRep_TeamId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamPublicInfo.OnRep_TeamDisplayAsset
// (Final, Native, Private)

void ALyraTeamPublicInfo::OnRep_TeamDisplayAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamPublicInfo", "OnRep_TeamDisplayAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTabListWidgetBase.GetPreregisteredTabInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TabNameID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLyraTabDescriptor               OutTabInfo                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::GetPreregisteredTabInfo(const class FName TabNameID, struct FLyraTabDescriptor* OutTabInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "GetPreregisteredTabInfo");

	Params::LyraTabListWidgetBase_GetPreregisteredTabInfo Parms{};

	Parms.TabNameID = TabNameID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTabInfo != nullptr)
		*OutTabInfo = std::move(Parms.OutTabInfo);

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTabListWidgetBase.GetVisibleTabCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraTabListWidgetBase::GetVisibleTabCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "GetVisibleTabCount");

	Params::LyraTabListWidgetBase_GetVisibleTabCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTabListWidgetBase.IsTabVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::IsTabVisible(class FName TabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "IsTabVisible");

	Params::LyraTabListWidgetBase_IsTabVisible Parms{};

	Parms.TabId = TabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction LyraGame.LyraTabListWidgetBase.OnTabContentCreated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonUserWidget*                TabWidget                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTabListWidgetBase::OnTabContentCreated__DelegateSignature(class FName TabId, class UCommonUserWidget* TabWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "OnTabContentCreated__DelegateSignature");

	Params::LyraTabListWidgetBase_OnTabContentCreated__DelegateSignature Parms{};

	Parms.TabId = TabId;
	Parms.TabWidget = TabWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraTabListWidgetBase.RegisterDynamicTab
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraTabDescriptor               TabDescriptor                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::RegisterDynamicTab(const struct FLyraTabDescriptor& TabDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "RegisterDynamicTab");

	Params::LyraTabListWidgetBase_RegisterDynamicTab Parms{};

	Parms.TabDescriptor = std::move(TabDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTabListWidgetBase.SetPreregisteredTabInfoLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TabNameID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTabListWidgetBase::SetPreregisteredTabInfoLock(const class FName TabNameID, bool IsLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "SetPreregisteredTabInfoLock");

	Params::LyraTabListWidgetBase_SetPreregisteredTabInfoLock Parms{};

	Parms.TabNameID = TabNameID;
	Parms.IsLock = IsLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTabListWidgetBase.SetTabHiddenState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TabNameID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTabListWidgetBase::SetTabHiddenState(class FName TabNameID, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "SetTabHiddenState");

	Params::LyraTabListWidgetBase_SetTabHiddenState Parms{};

	Parms.TabNameID = TabNameID;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTabListWidgetBase.IsFirstTabActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::IsFirstTabActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "IsFirstTabActive");

	Params::LyraTabListWidgetBase_IsFirstTabActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTabListWidgetBase.IsLastTabActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::IsLastTabActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "IsLastTabActive");

	Params::LyraTabListWidgetBase_IsLastTabActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.MaterialProgressBar.AnimateProgressFromCurrent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::AnimateProgressFromCurrent(float End, float AnimSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "AnimateProgressFromCurrent");

	Params::MaterialProgressBar_AnimateProgressFromCurrent Parms{};

	Parms.End = End;
	Parms.AnimSpeed = AnimSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.MaterialProgressBar.AnimateProgressFromStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::AnimateProgressFromStart(float Start, float End, float AnimSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "AnimateProgressFromStart");

	Params::MaterialProgressBar_AnimateProgressFromStart Parms{};

	Parms.Start = Start;
	Parms.End = End;
	Parms.AnimSpeed = AnimSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction LyraGame.MaterialProgressBar.OnFillAnimationFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UMaterialProgressBar::OnFillAnimationFinished__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "OnFillAnimationFinished__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.MaterialProgressBar.SetColorA
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ColorA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetColorA(const struct FLinearColor& ColorA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetColorA");

	Params::MaterialProgressBar_SetColorA Parms{};

	Parms.ColorA = std::move(ColorA);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.MaterialProgressBar.SetColorB
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ColorB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetColorB(const struct FLinearColor& ColorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetColorB");

	Params::MaterialProgressBar_SetColorB Parms{};

	Parms.ColorB = std::move(ColorB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.MaterialProgressBar.SetColorBackground
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ColorBackground                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetColorBackground(const struct FLinearColor& ColorBackground)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetColorBackground");

	Params::MaterialProgressBar_SetColorBackground Parms{};

	Parms.ColorBackground = std::move(ColorBackground);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.MaterialProgressBar.SetProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetProgress");

	Params::MaterialProgressBar_SetProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.MaterialProgressBar.SetStartProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetStartProgress(float StartProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetStartProgress");

	Params::MaterialProgressBar_SetStartProgress Parms{};

	Parms.StartProgress = StartProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAnimNotifyState_WeaponMaterialParameter.ElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Default                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAnimNotifyState_WeaponMaterialParameter::ElapsedTime(class USkeletalMeshComponent* MeshComp, float Default) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAnimNotifyState_WeaponMaterialParameter", "ElapsedTime");

	Params::TgfAnimNotifyState_WeaponMaterialParameter_ElapsedTime Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Default = Default;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAnimNotifyState_WeaponMaterialParameter.TotalTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Default                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAnimNotifyState_WeaponMaterialParameter::TotalTime(class USkeletalMeshComponent* MeshComp, float Default) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAnimNotifyState_WeaponMaterialParameter", "TotalTime");

	Params::TgfAnimNotifyState_WeaponMaterialParameter_TotalTime Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Default = Default;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraButtonBase.SetButtonText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraButtonBase::SetButtonText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraButtonBase", "SetButtonText");

	Params::LyraButtonBase_SetButtonText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraButtonBase.UpdateButtonStyle
// (Event, Protected, BlueprintEvent)

void ULyraButtonBase::UpdateButtonStyle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraButtonBase", "UpdateButtonStyle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraButtonBase.UpdateButtonText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraButtonBase::UpdateButtonText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraButtonBase", "UpdateButtonText");

	Params::LyraButtonBase_UpdateButtonText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraTabButtonBase.SetTabLabelInfo_Implementation
// (Native, Protected, HasOutParams)
// Parameters:
// struct FLyraTabDescriptor               TabLabelInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULyraTabButtonBase::SetTabLabelInfo_Implementation(const struct FLyraTabDescriptor& TabLabelInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabButtonBase", "SetTabLabelInfo_Implementation");

	Params::LyraTabButtonBase_SetTabLabelInfo_Implementation Parms{};

	Parms.TabLabelInfo = std::move(TabLabelInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentInstance.DecLoosePointOnDeath
// (Final, Native, Public, BlueprintCallable)

void UTgfEquipmentInstance::DecLoosePointOnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "DecLoosePointOnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentInstance.K2_OnSpawnedActors
// (Event, Public, BlueprintEvent)

void UTgfEquipmentInstance::K2_OnSpawnedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "K2_OnSpawnedActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfEquipmentInstance.K2_OnWeaponVisibleChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Visiblity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentInstance::K2_OnWeaponVisibleChanged(bool Visiblity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "K2_OnWeaponVisibleChanged");

	Params::TgfEquipmentInstance_K2_OnWeaponVisibleChanged Parms{};

	Parms.Visiblity = Visiblity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfEquipmentInstance.ModifiedDurabilityPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DeltaPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentInstance::ModifiedDurabilityPoint(int32 DeltaPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "ModifiedDurabilityPoint");

	Params::TgfEquipmentInstance_ModifiedDurabilityPoint Parms{};

	Parms.DeltaPoint = DeltaPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentInstance.OnRep_SpawnedActors
// (Final, Native, Protected)

void UTgfEquipmentInstance::OnRep_SpawnedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "OnRep_SpawnedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentInstance.OnRep_WeaponVisible
// (Final, Native, Protected)

void UTgfEquipmentInstance::OnRep_WeaponVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "OnRep_WeaponVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentInstance.RemoveGameplayEffectWithSourceObjectAndTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            TagContainer                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    CheckAnotherWeapon                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfEquipmentInstance::RemoveGameplayEffectWithSourceObjectAndTags(const struct FGameplayTagContainer& TagContainer, bool CheckAnotherWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "RemoveGameplayEffectWithSourceObjectAndTags");

	Params::TgfEquipmentInstance_RemoveGameplayEffectWithSourceObjectAndTags Parms{};

	Parms.TagContainer = std::move(TagContainer);
	Parms.CheckAnotherWeapon = CheckAnotherWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentInstance.SetWeaponVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentInstance::SetWeaponVisible(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "SetWeaponVisible");

	Params::TgfEquipmentInstance_SetWeaponVisible Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentInstance.SpawnEquipmentActorsWithAttachTarget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USceneComponent*                  AttachTarget                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutSpawnedActors                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfEquipmentInstance::SpawnEquipmentActorsWithAttachTarget(class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "SpawnEquipmentActorsWithAttachTarget");

	Params::TgfEquipmentInstance_SpawnEquipmentActorsWithAttachTarget Parms{};

	Parms.AttachTarget = AttachTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnedActors != nullptr)
		*OutSpawnedActors = std::move(Parms.OutSpawnedActors);
}


// Function LyraGame.TgfEquipmentInstance.GetDurabilityPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfEquipmentInstance::GetDurabilityPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "GetDurabilityPoint");

	Params::TgfEquipmentInstance_GetDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentInstance.GetSpawnedActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTgfEquipmentInstance::GetSpawnedActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "GetSpawnedActors");

	Params::TgfEquipmentInstance_GetSpawnedActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentInstance.GetWeaponVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentInstance::GetWeaponVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "GetWeaponVisible");

	Params::TgfEquipmentInstance_GetWeaponVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentInstance.HasDurabilityPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentInstance::HasDurabilityPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentInstance", "HasDurabilityPoint");

	Params::TgfEquipmentInstance_HasDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttachedAnimInstance.GetAttachedParentAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UTgfAttachedAnimInstance::GetAttachedParentAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttachedAnimInstance", "GetAttachedParentAnimInstance");

	Params::TgfAttachedAnimInstance_GetAttachedParentAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttachedAnimInstance.GetAttachedParentCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UTgfAttachedAnimInstance::GetAttachedParentCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttachedAnimInstance", "GetAttachedParentCharacter");

	Params::TgfAttachedAnimInstance_GetAttachedParentCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttachedAnimInstance.IsOnDedicatedServer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttachedAnimInstance::IsOnDedicatedServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttachedAnimInstance", "IsOnDedicatedServer");

	Params::TgfAttachedAnimInstance_IsOnDedicatedServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSimulatedInputWidget.FlushSimulatedInput
// (Final, Native, Public, BlueprintCallable)

void ULyraSimulatedInputWidget::FlushSimulatedInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "FlushSimulatedInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSimulatedInputWidget.InputKeyValue
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSimulatedInputWidget::InputKeyValue(const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "InputKeyValue");

	Params::LyraSimulatedInputWidget_InputKeyValue Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSimulatedInputWidget.InputKeyValue2D
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSimulatedInputWidget::InputKeyValue2D(const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "InputKeyValue2D");

	Params::LyraSimulatedInputWidget_InputKeyValue2D Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSimulatedInputWidget.GetAssociatedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* ULyraSimulatedInputWidget::GetAssociatedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "GetAssociatedAction");

	Params::LyraSimulatedInputWidget_GetAssociatedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSimulatedInputWidget.GetEnhancedInputSubsystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEnhancedInputLocalPlayerSubsystem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnhancedInputLocalPlayerSubsystem* ULyraSimulatedInputWidget::GetEnhancedInputSubsystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "GetEnhancedInputSubsystem");

	Params::LyraSimulatedInputWidget_GetEnhancedInputSubsystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSimulatedInputWidget.GetSimulatedKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey ULyraSimulatedInputWidget::GetSimulatedKey() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "GetSimulatedKey");

	Params::LyraSimulatedInputWidget_GetSimulatedKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAuraManagerComponent.AddGameplayAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfGameplayAura>     AuraClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfActiveGameplayAuraHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfActiveGameplayAuraHandle UTgfAuraManagerComponent::AddGameplayAura(TSubclassOf<class UTgfGameplayAura> AuraClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "AddGameplayAura");

	Params::TgfAuraManagerComponent_AddGameplayAura Parms{};

	Parms.AuraClass = AuraClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAuraManagerComponent.AddGameplayAuraWithSourceCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfGameplayAura>     AuraClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfActiveGameplayAuraHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfActiveGameplayAuraHandle UTgfAuraManagerComponent::AddGameplayAuraWithSourceCharacter(TSubclassOf<class UTgfGameplayAura> AuraClass, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "AddGameplayAuraWithSourceCharacter");

	Params::TgfAuraManagerComponent_AddGameplayAuraWithSourceCharacter Parms{};

	Parms.AuraClass = AuraClass;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAuraManagerComponent.GetActiveAuraByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfGameplayAura>     AuraClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfGameplayAura*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfGameplayAura* UTgfAuraManagerComponent::GetActiveAuraByClass(TSubclassOf<class UTgfGameplayAura> AuraClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "GetActiveAuraByClass");

	Params::TgfAuraManagerComponent_GetActiveAuraByClass Parms{};

	Parms.AuraClass = AuraClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAuraManagerComponent.HandleInstigatorDeath
// (Final, Native, Private)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::HandleInstigatorDeath(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "HandleInstigatorDeath");

	Params::TgfAuraManagerComponent_HandleInstigatorDeath Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAuraManagerComponent.HandleInstigatorEscape
// (Final, Native, Private)
// Parameters:
// class APawn*                            OwingPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaiting                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::HandleInstigatorEscape(class APawn* OwingPawn, bool bWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "HandleInstigatorEscape");

	Params::TgfAuraManagerComponent_HandleInstigatorEscape Parms{};

	Parms.OwingPawn = OwingPawn;
	Parms.bWaiting = bWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAuraManagerComponent.HandleInstigatorRebirth
// (Final, Native, Private)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::HandleInstigatorRebirth(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "HandleInstigatorRebirth");

	Params::TgfAuraManagerComponent_HandleInstigatorRebirth Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAuraManagerComponent.RemoveGameplayAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfGameplayAura*                 GameplayAura                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::RemoveGameplayAura(class UTgfGameplayAura* GameplayAura)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "RemoveGameplayAura");

	Params::TgfAuraManagerComponent_RemoveGameplayAura Parms{};

	Parms.GameplayAura = GameplayAura;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAuraManagerComponent.RemoveGameplayAuraByHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfActiveGameplayAuraHandle     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::RemoveGameplayAuraByHandle(const struct FTgfActiveGameplayAuraHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "RemoveGameplayAuraByHandle");

	Params::TgfAuraManagerComponent_RemoveGameplayAuraByHandle Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAuraManagerComponent.RemoveGameplayAuraBySourceAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfGameplayAura>     AuraClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::RemoveGameplayAuraBySourceAura(TSubclassOf<class UTgfGameplayAura> AuraClass, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "RemoveGameplayAuraBySourceAura");

	Params::TgfAuraManagerComponent_RemoveGameplayAuraBySourceAura Parms{};

	Parms.AuraClass = AuraClass;
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAuraManagerComponent.RemoveGameplayAuraWithAppliedTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)

void UTgfAuraManagerComponent::RemoveGameplayAuraWithAppliedTags(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAuraManagerComponent", "RemoveGameplayAuraWithAppliedTags");

	Params::TgfAuraManagerComponent_RemoveGameplayAuraWithAppliedTags Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTaggedActor.IsAttachedFirstPersonCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraTaggedActor::IsAttachedFirstPersonCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTaggedActor", "IsAttachedFirstPersonCharacter");

	Params::LyraTaggedActor_IsAttachedFirstPersonCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.BuildAvatarMeshForExternalUse
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class USkeletalMesh*>            OutMeshesToAppend                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* ATgfAvatarActor::BuildAvatarMeshForExternalUse(const struct FGameplayTagContainer& CosmeticTags, TArray<class USkeletalMesh*>* OutMeshesToAppend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "BuildAvatarMeshForExternalUse");

	Params::TgfAvatarActor_BuildAvatarMeshForExternalUse Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshesToAppend != nullptr)
		*OutMeshesToAppend = std::move(Parms.OutMeshesToAppend);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.ClearAllAttachmentActors
// (Final, Native, Public, BlueprintCallable)

void ATgfAvatarActor::ClearAllAttachmentActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "ClearAllAttachmentActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.ClearAllSkin
// (Final, Native, Public, BlueprintCallable)

void ATgfAvatarActor::ClearAllSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "ClearAllSkin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.ClearAvatarSkinMesh
// (Final, Native, Public, BlueprintCallable)

void ATgfAvatarActor::ClearAvatarSkinMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "ClearAvatarSkinMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.DisableSubMeshClothSimulation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::DisableSubMeshClothSimulation(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "DisableSubMeshClothSimulation");

	Params::TgfAvatarActor_DisableSubMeshClothSimulation Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.ForceThirdPerson
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bThirdPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::ForceThirdPerson(bool bThirdPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "ForceThirdPerson");

	Params::TgfAvatarActor_ForceThirdPerson Parms{};

	Parms.bThirdPerson = bThirdPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.GetAllAttachmentActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   OutSpawnedActors                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ATgfAvatarActor::GetAllAttachmentActors(TArray<class AActor*>* OutSpawnedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetAllAttachmentActors");

	Params::TgfAvatarActor_GetAllAttachmentActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnedActors != nullptr)
		*OutSpawnedActors = std::move(Parms.OutSpawnedActors);
}


// Function LyraGame.TgfAvatarActor.GetAllSkinIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> ATgfAvatarActor::GetAllSkinIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetAllSkinIDs");

	Params::TgfAvatarActor_GetAllSkinIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.GetAvatarGender
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorGender                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorGender ATgfAvatarActor::GetAvatarGender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetAvatarGender");

	Params::TgfAvatarActor_GetAvatarGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.GetAvatarRace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorRace                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorRace ATgfAvatarActor::GetAvatarRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetAvatarRace");

	Params::TgfAvatarActor_GetAvatarRace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.GetFaceConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfHeadResConfig                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfHeadResConfig ATgfAvatarActor::GetFaceConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetFaceConfig");

	Params::TgfAvatarActor_GetFaceConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.GetInventoryAvatar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATgfAvatarActor*                  InventoryAvatar                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::GetInventoryAvatar(class ATgfAvatarActor* InventoryAvatar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetInventoryAvatar");

	Params::TgfAvatarActor_GetInventoryAvatar Parms{};

	Parms.InventoryAvatar = InventoryAvatar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.GetIsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfAvatarActor::GetIsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetIsActive");

	Params::TgfAvatarActor_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.GetIsMainAvatar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfAvatarActor::GetIsMainAvatar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "GetIsMainAvatar");

	Params::TgfAvatarActor_GetIsMainAvatar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.OnUpdateAvatarDataMesh
// (Event, Public, BlueprintEvent)
// Parameters:
// ETgfActorGender                         Gender                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::OnUpdateAvatarDataMesh(ETgfActorGender Gender, ETgfActorRace Race)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "OnUpdateAvatarDataMesh");

	Params::TgfAvatarActor_OnUpdateAvatarDataMesh Parms{};

	Parms.Gender = Gender;
	Parms.Race = Race;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfAvatarActor.RemoveSkinMeshIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfSkinSlot                            Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::RemoveSkinMeshIDs(ETgfSkinSlot Slot, int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "RemoveSkinMeshIDs");

	Params::TgfAvatarActor_RemoveSkinMeshIDs Parms{};

	Parms.Slot = Slot;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetActive(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetActive");

	Params::TgfAvatarActor_SetActive Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetAllSkinIdMeshIdsAndHelmetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           SkinIds                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    HelmetVisible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetAllSkinIdMeshIdsAndHelmetVisible(const TArray<int32>& SkinIds, bool HelmetVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetAllSkinIdMeshIdsAndHelmetVisible");

	Params::TgfAvatarActor_SetAllSkinIdMeshIdsAndHelmetVisible Parms{};

	Parms.SkinIds = std::move(SkinIds);
	Parms.HelmetVisible = HelmetVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetAnimTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVisibilityBasedAnimTickOption          Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetAnimTick(EVisibilityBasedAnimTickOption Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetAnimTick");

	Params::TgfAvatarActor_SetAnimTick Parms{};

	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetAvatarGender
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorGender                         Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetAvatarGender(ETgfActorGender Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetAvatarGender");

	Params::TgfAvatarActor_SetAvatarGender Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetAvatarRace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorRace                           Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetAvatarRace(ETgfActorRace Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetAvatarRace");

	Params::TgfAvatarActor_SetAvatarRace Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetAvatarSkinMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTgfCharaPartChangeConfig>InAttachmentMeshParts                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfAvatarActor::SetAvatarSkinMesh(const TArray<struct FTgfCharaPartChangeConfig>& InAttachmentMeshParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetAvatarSkinMesh");

	Params::TgfAvatarActor_SetAvatarSkinMesh Parms{};

	Parms.InAttachmentMeshParts = std::move(InAttachmentMeshParts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.SetEquipmentAttachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FTgfCharaPartSpawnActor>  SpawnActorsInfo                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetEquipmentAttachment(const TArray<struct FTgfCharaPartSpawnActor>& SpawnActorsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetEquipmentAttachment");

	Params::TgfAvatarActor_SetEquipmentAttachment Parms{};

	Parms.SpawnActorsInfo = std::move(SpawnActorsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetFaceConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfHeadResConfig                Data                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetFaceConfig(const struct FTgfHeadResConfig& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetFaceConfig");

	Params::TgfAvatarActor_SetFaceConfig Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetIsMainAvatar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetIsMainAvatar(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetIsMainAvatar");

	Params::TgfAvatarActor_SetIsMainAvatar Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetLobbyActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SetLobbyActor(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetLobbyActor");

	Params::TgfAvatarActor_SetLobbyActor Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.SetOverrideAvatarMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTgfCharaPartChangeConfig>InOverrideMeshParts                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfAvatarActor::SetOverrideAvatarMesh(const TArray<struct FTgfCharaPartChangeConfig>& InOverrideMeshParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetOverrideAvatarMesh");

	Params::TgfAvatarActor_SetOverrideAvatarMesh Parms{};

	Parms.InOverrideMeshParts = std::move(InOverrideMeshParts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.SetSkinMeshForce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreTypeCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfSkinSlot                            SlotAlternative                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>Definition                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfAvatarActor::SetSkinMeshForce(int32 Type_id, bool IgnoreTypeCheck, ETgfSkinSlot SlotAlternative, TSubclassOf<class ULyraInventoryItemDefinition> Definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SetSkinMeshForce");

	Params::TgfAvatarActor_SetSkinMeshForce Parms{};

	Parms.Type_id = Type_id;
	Parms.IgnoreTypeCheck = IgnoreTypeCheck;
	Parms.SlotAlternative = SlotAlternative;
	Parms.Definition = Definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAvatarActor.SwitchSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               SkinMat                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::SwitchSkin(class UMaterialInterface* SkinMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "SwitchSkin");

	Params::TgfAvatarActor_SwitchSkin Parms{};

	Parms.SkinMat = SkinMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.ToggleBaseMeshForBodyPart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharaPart                           Part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseMeshVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::ToggleBaseMeshForBodyPart(ETgfCharaPart Part, bool bBaseMeshVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "ToggleBaseMeshForBodyPart");

	Params::TgfAvatarActor_ToggleBaseMeshForBodyPart Parms{};

	Parms.Part = Part;
	Parms.bBaseMeshVisible = bBaseMeshVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.ToggleSubMeshPostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)

void ATgfAvatarActor::ToggleSubMeshPostProcessBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "ToggleSubMeshPostProcessBlueprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.UpdateMesh
// (Final, Native, Public, BlueprintCallable)

void ATgfAvatarActor::UpdateMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "UpdateMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.UpdateMeshMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MorphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfAvatarActor::UpdateMeshMorphTarget(class FName MorphName, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "UpdateMeshMorphTarget");

	Params::TgfAvatarActor_UpdateMeshMorphTarget Parms{};

	Parms.MorphName = MorphName;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarActor.UpdatePhysics
// (Final, Native, Public, BlueprintCallable)

void ATgfAvatarActor::UpdatePhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarActor", "UpdatePhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarHelperComponent.CopyDataFromAvatar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATgfAvatarActor*                  Avatar                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAvatarHelperComponent::CopyDataFromAvatar(class ATgfAvatarActor* Avatar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarHelperComponent", "CopyDataFromAvatar");

	Params::TgfAvatarHelperComponent_CopyDataFromAvatar Parms{};

	Parms.Avatar = Avatar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarHelperComponent.OnRep_AvatarGender
// (Native, Public)

void UTgfAvatarHelperComponent::OnRep_AvatarGender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarHelperComponent", "OnRep_AvatarGender");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarHelperComponent.OnRep_AvatarHeadConfig
// (Native, Public)

void UTgfAvatarHelperComponent::OnRep_AvatarHeadConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarHelperComponent", "OnRep_AvatarHeadConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarHelperComponent.OnRep_LinkAnimLayer
// (Final, Native, Protected)

void UTgfAvatarHelperComponent::OnRep_LinkAnimLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarHelperComponent", "OnRep_LinkAnimLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarHelperComponent.OnRep_MeshParts
// (Native, Public)

void UTgfAvatarHelperComponent::OnRep_MeshParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarHelperComponent", "OnRep_MeshParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAvatarHelperComponent.CopyDataToAvatar
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class ATgfAvatarActor*                  Avatar                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAvatarHelperComponent::CopyDataToAvatar(class ATgfAvatarActor* Avatar) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAvatarHelperComponent", "CopyDataToAvatar");

	Params::TgfAvatarHelperComponent_CopyDataToAvatar Parms{};

	Parms.Avatar = Avatar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBattleEleResistanceDataAsset.GetConfigElementResistanceRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfBattleElement                       AttackElement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfBattleElement                       DefendElement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBattleEleResistanceDataAsset::GetConfigElementResistanceRate(ETgfBattleElement AttackElement, ETgfBattleElement DefendElement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBattleEleResistanceDataAsset", "GetConfigElementResistanceRate");

	Params::TgfBattleEleResistanceDataAsset_GetConfigElementResistanceRate Parms{};

	Parms.AttackElement = AttackElement;
	Parms.DefendElement = DefendElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.CircumferenceMarkerWidget.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCircumferenceMarkerWidget::SetRadius(float InRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircumferenceMarkerWidget", "SetRadius");

	Params::CircumferenceMarkerWidget_SetRadius Parms{};

	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.EnumUtils.GetAnotherSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UEnumUtils::GetAnotherSlot(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "GetAnotherSlot");

	Params::EnumUtils_GetAnotherSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsAdditionalWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsAdditionalWeapon(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsAdditionalWeapon");

	Params::EnumUtils_IsAdditionalWeapon Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsBossMonster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsBossMonster(ETgfActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsBossMonster");

	Params::EnumUtils_IsBossMonster Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsBotPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsBotPlayer(ETgfActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsBotPlayer");

	Params::EnumUtils_IsBotPlayer Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsCurrentWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ChangeSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsCurrentWeapon(ETgfEquipSlot Slot, ETgfWeaponChangeSlot ChangeSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsCurrentWeapon");

	Params::EnumUtils_IsCurrentWeapon Parms{};

	Parms.Slot = Slot;
	Parms.ChangeSlot = ChangeSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsEliteMonster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsEliteMonster(ETgfActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsEliteMonster");

	Params::EnumUtils_IsEliteMonster Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsLeftHandWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsLeftHandWeapon(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsLeftHandWeapon");

	Params::EnumUtils_IsLeftHandWeapon Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsMatchSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponEquipType                     EquipType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanEquipDouble                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsMatchSlot(ETgfEquipSlot Slot, ETgfWeaponEquipType EquipType, bool CanEquipDouble)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsMatchSlot");

	Params::EnumUtils_IsMatchSlot Parms{};

	Parms.Slot = Slot;
	Parms.EquipType = EquipType;
	Parms.CanEquipDouble = CanEquipDouble;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsMonster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsMonster(ETgfActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsMonster");

	Params::EnumUtils_IsMonster Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsPlayer(ETgfActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsPlayer");

	Params::EnumUtils_IsPlayer Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsRightHandWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedConsumable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsRightHandWeapon(ETgfEquipSlot Slot, bool NeedConsumable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsRightHandWeapon");

	Params::EnumUtils_IsRightHandWeapon Parms{};

	Parms.Slot = Slot;
	Parms.NeedConsumable = NeedConsumable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsSummonActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsSummonActor(ETgfActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsSummonActor");

	Params::EnumUtils_IsSummonActor Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsWeapon(ETgfEquipSlot Slot, bool OnlyBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsWeapon");

	Params::EnumUtils_IsWeapon Parms{};

	Parms.Slot = Slot;
	Parms.OnlyBase = OnlyBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.IsWeaponChangeSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfWeaponChangeSlot                    ChangeSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::IsWeaponChangeSlot(ETgfWeaponChangeSlot ChangeSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "IsWeaponChangeSlot");

	Params::EnumUtils_IsWeaponChangeSlot Parms{};

	Parms.ChangeSlot = ChangeSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.NeedLeftHand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfWeaponEquipType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::NeedLeftHand(ETgfWeaponEquipType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "NeedLeftHand");

	Params::EnumUtils_NeedLeftHand Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.NeedRightHand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfWeaponEquipType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::NeedRightHand(ETgfWeaponEquipType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "NeedRightHand");

	Params::EnumUtils_NeedRightHand Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.Parse3ValIntFromFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEnumUtils::Parse3ValIntFromFloat(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "Parse3ValIntFromFloat");

	Params::EnumUtils_Parse3ValIntFromFloat Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseAttackTypeFromFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfUseAttackType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfUseAttackType UEnumUtils::ParseAttackTypeFromFloat(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseAttackTypeFromFloat");

	Params::EnumUtils_ParseAttackTypeFromFloat Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseBattleElementTagFromEnum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfBattleElement                       BattleElement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UEnumUtils::ParseBattleElementTagFromEnum(ETgfBattleElement BattleElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseBattleElementTagFromEnum");

	Params::EnumUtils_ParseBattleElementTagFromEnum Parms{};

	Parms.BattleElement = BattleElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseBoolFromFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnumUtils::ParseBoolFromFloat(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseBoolFromFloat");

	Params::EnumUtils_ParseBoolFromFloat Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseDamageBattleElementTagFromEnum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfBattleElement                       BattleElement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UEnumUtils::ParseDamageBattleElementTagFromEnum(ETgfBattleElement BattleElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseDamageBattleElementTagFromEnum");

	Params::EnumUtils_ParseDamageBattleElementTagFromEnum Parms{};

	Parms.BattleElement = BattleElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseElementFromFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfBattleElement                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfBattleElement UEnumUtils::ParseElementFromFloat(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseElementFromFloat");

	Params::EnumUtils_ParseElementFromFloat Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseLeftHandWeaponSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UEnumUtils::ParseLeftHandWeaponSlot(ETgfWeaponChangeSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseLeftHandWeaponSlot");

	Params::EnumUtils_ParseLeftHandWeaponSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseRightHandWeaponSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UEnumUtils::ParseRightHandWeaponSlot(ETgfWeaponChangeSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseRightHandWeaponSlot");

	Params::EnumUtils_ParseRightHandWeaponSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseWeaponSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UEnumUtils::ParseWeaponSlot(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseWeaponSlot");

	Params::EnumUtils_ParseWeaponSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.EnumUtils.ParseWeaponSlotToEquipSlotExtra
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UEnumUtils::ParseWeaponSlotToEquipSlotExtra(ETgfWeaponChangeSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnumUtils", "ParseWeaponSlotToEquipSlotExtra");

	Params::EnumUtils_ParseWeaponSlotToEquipSlotExtra Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.ApplyDisplayGamma
// (Final, Native, Static, Public, BlueprintCallable)

void UTgfBlueprintFunctionLibrary::ApplyDisplayGamma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "ApplyDisplayGamma");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.BlendFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   CurValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBlendingUtilParamsCache         CachedParams                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::BlendFloat(float CurValue, float TargetValue, float DeltaTime, float TotalTime, struct FBlendingUtilParamsCache& CachedParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "BlendFloat");

	Params::TgfBlueprintFunctionLibrary_BlendFloat Parms{};

	Parms.CurValue = CurValue;
	Parms.TargetValue = TargetValue;
	Parms.DeltaTime = DeltaTime;
	Parms.TotalTime = TotalTime;
	Parms.CachedParams = std::move(CachedParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CachedParams = std::move(Parms.CachedParams);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.BoxOverlapActorsWithRot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rot                                                    (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::BoxOverlapActorsWithRot(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FQuat& Rot, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "BoxOverlapActorsWithRot");

	Params::TgfBlueprintFunctionLibrary_BoxOverlapActorsWithRot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.Rot = std::move(Rot);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.BoxOverlapComponentsWithRot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rot                                                    (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::BoxOverlapComponentsWithRot(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, const struct FQuat& Rot, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "BoxOverlapComponentsWithRot");

	Params::TgfBlueprintFunctionLibrary_BoxOverlapComponentsWithRot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.Extent = std::move(Extent);
	Parms.Rot = std::move(Rot);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.CalcItemScreenSizeByViewTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ViewPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ItemPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ItemExtent                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InViewTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::CalcItemScreenSizeByViewTarget(const struct FVector& ViewPos, const struct FVector& ItemPos, const struct FVector& ItemExtent, class AActor* InViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "CalcItemScreenSizeByViewTarget");

	Params::TgfBlueprintFunctionLibrary_CalcItemScreenSizeByViewTarget Parms{};

	Parms.ViewPos = std::move(ViewPos);
	Parms.ItemPos = std::move(ItemPos);
	Parms.ItemExtent = std::move(ItemExtent);
	Parms.InViewTarget = InViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.CheckCurrentWeaponSlotType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::CheckCurrentWeaponSlotType(class ALyraCharacter* Character, ETgfWeaponChangeSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "CheckCurrentWeaponSlotType");

	Params::TgfBlueprintFunctionLibrary_CheckCurrentWeaponSlotType Parms{};

	Parms.Character = Character;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.ClassicSpeedDamping
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpeedDampingParams              DampingParams                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::ClassicSpeedDamping(float Current, float DeltaTime, struct FSpeedDampingParams& DampingParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "ClassicSpeedDamping");

	Params::TgfBlueprintFunctionLibrary_ClassicSpeedDamping Parms{};

	Parms.Current = Current;
	Parms.DeltaTime = DeltaTime;
	Parms.DampingParams = std::move(DampingParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DampingParams = std::move(Parms.DampingParams);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.DestroyChildActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ChildType                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::DestroyChildActor(class AActor* Parent, TSubclassOf<class AActor> ChildType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "DestroyChildActor");

	Params::TgfBlueprintFunctionLibrary_DestroyChildActor Parms{};

	Parms.Parent = Parent;
	Parms.ChildType = ChildType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.EvaluateCurve
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRuntimeFloatCurve               Curve                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::EvaluateCurve(const struct FRuntimeFloatCurve& Curve, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "EvaluateCurve");

	Params::TgfBlueprintFunctionLibrary_EvaluateCurve Parms{};

	Parms.Curve = std::move(Curve);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.EvaluateCurveMapping
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRuntimeFloatCurve               Curve                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MappingDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::EvaluateCurveMapping(const struct FRuntimeFloatCurve& Curve, float Time, float MappingDuration, float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "EvaluateCurveMapping");

	Params::TgfBlueprintFunctionLibrary_EvaluateCurveMapping Parms{};

	Parms.Curve = std::move(Curve);
	Parms.Time = Time;
	Parms.MappingDuration = MappingDuration;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.FindUnoccupiedLocationForSpawn
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TestLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TestRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          PlaceLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::FindUnoccupiedLocationForSpawn(const class AActor* WorldContext, TSubclassOf<class AActor> ActorClass, const struct FVector& TestLocation, const struct FRotator& TestRotation, struct FVector* PlaceLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "FindUnoccupiedLocationForSpawn");

	Params::TgfBlueprintFunctionLibrary_FindUnoccupiedLocationForSpawn Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ActorClass = ActorClass;
	Parms.TestLocation = std::move(TestLocation);
	Parms.TestRotation = std::move(TestRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PlaceLocation != nullptr)
		*PlaceLocation = std::move(Parms.PlaceLocation);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.ForceDefaultGamma
// (Final, Native, Static, Public, BlueprintCallable)

void UTgfBlueprintFunctionLibrary::ForceDefaultGamma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "ForceDefaultGamma");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetAllBluePrintClassesOfPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             Path                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludingSubPath                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UClass*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UClass*> UTgfBlueprintFunctionLibrary::GetAllBluePrintClassesOfPath(class FName Path, bool IncludingSubPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetAllBluePrintClassesOfPath");

	Params::TgfBlueprintFunctionLibrary_GetAllBluePrintClassesOfPath Parms{};

	Parms.Path = Path;
	Parms.IncludingSubPath = IncludingSubPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetAngleBetweenTwoVectors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Lhs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Rhs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Signed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::GetAngleBetweenTwoVectors(const struct FVector& Lhs, const struct FVector& Rhs, bool Signed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetAngleBetweenTwoVectors");

	Params::TgfBlueprintFunctionLibrary_GetAngleBetweenTwoVectors Parms{};

	Parms.Lhs = std::move(Lhs);
	Parms.Rhs = std::move(Rhs);
	Parms.Signed = Signed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetAngleBetweenTwoVectors2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Lhs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Rhs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Signed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::GetAngleBetweenTwoVectors2D(const struct FVector& Lhs, const struct FVector& Rhs, bool Signed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetAngleBetweenTwoVectors2D");

	Params::TgfBlueprintFunctionLibrary_GetAngleBetweenTwoVectors2D Parms{};

	Parms.Lhs = std::move(Lhs);
	Parms.Rhs = std::move(Rhs);
	Parms.Signed = Signed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetAngleDirection8
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimConfigDirection8                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimConfigDirection8 UTgfBlueprintFunctionLibrary::GetAngleDirection8(const float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetAngleDirection8");

	Params::TgfBlueprintFunctionLibrary_GetAngleDirection8 Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetAngleDirection8_WithThreshold
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BackThreshold                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HorizThreshold                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FrontThreshold                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimConfigDirection8                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimConfigDirection8 UTgfBlueprintFunctionLibrary::GetAngleDirection8_WithThreshold(const float Angle, const float BackThreshold, const float HorizThreshold, const float FrontThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetAngleDirection8_WithThreshold");

	Params::TgfBlueprintFunctionLibrary_GetAngleDirection8_WithThreshold Parms{};

	Parms.Angle = Angle;
	Parms.BackThreshold = BackThreshold;
	Parms.HorizThreshold = HorizThreshold;
	Parms.FrontThreshold = FrontThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetAttachNiagaraComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        NiagaraSystems                                         (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::GetAttachNiagaraComponents(class AActor* Target, TArray<class UNiagaraComponent*>* NiagaraSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetAttachNiagaraComponents");

	Params::TgfBlueprintFunctionLibrary_GetAttachNiagaraComponents Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NiagaraSystems != nullptr)
		*NiagaraSystems = std::move(Parms.NiagaraSystems);
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetCharacterControlledRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UTgfBlueprintFunctionLibrary::GetCharacterControlledRotation(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetCharacterControlledRotation");

	Params::TgfBlueprintFunctionLibrary_GetCharacterControlledRotation Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetCurrentAcceleration
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCharacterMovementComponent*      MovementComponent                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTgfBlueprintFunctionLibrary::GetCurrentAcceleration(const class UCharacterMovementComponent* MovementComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetCurrentAcceleration");

	Params::TgfBlueprintFunctionLibrary_GetCurrentAcceleration Parms{};

	Parms.MovementComponent = MovementComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetDebugName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfBlueprintFunctionLibrary::GetDebugName(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetDebugName");

	Params::TgfBlueprintFunctionLibrary_GetDebugName Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetDeltaTimeInMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        EndTime                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        StartTime                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::GetDeltaTimeInMilliseconds(const struct FDateTime& EndTime, const struct FDateTime& StartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetDeltaTimeInMilliseconds");

	Params::TgfBlueprintFunctionLibrary_GetDeltaTimeInMilliseconds Parms{};

	Parms.EndTime = std::move(EndTime);
	Parms.StartTime = std::move(StartTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetEquipmentDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTgfEquipmentDefinition*    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTgfEquipmentDefinition* UTgfBlueprintFunctionLibrary::GetEquipmentDefinition(int32 TypeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetEquipmentDefinition");

	Params::TgfBlueprintFunctionLibrary_GetEquipmentDefinition Parms{};

	Parms.TypeId = TypeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetLocalViewTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfBlueprintFunctionLibrary::GetLocalViewTarget(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetLocalViewTarget");

	Params::TgfBlueprintFunctionLibrary_GetLocalViewTarget Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetMeshComponentsBound
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFromChildActors                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyCollidingComponents                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::GetMeshComponentsBound(class AActor* InActor, struct FVector* Origin, struct FVector* BoxExtent, bool bIncludeFromChildActors, bool bOnlyCollidingComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetMeshComponentsBound");

	Params::TgfBlueprintFunctionLibrary_GetMeshComponentsBound Parms{};

	Parms.InActor = InActor;
	Parms.bIncludeFromChildActors = bIncludeFromChildActors;
	Parms.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetPlayMontageDelayInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   DelayTime                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheck                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultInvalidValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::GetPlayMontageDelayInfo(float* DelayTime, const bool& bCheck, float DefaultInvalidValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetPlayMontageDelayInfo");

	Params::TgfBlueprintFunctionLibrary_GetPlayMontageDelayInfo Parms{};

	Parms.bCheck = bCheck;
	Parms.DefaultInvalidValue = DefaultInvalidValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DelayTime != nullptr)
		*DelayTime = Parms.DelayTime;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetRaceAvatarData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorRace                           Race                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightOffset                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTgfRaceAvatarBodyModifyDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTgfRaceAvatarBodyModifyData UTgfBlueprintFunctionLibrary::GetRaceAvatarData(ETgfActorRace Race, float* HeightOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetRaceAvatarData");

	Params::TgfBlueprintFunctionLibrary_GetRaceAvatarData Parms{};

	Parms.Race = Race;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HeightOffset != nullptr)
		*HeightOffset = Parms.HeightOffset;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetSpawnOffsetPos
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  OutOffsetPos                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           SrcActor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  SpawnOffset                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SpawnNum                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SourceOffset                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::GetSpawnOffsetPos(TArray<struct FVector>* OutOffsetPos, const class AActor* SrcActor, const TArray<struct FVector>& SpawnOffset, const int32 SpawnNum, const struct FVector& SourceOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetSpawnOffsetPos");

	Params::TgfBlueprintFunctionLibrary_GetSpawnOffsetPos Parms{};

	Parms.SrcActor = SrcActor;
	Parms.SpawnOffset = std::move(SpawnOffset);
	Parms.SpawnNum = SpawnNum;
	Parms.SourceOffset = std::move(SourceOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOffsetPos != nullptr)
		*OutOffsetPos = std::move(Parms.OutOffsetPos);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetUniqueHitResultsByActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FHitResult>               InHits                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::GetUniqueHitResultsByActor(const TArray<struct FHitResult>& InHits, TArray<struct FHitResult>* OutHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetUniqueHitResultsByActor");

	Params::TgfBlueprintFunctionLibrary_GetUniqueHitResultsByActor Parms{};

	Parms.InHits = std::move(InHits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetVectorDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Lhs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Rhs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::GetVectorDirection(const struct FVector& Lhs, const struct FVector& Rhs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetVectorDirection");

	Params::TgfBlueprintFunctionLibrary_GetVectorDirection Parms{};

	Parms.Lhs = std::move(Lhs);
	Parms.Rhs = std::move(Rhs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.GetWorldNameOfSpecificLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           InLevel                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfBlueprintFunctionLibrary::GetWorldNameOfSpecificLevel(class ULevel* InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "GetWorldNameOfSpecificLevel");

	Params::TgfBlueprintFunctionLibrary_GetWorldNameOfSpecificLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsActorCloser
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsActorCloser(const class AActor* ActorA, const class AActor* ActorB, const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsActorCloser");

	Params::TgfBlueprintFunctionLibrary_IsActorCloser Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;
	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsCharacterAttrGreater
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               Attribute                                              (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsCharacterAttrGreater(const class AActor* ActorA, const class AActor* ActorB, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsCharacterAttrGreater");

	Params::TgfBlueprintFunctionLibrary_IsCharacterAttrGreater Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsCharacterCloser
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsCharacterCloser(const class AActor* ActorA, const class AActor* ActorB, const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsCharacterCloser");

	Params::TgfBlueprintFunctionLibrary_IsCharacterCloser Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;
	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsCharacterHealthRatioHigher
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsCharacterHealthRatioHigher(const class AActor* ActorA, const class AActor* ActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsCharacterHealthRatioHigher");

	Params::TgfBlueprintFunctionLibrary_IsCharacterHealthRatioHigher Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsCharacterRight
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CenterPos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsCharacterRight(const class AActor* ActorA, const class AActor* ActorB, const struct FVector& CenterPos, const struct FVector& Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsCharacterRight");

	Params::TgfBlueprintFunctionLibrary_IsCharacterRight Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;
	Parms.CenterPos = std::move(CenterPos);
	Parms.Forward = std::move(Forward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsDevelopmentBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsDevelopmentBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsDevelopmentBuild");

	Params::TgfBlueprintFunctionLibrary_IsDevelopmentBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsOnDedicatedServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsOnDedicatedServer(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsOnDedicatedServer");

	Params::TgfBlueprintFunctionLibrary_IsOnDedicatedServer Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsPendingKillPending
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsPendingKillPending(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsPendingKillPending");

	Params::TgfBlueprintFunctionLibrary_IsPendingKillPending Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsRunningInPIE
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsRunningInPIE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsRunningInPIE");

	Params::TgfBlueprintFunctionLibrary_IsRunningInPIE Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            TagContainer                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBlueprintFunctionLibrary::IsValid(const struct FGameplayTagContainer& TagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "IsValid");

	Params::TgfBlueprintFunctionLibrary_IsValid Parms{};

	Parms.TagContainer = std::move(TagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.MakeAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfAxisName                            Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAxis                            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAxis UTgfBlueprintFunctionLibrary::MakeAxis(ETgfAxisName Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "MakeAxis");

	Params::TgfBlueprintFunctionLibrary_MakeAxis Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.MakeVectorFromAxis
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfAxisName                            Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTgfBlueprintFunctionLibrary::MakeVectorFromAxis(ETgfAxisName Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "MakeVectorFromAxis");

	Params::TgfBlueprintFunctionLibrary_MakeVectorFromAxis Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.PreparePhysicalMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTgfObjectListDataAsset*          ObjectListDataAsset                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::PreparePhysicalMaterials(const class UTgfObjectListDataAsset* ObjectListDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "PreparePhysicalMaterials");

	Params::TgfBlueprintFunctionLibrary_PreparePhysicalMaterials Parms{};

	Parms.ObjectListDataAsset = ObjectListDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.RequestRoleAppearanceTexture
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int64                                   RoleID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfAvatarBuildConfig            InAppearanceConfig                                     (Parm, NativeAccessSpecifierPublic)
// bool                                    NeedQueueFirst                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ImgSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::RequestRoleAppearanceTexture(int64 RoleID, const struct FTgfAvatarBuildConfig& InAppearanceConfig, bool NeedQueueFirst, const struct FVector2D& ImgSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "RequestRoleAppearanceTexture");

	Params::TgfBlueprintFunctionLibrary_RequestRoleAppearanceTexture Parms{};

	Parms.RoleID = RoleID;
	Parms.InAppearanceConfig = std::move(InAppearanceConfig);
	Parms.NeedQueueFirst = NeedQueueFirst;
	Parms.ImgSize = std::move(ImgSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.ReregisterActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::ReregisterActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "ReregisterActor");

	Params::TgfBlueprintFunctionLibrary_ReregisterActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.ResetBlendFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBlendingUtilParamsCache         CachedParams                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::ResetBlendFloat(struct FBlendingUtilParamsCache& CachedParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "ResetBlendFloat");

	Params::TgfBlueprintFunctionLibrary_ResetBlendFloat Parms{};

	Parms.CachedParams = std::move(CachedParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CachedParams = std::move(Parms.CachedParams);
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SetActorCustomStencilValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfStencilRef                          StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::SetActorCustomStencilValue(class AActor* TargetActor, ETgfStencilRef StencilValue, bool bSet, class UPrimitiveComponent* TargetMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SetActorCustomStencilValue");

	Params::TgfBlueprintFunctionLibrary_SetActorCustomStencilValue Parms{};

	Parms.TargetActor = TargetActor;
	Parms.StencilValue = StencilValue;
	Parms.bSet = bSet;
	Parms.TargetMesh = TargetMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SetCharacterWeaponMaterialParameter_Float
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Param_Name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponHandType                      Hand                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::SetCharacterWeaponMaterialParameter_Float(class ACharacter* Character, class FName Param_Name, float Value, ETgfWeaponHandType Hand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SetCharacterWeaponMaterialParameter_Float");

	Params::TgfBlueprintFunctionLibrary_SetCharacterWeaponMaterialParameter_Float Parms{};

	Parms.Character = Character;
	Parms.Param_Name = Param_Name;
	Parms.Value = Value;
	Parms.Hand = Hand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SetCustomStencilValueSingleBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfStencilRef                          StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::SetCustomStencilValueSingleBit(class UPrimitiveComponent* Mesh, ETgfStencilRef StencilValue, bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SetCustomStencilValueSingleBit");

	Params::TgfBlueprintFunctionLibrary_SetCustomStencilValueSingleBit Parms{};

	Parms.Mesh = Mesh;
	Parms.StencilValue = StencilValue;
	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SetWorldPhysicsSimulationEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::SetWorldPhysicsSimulationEnabled(class AActor* Actor, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SetWorldPhysicsSimulationEnabled");

	Params::TgfBlueprintFunctionLibrary_SetWorldPhysicsSimulationEnabled Parms{};

	Parms.Actor = Actor;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SortActorsByAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          CenterPos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsReverse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTgfBlueprintFunctionLibrary::SortActorsByAngle(TArray<class AActor*>& Actors, const struct FVector& CenterPos, const struct FVector& Forward, bool bIsReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SortActorsByAngle");

	Params::TgfBlueprintFunctionLibrary_SortActorsByAngle Parms{};

	Parms.Actors = std::move(Actors);
	Parms.CenterPos = std::move(CenterPos);
	Parms.Forward = std::move(Forward);
	Parms.bIsReverse = bIsReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SortActorsByAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               Attribute                                              (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsReverse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTgfBlueprintFunctionLibrary::SortActorsByAttribute(TArray<class AActor*>& Actors, const struct FGameplayAttribute& Attribute, bool bIsReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SortActorsByAttribute");

	Params::TgfBlueprintFunctionLibrary_SortActorsByAttribute Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Attribute = std::move(Attribute);
	Parms.bIsReverse = bIsReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SortActorsByDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsReverse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTgfBlueprintFunctionLibrary::SortActorsByDistance(TArray<class AActor*>& Actors, const struct FVector& Pos, bool bIsReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SortActorsByDistance");

	Params::TgfBlueprintFunctionLibrary_SortActorsByDistance Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Pos = std::move(Pos);
	Parms.bIsReverse = bIsReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SortActorsByHealthRatio
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsReverse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTgfBlueprintFunctionLibrary::SortActorsByHealthRatio(TArray<class AActor*>& Actors, bool bIsReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SortActorsByHealthRatio");

	Params::TgfBlueprintFunctionLibrary_SortActorsByHealthRatio Parms{};

	Parms.Actors = std::move(Actors);
	Parms.bIsReverse = bIsReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Actors = std::move(Parms.Actors);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SpawnDecalFromAbility
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnCenter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpawnRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EPhysicalSurface>                SurfaceTypes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     GECH                                                   (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::SpawnDecalFromAbility(class AActor* Instigator, const struct FVector& SpawnCenter, float SpawnRadius, const TArray<EObjectTypeQuery>& ObjectTypes, const TArray<EPhysicalSurface>& SurfaceTypes, const struct FGameplayEffectContextHandle& GECH, const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SpawnDecalFromAbility");

	Params::TgfBlueprintFunctionLibrary_SpawnDecalFromAbility Parms{};

	Parms.Instigator = Instigator;
	Parms.SpawnCenter = std::move(SpawnCenter);
	Parms.SpawnRadius = SpawnRadius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.SurfaceTypes = std::move(SurfaceTypes);
	Parms.GECH = std::move(GECH);
	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SpawnEquipmentActorsWithAttachTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Type_id                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachTarget                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutSpawnedActors                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAttachToLeft                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::SpawnEquipmentActorsWithAttachTarget(int32 Type_id, class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors, bool bAttachToLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SpawnEquipmentActorsWithAttachTarget");

	Params::TgfBlueprintFunctionLibrary_SpawnEquipmentActorsWithAttachTarget Parms{};

	Parms.Type_id = Type_id;
	Parms.AttachTarget = AttachTarget;
	Parms.bAttachToLeft = bAttachToLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnedActors != nullptr)
		*OutSpawnedActors = std::move(Parms.OutSpawnedActors);
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SpringFloatBlendAssist
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloatSpringState                State                                                  (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::SpringFloatBlendAssist(float Current, float Target, struct FFloatSpringState& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SpringFloatBlendAssist");

	Params::TgfBlueprintFunctionLibrary_SpringFloatBlendAssist Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	State = std::move(Parms.State);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.SpringFloatSpeed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFloatSpringState                State                                                  (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBlueprintFunctionLibrary::SpringFloatSpeed(struct FFloatSpringState& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "SpringFloatSpeed");

	Params::TgfBlueprintFunctionLibrary_SpringFloatSpeed Parms{};

	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	State = std::move(Parms.State);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.StopAllMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::StopAllMontage(class UAnimInstance* AnimInstance, float BlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "StopAllMontage");

	Params::TgfBlueprintFunctionLibrary_StopAllMontage Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.BlendOutTime = BlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBlueprintFunctionLibrary.TGFEasilyGetItemById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       OutEquipment                                           (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class USkeletalMesh*>            OutSkinParts                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotatar                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::TGFEasilyGetItemById(int32 SkinId, TArray<TSubclassOf<class AActor>>* OutEquipment, TArray<class USkeletalMesh*>* OutSkinParts, struct FRotator* OutRotatar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "TGFEasilyGetItemById");

	Params::TgfBlueprintFunctionLibrary_TGFEasilyGetItemById Parms{};

	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEquipment != nullptr)
		*OutEquipment = std::move(Parms.OutEquipment);

	if (OutSkinParts != nullptr)
		*OutSkinParts = std::move(Parms.OutSkinParts);

	if (OutRotatar != nullptr)
		*OutRotatar = std::move(Parms.OutRotatar);
}


// Function LyraGame.TgfBlueprintFunctionLibrary.ToggleActorTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShouldTick                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShouldAffectComps                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBlueprintFunctionLibrary::ToggleActorTick(class AActor* InActor, bool ShouldTick, bool ShouldAffectComps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfBlueprintFunctionLibrary", "ToggleActorTick");

	Params::TgfBlueprintFunctionLibrary_ToggleActorTick Parms{};

	Parms.InActor = InActor;
	Parms.ShouldTick = ShouldTick;
	Parms.ShouldAffectComps = ShouldAffectComps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBPCheatsBase.CheatEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBPCheatsBase::CheatEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBPCheatsBase", "CheatEnabled");

	Params::TgfBPCheatsBase_CheatEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBPCheatsBase.GetAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* UTgfBPCheatsBase::GetAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBPCheatsBase", "GetAbilitySystemComponent");

	Params::TgfBPCheatsBase_GetAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBPCheatsBase.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfBPCheatsBase::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBPCheatsBase", "GetCharacter");

	Params::TgfBPCheatsBase_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBPCheatsBase.GetTgfCheatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfCheatComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfCheatComponent* UTgfBPCheatsBase::GetTgfCheatComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBPCheatsBase", "GetTgfCheatComponent");

	Params::TgfBPCheatsBase_GetTgfCheatComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraIndicatorManagerComponent.AddIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UIndicatorDescriptor*             IndicatorDescriptor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraIndicatorManagerComponent::AddIndicator(class UIndicatorDescriptor* IndicatorDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraIndicatorManagerComponent", "AddIndicator");

	Params::LyraIndicatorManagerComponent_AddIndicator Parms{};

	Parms.IndicatorDescriptor = IndicatorDescriptor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraIndicatorManagerComponent.RemoveIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UIndicatorDescriptor*             IndicatorDescriptor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraIndicatorManagerComponent::RemoveIndicator(class UIndicatorDescriptor* IndicatorDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraIndicatorManagerComponent", "RemoveIndicator");

	Params::LyraIndicatorManagerComponent_RemoveIndicator Parms{};

	Parms.IndicatorDescriptor = IndicatorDescriptor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfButton.TgfOnClicked
// (Native, Event, Public, BlueprintEvent)

void UTgfButton::TgfOnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfButton", "TgfOnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReticleWidgetBase.InitializeFromWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraWeaponInstance*              InWeapon                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraReticleWidgetBase::InitializeFromWeapon(class ULyraWeaponInstance* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReticleWidgetBase", "InitializeFromWeapon");

	Params::LyraReticleWidgetBase_InitializeFromWeapon Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReticleWidgetBase.OnWeaponInitialized
// (Event, Public, BlueprintEvent)

void ULyraReticleWidgetBase::OnWeaponInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReticleWidgetBase", "OnWeaponInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraReticleWidgetBase.ComputeMaxScreenspaceSpreadRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraReticleWidgetBase::ComputeMaxScreenspaceSpreadRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReticleWidgetBase", "ComputeMaxScreenspaceSpreadRadius");

	Params::LyraReticleWidgetBase_ComputeMaxScreenspaceSpreadRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReticleWidgetBase.ComputeSpreadAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraReticleWidgetBase::ComputeSpreadAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReticleWidgetBase", "ComputeSpreadAngle");

	Params::LyraReticleWidgetBase_ComputeSpreadAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReticleWidgetBase.HasFirstShotAccuracy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraReticleWidgetBase::HasFirstShotAccuracy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReticleWidgetBase", "HasFirstShotAccuracy");

	Params::LyraReticleWidgetBase_HasFirstShotAccuracy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPerfStatContainerBase.UpdateVisibilityOfChildren
// (Final, Native, Public, BlueprintCallable)

void ULyraPerfStatContainerBase::UpdateVisibilityOfChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerfStatContainerBase", "UpdateVisibilityOfChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCameraPostProcessBlueprintLibrary.DeletePostProcessMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeightedBlendables              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeightedBlendables UTgfCameraPostProcessBlueprintLibrary::DeletePostProcessMaterial(class UCameraComponent* CameraComponent, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfCameraPostProcessBlueprintLibrary", "DeletePostProcessMaterial");

	Params::TgfCameraPostProcessBlueprintLibrary_DeletePostProcessMaterial Parms{};

	Parms.CameraComponent = CameraComponent;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCameraPostProcessBlueprintLibrary.InsertPostProcessMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 CameroComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeightedBlendables              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeightedBlendables UTgfCameraPostProcessBlueprintLibrary::InsertPostProcessMaterial(class UCameraComponent* CameroComponent, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfCameraPostProcessBlueprintLibrary", "InsertPostProcessMaterial");

	Params::TgfCameraPostProcessBlueprintLibrary_InsertPostProcessMaterial Parms{};

	Parms.CameroComponent = CameroComponent;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.MonsterBrokenArmHelperActor.BrokenArmL
// (Event, Public, BlueprintEvent)

void AMonsterBrokenArmHelperActor::BrokenArmL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBrokenArmHelperActor", "BrokenArmL");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.MonsterBrokenArmHelperActor.BrokenArmR
// (Event, Public, BlueprintEvent)

void AMonsterBrokenArmHelperActor::BrokenArmR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBrokenArmHelperActor", "BrokenArmR");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfReticleWidgetBase.InitializeFromWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfEquipmentInstance*            InWeapon                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfReticleWidgetBase::InitializeFromWeapon(class UTgfEquipmentInstance* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfReticleWidgetBase", "InitializeFromWeapon");

	Params::TgfReticleWidgetBase_InitializeFromWeapon Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfReticleWidgetBase.OnWeaponInitialized
// (Event, Public, BlueprintEvent)

void UTgfReticleWidgetBase::OnWeaponInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfReticleWidgetBase", "OnWeaponInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.AddTimeDilationConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::AddTimeDilationConfig(float Duration, float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "AddTimeDilationConfig");

	Params::TgfCharacterAnimationHelperComponent_AddTimeDilationConfig Parms{};

	Parms.Duration = Duration;
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.AttachProjectileSword
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               SwordTemplate                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProjectileActorSpawnParams      Params_0                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProjectileInitParams            ProjectileParams                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::AttachProjectileSword(TSubclassOf<class AActor> SwordTemplate, const struct FProjectileActorSpawnParams& Params_0, const struct FProjectileInitParams& ProjectileParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "AttachProjectileSword");

	Params::TgfCharacterAnimationHelperComponent_AttachProjectileSword Parms{};

	Parms.SwordTemplate = SwordTemplate;
	Parms.Params_0 = std::move(Params_0);
	Parms.ProjectileParams = std::move(ProjectileParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.AttachSword
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               SwordTemplate                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SwordIns                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::AttachSword(TSubclassOf<class AActor> SwordTemplate, class AActor* SwordIns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "AttachSword");

	Params::TgfCharacterAnimationHelperComponent_AttachSword Parms{};

	Parms.SwordTemplate = SwordTemplate;
	Parms.SwordIns = SwordIns;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.CrouchMeshTickEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::CrouchMeshTickEnable(float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "CrouchMeshTickEnable");

	Params::TgfCharacterAnimationHelperComponent_CrouchMeshTickEnable Parms{};

	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.DestroySword
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// int32                                   SwordIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::DestroySword(int32 SwordIndex, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "DestroySword");

	Params::TgfCharacterAnimationHelperComponent_DestroySword Parms{};

	Parms.SwordIndex = SwordIndex;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.EndMimic
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            TagsToRemove                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::EndMimic(const struct FGameplayTagContainer& TagsToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "EndMimic");

	Params::TgfCharacterAnimationHelperComponent_EndMimic Parms{};

	Parms.TagsToRemove = std::move(TagsToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.GetTagFromBoneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UTgfCharacterAnimationHelperComponent::GetTagFromBoneName(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "GetTagFromBoneName");

	Params::TgfCharacterAnimationHelperComponent_GetTagFromBoneName Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.HelperActorPlayMontage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::HelperActorPlayMontage(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "HelperActorPlayMontage");

	Params::TgfCharacterAnimationHelperComponent_HelperActorPlayMontage Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.HelperActorStopMontage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::HelperActorStopMontage(class UAnimMontage* Montage, float BlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "HelperActorStopMontage");

	Params::TgfCharacterAnimationHelperComponent_HelperActorStopMontage Parms{};

	Parms.Montage = Montage;
	Parms.BlendOutTime = BlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.HelperActorStopMontageByGroup
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::HelperActorStopMontageByGroup(class FName GroupName, float BlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "HelperActorStopMontageByGroup");

	Params::TgfCharacterAnimationHelperComponent_HelperActorStopMontageByGroup Parms{};

	Parms.GroupName = GroupName;
	Parms.BlendOutTime = BlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.InitHelperActor
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)

void UTgfCharacterAnimationHelperComponent::InitHelperActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "InitHelperActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.OnBrokenArm
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bArmL                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAttach                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::OnBrokenArm(bool bArmL, bool bAttach)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "OnBrokenArm");

	Params::TgfCharacterAnimationHelperComponent_OnBrokenArm Parms{};

	Parms.bArmL = bArmL;
	Parms.bAttach = bAttach;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.OnGameplayTagChange
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::OnGameplayTagChange(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "OnGameplayTagChange");

	Params::TgfCharacterAnimationHelperComponent_OnGameplayTagChange Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.OnRep_MimicArg
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FMimicArg                        OldMimicArg                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::OnRep_MimicArg(const struct FMimicArg& OldMimicArg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "OnRep_MimicArg");

	Params::TgfCharacterAnimationHelperComponent_OnRep_MimicArg Parms{};

	Parms.OldMimicArg = std::move(OldMimicArg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.RangedWeaponAction
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// ERangedWeaponActionType                 Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::RangedWeaponAction(ERangedWeaponActionType Action, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "RangedWeaponAction");

	Params::TgfCharacterAnimationHelperComponent_RangedWeaponAction Parms{};

	Parms.Action = Action;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.ReleaseHelperActor
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)

void UTgfCharacterAnimationHelperComponent::ReleaseHelperActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "ReleaseHelperActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.RemoveTimeDilationConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::RemoveTimeDilationConfig(float Duration, float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "RemoveTimeDilationConfig");

	Params::TgfCharacterAnimationHelperComponent_RemoveTimeDilationConfig Parms{};

	Parms.Duration = Duration;
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.SetTimeDilationTimer
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterAnimationHelperComponent::SetTimeDilationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "SetTimeDilationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.SpawnProjectile
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorTemplate                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProjectileActorSpawnParams      Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProjectileInitParams            ProjectileParams                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ATgfProjectileBase*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATgfProjectileBase* UTgfCharacterAnimationHelperComponent::SpawnProjectile(TSubclassOf<class AActor> ActorTemplate, const struct FProjectileActorSpawnParams& Params_0, const struct FProjectileInitParams& ProjectileParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "SpawnProjectile");

	Params::TgfCharacterAnimationHelperComponent_SpawnProjectile Parms{};

	Parms.ActorTemplate = ActorTemplate;
	Parms.Params_0 = std::move(Params_0);
	Parms.ProjectileParams = std::move(ProjectileParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.StartHelperActor
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// ESwordMasterSkillType                   Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::StartHelperActor(ESwordMasterSkillType Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "StartHelperActor");

	Params::TgfCharacterAnimationHelperComponent_StartHelperActor Parms{};

	Parms.Skill = Skill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.StartMimic
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               MimicTargetActorTemplate                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagsToAdd                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::StartMimic(TSubclassOf<class AActor> MimicTargetActorTemplate, const struct FGameplayTagContainer& TagsToAdd, bool bIgnoreCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "StartMimic");

	Params::TgfCharacterAnimationHelperComponent_StartMimic Parms{};

	Parms.MimicTargetActorTemplate = MimicTargetActorTemplate;
	Parms.TagsToAdd = std::move(TagsToAdd);
	Parms.bIgnoreCollision = bIgnoreCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.TryChangePhysicalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharaPart                           Part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::TryChangePhysicalMaterial(ETgfCharaPart Part, class UPhysicalMaterial* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "TryChangePhysicalMaterial");

	Params::TgfCharacterAnimationHelperComponent_TryChangePhysicalMaterial Parms{};

	Parms.Part = Part;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.TryPlayCurEquipmentSingleAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               EquipClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::TryPlayCurEquipmentSingleAnimation(TSubclassOf<class AActor> EquipClass, class UAnimSequenceBase* Sequence, float PlayRate, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "TryPlayCurEquipmentSingleAnimation");

	Params::TgfCharacterAnimationHelperComponent_TryPlayCurEquipmentSingleAnimation Parms{};

	Parms.EquipClass = EquipClass;
	Parms.Sequence = Sequence;
	Parms.PlayRate = PlayRate;
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.UpdateTimeDilationRate
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterAnimationHelperComponent::UpdateTimeDilationRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "UpdateTimeDilationRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.WaitToReleaseActor
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAnimationHelperComponent::WaitToReleaseActor(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "WaitToReleaseActor");

	Params::TgfCharacterAnimationHelperComponent_WaitToReleaseActor Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.GetHitReactAnimation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHeavyHit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimConfigDirection                    HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimSequenceBase*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimSequenceBase* UTgfCharacterAnimationHelperComponent::GetHitReactAnimation(const struct FGameplayTagContainer& Tags, class ALyraCharacter* Character, bool bHeavyHit, EAnimConfigDirection HitDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "GetHitReactAnimation");

	Params::TgfCharacterAnimationHelperComponent_GetHitReactAnimation Parms{};

	Parms.Tags = std::move(Tags);
	Parms.Character = Character;
	Parms.bHeavyHit = bHeavyHit;
	Parms.HitDirection = HitDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.GetSocketTransform
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SwordIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UTgfCharacterAnimationHelperComponent::GetSocketTransform(int32 SwordIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "GetSocketTransform");

	Params::TgfCharacterAnimationHelperComponent_GetSocketTransform Parms{};

	Parms.SwordIndex = SwordIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.GetSocketTransformExtra
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UTgfCharacterAnimationHelperComponent::GetSocketTransformExtra() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "GetSocketTransformExtra");

	Params::TgfCharacterAnimationHelperComponent_GetSocketTransformExtra Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterAnimationHelperComponent.GetTimeDilationRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfCharacterAnimationHelperComponent::GetTimeDilationRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAnimationHelperComponent", "GetTimeDilationRate");

	Params::TgfCharacterAnimationHelperComponent_GetTimeDilationRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterAvatarComponent.OnRep_Avatar
// (Final, Native, Public)

void UTgfCharacterAvatarComponent::OnRep_Avatar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAvatarComponent", "OnRep_Avatar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAvatarComponent.SetFaceConfigServerOnly
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           Part                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAvatarComponent::SetFaceConfigServerOnly(const class FString& Part, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAvatarComponent", "SetFaceConfigServerOnly");

	Params::TgfCharacterAvatarComponent_SetFaceConfigServerOnly Parms{};

	Parms.Part = std::move(Part);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAvatarComponent.SetShowHelmet
// (Final, Native, Public)
// Parameters:
// bool                                    Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterAvatarComponent::SetShowHelmet(bool Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAvatarComponent", "SetShowHelmet");

	Params::TgfCharacterAvatarComponent_SetShowHelmet Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterAvatarComponent.ToggleHelmetVisible
// (Final, Native, Public)

void UTgfCharacterAvatarComponent::ToggleHelmetVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterAvatarComponent", "ToggleHelmetVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.FindCharacterMovementExtensionComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfCharacterMovementExtensionComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfCharacterMovementExtensionComponent* UTgfCharacterMovementExtensionComponent::FindCharacterMovementExtensionComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfCharacterMovementExtensionComponent", "FindCharacterMovementExtensionComponent");

	Params::TgfCharacterMovementExtensionComponent_FindCharacterMovementExtensionComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.AddMovementMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfMovementMonitorConfig        NewMonitorConfig                                       (Parm, NativeAccessSpecifierPublic)
// bool                                    CheckUnique                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfCharacterMovementExtensionComponent::AddMovementMonitor(const struct FTgfMovementMonitorConfig& NewMonitorConfig, bool CheckUnique)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "AddMovementMonitor");

	Params::TgfCharacterMovementExtensionComponent_AddMovementMonitor Parms{};

	Parms.NewMonitorConfig = std::move(NewMonitorConfig);
	Parms.CheckUnique = CheckUnique;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.ClientEndFloating
// (Net, NetReliable, Native, Event, Public, NetClient)

void UTgfCharacterMovementExtensionComponent::ClientEndFloating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "ClientEndFloating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.ClientStartFloating
// (Net, NetReliable, Native, Event, Public, NetClient)

void UTgfCharacterMovementExtensionComponent::ClientStartFloating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "ClientStartFloating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.EndFloating
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMovementExtensionComponent::EndFloating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "EndFloating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.ForceResetMovementMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     MovementMonitorTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedResetTriggerTime                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::ForceResetMovementMonitor(const struct FGameplayTag& MovementMonitorTag, bool bNeedResetTriggerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "ForceResetMovementMonitor");

	Params::TgfCharacterMovementExtensionComponent_ForceResetMovementMonitor Parms{};

	Parms.MovementMonitorTag = std::move(MovementMonitorTag);
	Parms.bNeedResetTriggerTime = bNeedResetTriggerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.ForceTriggerMovementMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     MovementMonitorTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::ForceTriggerMovementMonitor(const struct FGameplayTag& MovementMonitorTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "ForceTriggerMovementMonitor");

	Params::TgfCharacterMovementExtensionComponent_ForceTriggerMovementMonitor Parms{};

	Parms.MovementMonitorTag = std::move(MovementMonitorTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.MoveActorBlockedOnLocal
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ClientPos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           BlockedActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::MoveActorBlockedOnLocal(const struct FVector& ClientPos, const class AActor* BlockedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "MoveActorBlockedOnLocal");

	Params::TgfCharacterMovementExtensionComponent_MoveActorBlockedOnLocal Parms{};

	Parms.ClientPos = std::move(ClientPos);
	Parms.BlockedActor = BlockedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.OnRep_IgnorePawnCollision
// (Final, Native, Public)

void UTgfCharacterMovementExtensionComponent::OnRep_IgnorePawnCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "OnRep_IgnorePawnCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.OnRep_IsPantherState
// (Final, Native, Public)

void UTgfCharacterMovementExtensionComponent::OnRep_IsPantherState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "OnRep_IsPantherState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.OnSelectedSnapTargetLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::OnSelectedSnapTargetLocal(const class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "OnSelectedSnapTargetLocal");

	Params::TgfCharacterMovementExtensionComponent_OnSelectedSnapTargetLocal Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.OnSelectedSnapTargetServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::OnSelectedSnapTargetServer(const class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "OnSelectedSnapTargetServer");

	Params::TgfCharacterMovementExtensionComponent_OnSelectedSnapTargetServer Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.RemoveMovementMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     MovementMonitorTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::RemoveMovementMonitor(const struct FGameplayTag& MovementMonitorTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "RemoveMovementMonitor");

	Params::TgfCharacterMovementExtensionComponent_RemoveMovementMonitor Parms{};

	Parms.MovementMonitorTag = std::move(MovementMonitorTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.ServerCheckSnapTargetValid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfSnapQueryConfig              SnapQueryConfig                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfCharacterMovementExtensionComponent::ServerCheckSnapTargetValid(class AActor* TargetActor, const struct FTgfSnapQueryConfig& SnapQueryConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "ServerCheckSnapTargetValid");

	Params::TgfCharacterMovementExtensionComponent_ServerCheckSnapTargetValid Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SnapQueryConfig = std::move(SnapQueryConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.SetIgnorePawnCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterMovementExtensionComponent::SetIgnorePawnCollision(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "SetIgnorePawnCollision");

	Params::TgfCharacterMovementExtensionComponent_SetIgnorePawnCollision Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.StartFloating
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMovementExtensionComponent::StartFloating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "StartFloating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.TransToNormal
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMovementExtensionComponent::TransToNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "TransToNormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.TransToPanther
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterMovementExtensionComponent::TransToPanther()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "TransToPanther");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.TryGetSnapTargetLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTgfSnapQueryConfig              SnapQueryConfig                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfCharacterMovementExtensionComponent::TryGetSnapTargetLocal(const struct FTgfSnapQueryConfig& SnapQueryConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "TryGetSnapTargetLocal");

	Params::TgfCharacterMovementExtensionComponent_TryGetSnapTargetLocal Parms{};

	Parms.SnapQueryConfig = std::move(SnapQueryConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.TryingTeleportToFitPos
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfCharacterMovementExtensionComponent::TryingTeleportToFitPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "TryingTeleportToFitPos");

	Params::TgfCharacterMovementExtensionComponent_TryingTeleportToFitPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.GetCharacterOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UTgfCharacterMovementExtensionComponent::GetCharacterOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "GetCharacterOwner");

	Params::TgfCharacterMovementExtensionComponent_GetCharacterOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterMovementExtensionComponent.GetIsPantherState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfCharacterMovementExtensionComponent::GetIsPantherState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterMovementExtensionComponent", "GetIsPantherState");

	Params::TgfCharacterMovementExtensionComponent_GetIsPantherState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterSummonComponent.AddToSummonActorList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SummonActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::AddToSummonActorList(class AActor* SummonActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "AddToSummonActorList");

	Params::TgfCharacterSummonComponent_AddToSummonActorList Parms{};

	Parms.SummonActor = SummonActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.ApplyEffectToSummonActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SummonActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UGameplayEffect>>GEs                                                    (ConstParm, Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::ApplyEffectToSummonActor(const class AActor* SummonActor, const TArray<TSubclassOf<class UGameplayEffect>>& GEs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "ApplyEffectToSummonActor");

	Params::TgfCharacterSummonComponent_ApplyEffectToSummonActor Parms{};

	Parms.SummonActor = SummonActor;
	Parms.GEs = std::move(GEs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.ApplyEffectToSummonActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<TSubclassOf<class UGameplayEffect>>GEs                                                    (ConstParm, Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::ApplyEffectToSummonActors(const TArray<TSubclassOf<class UGameplayEffect>>& GEs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "ApplyEffectToSummonActors");

	Params::TgfCharacterSummonComponent_ApplyEffectToSummonActors Parms{};

	Parms.GEs = std::move(GEs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.DestroyAllSummonActors
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterSummonComponent::DestroyAllSummonActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "DestroyAllSummonActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.DestroyAllSummonActorsWithDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::DestroyAllSummonActorsWithDelay(float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "DestroyAllSummonActorsWithDelay");

	Params::TgfCharacterSummonComponent_DestroyAllSummonActorsWithDelay Parms{};

	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.DestroySummonActorsWhenLoseTarget
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterSummonComponent::DestroySummonActorsWhenLoseTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "DestroySummonActorsWhenLoseTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.OnRep_SummonSource
// (Final, Native, Protected)

void UTgfCharacterSummonComponent::OnRep_SummonSource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "OnRep_SummonSource");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.RemoveFromSummonActorList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SummonActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::RemoveFromSummonActorList(class AActor* SummonActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "RemoveFromSummonActorList");

	Params::TgfCharacterSummonComponent_RemoveFromSummonActorList Parms{};

	Parms.SummonActor = SummonActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.SetDestroySummonsWhenDied
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Destroy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::SetDestroySummonsWhenDied(bool Destroy, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "SetDestroySummonsWhenDied");

	Params::TgfCharacterSummonComponent_SetDestroySummonsWhenDied Parms{};

	Parms.Destroy = Destroy;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.SetSummonSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCharacterSummonComponent::SetSummonSource(class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "SetSummonSource");

	Params::TgfCharacterSummonComponent_SetSummonSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.UpdateSummonActorList
// (Final, Native, Public, BlueprintCallable)

void UTgfCharacterSummonComponent::UpdateSummonActorList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "UpdateSummonActorList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCharacterSummonComponent.GetSummonActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    Recursively                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTgfCharacterSummonComponent::GetSummonActors(bool Recursively) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "GetSummonActors");

	Params::TgfCharacterSummonComponent_GetSummonActors Parms{};

	Parms.Recursively = Recursively;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterSummonComponent.GetSummonActorsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfCharacterSummonComponent::GetSummonActorsCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "GetSummonActorsCount");

	Params::TgfCharacterSummonComponent_GetSummonActorsCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterSummonComponent.GetSummonSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    Recursively                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfCharacterSummonComponent::GetSummonSource(bool Recursively) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "GetSummonSource");

	Params::TgfCharacterSummonComponent_GetSummonSource Parms{};

	Parms.Recursively = Recursively;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCharacterSummonComponent.IsSummonSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfCharacterSummonComponent::IsSummonSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCharacterSummonComponent", "IsSummonSource");

	Params::TgfCharacterSummonComponent_IsSummonSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponStateComponent.ClientConfirmTargetData
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// uint16                                  UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           HitReplaces                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraWeaponStateComponent::ClientConfirmTargetData(uint16 UniqueId, bool bSuccess, const TArray<uint8>& HitReplaces)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponStateComponent", "ClientConfirmTargetData");

	Params::LyraWeaponStateComponent_ClientConfirmTargetData Parms{};

	Parms.UniqueId = UniqueId;
	Parms.bSuccess = bSuccess;
	Parms.HitReplaces = std::move(HitReplaces);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCollectableLightComponent.GetCollectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfCollectableLightComponent::GetCollectable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCollectableLightComponent", "GetCollectable");

	Params::TgfCollectableLightComponent_GetCollectable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfCollectableLightComponent.OnRep_Collectable
// (Final, Native, Private)

void UTgfCollectableLightComponent::OnRep_Collectable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCollectableLightComponent", "OnRep_Collectable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCollectableLightComponent.SetCollectable
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCollectable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfCollectableLightComponent::SetCollectable(bool bCollectable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCollectableLightComponent", "SetCollectable");

	Params::TgfCollectableLightComponent_SetCollectable Parms{};

	Parms.bCollectable = bCollectable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfCollectableLightComponent.SetupLightEffectComponent
// (Final, Native, Private)

void UTgfCollectableLightComponent::SetupLightEffectComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfCollectableLightComponent", "SetupLightEffectComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AsyncAction_FinishCameraBlend.FinishCameraBlend
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LeadTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_FinishCameraBlend*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_FinishCameraBlend* UAsyncAction_FinishCameraBlend::FinishCameraBlend(class UObject* WorldContextObject, float LeadTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_FinishCameraBlend", "FinishCameraBlend");

	Params::AsyncAction_FinishCameraBlend_FinishCameraBlend Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LeadTime = LeadTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfControllerSteamAchievementComponent.OnOtherResurrect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfControllerSteamAchievementComponent::OnOtherResurrect(class ALyraCharacter* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfControllerSteamAchievementComponent", "OnOtherResurrect");

	Params::TgfControllerSteamAchievementComponent_OnOtherResurrect Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfControllerSteamAchievementComponent.OnPlayerKillEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayTag                     Channel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLyraVerbMessage                 InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfControllerSteamAchievementComponent::OnPlayerKillEvent(const struct FGameplayTag& Channel, const struct FLyraVerbMessage& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfControllerSteamAchievementComponent", "OnPlayerKillEvent");

	Params::TgfControllerSteamAchievementComponent_OnPlayerKillEvent Parms{};

	Parms.Channel = std::move(Channel);
	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfControllerSteamAchievementComponent.OnRebirthOtherMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RevivedTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfControllerSteamAchievementComponent::OnRebirthOtherMember(class AActor* RevivedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfControllerSteamAchievementComponent", "OnRebirthOtherMember");

	Params::TgfControllerSteamAchievementComponent_OnRebirthOtherMember Parms{};

	Parms.RevivedTarget = RevivedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEnterNpcStateAsyncAction.WaitForGlobalNpcState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfNpcState>         NpcState                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEnterNpcStateAsyncAction*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfEnterNpcStateAsyncAction* UTgfEnterNpcStateAsyncAction::WaitForGlobalNpcState(const class UObject* WorldContext, TSubclassOf<class UTgfNpcState> NpcState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfEnterNpcStateAsyncAction", "WaitForGlobalNpcState");

	Params::TgfEnterNpcStateAsyncAction_WaitForGlobalNpcState Parms{};

	Parms.WorldContext = WorldContext;
	Parms.NpcState = NpcState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.StaticCreateInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraEquipmentInstance>InstanceType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* ULyraEquipmentManagerComponent::StaticCreateInstance(class AActor* Owner, class ULyraInventoryItemInstance* ItemInstance, TSubclassOf<class ULyraEquipmentInstance> InstanceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraEquipmentManagerComponent", "StaticCreateInstance");

	Params::LyraEquipmentManagerComponent_StaticCreateInstance Parms{};

	Parms.Owner = Owner;
	Parms.ItemInstance = ItemInstance;
	Parms.InstanceType = InstanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.ClearAllEquipment
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULyraEquipmentManagerComponent::ClearAllEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "ClearAllEquipment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.EquipItemByDefinition
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::EquipItemByDefinition(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "EquipItemByDefinition");

	Params::LyraEquipmentManagerComponent_EquipItemByDefinition Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.EquipItemByInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraEquipmentInstance*           Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::EquipItemByInstance(class ULyraEquipmentInstance* Instance, ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "EquipItemByInstance");

	Params::LyraEquipmentManagerComponent_EquipItemByInstance Parms{};

	Parms.Instance = Instance;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetFirstInstanceOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ULyraEquipmentInstance>InstanceType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* ULyraEquipmentManagerComponent::GetFirstInstanceOfType(TSubclassOf<class ULyraEquipmentInstance> InstanceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetFirstInstanceOfType");

	Params::LyraEquipmentManagerComponent_GetFirstInstanceOfType Parms{};

	Parms.InstanceType = InstanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.OnRep_EquipmentList
// (Native, Protected)

void ULyraEquipmentManagerComponent::OnRep_EquipmentList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "OnRep_EquipmentList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.UnequipItemByDefinition
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// TSubclassOf<class ULyraEquipmentDefinition>EquipClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::UnequipItemByDefinition(TSubclassOf<class ULyraEquipmentDefinition> EquipClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "UnequipItemByDefinition");

	Params::LyraEquipmentManagerComponent_UnequipItemByDefinition Parms{};

	Parms.EquipClass = EquipClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.UnequipItemByInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraEquipmentInstance*           Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::UnequipItemByInstance(class ULyraEquipmentInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "UnequipItemByInstance");

	Params::LyraEquipmentManagerComponent_UnequipItemByInstance Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.UnequipItemByItem
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::UnequipItemByItem(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "UnequipItemByItem");

	Params::LyraEquipmentManagerComponent_UnequipItemByItem Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.UnequipItemByItemAuth
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::UnequipItemByItemAuth(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "UnequipItemByItemAuth");

	Params::LyraEquipmentManagerComponent_UnequipItemByItemAuth Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.UpdateEquipInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraEquipmentInstance*           EquipInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::UpdateEquipInstance(class ULyraEquipmentInstance* EquipInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "UpdateEquipInstance");

	Params::LyraEquipmentManagerComponent_UpdateEquipInstance Parms{};

	Parms.EquipInstance = EquipInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.UpdateItemInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraEquipmentManagerComponent::UpdateItemInstance(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "UpdateItemInstance");

	Params::LyraEquipmentManagerComponent_UpdateItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraEquipmentManagerComponent.CanUnequipItemInstance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsExchange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraEquipmentManagerComponent::CanUnequipItemInstance(class ULyraEquipmentInstance* Instance, bool IsExchange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "CanUnequipItemInstance");

	Params::LyraEquipmentManagerComponent_CanUnequipItemInstance Parms{};

	Parms.Instance = Instance;
	Parms.IsExchange = IsExchange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.CanUnequipItemInventory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsExchange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraEquipmentManagerComponent::CanUnequipItemInventory(class ULyraInventoryItemInstance* Instance, bool IsExchange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "CanUnequipItemInventory");

	Params::LyraEquipmentManagerComponent_CanUnequipItemInventory Parms{};

	Parms.Instance = Instance;
	Parms.IsExchange = IsExchange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.CreateInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* ULyraEquipmentManagerComponent::CreateInstance(class ULyraInventoryItemInstance* ItemInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "CreateInstance");

	Params::LyraEquipmentManagerComponent_CreateInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.FindFirstItemByDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraEquipmentDefinition>EquipDef                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* ULyraEquipmentManagerComponent::FindFirstItemByDefinition(TSubclassOf<class ULyraEquipmentDefinition> EquipDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "FindFirstItemByDefinition");

	Params::LyraEquipmentManagerComponent_FindFirstItemByDefinition Parms{};

	Parms.EquipDef = EquipDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetAllEntries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FLyraAppliedEquipmentEntry>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FLyraAppliedEquipmentEntry> ULyraEquipmentManagerComponent::GetAllEntries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetAllEntries");

	Params::LyraEquipmentManagerComponent_GetAllEntries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetAllEquips
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ULyraEquipmentInstance*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULyraEquipmentInstance*> ULyraEquipmentManagerComponent::GetAllEquips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetAllEquips");

	Params::LyraEquipmentManagerComponent_GetAllEquips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetEntryIndexByEquipInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           EquipInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraEquipmentManagerComponent::GetEntryIndexByEquipInstance(class ULyraEquipmentInstance* EquipInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetEntryIndexByEquipInstance");

	Params::LyraEquipmentManagerComponent_GetEntryIndexByEquipInstance Parms{};

	Parms.EquipInstance = EquipInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetEntryIndexByItemInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraEquipmentManagerComponent::GetEntryIndexByItemInstance(class ULyraInventoryItemInstance* ItemInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetEntryIndexByItemInstance");

	Params::LyraEquipmentManagerComponent_GetEntryIndexByItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetEquipInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* ULyraEquipmentManagerComponent::GetEquipInstance(int32 Param_Index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetEquipInstance");

	Params::LyraEquipmentManagerComponent_GetEquipInstance Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetEquipmentInstanceByItemInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* ULyraEquipmentManagerComponent::GetEquipmentInstanceByItemInstance(class ULyraInventoryItemInstance* ItemInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetEquipmentInstanceByItemInstance");

	Params::LyraEquipmentManagerComponent_GetEquipmentInstanceByItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetEquipmentInstancesOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraEquipmentInstance>InstanceType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULyraEquipmentInstance*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULyraEquipmentInstance*> ULyraEquipmentManagerComponent::GetEquipmentInstancesOfType(TSubclassOf<class ULyraEquipmentInstance> InstanceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetEquipmentInstancesOfType");

	Params::LyraEquipmentManagerComponent_GetEquipmentInstancesOfType Parms{};

	Parms.InstanceType = InstanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.GetSlotOfEquipment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           Equipment                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot ULyraEquipmentManagerComponent::GetSlotOfEquipment(const class ULyraEquipmentInstance* Equipment) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "GetSlotOfEquipment");

	Params::LyraEquipmentManagerComponent_GetSlotOfEquipment Parms{};

	Parms.Equipment = Equipment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.IsEquipSlotEmpty
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraEquipmentManagerComponent::IsEquipSlotEmpty(ETgfEquipSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "IsEquipSlotEmpty");

	Params::LyraEquipmentManagerComponent_IsEquipSlotEmpty Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraEquipmentManagerComponent.MatchSlotConfig
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSubType                        WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreDead                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraEquipmentManagerComponent::MatchSlotConfig(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot SlotType, ETgfEquipSubType WeaponType, bool bIgnoreDead) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraEquipmentManagerComponent", "MatchSlotConfig");

	Params::LyraEquipmentManagerComponent_MatchSlotConfig Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.SlotType = SlotType;
	Parms.WeaponType = WeaponType;
	Parms.bIgnoreDead = bIgnoreDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.AddBlockingLootSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::AddBlockingLootSlot(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "AddBlockingLootSlot");

	Params::TgfEquipmentManagerComponent_AddBlockingLootSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.AddDefaultWeapon
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       OutDropInstance                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UTgfEquipmentManagerComponent::AddDefaultWeapon(class ULyraInventoryItemInstance* ItemInstance, class ULyraInventoryItemInstance** OutDropInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "AddDefaultWeapon");

	Params::TgfEquipmentManagerComponent_AddDefaultWeapon Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDropInstance != nullptr)
		*OutDropInstance = Parms.OutDropInstance;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.AddDeltaGearsetLevel
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GearsetId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DeltaLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::AddDeltaGearsetLevel(int32 GearsetId, int32 DeltaLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "AddDeltaGearsetLevel");

	Params::TgfEquipmentManagerComponent_AddDeltaGearsetLevel Parms{};

	Parms.GearsetId = GearsetId;
	Parms.DeltaLevel = DeltaLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ChangeWeaponAnim
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfWeaponAnimDefinition>AnimClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfWeaponAnimInstance*           OldAnimInstance                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::ChangeWeaponAnim(ETgfWeaponChangeSlot Slot, TSubclassOf<class UTgfWeaponAnimDefinition> AnimClass, class UTgfWeaponAnimInstance* OldAnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ChangeWeaponAnim");

	Params::TgfEquipmentManagerComponent_ChangeWeaponAnim Parms{};

	Parms.Slot = Slot;
	Parms.AnimClass = AnimClass;
	Parms.OldAnimInstance = OldAnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.CheckAllEquipmentsVaild
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>OutDropInstances                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::CheckAllEquipmentsVaild(TArray<class ULyraInventoryItemInstance*>* OutDropInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CheckAllEquipmentsVaild");

	Params::TgfEquipmentManagerComponent_CheckAllEquipmentsVaild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDropInstances != nullptr)
		*OutDropInstances = std::move(Parms.OutDropInstances);
}


// Function LyraGame.TgfEquipmentManagerComponent.CheckStackZeroUnequip
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAttemptToRefill                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::CheckStackZeroUnequip(ETgfWeaponChangeSlot Slot, bool bAttemptToRefill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CheckStackZeroUnequip");

	Params::TgfEquipmentManagerComponent_CheckStackZeroUnequip Parms{};

	Parms.Slot = Slot;
	Parms.bAttemptToRefill = bAttemptToRefill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.CheckWeaponAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfWeaponAnimInstance*           OldAnimInstance                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::CheckWeaponAnim(class UTgfWeaponAnimInstance* OldAnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CheckWeaponAnim");

	Params::TgfEquipmentManagerComponent_CheckWeaponAnim Parms{};

	Parms.OldAnimInstance = OldAnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.ClearAllGearsetLevel
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UTgfEquipmentManagerComponent::ClearAllGearsetLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ClearAllGearsetLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ClearBlockingLootSlot
// (Final, Native, Public, BlueprintCallable)

void UTgfEquipmentManagerComponent::ClearBlockingLootSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ClearBlockingLootSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ConsumeItemByWeaponSlot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreSwitch                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::ConsumeItemByWeaponSlot(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 Nums, ETgfWeaponChangeSlot Slot, bool IgnoreSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ConsumeItemByWeaponSlot");

	Params::TgfEquipmentManagerComponent_ConsumeItemByWeaponSlot Parms{};

	Parms.ItemDef = ItemDef;
	Parms.Nums = Nums;
	Parms.Slot = Slot;
	Parms.IgnoreSwitch = IgnoreSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.DealLoosePointOnPlayerDeath
// (Final, Native, Public, BlueprintCallable)

void UTgfEquipmentManagerComponent::DealLoosePointOnPlayerDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "DealLoosePointOnPlayerDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ExchangeEquipsWithSlots
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// ETgfEquipSlot                           Slot1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::ExchangeEquipsWithSlots(ETgfEquipSlot Slot1, ETgfEquipSlot Slot2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ExchangeEquipsWithSlots");

	Params::TgfEquipmentManagerComponent_ExchangeEquipsWithSlots Parms{};

	Parms.Slot1 = Slot1;
	Parms.Slot2 = Slot2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ExchangeEquipToInventory
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckInInventory                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::ExchangeEquipToInventory(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot, bool CheckInInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ExchangeEquipToInventory");

	Params::TgfEquipmentManagerComponent_ExchangeEquipToInventory Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Slot = Slot;
	Parms.CheckInInventory = CheckInInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ExchangeEquipToInventoryFromLoot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentManagerComponent*    SourceEquipment                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryManagerComponent*    SourceInventory                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PosX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PosY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::ExchangeEquipToInventoryFromLoot(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot, class UTgfEquipmentManagerComponent* SourceEquipment, class UTgfInventoryManagerComponent* SourceInventory, ETgfEquipSlot SourceSlot, int32 PosX, int32 PosY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ExchangeEquipToInventoryFromLoot");

	Params::TgfEquipmentManagerComponent_ExchangeEquipToInventoryFromLoot Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Slot = Slot;
	Parms.SourceEquipment = SourceEquipment;
	Parms.SourceInventory = SourceInventory;
	Parms.SourceSlot = SourceSlot;
	Parms.PosX = PosX;
	Parms.PosY = PosY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.ExchangeWeaponSet
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// ETgfEquipSlot                           Set1RightSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Set1LeftSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Set2RightSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Set2LeftSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::ExchangeWeaponSet(ETgfEquipSlot Set1RightSlot, ETgfEquipSlot Set1LeftSlot, ETgfEquipSlot Set2RightSlot, ETgfEquipSlot Set2LeftSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "ExchangeWeaponSet");

	Params::TgfEquipmentManagerComponent_ExchangeWeaponSet Parms{};

	Parms.Set1RightSlot = Set1RightSlot;
	Parms.Set1LeftSlot = Set1LeftSlot;
	Parms.Set2RightSlot = Set2RightSlot;
	Parms.Set2LeftSlot = Set2LeftSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetAllEquipments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIgnoreAdditional                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentInstance*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTgfEquipmentInstance*> UTgfEquipmentManagerComponent::GetAllEquipments(bool bIgnoreAdditional)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetAllEquipments");

	Params::TgfEquipmentManagerComponent_GetAllEquipments Parms{};

	Parms.bIgnoreAdditional = bIgnoreAdditional;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetAutoFillWeaponQuility
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<ETgfEquipQuality>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ETgfEquipQuality> UTgfEquipmentManagerComponent::GetAutoFillWeaponQuility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetAutoFillWeaponQuility");

	Params::TgfEquipmentManagerComponent_GetAutoFillWeaponQuility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.HasZeroDurabilityEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::HasZeroDurabilityEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "HasZeroDurabilityEquip");

	Params::TgfEquipmentManagerComponent_HasZeroDurabilityEquip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.OnRep_CurrentWeaponSlot
// (Final, Native, Protected)
// Parameters:
// ETgfWeaponChangeSlot                    OldWeaponSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::OnRep_CurrentWeaponSlot(ETgfWeaponChangeSlot OldWeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "OnRep_CurrentWeaponSlot");

	Params::TgfEquipmentManagerComponent_OnRep_CurrentWeaponSlot Parms{};

	Parms.OldWeaponSlot = OldWeaponSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.OnRep_WeaponSlotList
// (Final, Native, Protected)

void UTgfEquipmentManagerComponent::OnRep_WeaponSlotList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "OnRep_WeaponSlotList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.RemoveEquipByItemInstance
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::RemoveEquipByItemInstance(class ULyraInventoryItemInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "RemoveEquipByItemInstance");

	Params::TgfEquipmentManagerComponent_RemoveEquipByItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.RemoveEquipBySlot
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::RemoveEquipBySlot(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "RemoveEquipBySlot");

	Params::TgfEquipmentManagerComponent_RemoveEquipBySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.RemoveEquipToInventory
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::RemoveEquipToInventory(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "RemoveEquipToInventory");

	Params::TgfEquipmentManagerComponent_RemoveEquipToInventory Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.SetActiveAdditionalSlot
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::SetActiveAdditionalSlot(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "SetActiveAdditionalSlot");

	Params::TgfEquipmentManagerComponent_SetActiveAdditionalSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.SetAutoFillWeaponQuality
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TArray<ETgfEquipQuality>                QualityList                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::SetAutoFillWeaponQuality(const TArray<ETgfEquipQuality>& QualityList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "SetAutoFillWeaponQuality");

	Params::TgfEquipmentManagerComponent_SetAutoFillWeaponQuality Parms{};

	Parms.QualityList = std::move(QualityList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.SetEquipmentVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowInClient                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceAll                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponHandType                      RestrictWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::SetEquipmentVisible(bool bVisible, bool AllowInClient, bool bForceAll, ETgfWeaponHandType RestrictWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "SetEquipmentVisible");

	Params::TgfEquipmentManagerComponent_SetEquipmentVisible Parms{};

	Parms.bVisible = bVisible;
	Parms.AllowInClient = AllowInClient;
	Parms.bForceAll = bForceAll;
	Parms.RestrictWeapon = RestrictWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.SwitchWeaponSlot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedForce                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::SwitchWeaponSlot(ETgfWeaponChangeSlot Slot, bool NeedForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "SwitchWeaponSlot");

	Params::TgfEquipmentManagerComponent_SwitchWeaponSlot Parms{};

	Parms.Slot = Slot;
	Parms.NeedForce = NeedForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfEquipmentManagerComponent.CanConsumeItemByWeaponSlot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::CanConsumeItemByWeaponSlot(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, int32 Nums, ETgfWeaponChangeSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CanConsumeItemByWeaponSlot");

	Params::TgfEquipmentManagerComponent_CanConsumeItemByWeaponSlot Parms{};

	Parms.ItemDef = ItemDef;
	Parms.Nums = Nums;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.CanExchangeEquipsWithSlots
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           Slot1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::CanExchangeEquipsWithSlots(ETgfEquipSlot Slot1, ETgfEquipSlot Slot2) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CanExchangeEquipsWithSlots");

	Params::TgfEquipmentManagerComponent_CanExchangeEquipsWithSlots Parms{};

	Parms.Slot1 = Slot1;
	Parms.Slot2 = Slot2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.CanExchangeEquipToInventory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckInInventory                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::CanExchangeEquipToInventory(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot, bool CheckInInventory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CanExchangeEquipToInventory");

	Params::TgfEquipmentManagerComponent_CanExchangeEquipToInventory Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Slot = Slot;
	Parms.CheckInInventory = CheckInInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.CanLootUseEquip
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::CanLootUseEquip(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CanLootUseEquip");

	Params::TgfEquipmentManagerComponent_CanLootUseEquip Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.CanRemoveEquipToInventory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::CanRemoveEquipToInventory(ETgfEquipSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "CanRemoveEquipToInventory");

	Params::TgfEquipmentManagerComponent_CanRemoveEquipToInventory Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetActiveAdditionalSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UTgfEquipmentManagerComponent::GetActiveAdditionalSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetActiveAdditionalSlot");

	Params::TgfEquipmentManagerComponent_GetActiveAdditionalSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetAnimWeaponInstances
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           OutRightWeapon                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           OutLeftWeapon                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::GetAnimWeaponInstances(class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetAnimWeaponInstances");

	Params::TgfEquipmentManagerComponent_GetAnimWeaponInstances Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRightWeapon != nullptr)
		*OutRightWeapon = Parms.OutRightWeapon;

	if (OutLeftWeapon != nullptr)
		*OutLeftWeapon = Parms.OutLeftWeapon;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetAnimWeaponSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTgfWeaponSlot                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfWeaponSlot UTgfEquipmentManagerComponent::GetAnimWeaponSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetAnimWeaponSlot");

	Params::TgfEquipmentManagerComponent_GetAnimWeaponSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetChangeSlotByEquipmentInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           WeaponInstance                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UTgfEquipmentManagerComponent::GetChangeSlotByEquipmentInstance(class ULyraEquipmentInstance* WeaponInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetChangeSlotByEquipmentInstance");

	Params::TgfEquipmentManagerComponent_GetChangeSlotByEquipmentInstance Parms{};

	Parms.WeaponInstance = WeaponInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetChangeSlotByInventoryInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UTgfEquipmentManagerComponent::GetChangeSlotByInventoryInstance(class ULyraInventoryItemInstance* ItemInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetChangeSlotByInventoryInstance");

	Params::TgfEquipmentManagerComponent_GetChangeSlotByInventoryInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetCurrentWeaponAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfWeaponAnimInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfWeaponAnimInstance* UTgfEquipmentManagerComponent::GetCurrentWeaponAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetCurrentWeaponAnimInstance");

	Params::TgfEquipmentManagerComponent_GetCurrentWeaponAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetCurrentWeaponInstances
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           OutRightWeapon                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           OutLeftWeapon                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::GetCurrentWeaponInstances(class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetCurrentWeaponInstances");

	Params::TgfEquipmentManagerComponent_GetCurrentWeaponInstances Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRightWeapon != nullptr)
		*OutRightWeapon = Parms.OutRightWeapon;

	if (OutLeftWeapon != nullptr)
		*OutLeftWeapon = Parms.OutLeftWeapon;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetCurrentWeaponSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTgfWeaponSlot                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfWeaponSlot UTgfEquipmentManagerComponent::GetCurrentWeaponSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetCurrentWeaponSlot");

	Params::TgfEquipmentManagerComponent_GetCurrentWeaponSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetEquipBySlot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* UTgfEquipmentManagerComponent::GetEquipBySlot(ETgfEquipSlot Slot, int32 IgnoreIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetEquipBySlot");

	Params::TgfEquipmentManagerComponent_GetEquipBySlot Parms{};

	Parms.Slot = Slot;
	Parms.IgnoreIndex = IgnoreIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetGearsetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   GearsetId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfEquipmentManagerComponent::GetGearsetLevel(int32 GearsetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetGearsetLevel");

	Params::TgfEquipmentManagerComponent_GetGearsetLevel Parms{};

	Parms.GearsetId = GearsetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetLastWeaponInstances
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           OutRightWeapon                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           OutLeftWeapon                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::GetLastWeaponInstances(class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetLastWeaponInstances");

	Params::TgfEquipmentManagerComponent_GetLastWeaponInstances Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRightWeapon != nullptr)
		*OutRightWeapon = Parms.OutRightWeapon;

	if (OutLeftWeapon != nullptr)
		*OutLeftWeapon = Parms.OutLeftWeapon;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetSlotWeaponInstances
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           OutRightWeapon                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           OutLeftWeapon                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfEquipmentManagerComponent::GetSlotWeaponInstances(ETgfWeaponChangeSlot Slot, class ULyraEquipmentInstance** OutRightWeapon, class ULyraEquipmentInstance** OutLeftWeapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetSlotWeaponInstances");

	Params::TgfEquipmentManagerComponent_GetSlotWeaponInstances Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRightWeapon != nullptr)
		*OutRightWeapon = Parms.OutRightWeapon;

	if (OutLeftWeapon != nullptr)
		*OutLeftWeapon = Parms.OutLeftWeapon;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetWeaponElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfBattleElement                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfBattleElement UTgfEquipmentManagerComponent::GetWeaponElement(ETgfUseAttackType AttackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetWeaponElement");

	Params::TgfEquipmentManagerComponent_GetWeaponElement Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetWeaponInspectMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UTgfEquipmentManagerComponent::GetWeaponInspectMontage(const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetWeaponInspectMontage");

	Params::TgfEquipmentManagerComponent_GetWeaponInspectMontage Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.GetWeaponInstanceByAnother
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           WeaponInstance                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* UTgfEquipmentManagerComponent::GetWeaponInstanceByAnother(class ULyraEquipmentInstance* WeaponInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "GetWeaponInstanceByAnother");

	Params::TgfEquipmentManagerComponent_GetWeaponInstanceByAnother Parms{};

	Parms.WeaponInstance = WeaponInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.IsBothWeaponHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::IsBothWeaponHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "IsBothWeaponHidden");

	Params::TgfEquipmentManagerComponent_IsBothWeaponHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.IsLeftWeaponHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::IsLeftWeaponHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "IsLeftWeaponHidden");

	Params::TgfEquipmentManagerComponent_IsLeftWeaponHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.IsLootSlotBlocking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::IsLootSlotBlocking(ETgfEquipSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "IsLootSlotBlocking");

	Params::TgfEquipmentManagerComponent_IsLootSlotBlocking Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.IsRightWeaponHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::IsRightWeaponHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "IsRightWeaponHidden");

	Params::TgfEquipmentManagerComponent_IsRightWeaponHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.IsWeaponSlotEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponChangeSlot                    Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::IsWeaponSlotEmpty(ETgfWeaponChangeSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "IsWeaponSlotEmpty");

	Params::TgfEquipmentManagerComponent_IsWeaponSlotEmpty Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfEquipmentManagerComponent.MatchAdditionalSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           OutSlot                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConfig                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfEquipmentManagerComponent::MatchAdditionalSlot(class ULyraInventoryItemInstance* ItemInstance, ETgfEquipSlot* OutSlot, bool bUseConfig) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfEquipmentManagerComponent", "MatchAdditionalSlot");

	Params::TgfEquipmentManagerComponent_MatchAdditionalSlot Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.bUseConfig = bUseConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSlot != nullptr)
		*OutSlot = Parms.OutSlot;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameFollowUIItem.DestoryItem
// (Final, Native, Public, BlueprintCallable)

void UTgfGameFollowUIItem::DestoryItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameFollowUIItem", "DestoryItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameFollowUIItem.OnStartByMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHurtNotifyMessage               Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTgfGameFollowUIItem::OnStartByMessage(const struct FHurtNotifyMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameFollowUIItem", "OnStartByMessage");

	Params::TgfGameFollowUIItem_OnStartByMessage Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameFollowUIManagerComponent.CreateFollowUIItem
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InWorldPos                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfGameFollowUIItem*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfGameFollowUIItem* UTgfGameFollowUIManagerComponent::CreateFollowUIItem(const struct FVector& InWorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameFollowUIManagerComponent", "CreateFollowUIItem");

	Params::TgfGameFollowUIManagerComponent_CreateFollowUIItem Parms{};

	Parms.InWorldPos = std::move(InWorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility_Rebirth.CancelRebirth
// (Final, Native, Protected, BlueprintCallable)

void UTgfGameplayAbility_Rebirth::CancelRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Rebirth", "CancelRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility_Rebirth.CheckEquipmentsVaild
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>DropItems                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfGameplayAbility_Rebirth::CheckEquipmentsVaild(TArray<class ULyraInventoryItemInstance*>* DropItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Rebirth", "CheckEquipmentsVaild");

	Params::TgfGameplayAbility_Rebirth_CheckEquipmentsVaild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DropItems != nullptr)
		*DropItems = std::move(Parms.DropItems);
}


// Function LyraGame.TgfGameplayAbility_Rebirth.CheckWeaponSlot
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemInstance*        Param_DropItem                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UTgfGameplayAbility_Rebirth::CheckWeaponSlot(class UTgfInventoryItemInstance** Param_DropItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Rebirth", "CheckWeaponSlot");

	Params::TgfGameplayAbility_Rebirth_CheckWeaponSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_DropItem != nullptr)
		*Param_DropItem = Parms.Param_DropItem;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility_Rebirth.DropItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTgfInventoryItemInstance*        Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAbility_Rebirth::DropItem(class UTgfInventoryItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Rebirth", "DropItem");

	Params::TgfGameplayAbility_Rebirth_DropItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAbility_Rebirth.FinishRebirth
// (Final, Native, Protected, BlueprintCallable)

void UTgfGameplayAbility_Rebirth::FinishRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Rebirth", "FinishRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility_Rebirth.StartRebirth
// (Final, Native, Protected, BlueprintCallable)

void UTgfGameplayAbility_Rebirth::StartRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Rebirth", "StartRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility_SnapToTarget.OnTargetLocationReached
// (Final, Native, Private)

void UTgfGameplayAbility_SnapToTarget::OnTargetLocationReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_SnapToTarget", "OnTargetLocationReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAura.AddIgnoreTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::AddIgnoreTarget(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "AddIgnoreTarget");

	Params::TgfGameplayAura_AddIgnoreTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAura.BP_NeedApplyEffect
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameplayAura::BP_NeedApplyEffect(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "BP_NeedApplyEffect");

	Params::TgfGameplayAura_BP_NeedApplyEffect Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAura.BroadCastGameplayMessage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuraMessageVerb                 Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTgfGameplayAura::BroadCastGameplayMessage(const struct FGameplayTag& Tag, const struct FAuraMessageVerb& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "BroadCastGameplayMessage");

	Params::TgfGameplayAura_BroadCastGameplayMessage Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAura.GetCapsuleRadius
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfGameplayAura::GetCapsuleRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "GetCapsuleRadius");

	Params::TgfGameplayAura_GetCapsuleRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAura.K2_OnAuraAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTgfAuraManagerComponent*         AuraManagerComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::K2_OnAuraAdded(class UTgfAuraManagerComponent* AuraManagerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "K2_OnAuraAdded");

	Params::TgfGameplayAura_K2_OnAuraAdded Parms{};

	Parms.AuraManagerComponent = AuraManagerComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAura.K2_OnAuraRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTgfAuraManagerComponent*         AuraManagerComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::K2_OnAuraRemoved(class UTgfAuraManagerComponent* AuraManagerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "K2_OnAuraRemoved");

	Params::TgfGameplayAura_K2_OnAuraRemoved Parms{};

	Parms.AuraManagerComponent = AuraManagerComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAura.K2_OnCharacterEnter
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::K2_OnCharacterEnter(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "K2_OnCharacterEnter");

	Params::TgfGameplayAura_K2_OnCharacterEnter Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAura.K2_OnCharacterLeave
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::K2_OnCharacterLeave(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "K2_OnCharacterLeave");

	Params::TgfGameplayAura_K2_OnCharacterLeave Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAura.K2_PreTickAura
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::K2_PreTickAura(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "K2_PreTickAura");

	Params::TgfGameplayAura_K2_PreTickAura Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAura.K2_TickAura
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::K2_TickAura(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "K2_TickAura");

	Params::TgfGameplayAura_K2_TickAura Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayAura.RemoveIgnoreTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameplayAura::RemoveIgnoreTarget(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "RemoveIgnoreTarget");

	Params::TgfGameplayAura_RemoveIgnoreTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAura.GetInstigatorAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* UTgfGameplayAura::GetInstigatorAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "GetInstigatorAbilitySystemComponent");

	Params::TgfGameplayAura_GetInstigatorAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAura.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfGameplayAura::GetOwningActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "GetOwningActor");

	Params::TgfGameplayAura_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAura.GetSourceCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfGameplayAura::GetSourceCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "GetSourceCharacter");

	Params::TgfGameplayAura_GetSourceCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAura.GetTargetCharacters
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ALyraCharacter*>           OutTargets                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfGameplayAura::GetTargetCharacters(TArray<class ALyraCharacter*>* OutTargets) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "GetTargetCharacters");

	Params::TgfGameplayAura_GetTargetCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargets != nullptr)
		*OutTargets = std::move(Parms.OutTargets);
}


// Function LyraGame.TgfGameplayAura.GetTotalRunningTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfGameplayAura::GetTotalRunningTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAura", "GetTotalRunningTime");

	Params::TgfGameplayAura_GetTotalRunningTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayCueNotify_Looping.OnTgfApplication
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTgfGameplayCueNotify_SpawnResultTgfSpawnResults                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    NeedCulling                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfGameplayCueNotify_Looping::OnTgfApplication(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_Looping", "OnTgfApplication");

	Params::TgfGameplayCueNotify_Looping_OnTgfApplication Parms{};

	Parms.Target = Target;
	Parms.Parameters = std::move(Parameters);
	Parms.TgfSpawnResults = std::move(TgfSpawnResults);
	Parms.NeedCulling = NeedCulling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayCueNotify_Looping.OnTgfLoopingStart
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTgfGameplayCueNotify_SpawnResultTgfSpawnResults                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    NeedCulling                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfGameplayCueNotify_Looping::OnTgfLoopingStart(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_Looping", "OnTgfLoopingStart");

	Params::TgfGameplayCueNotify_Looping_OnTgfLoopingStart Parms{};

	Parms.Target = Target;
	Parms.Parameters = std::move(Parameters);
	Parms.TgfSpawnResults = std::move(TgfSpawnResults);
	Parms.NeedCulling = NeedCulling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayCueNotify_Looping.OnTgfRecurring
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTgfGameplayCueNotify_SpawnResultTgfSpawnResults                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    NeedCulling                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfGameplayCueNotify_Looping::OnTgfRecurring(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_Looping", "OnTgfRecurring");

	Params::TgfGameplayCueNotify_Looping_OnTgfRecurring Parms{};

	Parms.Target = Target;
	Parms.Parameters = std::move(Parameters);
	Parms.TgfSpawnResults = std::move(TgfSpawnResults);
	Parms.NeedCulling = NeedCulling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayCueNotify_Looping.OnTgfRemoval
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTgfGameplayCueNotify_SpawnResultTgfSpawnResults                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    NeedCulling                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfGameplayCueNotify_Looping::OnTgfRemoval(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_Looping", "OnTgfRemoval");

	Params::TgfGameplayCueNotify_Looping_OnTgfRemoval Parms{};

	Parms.Target = Target;
	Parms.Parameters = std::move(Parameters);
	Parms.TgfSpawnResults = std::move(TgfSpawnResults);
	Parms.NeedCulling = NeedCulling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameWidgetLibrary.BoolArrayIdxOf
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<bool>                            Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameWidgetLibrary::BoolArrayIdxOf(const TArray<bool>& Array, int32 Idx, bool* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "BoolArrayIdxOf");

	Params::TgfGameWidgetLibrary_BoolArrayIdxOf Parms{};

	Parms.Array = std::move(Array);
	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = Parms.Out;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.BroadcastKeyBindingChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameWidgetLibrary::BroadcastKeyBindingChange(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "BroadcastKeyBindingChange");

	Params::TgfGameWidgetLibrary_BroadcastKeyBindingChange Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameWidgetLibrary.FindInputActionForTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogNotFound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* UTgfGameWidgetLibrary::FindInputActionForTag(const class UUserWidget* UserWidget, const struct FGameplayTag& InputTag, bool bLogNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "FindInputActionForTag");

	Params::TgfGameWidgetLibrary_FindInputActionForTag Parms{};

	Parms.UserWidget = UserWidget;
	Parms.InputTag = std::move(InputTag);
	Parms.bLogNotFound = bLogNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.FindInputActionForTagByController
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogNotFound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* UTgfGameWidgetLibrary::FindInputActionForTagByController(const class APlayerController* PlayerController, const struct FGameplayTag& InputTag, bool bLogNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "FindInputActionForTagByController");

	Params::TgfGameWidgetLibrary_FindInputActionForTagByController Parms{};

	Parms.PlayerController = PlayerController;
	Parms.InputTag = std::move(InputTag);
	Parms.bLogNotFound = bLogNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GameWidgetGetAbilitySystemComponentFromActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* UTgfGameWidgetLibrary::GameWidgetGetAbilitySystemComponentFromActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GameWidgetGetAbilitySystemComponentFromActor");

	Params::TgfGameWidgetLibrary_GameWidgetGetAbilitySystemComponentFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetActiveGameplayEffectShowTotalAndRemainTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameWidgetLibrary::GetActiveGameplayEffectShowTotalAndRemainTime(const struct FActiveGameplayEffectHandle& ActiveHandle, float* RemainTime, float* TotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetActiveGameplayEffectShowTotalAndRemainTime");

	Params::TgfGameWidgetLibrary_GetActiveGameplayEffectShowTotalAndRemainTime Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RemainTime != nullptr)
		*RemainTime = Parms.RemainTime;

	if (TotalTime != nullptr)
		*TotalTime = Parms.TotalTime;
}


// Function LyraGame.TgfGameWidgetLibrary.GetAutoFillQuality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ETgfEquipQuality>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ETgfEquipQuality> UTgfGameWidgetLibrary::GetAutoFillQuality(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetAutoFillQuality");

	Params::TgfGameWidgetLibrary_GetAutoFillQuality Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetCameraFOVAngle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfGameWidgetLibrary::GetCameraFOVAngle(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetCameraFOVAngle");

	Params::TgfGameWidgetLibrary_GetCameraFOVAngle Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetCareerAndRaceFromNecklace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         OutCareer                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           OutRace                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameWidgetLibrary::GetCareerAndRaceFromNecklace(const class ALyraCharacter* Character, ETgfActorCareer* OutCareer, ETgfActorRace* OutRace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetCareerAndRaceFromNecklace");

	Params::TgfGameWidgetLibrary_GetCareerAndRaceFromNecklace Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCareer != nullptr)
		*OutCareer = Parms.OutCareer;

	if (OutRace != nullptr)
		*OutRace = Parms.OutRace;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetCommonInputSubsystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonInputSubsystem*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonInputSubsystem* UTgfGameWidgetLibrary::GetCommonInputSubsystem(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetCommonInputSubsystem");

	Params::TgfGameWidgetLibrary_GetCommonInputSubsystem Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetDisplayCareerAndRace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorCareer                         OutCareer                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRace                           OutRace                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameWidgetLibrary::GetDisplayCareerAndRace(class ALyraCharacter* Character, ETgfActorCareer* OutCareer, ETgfActorRace* OutRace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetDisplayCareerAndRace");

	Params::TgfGameWidgetLibrary_GetDisplayCareerAndRace Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCareer != nullptr)
		*OutCareer = Parms.OutCareer;

	if (OutRace != nullptr)
		*OutRace = Parms.OutRace;
}


// Function LyraGame.TgfGameWidgetLibrary.GetEffectCauserByEffectContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     ContextHandle                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfGameWidgetLibrary::GetEffectCauserByEffectContext(const struct FGameplayEffectContextHandle& ContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetEffectCauserByEffectContext");

	Params::TgfGameWidgetLibrary_GetEffectCauserByEffectContext Parms{};

	Parms.ContextHandle = std::move(ContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetFollowUIManagerComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfGameFollowUIManagerComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfGameFollowUIManagerComponent* UTgfGameWidgetLibrary::GetFollowUIManagerComponent(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetFollowUIManagerComponent");

	Params::TgfGameWidgetLibrary_GetFollowUIManagerComponent Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetGameplayTagFromString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UTgfGameWidgetLibrary::GetGameplayTagFromString(const class FString& TagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetGameplayTagFromString");

	Params::TgfGameWidgetLibrary_GetGameplayTagFromString Parms{};

	Parms.TagString = std::move(TagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetInputKeyByInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraLocalPlayer*                 LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UTgfGameWidgetLibrary::GetInputKeyByInputAction(class ULyraLocalPlayer* LocalPlayer, class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetInputKeyByInputAction");

	Params::TgfGameWidgetLibrary_GetInputKeyByInputAction Parms{};

	Parms.LocalPlayer = LocalPlayer;
	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetInputKeyTextByInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraLocalPlayer*                 LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTgfGameWidgetLibrary::GetInputKeyTextByInputAction(class ULyraLocalPlayer* LocalPlayer, class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetInputKeyTextByInputAction");

	Params::TgfGameWidgetLibrary_GetInputKeyTextByInputAction Parms{};

	Parms.LocalPlayer = LocalPlayer;
	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetLyraCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfGameWidgetLibrary::GetLyraCharacter(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetLyraCharacter");

	Params::TgfGameWidgetLibrary_GetLyraCharacter Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetMagicPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfGameWidgetLibrary::GetMagicPercent(class UAbilitySystemComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetMagicPercent");

	Params::TgfGameWidgetLibrary_GetMagicPercent Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetSoulEnergyPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfGameWidgetLibrary::GetSoulEnergyPercent(class UAbilitySystemComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetSoulEnergyPercent");

	Params::TgfGameWidgetLibrary_GetSoulEnergyPercent Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.GetWidgetViewTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfGameWidgetLibrary::GetWidgetViewTarget(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "GetWidgetViewTarget");

	Params::TgfGameWidgetLibrary_GetWidgetViewTarget Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.Is0penoperationTips
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameWidgetLibrary::Is0penoperationTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "Is0penoperationTips");

	Params::TgfGameWidgetLibrary_Is0penoperationTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.IsPVPMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfGameWidgetLibrary::IsPVPMode(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "IsPVPMode");

	Params::TgfGameWidgetLibrary_IsPVPMode Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameWidgetLibrary.RecomputeGameplayEffectStartWorldTimes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      LyraASC                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGameWidgetLibrary::RecomputeGameplayEffectStartWorldTimes(class ULyraAbilitySystemComponent* LyraASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "RecomputeGameplayEffectStartWorldTimes");

	Params::TgfGameWidgetLibrary_RecomputeGameplayEffectStartWorldTimes Parms{};

	Parms.LyraASC = LyraASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameWidgetLibrary.SetDSAutoFillQuality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ETgfEquipQuality>                QualityList                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfGameWidgetLibrary::SetDSAutoFillQuality(class UUserWidget* UserWidget, const TArray<ETgfEquipQuality>& QualityList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "SetDSAutoFillQuality");

	Params::TgfGameWidgetLibrary_SetDSAutoFillQuality Parms{};

	Parms.UserWidget = UserWidget;
	Parms.QualityList = std::move(QualityList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameWidgetLibrary.ShowHurtNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHurtNotifyMessage               Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTgfGameWidgetLibrary::ShowHurtNum(class APlayerController* PlayerController, const struct FHurtNotifyMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfGameWidgetLibrary", "ShowHurtNum");

	Params::TgfGameWidgetLibrary_ShowHurtNum Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfHealthBarWidget.BP_OnBuffAdd
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTgfGameplayEffect*               GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfHealthBarWidget::BP_OnBuffAdd(class UTgfGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle, float RemainTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "BP_OnBuffAdd");

	Params::TgfHealthBarWidget_BP_OnBuffAdd Parms{};

	Parms.GE = GE;
	Parms.ActiveHandle = std::move(ActiveHandle);
	Parms.RemainTime = RemainTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfHealthBarWidget.BP_OnGERemove
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FActiveGameplayEffectHandle      GEHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfHealthBarWidget::BP_OnGERemove(const struct FActiveGameplayEffectHandle& GEHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "BP_OnGERemove");

	Params::TgfHealthBarWidget_BP_OnGERemove Parms{};

	Parms.GEHandle = std::move(GEHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfHealthBarWidget.GetCurHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetCurHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetCurHealth");

	Params::TgfHealthBarWidget_GetCurHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetCurMagic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetCurMagic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetCurMagic");

	Params::TgfHealthBarWidget_GetCurMagic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetCurNaturalEnergy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetCurNaturalEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetCurNaturalEnergy");

	Params::TgfHealthBarWidget_GetCurNaturalEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetCurShield
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetCurShield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetCurShield");

	Params::TgfHealthBarWidget_GetCurShield Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetCurSoulEnergy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetCurSoulEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetCurSoulEnergy");

	Params::TgfHealthBarWidget_GetCurSoulEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetHealthPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetHealthPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetHealthPercent");

	Params::TgfHealthBarWidget_GetHealthPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetMagicPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetMagicPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetMagicPercent");

	Params::TgfHealthBarWidget_GetMagicPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetMaxHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetMaxHealth");

	Params::TgfHealthBarWidget_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetMaxMagic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetMaxMagic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetMaxMagic");

	Params::TgfHealthBarWidget_GetMaxMagic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetMaxNaturalEnergy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetMaxNaturalEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetMaxNaturalEnergy");

	Params::TgfHealthBarWidget_GetMaxNaturalEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetMaxSoulEnergy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetMaxSoulEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetMaxSoulEnergy");

	Params::TgfHealthBarWidget_GetMaxSoulEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetNaturalEnergyPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetNaturalEnergyPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetNaturalEnergyPercent");

	Params::TgfHealthBarWidget_GetNaturalEnergyPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetShieldPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetShieldPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetShieldPercent");

	Params::TgfHealthBarWidget_GetShieldPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.GetSoulEnergyPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfHealthBarWidget::GetSoulEnergyPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "GetSoulEnergyPercent");

	Params::TgfHealthBarWidget_GetSoulEnergyPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfHealthBarWidget.SetCustomAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      CustomASC                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfHealthBarWidget::SetCustomAttribute(class ULyraAbilitySystemComponent* CustomASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfHealthBarWidget", "SetCustomAttribute");

	Params::TgfHealthBarWidget_SetCustomAttribute Parms{};

	Parms.CustomASC = CustomASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInertanceComponent.BlendingToTarget
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTgfInertanceComponent::BlendingToTarget(float DeltaTime, const struct FVector& InLocation, const struct FVector& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInertanceComponent", "BlendingToTarget");

	Params::TgfInertanceComponent_BlendingToTarget Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.InLocation = std::move(InLocation);
	Parms.Target = std::move(Target);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInertanceComponent.SetComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InSceneComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInertanceComponent::SetComponent(class USceneComponent* InSceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInertanceComponent", "SetComponent");

	Params::TgfInertanceComponent_SetComponent Parms{};

	Parms.InSceneComponent = InSceneComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInertanceAnimInstance.GetInertanceComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInertanceComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInertanceComponent* UTgfInertanceAnimInstance::GetInertanceComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInertanceAnimInstance", "GetInertanceComponent");

	Params::TgfInertanceAnimInstance_GetInertanceComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryCheats.AddBlockingLootSlot
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::AddBlockingLootSlot(int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "AddBlockingLootSlot");

	Params::TgfInventoryCheats_AddBlockingLootSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.AddGearsetLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   GearsetId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DeltaLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::AddGearsetLevel(int32 GearsetId, int32 DeltaLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "AddGearsetLevel");

	Params::TgfInventoryCheats_AddGearsetLevel Parms{};

	Parms.GearsetId = GearsetId;
	Parms.DeltaLevel = DeltaLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.AddItem
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::AddItem(const class FString& AssetName, int32 Nums)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "AddItem");

	Params::TgfInventoryCheats_AddItem Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.Nums = Nums;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.AddLootItem
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::AddLootItem(int32 ItemId, int32 Nums)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "AddLootItem");

	Params::TgfInventoryCheats_AddLootItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Nums = Nums;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.AddPackage
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   PackageId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::AddPackage(int32 PackageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "AddPackage");

	Params::TgfInventoryCheats_AddPackage Parms{};

	Parms.PackageId = PackageId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.ClearAllGearsetLevel
// (Final, Exec, Native, Public)

void UTgfInventoryCheats::ClearAllGearsetLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "ClearAllGearsetLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.InvenChangeSize
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::InvenChangeSize(int32 SizeX, int32 SizeY, int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "InvenChangeSize");

	Params::TgfInventoryCheats_InvenChangeSize Parms{};

	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.ItemReady
// (Final, Exec, Native, Public)

void UTgfInventoryCheats::ItemReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "ItemReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.RecoverAmmo
// (Final, Exec, Native, Public)

void UTgfInventoryCheats::RecoverAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "RecoverAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryCheats.RemoveItem
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nums                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryCheats::RemoveItem(const class FString& AssetName, int32 Nums)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryCheats", "RemoveItem");

	Params::TgfInventoryCheats_RemoveItem Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.Nums = Nums;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.GetDefaultInventorySize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryManagerComponent::GetDefaultInventorySize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfInventoryManagerComponent", "GetDefaultInventorySize");

	Params::TgfInventoryManagerComponent_GetDefaultInventorySize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.GetDefaultInventorySizeInPVP
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryManagerComponent::GetDefaultInventorySizeInPVP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfInventoryManagerComponent", "GetDefaultInventorySizeInPVP");

	Params::TgfInventoryManagerComponent_GetDefaultInventorySizeInPVP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.AddItemInstanceWithPosition
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::AddItemInstanceWithPosition(class ULyraInventoryItemInstance* ItemInstance, const struct FIntPoint& Position, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "AddItemInstanceWithPosition");

	Params::TgfInventoryManagerComponent_AddItemInstanceWithPosition Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Position = std::move(Position);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.AutoMergeItemStacks
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UTgfInventoryManagerComponent::AutoMergeItemStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "AutoMergeItemStacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.ChangeEntryPosByInstance
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::ChangeEntryPosByInstance(class ULyraInventoryItemInstance* ItemInstance, const struct FIntPoint& Position, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "ChangeEntryPosByInstance");

	Params::TgfInventoryManagerComponent_ChangeEntryPosByInstance Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Position = std::move(Position);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.DropAllAddtionalInventoryItem
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>DropItems                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::DropAllAddtionalInventoryItem(TArray<class ULyraInventoryItemInstance*>* DropItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "DropAllAddtionalInventoryItem");

	Params::TgfInventoryManagerComponent_DropAllAddtionalInventoryItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DropItems != nullptr)
		*DropItems = std::move(Parms.DropItems);
}


// Function LyraGame.TgfInventoryManagerComponent.ExchangeItemInstances
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>AddInstances                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ULyraInventoryItemInstance*>RemoveInstances                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckInInventory                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::ExchangeItemInstances(const TArray<class ULyraInventoryItemInstance*>& AddInstances, const TArray<class ULyraInventoryItemInstance*>& RemoveInstances, ELyraInventoryType InventoryType, bool CheckInInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "ExchangeItemInstances");

	Params::TgfInventoryManagerComponent_ExchangeItemInstances Parms{};

	Parms.AddInstances = std::move(AddInstances);
	Parms.RemoveInstances = std::move(RemoveInstances);
	Parms.InventoryType = InventoryType;
	Parms.CheckInInventory = CheckInInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.InitAdditionalInventoryWithSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        InventorySize                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::InitAdditionalInventoryWithSize(const struct FIntPoint& InventorySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "InitAdditionalInventoryWithSize");

	Params::TgfInventoryManagerComponent_InitAdditionalInventoryWithSize Parms{};

	Parms.InventorySize = std::move(InventorySize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.InitInventoryWithSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        InventorySize                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::InitInventoryWithSize(const struct FIntPoint& InventorySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "InitInventoryWithSize");

	Params::TgfInventoryManagerComponent_InitInventoryWithSize Parms{};

	Parms.InventorySize = std::move(InventorySize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.IsAdditonalInventoryEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::IsAdditonalInventoryEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "IsAdditonalInventoryEnable");

	Params::TgfInventoryManagerComponent_IsAdditonalInventoryEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.OnRep_AdditionalSize
// (Native, Protected)

void UTgfInventoryManagerComponent::OnRep_AdditionalSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "OnRep_AdditionalSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.OnRep_Size
// (Native, Protected)

void UTgfInventoryManagerComponent::OnRep_Size()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "OnRep_Size");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.ResizeInventory
// (BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        NewSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryManagerComponent::ResizeInventory(const struct FIntPoint& NewSize, ELyraInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "ResizeInventory");

	Params::TgfInventoryManagerComponent_ResizeInventory Parms{};

	Parms.NewSize = std::move(NewSize);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryManagerComponent.CanExchangeItemInstances
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>AddInstances                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ULyraInventoryItemInstance*>RemoveInstances                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckInInventory                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::CanExchangeItemInstances(const TArray<class ULyraInventoryItemInstance*>& AddInstances, const TArray<class ULyraInventoryItemInstance*>& RemoveInstances, ELyraInventoryType InventoryType, bool CheckInInventory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "CanExchangeItemInstances");

	Params::TgfInventoryManagerComponent_CanExchangeItemInstances Parms{};

	Parms.AddInstances = std::move(AddInstances);
	Parms.RemoveInstances = std::move(RemoveInstances);
	Parms.InventoryType = InventoryType;
	Parms.CheckInInventory = CheckInInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.CanResizeInventory
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        NewSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::CanResizeInventory(const struct FIntPoint& NewSize, ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "CanResizeInventory");

	Params::TgfInventoryManagerComponent_CanResizeInventory Parms{};

	Parms.NewSize = std::move(NewSize);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.GetEntryByPos
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLyraInventoryEntry              Entry                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::GetEntryByPos(const struct FIntPoint& Position, struct FLyraInventoryEntry* Entry, ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "GetEntryByPos");

	Params::TgfInventoryManagerComponent_GetEntryByPos Parms{};

	Parms.Position = std::move(Position);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Entry != nullptr)
		*Entry = std::move(Parms.Entry);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.GetItemInstanceByPos
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* UTgfInventoryManagerComponent::GetItemInstanceByPos(const struct FIntPoint& Position, ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "GetItemInstanceByPos");

	Params::TgfInventoryManagerComponent_GetItemInstanceByPos Parms{};

	Parms.Position = std::move(Position);
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.GetItemSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryManagerComponent::GetItemSize(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "GetItemSize");

	Params::TgfInventoryManagerComponent_GetItemSize Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryManagerComponent::GetSize(ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "GetSize");

	Params::TgfInventoryManagerComponent_GetSize Parms{};

	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.IsPositionValid
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ItemSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IgnoreIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::IsPositionValid(const struct FIntPoint& Position, const struct FIntPoint& ItemSize, ELyraInventoryType InventoryType, int32 IgnoreIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "IsPositionValid");

	Params::TgfInventoryManagerComponent_IsPositionValid Parms{};

	Parms.Position = std::move(Position);
	Parms.ItemSize = std::move(ItemSize);
	Parms.InventoryType = InventoryType;
	Parms.IgnoreIndex = IgnoreIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.IsPositionValidByItemDef
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::IsPositionValidByItemDef(const struct FIntPoint& Position, TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "IsPositionValidByItemDef");

	Params::TgfInventoryManagerComponent_IsPositionValidByItemDef Parms{};

	Parms.Position = std::move(Position);
	Parms.ItemDef = ItemDef;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryManagerComponent.IsPositionValidByItemInstance
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryManagerComponent::IsPositionValidByItemInstance(const struct FIntPoint& Position, class ULyraInventoryItemInstance* ItemInstance, ELyraInventoryType InventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryManagerComponent", "IsPositionValidByItemInstance");

	Params::TgfInventoryManagerComponent_IsPositionValidByItemInstance Parms{};

	Parms.Position = std::move(Position);
	Parms.ItemInstance = ItemInstance;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper_InGame.CreateInventoryRoleWrapperFromActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       RoleDisplaytable                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryRoleWrapper_InGame*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryRoleWrapper_InGame* UTgfInventoryRoleWrapper_InGame::CreateInventoryRoleWrapperFromActor(class AActor* Actor, class UDataTable* RoleDisplaytable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfInventoryRoleWrapper_InGame", "CreateInventoryRoleWrapperFromActor");

	Params::TgfInventoryRoleWrapper_InGame_CreateInventoryRoleWrapperFromActor Parms{};

	Parms.Actor = Actor;
	Parms.RoleDisplaytable = RoleDisplaytable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper_InGame.GetActorCareer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorCareer                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorCareer UTgfInventoryRoleWrapper_InGame::GetActorCareer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper_InGame", "GetActorCareer");

	Params::TgfInventoryRoleWrapper_InGame_GetActorCareer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryRoleWrapper_InGame.GetActorRace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorRace                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorRace UTgfInventoryRoleWrapper_InGame::GetActorRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryRoleWrapper_InGame", "GetActorRace");

	Params::TgfInventoryRoleWrapper_InGame_GetActorRace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.AreItemGearable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemWrapper*         Diamond                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::AreItemGearable(const class UTgfInventoryItemWrapper* Item, const class UTgfInventoryItemWrapper* Diamond, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfInventoryWrapper", "AreItemGearable");

	Params::TgfInventoryWrapper_AreItemGearable Parms{};

	Parms.Item = Item;
	Parms.Diamond = Diamond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.AddToInventoryAutoPlacement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             ItemInventory                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::AddToInventoryAutoPlacement(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool bCommit, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "AddToInventoryAutoPlacement");

	Params::TgfInventoryWrapper_AddToInventoryAutoPlacement Parms{};

	Parms.Item = Item;
	Parms.ItemInventory = ItemInventory;
	Parms.bCommit = bCommit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.AddToMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          WidgetToAdd                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryWrapper::AddToMenu(class UWidget* WidgetToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "AddToMenu");

	Params::TgfInventoryWrapper_AddToMenu Parms{};

	Parms.WidgetToAdd = WidgetToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.CanDiscardEquipment
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfEquipmentWrapper*             Equipment                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfEquipmentWrapper*>     OutEquipmentsToDiscard                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::CanDiscardEquipment(class UTgfEquipmentWrapper* Equipment, TArray<class UTgfEquipmentWrapper*>* OutEquipmentsToDiscard, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "CanDiscardEquipment");

	Params::TgfInventoryWrapper_CanDiscardEquipment Parms{};

	Parms.Equipment = Equipment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEquipmentsToDiscard != nullptr)
		*OutEquipmentsToDiscard = std::move(Parms.OutEquipmentsToDiscard);

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.CanDiscardInventoryItem
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::CanDiscardInventoryItem(class UTgfInventoryItemWrapper* Item, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "CanDiscardInventoryItem");

	Params::TgfInventoryWrapper_CanDiscardInventoryItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.CanTakeoffMainweapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::CanTakeoffMainweapon(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "CanTakeoffMainweapon");

	Params::TgfInventoryWrapper_CanTakeoffMainweapon Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.CheckMyHeirloom
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::CheckMyHeirloom(class UTgfInventoryItemWrapper* Item, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "CheckMyHeirloom");

	Params::TgfInventoryWrapper_CheckMyHeirloom Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.ClearEquipmentCache
// (Final, Native, Public, BlueprintCallable)

void UTgfInventoryWrapper::ClearEquipmentCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "ClearEquipmentCache");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.DropToEquipmentSlot
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryDragDropOperation*   DragOperation                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::DropToEquipmentSlot(class UTgfInventoryDragDropOperation* DragOperation, ETgfEquipSlot Slot, bool bCommit, int32 SlotId, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "DropToEquipmentSlot");

	Params::TgfInventoryWrapper_DropToEquipmentSlot Parms{};

	Parms.DragOperation = DragOperation;
	Parms.Slot = Slot;
	Parms.bCommit = bCommit;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.DropToEquipmentSlotForLua
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryDragDropOperation*   DragOperation                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::DropToEquipmentSlotForLua(class UTgfInventoryDragDropOperation* DragOperation, int32 Slot, bool bCommit, int32 SlotId, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "DropToEquipmentSlotForLua");

	Params::TgfInventoryWrapper_DropToEquipmentSlotForLua Parms{};

	Parms.DragOperation = DragOperation;
	Parms.Slot = Slot;
	Parms.bCommit = bCommit;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.DropToInventory
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UTgfInventoryDragDropOperation*   DragOperation                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        DropPosition                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        DropSize                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::DropToInventory(class UTgfInventoryDragDropOperation* DragOperation, const struct FIntPoint& DropPosition, const struct FIntPoint& DropSize, bool bCommit, int32 SlotId, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "DropToInventory");

	Params::TgfInventoryWrapper_DropToInventory Parms{};

	Parms.DragOperation = DragOperation;
	Parms.DropPosition = std::move(DropPosition);
	Parms.DropSize = std::move(DropSize);
	Parms.bCommit = bCommit;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.FindCompareTargetForItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemWrapper*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryItemWrapper* UTgfInventoryWrapper::FindCompareTargetForItem(class UTgfInventoryItemWrapper* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "FindCompareTargetForItem");

	Params::TgfInventoryWrapper_FindCompareTargetForItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GearinItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             ItemContext                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemWrapper*         Diamond                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             FromContext                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           EquipSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GemSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryWrapper::GearinItem(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemContext, class UTgfInventoryItemWrapper* Diamond, class UTgfInventoryWrapper* FromContext, ETgfEquipSlot EquipSlot, int32 GemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GearinItem");

	Params::TgfInventoryWrapper_GearinItem Parms{};

	Parms.Item = Item;
	Parms.ItemContext = ItemContext;
	Parms.Diamond = Diamond;
	Parms.FromContext = FromContext;
	Parms.EquipSlot = EquipSlot;
	Parms.GemSlot = GemSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.GetAllEquipments
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UTgfEquipmentWrapper*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTgfEquipmentWrapper*> UTgfInventoryWrapper::GetAllEquipments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetAllEquipments");

	Params::TgfInventoryWrapper_GetAllEquipments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetAverageDefence
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfInventoryWrapper::GetAverageDefence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetAverageDefence");

	Params::TgfInventoryWrapper_GetAverageDefence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetAverageDPH
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfInventoryWrapper::GetAverageDPH()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetAverageDPH");

	Params::TgfInventoryWrapper_GetAverageDPH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetCurrentGroup
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryWrapper::GetCurrentGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetCurrentGroup");

	Params::TgfInventoryWrapper_GetCurrentGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetEquipmentBySlot
// (Native, Public, BlueprintCallable)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentWrapper*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfEquipmentWrapper* UTgfInventoryWrapper::GetEquipmentBySlot(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetEquipmentBySlot");

	Params::TgfInventoryWrapper_GetEquipmentBySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetInventoryItems
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UTgfInventoryItemWrapper*> OutItems                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bReadFromCache                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryWrapper::GetInventoryItems(TArray<class UTgfInventoryItemWrapper*>* OutItems, bool bReadFromCache)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetInventoryItems");

	Params::TgfInventoryWrapper_GetInventoryItems Parms{};

	Parms.bReadFromCache = bReadFromCache;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItems != nullptr)
		*OutItems = std::move(Parms.OutItems);
}


// Function LyraGame.TgfInventoryWrapper.GetInventoryItemsOfPage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReadFromCache                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryItemWrapper*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTgfInventoryItemWrapper*> UTgfInventoryWrapper::GetInventoryItemsOfPage(bool bReadFromCache)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetInventoryItemsOfPage");

	Params::TgfInventoryWrapper_GetInventoryItemsOfPage Parms{};

	Parms.bReadFromCache = bReadFromCache;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetItemFromPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemWrapper*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryItemWrapper* UTgfInventoryWrapper::GetItemFromPosition(const struct FIntPoint& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetItemFromPosition");

	Params::TgfInventoryWrapper_GetItemFromPosition Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.InvokeDragInitiatedEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryDragDropOperation*   DragOperation                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryWrapper::InvokeDragInitiatedEvent(class UTgfInventoryDragDropOperation* DragOperation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "InvokeDragInitiatedEvent");

	Params::TgfInventoryWrapper_InvokeDragInitiatedEvent Parms{};

	Parms.DragOperation = DragOperation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.IsSoulBoundParts
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::IsSoulBoundParts(ETgfEquipSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "IsSoulBoundParts");

	Params::TgfInventoryWrapper_IsSoulBoundParts Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.RemoveEquipmentToInventory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfEquipmentWrapper*             Equipment                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::RemoveEquipmentToInventory(class UTgfEquipmentWrapper* Equipment, bool bCommit, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "RemoveEquipmentToInventory");

	Params::TgfInventoryWrapper_RemoveEquipmentToInventory Parms{};

	Parms.Equipment = Equipment;
	Parms.bCommit = bCommit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.SetCurrentGroup
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryWrapper::SetCurrentGroup(int32 Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "SetCurrentGroup");

	Params::TgfInventoryWrapper_SetCurrentGroup Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.SetInventoryType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfInventoryType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryWrapper::SetInventoryType(ETgfInventoryType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "SetInventoryType");

	Params::TgfInventoryWrapper_SetInventoryType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.ToggleCompareMode
// (Final, Native, Public, BlueprintCallable)

void UTgfInventoryWrapper::ToggleCompareMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "ToggleCompareMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.ToggleOwnerListMode
// (Final, Native, Public, BlueprintCallable)

void UTgfInventoryWrapper::ToggleOwnerListMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "ToggleOwnerListMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapper.TryAutoStack
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             ItemInventory                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEquipSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInventory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::TryAutoStack(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool bEquipSlot, bool bInventory, bool bCommit, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryAutoStack");

	Params::TgfInventoryWrapper_TryAutoStack Parms{};

	Parms.Item = Item;
	Parms.ItemInventory = ItemInventory;
	Parms.bEquipSlot = bEquipSlot;
	Parms.bInventory = bInventory;
	Parms.bCommit = bCommit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.TryBeginItemDivide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         SourceItem                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DivideNumber                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryItemWrapper*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryItemWrapper* UTgfInventoryWrapper::TryBeginItemDivide(class UTgfInventoryItemWrapper* SourceItem, int32 DivideNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryBeginItemDivide");

	Params::TgfInventoryWrapper_TryBeginItemDivide Parms{};

	Parms.SourceItem = SourceItem;
	Parms.DivideNumber = DivideNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.TryCallInventoryLeftClickOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::TryCallInventoryLeftClickOverride(class UTgfInventoryItemWrapper* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryCallInventoryLeftClickOverride");

	Params::TgfInventoryWrapper_TryCallInventoryLeftClickOverride Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.TryCallInventoryRightClickOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::TryCallInventoryRightClickOverride(class UTgfInventoryItemWrapper* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryCallInventoryRightClickOverride");

	Params::TgfInventoryWrapper_TryCallInventoryRightClickOverride Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.TryMoveToInventory
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             ItemInventory                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DisableStack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::TryMoveToInventory(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool DisableStack, bool bCommit, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryMoveToInventory");

	Params::TgfInventoryWrapper_TryMoveToInventory Parms{};

	Parms.Item = Item;
	Parms.ItemInventory = ItemInventory;
	Parms.DisableStack = DisableStack;
	Parms.bCommit = bCommit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.TryPutOnItem
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             ItemInventory                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTargetEmptySlotOnly                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCommit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::TryPutOnItem(class UTgfInventoryItemWrapper* Item, class UTgfInventoryWrapper* ItemInventory, bool bTargetEmptySlotOnly, bool bCommit, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryPutOnItem");

	Params::TgfInventoryWrapper_TryPutOnItem Parms{};

	Parms.Item = Item;
	Parms.ItemInventory = ItemInventory;
	Parms.bTargetEmptySlotOnly = bTargetEmptySlotOnly;
	Parms.bCommit = bCommit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.TryUseItem
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::TryUseItem(class UTgfInventoryItemWrapper* Item, int32 Count, int32 Param_Index, class FText* OutFailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "TryUseItem");

	Params::TgfInventoryWrapper_TryUseItem Parms{};

	Parms.Item = Item;
	Parms.Count = Count;
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.CanSwapEquipments
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           SlotA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           SlotB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::CanSwapEquipments(ETgfEquipSlot SlotA, ETgfEquipSlot SlotB, class FText* OutFailReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "CanSwapEquipments");

	Params::TgfInventoryWrapper_CanSwapEquipments Parms{};

	Parms.SlotA = SlotA;
	Parms.SlotB = SlotB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.FindBestEquipSlotForItem
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UTgfInventoryWrapper::FindBestEquipSlotForItem(class UTgfInventoryItemWrapper* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "FindBestEquipSlotForItem");

	Params::TgfInventoryWrapper_FindBestEquipSlotForItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetCharacterCareer
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorCareer                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorCareer UTgfInventoryWrapper::GetCharacterCareer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetCharacterCareer");

	Params::TgfInventoryWrapper_GetCharacterCareer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetCharacterRace
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorRace                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorRace UTgfInventoryWrapper::GetCharacterRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetCharacterRace");

	Params::TgfInventoryWrapper_GetCharacterRace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetCurrentWeaponSlot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponChangeSlot                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponChangeSlot UTgfInventoryWrapper::GetCurrentWeaponSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetCurrentWeaponSlot");

	Params::TgfInventoryWrapper_GetCurrentWeaponSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetEquipmentBySlotCached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfEquipmentWrapper*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfEquipmentWrapper* UTgfInventoryWrapper::GetEquipmentBySlotCached(ETgfEquipSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetEquipmentBySlotCached");

	Params::TgfInventoryWrapper_GetEquipmentBySlotCached Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetEquipSlotOfItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfEquipSlot UTgfInventoryWrapper::GetEquipSlotOfItem(const class UTgfInventoryItemWrapper* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetEquipSlotOfItem");

	Params::TgfInventoryWrapper_GetEquipSlotOfItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetGearsetLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   GearsetId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryWrapper::GetGearsetLevel(int32 GearsetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetGearsetLevel");

	Params::TgfInventoryWrapper_GetGearsetLevel Parms{};

	Parms.GearsetId = GearsetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetInventorySize
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryWrapper::GetInventorySize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetInventorySize");

	Params::TgfInventoryWrapper_GetInventorySize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetItemPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryWrapper::GetItemPosition(const class UTgfInventoryItemWrapper* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetItemPosition");

	Params::TgfInventoryWrapper_GetItemPosition Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetItemSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UTgfInventoryWrapper::GetItemSize(TSubclassOf<class ULyraInventoryItemDefinition> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetItemSize");

	Params::TgfInventoryWrapper_GetItemSize Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetItemTooltipWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ITooltipWidget>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class ITooltipWidget> UTgfInventoryWrapper::GetItemTooltipWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetItemTooltipWidget");

	Params::TgfInventoryWrapper_GetItemTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetOverlappedItems
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        Span                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTgfInventoryItemWrapper*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTgfInventoryItemWrapper*> UTgfInventoryWrapper::GetOverlappedItems(const struct FIntPoint& Position, const struct FIntPoint& Span) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetOverlappedItems");

	Params::TgfInventoryWrapper_GetOverlappedItems Parms{};

	Parms.Position = std::move(Position);
	Parms.Span = std::move(Span);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetOwningCharacter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfInventoryWrapper::GetOwningCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetOwningCharacter");

	Params::TgfInventoryWrapper_GetOwningCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.GetParentInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInventoryWrapper*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryWrapper* UTgfInventoryWrapper::GetParentInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "GetParentInventory");

	Params::TgfInventoryWrapper_GetParentInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.HasAdditionalInventory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::HasAdditionalInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "HasAdditionalInventory");

	Params::TgfInventoryWrapper_HasAdditionalInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.HasBlockTag
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::HasBlockTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "HasBlockTag");

	Params::TgfInventoryWrapper_HasBlockTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.IsAdditionalInventoryEnable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::IsAdditionalInventoryEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "IsAdditionalInventoryEnable");

	Params::TgfInventoryWrapper_IsAdditionalInventoryEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.IsMithrillCharacter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::IsMithrillCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "IsMithrillCharacter");

	Params::TgfInventoryWrapper_IsMithrillCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.MatchEquipmentWithSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRoughlyMatch                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutFailReason                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper::MatchEquipmentWithSlot(class UTgfInventoryItemWrapper* Item, ETgfEquipSlot Slot, bool* bRoughlyMatch, class FText* OutFailReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "MatchEquipmentWithSlot");

	Params::TgfInventoryWrapper_MatchEquipmentWithSlot Parms{};

	Parms.Item = Item;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bRoughlyMatch != nullptr)
		*bRoughlyMatch = Parms.bRoughlyMatch;

	if (OutFailReason != nullptr)
		*OutFailReason = std::move(Parms.OutFailReason);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper.QueryRequirementForEquipment
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfInventoryRequirementQuery    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTgfInventoryRequirementQuery UTgfInventoryWrapper::QueryRequirementForEquipment(class UTgfInventoryItemWrapper* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper", "QueryRequirementForEquipment");

	Params::TgfInventoryWrapper_QueryRequirementForEquipment Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHeroComponent.FindHeroComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraHeroComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraHeroComponent* ULyraHeroComponent::FindHeroComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraHeroComponent", "FindHeroComponent");

	Params::LyraHeroComponent_FindHeroComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHeroComponent.AddLookMovingScaleAndClamp
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    AddClamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2f                        Clamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::AddLookMovingScaleAndClamp(bool AddClamp, const struct FVector2f& Clamp, bool AddScale, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "AddLookMovingScaleAndClamp");

	Params::LyraHeroComponent_AddLookMovingScaleAndClamp Parms{};

	Parms.AddClamp = AddClamp;
	Parms.Clamp = std::move(Clamp);
	Parms.AddScale = AddScale;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.AddMoveInterrputAbilityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AbilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::AddMoveInterrputAbilityTag(const struct FGameplayTag& AbilityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "AddMoveInterrputAbilityTag");

	Params::LyraHeroComponent_AddMoveInterrputAbilityTag Parms{};

	Parms.AbilityTag = std::move(AbilityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.AddMovingScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::AddMovingScale(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "AddMovingScale");

	Params::LyraHeroComponent_AddMovingScale Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.ClearAbilityCameraModeFromServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FGameplayAbilitySpecHandle       OwningSpecHandle                                       (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::ClearAbilityCameraModeFromServer(const struct FGameplayAbilitySpecHandle& OwningSpecHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "ClearAbilityCameraModeFromServer");

	Params::LyraHeroComponent_ClearAbilityCameraModeFromServer Parms{};

	Parms.OwningSpecHandle = std::move(OwningSpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.RemoveAnimationMoveScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::RemoveAnimationMoveScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "RemoveAnimationMoveScale");

	Params::LyraHeroComponent_RemoveAnimationMoveScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.RemoveLookMovingScaleAndClamp
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    AddClamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2f                        Clamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::RemoveLookMovingScaleAndClamp(bool AddClamp, const struct FVector2f& Clamp, bool AddScale, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "RemoveLookMovingScaleAndClamp");

	Params::LyraHeroComponent_RemoveLookMovingScaleAndClamp Parms{};

	Parms.AddClamp = AddClamp;
	Parms.Clamp = std::move(Clamp);
	Parms.AddScale = AddScale;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.RemoveMoveInterrputAbilityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AbilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::RemoveMoveInterrputAbilityTag(const struct FGameplayTag& AbilityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "RemoveMoveInterrputAbilityTag");

	Params::LyraHeroComponent_RemoveMoveInterrputAbilityTag Parms{};

	Parms.AbilityTag = std::move(AbilityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.ResetInspectTimer
// (Final, Native, Protected, BlueprintCallable)

void ULyraHeroComponent::ResetInspectTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "ResetInspectTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.SetAbilityCameraModeFromServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      CameraMode                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       OwningSpecHandle                                       (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::SetAbilityCameraModeFromServer(TSubclassOf<class ULyraCameraMode> CameraMode, const struct FGameplayAbilitySpecHandle& OwningSpecHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "SetAbilityCameraModeFromServer");

	Params::LyraHeroComponent_SetAbilityCameraModeFromServer Parms{};

	Parms.CameraMode = CameraMode;
	Parms.OwningSpecHandle = std::move(OwningSpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.TryInspectWeapon
// (Final, Native, Protected, BlueprintCallable)

void ULyraHeroComponent::TryInspectWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "TryInspectWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.UpdateInspectTimer
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHeroComponent::UpdateInspectTimer(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "UpdateInspectTimer");

	Params::LyraHeroComponent_UpdateInspectTimer Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHeroComponent.DetermineCameraMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraCameraMode> ULyraHeroComponent::DetermineCameraMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "DetermineCameraMode");

	Params::LyraHeroComponent_DetermineCameraMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHeroComponent.DetermineCameraModeThirdPerson
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraCameraMode> ULyraHeroComponent::DetermineCameraModeThirdPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHeroComponent", "DetermineCameraModeThirdPerson");

	Params::LyraHeroComponent_DetermineCameraModeThirdPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper_InGame.CheckLootDisVaild
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ULyraInventoryManagerComponent*   LootInventoryManager                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryWrapper_InGame::CheckLootDisVaild(const class ULyraInventoryManagerComponent* LootInventoryManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper_InGame", "CheckLootDisVaild");

	Params::TgfInventoryWrapper_InGame_CheckLootDisVaild Parms{};

	Parms.LootInventoryManager = LootInventoryManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper_InGame.DropItemInstance
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UTgfInventoryItemWrapper*         Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   OwningCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* UTgfInventoryWrapper_InGame::DropItemInstance(class UTgfInventoryItemWrapper* Item, class ALyraCharacter* OwningCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper_InGame", "DropItemInstance");

	Params::TgfInventoryWrapper_InGame_DropItemInstance Parms{};

	Parms.Item = Item;
	Parms.OwningCharacter = OwningCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryWrapper_InGame.OnAttributeChanged
// (Final, Native, Protected)
// Parameters:
// class UTgfAttributeComponent*           AttributeComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryWrapper_InGame::OnAttributeChanged(class UTgfAttributeComponent* AttributeComponent, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryWrapper_InGame", "OnAttributeChanged");

	Params::TgfInventoryWrapper_InGame_OnAttributeChanged Parms{};

	Parms.AttributeComponent = AttributeComponent;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryWrapperLibrary_InGame.CreateInventoryWrapperFromActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfInventoryType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOverlay*                         InMainOverlayPanel                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class ITooltipWidget>  InItemTooltipWidget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper*             ParentInventory                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraInventoryType                      InLyraInventoryType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfInventoryWrapper_InGame*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfInventoryWrapper_InGame* UTgfInventoryWrapperLibrary_InGame::CreateInventoryWrapperFromActor(class AActor* Actor, ETgfInventoryType Type, class UOverlay* InMainOverlayPanel, TScriptInterface<class ITooltipWidget> InItemTooltipWidget, class UTgfInventoryWrapper* ParentInventory, ELyraInventoryType InLyraInventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfInventoryWrapperLibrary_InGame", "CreateInventoryWrapperFromActor");

	Params::TgfInventoryWrapperLibrary_InGame_CreateInventoryWrapperFromActor Parms{};

	Parms.Actor = Actor;
	Parms.Type = Type;
	Parms.InMainOverlayPanel = InMainOverlayPanel;
	Parms.InItemTooltipWidget = InItemTooltipWidget;
	Parms.ParentInventory = ParentInventory;
	Parms.InLyraInventoryType = InLyraInventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemAnimInstance.IsOnDedicatedServer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfItemAnimInstance::IsOnDedicatedServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemAnimInstance", "IsOnDedicatedServer");

	Params::TgfItemAnimInstance_IsOnDedicatedServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemCosmeticComponent.CleanSlotSkins
// (Final, Native, Public, BlueprintCallable)

void UTgfItemCosmeticComponent::CleanSlotSkins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "CleanSlotSkins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfItemCosmeticComponent.GetAllSkinIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UTgfItemCosmeticComponent::GetAllSkinIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "GetAllSkinIDs");

	Params::TgfItemCosmeticComponent_GetAllSkinIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemCosmeticComponent.GetBestFitDefByDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>Def                                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> UTgfItemCosmeticComponent::GetBestFitDefByDefinition(TSubclassOf<class ULyraInventoryItemDefinition> Def, int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "GetBestFitDefByDefinition");

	Params::TgfItemCosmeticComponent_GetBestFitDefByDefinition Parms{};

	Parms.Def = Def;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemCosmeticComponent.GetBestFitDefByInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULyraInventoryItemInstance*       Instance                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> UTgfItemCosmeticComponent::GetBestFitDefByInstance(const class ULyraInventoryItemInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "GetBestFitDefByInstance");

	Params::TgfItemCosmeticComponent_GetBestFitDefByInstance Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemCosmeticComponent.GetBestFitKillEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfItemEffectDefinition         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfItemEffectDefinition UTgfItemCosmeticComponent::GetBestFitKillEffect(int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "GetBestFitKillEffect");

	Params::TgfItemCosmeticComponent_GetBestFitKillEffect Parms{};

	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemCosmeticComponent.GetSlotSkinId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfSkinSlot                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfSkinCategory                        Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfItemCosmeticComponent::GetSlotSkinId(ETgfSkinSlot Type, ETgfSkinCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "GetSlotSkinId");

	Params::TgfItemCosmeticComponent_GetSlotSkinId Parms{};

	Parms.Type = Type;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemCosmeticComponent.SetPushedData
// (Final, Native, Public, BlueprintCallable)

void UTgfItemCosmeticComponent::SetPushedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "SetPushedData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfItemCosmeticComponent.SetSlotSkinId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfSkinSlot                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfSkinCategory                        SkinCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfItemCosmeticComponent::SetSlotSkinId(ETgfSkinSlot Type, ETgfSkinCategory SkinCategory, int32 SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "SetSlotSkinId");

	Params::TgfItemCosmeticComponent_SetSlotSkinId Parms{};

	Parms.Type = Type;
	Parms.SkinCategory = SkinCategory;
	Parms.SkinId = SkinId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfItemCosmeticComponent.SetSlotSkinIdServerOnly
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// ETgfSkinSlot                            Part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfItemCosmeticComponent::SetSlotSkinIdServerOnly(ETgfSkinSlot Part, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemCosmeticComponent", "SetSlotSkinIdServerOnly");

	Params::TgfItemCosmeticComponent_SetSlotSkinIdServerOnly Parms{};

	Parms.Part = Part;
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfItemWidget.BP_OnCooldownStart
// (Event, Public, BlueprintEvent)

void UTgfItemWidget::BP_OnCooldownStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemWidget", "BP_OnCooldownStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfItemWidget.FormatCooldownTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CDTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfItemWidget::FormatCooldownTime(float CDTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemWidget", "FormatCooldownTime");

	Params::TgfItemWidget_FormatCooldownTime Parms{};

	Parms.CDTime = CDTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfItemWidget.SetCoolDownTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfGameplayAbility>  GAClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfItemWidget::SetCoolDownTags(TSubclassOf<class UTgfGameplayAbility> GAClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfItemWidget", "SetCoolDownTags");

	Params::TgfItemWidget_SetCoolDownTags Parms{};

	Parms.GAClass = GAClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ActivateAllEscapeDevices
// (Final, Exec, Native, Public)

void UTgfLevelCheats::ActivateAllEscapeDevices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ActivateAllEscapeDevices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.DsQuitGame
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::DsQuitGame(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "DsQuitGame");

	Params::TgfLevelCheats_DsQuitGame Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.EndCurrentPhase
// (Final, Exec, Native, Public)

void UTgfLevelCheats::EndCurrentPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "EndCurrentPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ForceGC
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    CallServer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FullPurge                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::ForceGC(bool CallServer, bool FullPurge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ForceGC");

	Params::TgfLevelCheats_ForceGC Parms{};

	Parms.CallServer = CallServer;
	Parms.FullPurge = FullPurge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.MultiWorldTravel
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           MapPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::MultiWorldTravel(const class FString& MapPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "MultiWorldTravel");

	Params::TgfLevelCheats_MultiWorldTravel Parms{};

	Parms.MapPath = std::move(MapPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.PrintPortalLocations
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::PrintPortalLocations(int32 PortalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "PrintPortalLocations");

	Params::TgfLevelCheats_PrintPortalLocations Parms{};

	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.SetDeathZoneEnabled
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::SetDeathZoneEnabled(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "SetDeathZoneEnabled");

	Params::TgfLevelCheats_SetDeathZoneEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ShowBattleId
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bIsShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::ShowBattleId(bool bIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ShowBattleId");

	Params::TgfLevelCheats_ShowBattleId Parms{};

	Parms.bIsShow = bIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ShowGoblinThief
// (Final, Exec, Native, Public)

void UTgfLevelCheats::ShowGoblinThief()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ShowGoblinThief");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ShowHurtNum
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bIsShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::ShowHurtNum(bool bIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ShowHurtNum");

	Params::TgfLevelCheats_ShowHurtNum Parms{};

	Parms.bIsShow = bIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ShowPing
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bIsShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::ShowPing(bool bIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ShowPing");

	Params::TgfLevelCheats_ShowPing Parms{};

	Parms.bIsShow = bIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.ShowServerFPS
// (Final, Exec, Native, Public)

void UTgfLevelCheats::ShowServerFPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "ShowServerFPS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.SpawnAllEscapeDevices
// (Final, Exec, Native, Public)

void UTgfLevelCheats::SpawnAllEscapeDevices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "SpawnAllEscapeDevices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.SpawnAllPortalsAndScrolls
// (Final, Exec, Native, Public)

void UTgfLevelCheats::SpawnAllPortalsAndScrolls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "SpawnAllPortalsAndScrolls");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.SpawnOnePortal
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   PortalType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::SpawnOnePortal(int32 PortalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "SpawnOnePortal");

	Params::TgfLevelCheats_SpawnOnePortal Parms{};

	Parms.PortalType = PortalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLevelCheats.WaitingRoomCountdown
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLevelCheats::WaitingRoomCountdown(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLevelCheats", "WaitingRoomCountdown");

	Params::TgfLevelCheats_WaitingRoomCountdown Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.CallFreezeAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsFreeze                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::CallFreezeAction(bool bIsFreeze)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "CallFreezeAction");

	Params::LyraCharacter_CallFreezeAction Parms{};

	Parms.bIsFreeze = bIsFreeze;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraCharacter.CollectMeshComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UMeshComponent*>           Meshes                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALyraCharacter::CollectMeshComponents(TArray<class UMeshComponent*>* Meshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "CollectMeshComponents");

	Params::LyraCharacter_CollectMeshComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Meshes != nullptr)
		*Meshes = std::move(Parms.Meshes);
}


// Function LyraGame.LyraCharacter.ConsumeMithrilRebirthChance
// (Final, Native, Public, BlueprintCallable)

void ALyraCharacter::ConsumeMithrilRebirthChance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ConsumeMithrilRebirthChance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.CopyAttachMentActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   SrcCharacter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           baseClass                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::CopyAttachMentActors(class ALyraCharacter* SrcCharacter, class UClass* baseClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "CopyAttachMentActors");

	Params::LyraCharacter_CopyAttachMentActors Parms{};

	Parms.SrcCharacter = SrcCharacter;
	Parms.baseClass = baseClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.DestoryAttachMentActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           baseClass                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::DestoryAttachMentActors(class UClass* baseClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "DestoryAttachMentActors");

	Params::LyraCharacter_DestoryAttachMentActors Parms{};

	Parms.baseClass = baseClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.DisableAvatarMeshClothSimulation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::DisableAvatarMeshClothSimulation(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "DisableAvatarMeshClothSimulation");

	Params::LyraCharacter_DisableAvatarMeshClothSimulation Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.DisableMovementAndCollision
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ALyraCharacter::DisableMovementAndCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "DisableMovementAndCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ExcuteWhenExtractPortal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bWaiting                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::ExcuteWhenExtractPortal(bool bWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ExcuteWhenExtractPortal");

	Params::LyraCharacter_ExcuteWhenExtractPortal Parms{};

	Parms.bWaiting = bWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.FastSharedReplication
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FSharedRepMovement               SharedRepMovement                                      (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALyraCharacter::FastSharedReplication(const struct FSharedRepMovement& SharedRepMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "FastSharedReplication");

	Params::LyraCharacter_FastSharedReplication Parms{};

	Parms.SharedRepMovement = std::move(SharedRepMovement);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.GetActiveAvatarActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATgfAvatarActor*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATgfAvatarActor* ALyraCharacter::GetActiveAvatarActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActiveAvatarActor");

	Params::LyraCharacter_GetActiveAvatarActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetDebugInfoString
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALyraCharacter::GetDebugInfoString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetDebugInfoString");

	Params::LyraCharacter_GetDebugInfoString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetDisplayCareer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorCareer                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorCareer ALyraCharacter::GetDisplayCareer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetDisplayCareer");

	Params::LyraCharacter_GetDisplayCareer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetDisplayRace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorRace                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorRace ALyraCharacter::GetDisplayRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetDisplayRace");

	Params::LyraCharacter_GetDisplayRace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.HasInPortalTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPortalTagType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::HasInPortalTags(EPortalTagType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "HasInPortalTags");

	Params::LyraCharacter_HasInPortalTags Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.LinkDefaultAnimLayer
// (Final, Native, Protected, BlueprintCallable)

void ALyraCharacter::LinkDefaultAnimLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "LinkDefaultAnimLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnCancelRebirth
// (Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnCancelRebirth(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnCancelRebirth");

	Params::LyraCharacter_OnCancelRebirth Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnControllerChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnControllerChangedTeam");

	Params::LyraCharacter_OnControllerChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnCosmeticViewChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsFirstPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnCosmeticViewChanged(bool IsFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnCosmeticViewChanged");

	Params::LyraCharacter_OnCosmeticViewChanged Parms{};

	Parms.IsFirstPerson = IsFirstPerson;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraCharacter.OnDeathFinished
// (Native, Protected)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnDeathFinished(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnDeathFinished");

	Params::LyraCharacter_OnDeathFinished Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnDeathStarted
// (Native, Protected)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnDeathStarted(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnDeathStarted");

	Params::LyraCharacter_OnDeathStarted Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnFinishRebirth
// (Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnFinishRebirth(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnFinishRebirth");

	Params::LyraCharacter_OnFinishRebirth Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_Avatar
// (Final, Native, Private)

void ALyraCharacter::OnRep_Avatar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_Avatar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_DisplayActorCareer
// (Final, Native, Private)

void ALyraCharacter::OnRep_DisplayActorCareer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_DisplayActorCareer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_DisplayActorRace
// (Final, Native, Private)

void ALyraCharacter::OnRep_DisplayActorRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_DisplayActorRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_Freeze
// (Final, Native, Protected, BlueprintCallable)

void ALyraCharacter::OnRep_Freeze()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_Freeze");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_GravityScale
// (Final, Native, Public)

void ALyraCharacter::OnRep_GravityScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_GravityScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_MyTeamID
// (Final, Native, Private)
// Parameters:
// struct FGenericTeamId                   OldTeamID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_MyTeamID");

	Params::LyraCharacter_OnRep_MyTeamID Parms{};

	Parms.OldTeamID = std::move(OldTeamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_ReplicatedAcceleration
// (Final, Native, Private)

void ALyraCharacter::OnRep_ReplicatedAcceleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_ReplicatedAcceleration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRep_ReplicatedCanWalkOffLedges
// (Final, Native, Public)

void ALyraCharacter::OnRep_ReplicatedCanWalkOffLedges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRep_ReplicatedCanWalkOffLedges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnRepMyOpenId
// (Event, Public, BlueprintEvent)

void ALyraCharacter::OnRepMyOpenId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnRepMyOpenId");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraCharacter.OnStartEscaping
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnStartEscaping(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnStartEscaping");

	Params::LyraCharacter_OnStartEscaping Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnStartRebirth
// (Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnStartRebirth(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnStartRebirth");

	Params::LyraCharacter_OnStartRebirth Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.OnTravelAsSpectator
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::OnTravelAsSpectator(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "OnTravelAsSpectator");

	Params::LyraCharacter_OnTravelAsSpectator Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.RemoveGameplayEffectWithGrantedTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            WithGrantedTags                                        (Parm, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::RemoveGameplayEffectWithGrantedTags(const struct FGameplayTagContainer& WithGrantedTags, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "RemoveGameplayEffectWithGrantedTags");

	Params::LyraCharacter_RemoveGameplayEffectWithGrantedTags Parms{};

	Parms.WithGrantedTags = std::move(WithGrantedTags);
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ResetMovementAndCollision
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ALyraCharacter::ResetMovementAndCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ResetMovementAndCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.RestoredDefaultGravityScale
// (Final, Native, Public, BlueprintCallable)

void ALyraCharacter::RestoredDefaultGravityScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "RestoredDefaultGravityScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ServerRPCChangeGender
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::ServerRPCChangeGender(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ServerRPCChangeGender");

	Params::LyraCharacter_ServerRPCChangeGender Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ServerRPCChangeRace
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::ServerRPCChangeRace(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ServerRPCChangeRace");

	Params::LyraCharacter_ServerRPCChangeRace Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ServerRPCNavigation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FVector                          DstLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::ServerRPCNavigation(const struct FVector& DstLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ServerRPCNavigation");

	Params::LyraCharacter_ServerRPCNavigation Parms{};

	Parms.DstLocation = std::move(DstLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ServerRPCNavigationToActor
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           Goal                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::ServerRPCNavigationToActor(const class AActor* Goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ServerRPCNavigationToActor");

	Params::LyraCharacter_ServerRPCNavigationToActor Parms{};

	Parms.Goal = Goal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetAITick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetAITick(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetAITick");

	Params::LyraCharacter_SetAITick Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetClientTick
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfPauseClientTickReason               Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetClientTick(bool Enabled, ETgfPauseClientTickReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetClientTick");

	Params::LyraCharacter_SetClientTick Parms{};

	Parms.Enabled = Enabled;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetClientTick_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetClientTick_BP(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetClientTick_BP");

	Params::LyraCharacter_SetClientTick_BP Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraCharacter.SetComponentTick
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfPauseActorTickReason                Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetComponentTick(bool Enabled, ETgfPauseActorTickReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetComponentTick");

	Params::LyraCharacter_SetComponentTick Parms{};

	Parms.Enabled = Enabled;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetComponentTick_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetComponentTick_BP(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetComponentTick_BP");

	Params::LyraCharacter_SetComponentTick_BP Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraCharacter.SetDisplayCareer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// ETgfActorCareer                         InCareer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetDisplayCareer(ETgfActorCareer InCareer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetDisplayCareer");

	Params::LyraCharacter_SetDisplayCareer Parms{};

	Parms.InCareer = InCareer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetDisplayRace
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// ETgfActorRace                           InRace                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetDisplayRace(ETgfActorRace InRace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetDisplayRace");

	Params::LyraCharacter_SetDisplayRace Parms{};

	Parms.InRace = InRace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetDSMeshTick
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfPauseDSMeshTickReason               Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetDSMeshTick(bool Enabled, ETgfPauseDSMeshTickReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetDSMeshTick");

	Params::LyraCharacter_SetDSMeshTick Parms{};

	Parms.Enabled = Enabled;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetFreezeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFreezeState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetFreezeState(bool bFreezeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetFreezeState");

	Params::LyraCharacter_SetFreezeState Parms{};

	Parms.bFreezeState = bFreezeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetGravityScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CacheDefault                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedReplicate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetGravityScale(float Gravity, bool CacheDefault, bool NeedReplicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetGravityScale");

	Params::LyraCharacter_SetGravityScale Parms{};

	Parms.Gravity = Gravity;
	Parms.CacheDefault = CacheDefault;
	Parms.NeedReplicate = NeedReplicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.SetUseControllerRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::SetUseControllerRotation(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "SetUseControllerRotation");

	Params::LyraCharacter_SetUseControllerRotation Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ShouldAddTeammateMarker
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Summoned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreDeath                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::ShouldAddTeammateMarker(class ALyraCharacter* Target, bool Summoned, bool IgnoreTarget, bool IgnoreDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ShouldAddTeammateMarker");

	Params::LyraCharacter_ShouldAddTeammateMarker Parms{};

	Parms.Target = Target;
	Parms.Summoned = Summoned;
	Parms.IgnoreTarget = IgnoreTarget;
	Parms.IgnoreDeath = IgnoreDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.TickAnimationOnce
// (Final, Native, Public, BlueprintCallable)

void ALyraCharacter::TickAnimationOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "TickAnimationOnce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ToggleAvatarMeshPostProcessBP
// (Final, Native, Public, BlueprintCallable)

void ALyraCharacter::ToggleAvatarMeshPostProcessBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ToggleAvatarMeshPostProcessBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.ToggleCapsuleCollision
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::ToggleCapsuleCollision(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "ToggleCapsuleCollision");

	Params::LyraCharacter_ToggleCapsuleCollision Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacter.TriggerDebugTestInput
// (Event, Public, BlueprintEvent)

void ALyraCharacter::TriggerDebugTestInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "TriggerDebugTestInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraCharacter.TriggerInput
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           InputStr                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::TriggerInput(const class FString& InputStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "TriggerInput");

	Params::LyraCharacter_TriggerInput Parms{};

	Parms.InputStr = std::move(InputStr);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraCharacter.TriggerInputContinous
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           InputStr                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraCharacter::TriggerInputContinous(const class FString& InputStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "TriggerInputContinous");

	Params::LyraCharacter_TriggerInputContinous Parms{};

	Parms.InputStr = std::move(InputStr);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraCharacter.GetActorCareer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorCareer                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorCareer ALyraCharacter::GetActorCareer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorCareer");

	Params::LyraCharacter_GetActorCareer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraCharacter::GetActorExp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorExp");

	Params::LyraCharacter_GetActorExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorGender                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorGender ALyraCharacter::GetActorGender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorGender");

	Params::LyraCharacter_GetActorGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraCharacter::GetActorLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorLevel");

	Params::LyraCharacter_GetActorLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorRace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorRace                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorRace ALyraCharacter::GetActorRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorRace");

	Params::LyraCharacter_GetActorRace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorRoleTypeId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraCharacter::GetActorRoleTypeId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorRoleTypeId");

	Params::LyraCharacter_GetActorRoleTypeId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorStatIdList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int32> ALyraCharacter::GetActorStatIdList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorStatIdList");

	Params::LyraCharacter_GetActorStatIdList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetActorType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfActorType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfActorType ALyraCharacter::GetActorType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetActorType");

	Params::LyraCharacter_GetActorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetAvatarComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfCharacterAvatarComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfCharacterAvatarComponent* ALyraCharacter::GetAvatarComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetAvatarComponent");

	Params::LyraCharacter_GetAvatarComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALyraCharacter::GetCharacterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetCharacterName");

	Params::LyraCharacter_GetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetCharacterOpenId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALyraCharacter::GetCharacterOpenId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetCharacterOpenId");

	Params::LyraCharacter_GetCharacterOpenId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ALyraCharacter::GetLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetLyraAbilitySystemComponent");

	Params::LyraCharacter_GetLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetLyraPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraPlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerController* ALyraCharacter::GetLyraPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetLyraPlayerController");

	Params::LyraCharacter_GetLyraPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetLyraPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraPlayerState*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerState* ALyraCharacter::GetLyraPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetLyraPlayerState");

	Params::LyraCharacter_GetLyraPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetRagdollComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTgfRagdollComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfRagdollComponent* ALyraCharacter::GetRagdollComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetRagdollComponent");

	Params::LyraCharacter_GetRagdollComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.GetSpawnTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ALyraCharacter::GetSpawnTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "GetSpawnTransform");

	Params::LyraCharacter_GetSpawnTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.HasInventoryItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDefine                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::HasInventoryItem(TSubclassOf<class ULyraInventoryItemDefinition> ItemDefine) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "HasInventoryItem");

	Params::LyraCharacter_HasInventoryItem Parms{};

	Parms.ItemDefine = ItemDefine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsDeadOrDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsDeadOrDying");

	Params::LyraCharacter_IsDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsFirstPersonCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsFirstPersonCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsFirstPersonCharacter");

	Params::LyraCharacter_IsFirstPersonCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsMithrillCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsMithrillCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsMithrillCharacter");

	Params::LyraCharacter_IsMithrillCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsNotAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsNotAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsNotAlive");

	Params::LyraCharacter_IsNotAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsOnlyServerSide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsOnlyServerSide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsOnlyServerSide");

	Params::LyraCharacter_IsOnlyServerSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsOnlySpectator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsOnlySpectator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsOnlySpectator");

	Params::LyraCharacter_IsOnlySpectator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.IsPendingDeath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::IsPendingDeath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "IsPendingDeath");

	Params::LyraCharacter_IsPendingDeath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacter.MithrilResurrecting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraCharacter::MithrilResurrecting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacter", "MithrilResurrecting");

	Params::LyraCharacter_MithrilResurrecting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfObjectListEntry.OnHovered
// (Event, Public, BlueprintEvent)

void ITgfObjectListEntry::OnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfObjectListEntry", "OnHovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfObjectListEntry.OnUnhovered
// (Event, Public, BlueprintEvent)

void ITgfObjectListEntry::OnUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfObjectListEntry", "OnUnhovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfLyraInteractComponent.HandleSettingScreenDestruct
// (Final, Native, Public)
// Parameters:
// class UObject*                          Args                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLyraInteractComponent::HandleSettingScreenDestruct(class UObject* Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLyraInteractComponent", "HandleSettingScreenDestruct");

	Params::TgfLyraInteractComponent_HandleSettingScreenDestruct Parms{};

	Parms.Args = Args;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLyraInteractComponent.InitSkillInputMethod
// (Final, Native, Public)

void UTgfLyraInteractComponent::InitSkillInputMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLyraInteractComponent", "InitSkillInputMethod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfLyraInteractComponent.RefreshServerSkillInputMethod
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    InputChargeSkillMethod                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InputMouseTargetingMethod                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfLyraInteractComponent::RefreshServerSkillInputMethod(bool InputChargeSkillMethod, bool InputMouseTargetingMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfLyraInteractComponent", "RefreshServerSkillInputMethod");

	Params::TgfLyraInteractComponent_RefreshServerSkillInputMethod Parms{};

	Parms.InputChargeSkillMethod = InputChargeSkillMethod;
	Parms.InputMouseTargetingMethod = InputMouseTargetingMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_CurMagic
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_CurMagic(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_CurMagic");

	Params::TgfMagicAttributeSet_OnRep_CurMagic Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MagicGenerateRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MagicGenerateRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MagicGenerateRate");

	Params::TgfMagicAttributeSet_OnRep_MagicGenerateRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MagicOnHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MagicOnHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MagicOnHit");

	Params::TgfMagicAttributeSet_OnRep_MagicOnHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MagicOnHurt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MagicOnHurt(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MagicOnHurt");

	Params::TgfMagicAttributeSet_OnRep_MagicOnHurt Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MagicOnKill
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MagicOnKill(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MagicOnKill");

	Params::TgfMagicAttributeSet_OnRep_MagicOnKill Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MagicOverTime
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MagicOverTime(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MagicOverTime");

	Params::TgfMagicAttributeSet_OnRep_MagicOverTime Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MaxMagicBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MaxMagicBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MaxMagicBase");

	Params::TgfMagicAttributeSet_OnRep_MaxMagicBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.OnRep_MaxMagicPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfMagicAttributeSet::OnRep_MaxMagicPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "OnRep_MaxMagicPercent");

	Params::TgfMagicAttributeSet_OnRep_MaxMagicPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMagicAttributeSet.GetMaxMagicFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfMagicAttributeSet::GetMaxMagicFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "GetMaxMagicFinal");

	Params::TgfMagicAttributeSet_GetMaxMagicFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMagicAttributeSet.IsFullMP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfMagicAttributeSet::IsFullMP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMagicAttributeSet", "IsFullMP");

	Params::TgfMagicAttributeSet_IsFullMP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.AddCharacterPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPart               NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraControllerComponent_CharacterParts::AddCharacterPart(const struct FLyraCharacterPart& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "AddCharacterPart");

	Params::LyraControllerComponent_CharacterParts_AddCharacterPart Parms{};

	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.AddTgfSplitPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTgfCharaPartChangeConfig        NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraControllerComponent_CharacterParts::AddTgfSplitPart(const struct FTgfCharaPartChangeConfig& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "AddTgfSplitPart");

	Params::LyraControllerComponent_CharacterParts_AddTgfSplitPart Parms{};

	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.OnControlledCharacterDead
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULyraControllerComponent_CharacterParts::OnControlledCharacterDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "OnControlledCharacterDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.OnPossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraControllerComponent_CharacterParts::OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "OnPossessedPawnChanged");

	Params::LyraControllerComponent_CharacterParts_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.RemoveAllCharacterParts
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULyraControllerComponent_CharacterParts::RemoveAllCharacterParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "RemoveAllCharacterParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.RemoveCharacterPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPart               PartToRemove                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraControllerComponent_CharacterParts::RemoveCharacterPart(const struct FLyraCharacterPart& PartToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "RemoveCharacterPart");

	Params::LyraControllerComponent_CharacterParts_RemoveCharacterPart Parms{};

	Parms.PartToRemove = std::move(PartToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraControllerComponent_CharacterParts.RemoveTgfSplitPart
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharaPart                           PartEnum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraControllerComponent_CharacterParts::RemoveTgfSplitPart(ETgfCharaPart PartEnum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraControllerComponent_CharacterParts", "RemoveTgfSplitPart");

	Params::LyraControllerComponent_CharacterParts_RemoveTgfSplitPart Parms{};

	Parms.PartEnum = PartEnum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMapWidgetBase.NativeAbsoluteUVPosToUniformViewportPosition
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InAbsoluteUVPos                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InViewportRect                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTgfMapWidgetBase::NativeAbsoluteUVPosToUniformViewportPosition(const struct FVector2D& InAbsoluteUVPos, const struct FLinearColor& InViewportRect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeAbsoluteUVPosToUniformViewportPosition");

	Params::TgfMapWidgetBase_NativeAbsoluteUVPosToUniformViewportPosition Parms{};

	Parms.InAbsoluteUVPos = std::move(InAbsoluteUVPos);
	Parms.InViewportRect = std::move(InViewportRect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMapWidgetBase.NativeCalculateUVRect
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                         InMapBounds                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InMapUVScale                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UTgfMapWidgetBase::NativeCalculateUVRect(const struct FVector4& InMapBounds, const struct FVector2D& InMapUVScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeCalculateUVRect");

	Params::TgfMapWidgetBase_NativeCalculateUVRect Parms{};

	Parms.InMapBounds = std::move(InMapBounds);
	Parms.InMapUVScale = std::move(InMapUVScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMapWidgetBase.NativeCheckInPlayerView
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InActorLoc                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayerViewSize                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InMapArea                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         InMapBounds                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InMapUVScale                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutWidgetPos                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutBorderPos                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutBorderRotator                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfMapWidgetBase::NativeCheckInPlayerView(const struct FVector& InActorLoc, const float& InPlayerViewSize, const class UWidget* InMapArea, const struct FVector4& InMapBounds, const struct FVector2D& InMapUVScale, struct FVector2D* OutWidgetPos, struct FVector2D* OutBorderPos, float* OutBorderRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeCheckInPlayerView");

	Params::TgfMapWidgetBase_NativeCheckInPlayerView Parms{};

	Parms.InActorLoc = std::move(InActorLoc);
	Parms.InPlayerViewSize = InPlayerViewSize;
	Parms.InMapArea = InMapArea;
	Parms.InMapBounds = std::move(InMapBounds);
	Parms.InMapUVScale = std::move(InMapUVScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWidgetPos != nullptr)
		*OutWidgetPos = std::move(Parms.OutWidgetPos);

	if (OutBorderPos != nullptr)
		*OutBorderPos = std::move(Parms.OutBorderPos);

	if (OutBorderRotator != nullptr)
		*OutBorderRotator = Parms.OutBorderRotator;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMapWidgetBase.NativeGetBorderIntersection
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        BorderA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        BorderB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        BorderC                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        BorderD                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutIntersectionLoc                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfMapWidgetBase::NativeGetBorderIntersection(const struct FVector2D& BorderA, const struct FVector2D& BorderB, const struct FVector2D& BorderC, const struct FVector2D& BorderD, struct FVector2D* OutIntersectionLoc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeGetBorderIntersection");

	Params::TgfMapWidgetBase_NativeGetBorderIntersection Parms{};

	Parms.BorderA = std::move(BorderA);
	Parms.BorderB = std::move(BorderB);
	Parms.BorderC = std::move(BorderC);
	Parms.BorderD = std::move(BorderD);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIntersectionLoc != nullptr)
		*OutIntersectionLoc = std::move(Parms.OutIntersectionLoc);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMapWidgetBase.NativeGetOutViewBorderViewData
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InLeftBottom                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InLeftTop                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InRightBottom                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InRightTop                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InTargetLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InViewCenterLocation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutBorderPlayerRotator                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTgfMapWidgetBase::NativeGetOutViewBorderViewData(const struct FVector2D& InLeftBottom, const struct FVector2D& InLeftTop, const struct FVector2D& InRightBottom, const struct FVector2D& InRightTop, const struct FVector2D& InTargetLocation, const struct FVector2D& InViewCenterLocation, float* OutBorderPlayerRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeGetOutViewBorderViewData");

	Params::TgfMapWidgetBase_NativeGetOutViewBorderViewData Parms{};

	Parms.InLeftBottom = std::move(InLeftBottom);
	Parms.InLeftTop = std::move(InLeftTop);
	Parms.InRightBottom = std::move(InRightBottom);
	Parms.InRightTop = std::move(InRightTop);
	Parms.InTargetLocation = std::move(InTargetLocation);
	Parms.InViewCenterLocation = std::move(InViewCenterLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBorderPlayerRotator != nullptr)
		*OutBorderPlayerRotator = Parms.OutBorderPlayerRotator;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMapWidgetBase.NativeUpdatePlayerWidgetRenderTransform
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InUVRect                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InMapArea                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         InMapBounds                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfMapWidgetBase::NativeUpdatePlayerWidgetRenderTransform(const class AActor* InActor, const struct FLinearColor& InUVRect, class UWidget* InWidget, const class UWidget* InMapArea, const struct FVector4& InMapBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeUpdatePlayerWidgetRenderTransform");

	Params::TgfMapWidgetBase_NativeUpdatePlayerWidgetRenderTransform Parms{};

	Parms.InActor = InActor;
	Parms.InUVRect = std::move(InUVRect);
	Parms.InWidget = InWidget;
	Parms.InMapArea = InMapArea;
	Parms.InMapBounds = std::move(InMapBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMapWidgetBase.NativeWorldPositionToAbsoluteUVPosition
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InWorldLoc                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         InMapBounds                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTgfMapWidgetBase::NativeWorldPositionToAbsoluteUVPosition(const struct FVector& InWorldLoc, const struct FVector4& InMapBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMapWidgetBase", "NativeWorldPositionToAbsoluteUVPosition");

	Params::TgfMapWidgetBase_NativeWorldPositionToAbsoluteUVPosition Parms{};

	Parms.InWorldLoc = std::move(InWorldLoc);
	Parms.InMapBounds = std::move(InMapBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMaterialParameterModifierInterface.GetMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ITgfMaterialParameterModifierInterface::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMaterialParameterModifierInterface", "GetMesh");

	Params::TgfMaterialParameterModifierInterface_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMaterialParameterModifierInterface.SetMaterialParameter_Float
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITgfMaterialParameterModifierInterface::SetMaterialParameter_Float(class FName Param, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMaterialParameterModifierInterface", "SetMaterialParameter_Float");

	Params::TgfMaterialParameterModifierInterface_SetMaterialParameter_Float Parms{};

	Parms.Param = Param;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMaterialParameterModifierInterface.EnableDynamicMaterial
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITgfMaterialParameterModifierInterface::EnableDynamicMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMaterialParameterModifierInterface", "EnableDynamicMaterial");

	Params::TgfMaterialParameterModifierInterface_EnableDynamicMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraQuickBarComponent.AddItemToSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraQuickBarComponent::AddItemToSlot(int32 SlotIndex, class ULyraInventoryItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "AddItemToSlot");

	Params::LyraQuickBarComponent_AddItemToSlot Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraQuickBarComponent.CycleActiveSlotBackward
// (Final, Native, Public, BlueprintCallable)

void ULyraQuickBarComponent::CycleActiveSlotBackward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "CycleActiveSlotBackward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraQuickBarComponent.CycleActiveSlotForward
// (Final, Native, Public, BlueprintCallable)

void ULyraQuickBarComponent::CycleActiveSlotForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "CycleActiveSlotForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraQuickBarComponent.OnRep_ActiveSlotIndex
// (Final, Native, Protected)

void ULyraQuickBarComponent::OnRep_ActiveSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "OnRep_ActiveSlotIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraQuickBarComponent.OnRep_Slots
// (Final, Native, Protected)

void ULyraQuickBarComponent::OnRep_Slots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "OnRep_Slots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraQuickBarComponent.RemoveItemFromSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraQuickBarComponent::RemoveItemFromSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "RemoveItemFromSlot");

	Params::LyraQuickBarComponent_RemoveItemFromSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraQuickBarComponent.SetActiveSlotIndex
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraQuickBarComponent::SetActiveSlotIndex(int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "SetActiveSlotIndex");

	Params::LyraQuickBarComponent_SetActiveSlotIndex Parms{};

	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraQuickBarComponent.GetActiveSlotIndex
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraQuickBarComponent::GetActiveSlotIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "GetActiveSlotIndex");

	Params::LyraQuickBarComponent_GetActiveSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraQuickBarComponent.GetActiveSlotItem
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraQuickBarComponent::GetActiveSlotItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "GetActiveSlotItem");

	Params::LyraQuickBarComponent_GetActiveSlotItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraQuickBarComponent.GetNextFreeItemSlot
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraQuickBarComponent::GetNextFreeItemSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "GetNextFreeItemSlot");

	Params::LyraQuickBarComponent_GetNextFreeItemSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraQuickBarComponent.GetSlots
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TArray<class ULyraInventoryItemInstance*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULyraInventoryItemInstance*> ULyraQuickBarComponent::GetSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraQuickBarComponent", "GetSlots");

	Params::LyraQuickBarComponent_GetSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMonsterReaction.ComputeBonePositions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfMonsterPostAnim*              MonsterPostProcessAnim                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DirectionIntensity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfMonsterReaction::ComputeBonePositions(class UTgfMonsterPostAnim* MonsterPostProcessAnim, float DirectionIntensity, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMonsterReaction", "ComputeBonePositions");

	Params::TgfMonsterReaction_ComputeBonePositions Parms{};

	Parms.MonsterPostProcessAnim = MonsterPostProcessAnim;
	Parms.DirectionIntensity = DirectionIntensity;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMonsterReaction.ComputeHitDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           FirstChara                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfMonsterReaction::ComputeHitDirection(class AActor* FirstChara)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMonsterReaction", "ComputeHitDirection");

	Params::TgfMonsterReaction_ComputeHitDirection Parms{};

	Parms.FirstChara = FirstChara;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfMonsterReaction.GetPostProcessAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfMonsterPostAnim*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfMonsterPostAnim* UTgfMonsterReaction::GetPostProcessAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMonsterReaction", "GetPostProcessAnim");

	Params::TgfMonsterReaction_GetPostProcessAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfMonsterReaction.ResetBonePositions
// (Final, Native, Public, BlueprintCallable)

void UTgfMonsterReaction::ResetBonePositions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfMonsterReaction", "ResetBonePositions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.FindAttributeComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfAttributeComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAttributeComponent* UTgfAttributeComponent::FindAttributeComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAttributeComponent", "FindAttributeComponent");

	Params::TgfAttributeComponent_FindAttributeComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.AddDamagePartMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfDamagePartMonitorConfig      NewMonitorConfig                                       (Parm, NativeAccessSpecifierPublic)
// bool                                    CheckUnique                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::AddDamagePartMonitor(const struct FTgfDamagePartMonitorConfig& NewMonitorConfig, bool CheckUnique)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "AddDamagePartMonitor");

	Params::TgfAttributeComponent_AddDamagePartMonitor Parms{};

	Parms.NewMonitorConfig = std::move(NewMonitorConfig);
	Parms.CheckUnique = CheckUnique;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.CancelRebirth
// (Native, Public, BlueprintCallable)

void UTgfAttributeComponent::CancelRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "CancelRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.CheckTriggerDamagePartMonitor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            InstigatorTags                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TargetTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     RestrictAssetTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Times                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceTrigger                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfAttributeComponent::CheckTriggerDamagePartMonitor(const struct FGameplayTagContainer& InstigatorTags, const struct FGameplayTagContainer& TargetTags, const struct FGameplayTag& RestrictAssetTag, float Damage, int32 Times, bool ForceTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "CheckTriggerDamagePartMonitor");

	Params::TgfAttributeComponent_CheckTriggerDamagePartMonitor Parms{};

	Parms.InstigatorTags = std::move(InstigatorTags);
	Parms.TargetTags = std::move(TargetTags);
	Parms.RestrictAssetTag = std::move(RestrictAssetTag);
	Parms.Damage = Damage;
	Parms.Times = Times;
	Parms.ForceTrigger = ForceTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.ClearDefaultGranted
// (Final, Native, Public, BlueprintCallable)

void UTgfAttributeComponent::ClearDefaultGranted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "ClearDefaultGranted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.ClearTalentGranted
// (Final, Native, Public, BlueprintCallable)

void UTgfAttributeComponent::ClearTalentGranted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "ClearTalentGranted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.ClientDamageDirectionEvent
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// float                                   Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGuarded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::ClientDamageDirectionEvent(const float Direction, bool bIsGuarded, class AActor* DamageInstigator, class AActor* DamageTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "ClientDamageDirectionEvent");

	Params::TgfAttributeComponent_ClientDamageDirectionEvent Parms{};

	Parms.Direction = Direction;
	Parms.bIsGuarded = bIsGuarded;
	Parms.DamageInstigator = DamageInstigator;
	Parms.DamageTarget = DamageTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.CopyAttrValueFromASC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      OtherASC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedDirect                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::CopyAttrValueFromASC(class ULyraAbilitySystemComponent* OtherASC, float Rate, bool NeedDirect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "CopyAttrValueFromASC");

	Params::TgfAttributeComponent_CopyAttrValueFromASC Parms{};

	Parms.OtherASC = OtherASC;
	Parms.Rate = Rate;
	Parms.NeedDirect = NeedDirect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.DamageSelfDestruct
// (Native, Public)
// Parameters:
// bool                                    bFellOutOfWorld                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::DamageSelfDestruct(bool bFellOutOfWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "DamageSelfDestruct");

	Params::TgfAttributeComponent_DamageSelfDestruct Parms{};

	Parms.bFellOutOfWorld = bFellOutOfWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.DumpAttrValueFromASC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      OtherASC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::DumpAttrValueFromASC(class ULyraAbilitySystemComponent* OtherASC, float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "DumpAttrValueFromASC");

	Params::TgfAttributeComponent_DumpAttrValueFromASC Parms{};

	Parms.OtherASC = OtherASC;
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.DumpLevelAttr
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfResetInitAttrArgs            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfResetInitAttrArgs UTgfAttributeComponent::DumpLevelAttr()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "DumpLevelAttr");

	Params::TgfAttributeComponent_DumpLevelAttr Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.FinishDeath
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    StopRagdoll                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::FinishDeath(bool StopRagdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "FinishDeath");

	Params::TgfAttributeComponent_FinishDeath Parms{};

	Parms.StopRagdoll = StopRagdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.FinishRebirth
// (Native, Public, BlueprintCallable)

void UTgfAttributeComponent::FinishRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "FinishRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.GetDamagePartMonitor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     AssetTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfDamagePartMonitorConfig      OutConfig                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::GetDamagePartMonitor(const struct FGameplayTag& AssetTag, struct FTgfDamagePartMonitorConfig* OutConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GetDamagePartMonitor");

	Params::TgfAttributeComponent_GetDamagePartMonitor Parms{};

	Parms.AssetTag = std::move(AssetTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConfig != nullptr)
		*OutConfig = std::move(Parms.OutConfig);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.GrantAbilitySet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySet*                  AbilitySet                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::GrantAbilitySet(const class ULyraAbilitySet* AbilitySet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GrantAbilitySet");

	Params::TgfAttributeComponent_GrantAbilitySet Parms{};

	Parms.AbilitySet = AbilitySet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.InitDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NeedReinitAttr                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedResetFirstLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::InitDefault(bool NeedReinitAttr, bool NeedResetFirstLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "InitDefault");

	Params::TgfAttributeComponent_InitDefault Parms{};

	Parms.NeedReinitAttr = NeedReinitAttr;
	Parms.NeedResetFirstLevel = NeedResetFirstLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.InitFirstLevel
// (Final, Native, Public, BlueprintCallable)

void UTgfAttributeComponent::InitFirstLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "InitFirstLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.InitializeWithAbilitySystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "InitializeWithAbilitySystem");

	Params::TgfAttributeComponent_InitializeWithAbilitySystem Parms{};

	Parms.InASC = InASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.InitTalents
// (Final, Native, Public, BlueprintCallable)

void UTgfAttributeComponent::InitTalents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "InitTalents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.MulticastDeathEvent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::MulticastDeathEvent(class AActor* DamageInstigator, class AActor* DamageTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "MulticastDeathEvent");

	Params::TgfAttributeComponent_MulticastDeathEvent Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.DamageTarget = DamageTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.OnRep_DeathStateInfo
// (Native, Protected)
// Parameters:
// struct FTgfDeathStateInfo               OldDeathStateInfo                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::OnRep_DeathStateInfo(const struct FTgfDeathStateInfo& OldDeathStateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "OnRep_DeathStateInfo");

	Params::TgfAttributeComponent_OnRep_DeathStateInfo Parms{};

	Parms.OldDeathStateInfo = std::move(OldDeathStateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.RebirthReinitData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReinitInventory                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::RebirthReinitData(bool ReinitInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "RebirthReinitData");

	Params::TgfAttributeComponent_RebirthReinitData Parms{};

	Parms.ReinitInventory = ReinitInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.RegistAttrHandlesBP
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAttribute               Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::RegistAttrHandlesBP(const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "RegistAttrHandlesBP");

	Params::TgfAttributeComponent_RegistAttrHandlesBP Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.RegistTagHandlesBP
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::RegistTagHandlesBP(const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "RegistTagHandlesBP");

	Params::TgfAttributeComponent_RegistTagHandlesBP Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.RemoveDamagePartMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     DamagePartMonitorTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::RemoveDamagePartMonitor(const struct FGameplayTag& DamagePartMonitorTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "RemoveDamagePartMonitor");

	Params::TgfAttributeComponent_RemoveDamagePartMonitor Parms{};

	Parms.DamagePartMonitorTag = std::move(DamagePartMonitorTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.ResetInitAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfResetInitAttrArgs            Args                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::ResetInitAttribute(const struct FTgfResetInitAttrArgs& Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "ResetInitAttribute");

	Params::TgfAttributeComponent_ResetInitAttribute Parms{};

	Parms.Args = std::move(Args);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.SetInitAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAttribute               Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          Mod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::SetInitAttribute(const struct FGameplayAttribute& Attribute, float Value, EGameplayModOp Mod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "SetInitAttribute");

	Params::TgfAttributeComponent_SetInitAttribute Parms{};

	Parms.Attribute = std::move(Attribute);
	Parms.Value = Value;
	Parms.Mod = Mod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.StartDeath
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EAnimConfigDirection                    DeathDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::StartDeath(EAnimConfigDirection DeathDirection, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "StartDeath");

	Params::TgfAttributeComponent_StartDeath Parms{};

	Parms.DeathDirection = DeathDirection;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.StartEscaping
// (Native, Public)

void UTgfAttributeComponent::StartEscaping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "StartEscaping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.StartRebirth
// (Native, Public, BlueprintCallable)

void UTgfAttributeComponent::StartRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "StartRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.TravelAsSpectator
// (Native, Public)

void UTgfAttributeComponent::TravelAsSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "TravelAsSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.UninitializeFromAbilitySystem
// (Final, Native, Public, BlueprintCallable)

void UTgfAttributeComponent::UninitializeFromAbilitySystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "UninitializeFromAbilitySystem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.UpdateAIAttributes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAngleSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSightDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHearingDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLightDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAttributeComponent::UpdateAIAttributes(bool bAngleSpeed, bool bSightDistance, bool bHearingDistance, bool bLightDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "UpdateAIAttributes");

	Params::TgfAttributeComponent_UpdateAIAttributes Parms{};

	Parms.bAngleSpeed = bAngleSpeed;
	Parms.bSightDistance = bSightDistance;
	Parms.bHearingDistance = bHearingDistance;
	Parms.bLightDistance = bLightDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttributeComponent.GetAttributeSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAttributeSet>        AttributeSetClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAttributeSet*              ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAttributeSet* UTgfAttributeComponent::GetAttributeSet(TSubclassOf<class UAttributeSet> AttributeSetClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GetAttributeSet");

	Params::TgfAttributeComponent_GetAttributeSet Parms{};

	Parms.AttributeSetClass = AttributeSetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.GetDeadOrDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::GetDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GetDeadOrDying");

	Params::TgfAttributeComponent_GetDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.GetDeathDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimConfigDirection                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimConfigDirection UTgfAttributeComponent::GetDeathDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GetDeathDirection");

	Params::TgfAttributeComponent_GetDeathDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.GetDeathState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfDeathState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfDeathState UTgfAttributeComponent::GetDeathState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GetDeathState");

	Params::TgfAttributeComponent_GetDeathState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.GetHitResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UTgfAttributeComponent::GetHitResult() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "GetHitResult");

	Params::TgfAttributeComponent_GetHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.IsDeadOrDying
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::IsDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "IsDeadOrDying");

	Params::TgfAttributeComponent_IsDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.IsNotAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::IsNotAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "IsNotAlive");

	Params::TgfAttributeComponent_IsNotAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.IsOnlySpectator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::IsOnlySpectator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "IsOnlySpectator");

	Params::TgfAttributeComponent_IsOnlySpectator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttributeComponent.IsPendingDeath
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfAttributeComponent::IsPendingDeath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttributeComponent", "IsPendingDeath");

	Params::TgfAttributeComponent_IsPendingDeath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_CurNaturalEnergy
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_CurNaturalEnergy(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_CurNaturalEnergy");

	Params::TgfNaturalEnergyAttributeSet_OnRep_CurNaturalEnergy Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_MaxNaturalEnergyBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_MaxNaturalEnergyBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_MaxNaturalEnergyBase");

	Params::TgfNaturalEnergyAttributeSet_OnRep_MaxNaturalEnergyBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_MaxNaturalEnergyPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_MaxNaturalEnergyPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_MaxNaturalEnergyPercent");

	Params::TgfNaturalEnergyAttributeSet_OnRep_MaxNaturalEnergyPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_NaturalEnergyGenerateRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_NaturalEnergyGenerateRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_NaturalEnergyGenerateRate");

	Params::TgfNaturalEnergyAttributeSet_OnRep_NaturalEnergyGenerateRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_NaturalEnergyOnHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_NaturalEnergyOnHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_NaturalEnergyOnHit");

	Params::TgfNaturalEnergyAttributeSet_OnRep_NaturalEnergyOnHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_NaturalEnergyOnHurt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_NaturalEnergyOnHurt(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_NaturalEnergyOnHurt");

	Params::TgfNaturalEnergyAttributeSet_OnRep_NaturalEnergyOnHurt Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_NaturalEnergyOnKill
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_NaturalEnergyOnKill(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_NaturalEnergyOnKill");

	Params::TgfNaturalEnergyAttributeSet_OnRep_NaturalEnergyOnKill Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.OnRep_NaturalEnergyOverTime
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNaturalEnergyAttributeSet::OnRep_NaturalEnergyOverTime(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "OnRep_NaturalEnergyOverTime");

	Params::TgfNaturalEnergyAttributeSet_OnRep_NaturalEnergyOverTime Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.GetMaxNaturalEnergyFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfNaturalEnergyAttributeSet::GetMaxNaturalEnergyFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "GetMaxNaturalEnergyFinal");

	Params::TgfNaturalEnergyAttributeSet_GetMaxNaturalEnergyFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNaturalEnergyAttributeSet.IsFullNEP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNaturalEnergyAttributeSet::IsFullNEP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNaturalEnergyAttributeSet", "IsFullNEP");

	Params::TgfNaturalEnergyAttributeSet_IsFullNEP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.DoBehavior
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfNpcBehavior::DoBehavior(const struct FGameplayTag& GameplayTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "DoBehavior");

	Params::TgfNpcBehavior_DoBehavior Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.EventData = std::move(EventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfNpcBehavior.DoChecks
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    PassCheck                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfNpcBehavior::DoChecks(const struct FGameplayTag& GameplayTag, const struct FGameplayEventData& EventData, bool* PassCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "DoChecks");

	Params::TgfNpcBehavior_DoChecks Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.EventData = std::move(EventData);

	UObject::ProcessEvent(Func, &Parms);

	if (PassCheck != nullptr)
		*PassCheck = Parms.PassCheck;
}


// Function LyraGame.TgfNpcBehavior.GetIsEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcBehavior::GetIsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "GetIsEditor");

	Params::TgfNpcBehavior_GetIsEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfNpcBehavior::GetOwningActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "GetOwningActor");

	Params::TgfNpcBehavior_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.GetOwningCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfNpcBehavior::GetOwningCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "GetOwningCharacter");

	Params::TgfNpcBehavior_GetOwningCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.GetReceivedEventNumber
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfNpcBehavior::GetReceivedEventNumber(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "GetReceivedEventNumber");

	Params::TgfNpcBehavior_GetReceivedEventNumber Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.HasReceivedEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcBehavior::HasReceivedEvent(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "HasReceivedEvent");

	Params::TgfNpcBehavior_HasReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.MoveToNextState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfNpcState>         NextState                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfNpcBehavior::MoveToNextState(TSubclassOf<class UTgfNpcState> NextState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "MoveToNextState");

	Params::TgfNpcBehavior_MoveToNextState Parms{};

	Parms.NextState = NextState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfNpcBehavior.PlayerEquipsItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraEquipmentDefinition>Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcBehavior::PlayerEquipsItem(class ALyraCharacter* Player, TSubclassOf<class ULyraEquipmentDefinition> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "PlayerEquipsItem");

	Params::TgfNpcBehavior_PlayerEquipsItem Parms{};

	Parms.Player = Player;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.PlayerHasItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredNumber                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcBehavior::PlayerHasItems(class ALyraCharacter* Player, TSubclassOf<class ULyraInventoryItemDefinition> Item, int32 RequiredNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "PlayerHasItems");

	Params::TgfNpcBehavior_PlayerHasItems Parms{};

	Parms.Player = Player;
	Parms.Item = Item;
	Parms.RequiredNumber = RequiredNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcBehavior.PlayerInventoryHasItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredNumber                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcBehavior::PlayerInventoryHasItems(class ALyraCharacter* Player, TSubclassOf<class ULyraInventoryItemDefinition> Item, int32 RequiredNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcBehavior", "PlayerInventoryHasItems");

	Params::TgfNpcBehavior_PlayerInventoryHasItems Parms{};

	Parms.Player = Player;
	Parms.Item = Item;
	Parms.RequiredNumber = RequiredNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcState.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTgfNpcState::GetOwningActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcState", "GetOwningActor");

	Params::TgfNpcState_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcState.GetOwningCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfNpcState::GetOwningCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcState", "GetOwningCharacter");

	Params::TgfNpcState_GetOwningCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcState.GetReceivedEventNumber
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfNpcState::GetReceivedEventNumber(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcState", "GetReceivedEventNumber");

	Params::TgfNpcState_GetReceivedEventNumber Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcState.HasReceivedEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcState::HasReceivedEvent(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcState", "HasReceivedEvent");

	Params::TgfNpcState_HasReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcState.OnEnterState
// (Event, Public, BlueprintEvent)

void UTgfNpcState::OnEnterState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcState", "OnEnterState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfNpcState.OnLeaveState
// (Event, Public, BlueprintEvent)

void UTgfNpcState::OnLeaveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcState", "OnLeaveState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfNpcStateManagerComponent.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfNpcState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfNpcState* UTgfNpcStateManagerComponent::GetCurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcStateManagerComponent", "GetCurrentState");

	Params::TgfNpcStateManagerComponent_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcStateManagerComponent.GetOwningCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfNpcStateManagerComponent::GetOwningCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcStateManagerComponent", "GetOwningCharacter");

	Params::TgfNpcStateManagerComponent_GetOwningCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcStateManagerComponent.IsInState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UTgfNpcState>         NpcState                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfNpcStateManagerComponent::IsInState(TSubclassOf<class UTgfNpcState> NpcState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcStateManagerComponent", "IsInState");

	Params::TgfNpcStateManagerComponent_IsInState Parms{};

	Parms.NpcState = NpcState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfNpcStateManagerComponent.MoveToState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTgfNpcState>         NextState                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfNpcStateManagerComponent::MoveToState(TSubclassOf<class UTgfNpcState> NextState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfNpcStateManagerComponent", "MoveToState");

	Params::TgfNpcStateManagerComponent_MoveToState Parms{};

	Parms.NextState = NextState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPlayerGameFlow.ClientEscape
// (Native, Event, Public, BlueprintEvent)

void UTgfPlayerGameFlow::ClientEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "ClientEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPlayerGameFlow.ClientTeleport
// (Native, Event, Public, BlueprintEvent)

void UTgfPlayerGameFlow::ClientTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "ClientTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPlayerGameFlow.ClientTeleportPawn
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTgfPlayerGameFlow::ClientTeleportPawn(class APawn* Pawn, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "ClientTeleportPawn");

	Params::TgfPlayerGameFlow_ClientTeleportPawn Parms{};

	Parms.Pawn = Pawn;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPlayerGameFlow.K2_ServerEscape
// (Event, Protected, BlueprintEvent)

void UTgfPlayerGameFlow::K2_ServerEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "K2_ServerEscape");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfPlayerGameFlow.K2_ServerTeleport
// (Event, Protected, BlueprintEvent)

void UTgfPlayerGameFlow::K2_ServerTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "K2_ServerTeleport");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfPlayerGameFlow.OnPlayerEnterPortal
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTgfEnterPortalParameter         Parameter                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTgfPlayerGameFlow::OnPlayerEnterPortal(const struct FTgfEnterPortalParameter& Parameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "OnPlayerEnterPortal");

	Params::TgfPlayerGameFlow_OnPlayerEnterPortal Parms{};

	Parms.Parameter = std::move(Parameter);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfPlayerGameFlow.ServerEscape
// (Final, Native, Public, BlueprintCallable)

void UTgfPlayerGameFlow::ServerEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "ServerEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPlayerGameFlow.ServerTeleport
// (Final, Native, Public, BlueprintCallable)

void UTgfPlayerGameFlow::ServerTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "ServerTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfPlayerGameFlow.TeleportToChosenPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsDeathPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfPlayerGameFlow::TeleportToChosenPoint(bool IsDeathPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfPlayerGameFlow", "TeleportToChosenPoint");

	Params::TgfPlayerGameFlow_TeleportToChosenPoint Parms{};

	Parms.IsDeathPoint = IsDeathPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGearsetInstance.AddGearsetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfGearsetInstance::AddGearsetLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGearsetInstance", "AddGearsetLevel");

	Params::TgfGearsetInstance_AddGearsetLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGearsetInstance.OnRep_GearsetLevel
// (Final, Native, Protected)

void UTgfGearsetInstance::OnRep_GearsetLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGearsetInstance", "OnRep_GearsetLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGearsetInstance.GetGearsetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfGearsetInstance::GetGearsetLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGearsetInstance", "GetGearsetLevel");

	Params::TgfGearsetInstance_GetGearsetLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfProjectileBase.AddGameplayAuras
// (Native, Event, Public, BlueprintEvent)

void ATgfProjectileBase::AddGameplayAuras()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "AddGameplayAuras");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.ApplyProjectileEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    AutoDestroy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfProjectileBase::ApplyProjectileEffect(class AActor* InHitActor, const struct FHitResult& InHitResult, bool AutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "ApplyProjectileEffect");

	Params::TgfProjectileBase_ApplyProjectileEffect Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InHitResult = std::move(InHitResult);
	Parms.AutoDestroy = AutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.ChangeMesh
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMesh*                    Mesh                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfProjectileBase::ChangeMesh(class USkeletalMesh* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "ChangeMesh");

	Params::TgfProjectileBase_ChangeMesh Parms{};

	Parms.Mesh = Mesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfProjectileBase.CheckGuarded
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfProjectileBase::CheckGuarded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "CheckGuarded");

	Params::TgfProjectileBase_CheckGuarded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfProjectileBase.CheckHitInteractEnvironment
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfProjectileBase::CheckHitInteractEnvironment(const struct FHitResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "CheckHitInteractEnvironment");

	Params::TgfProjectileBase_CheckHitInteractEnvironment Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfProjectileBase.ClientNotifyApplyProjectileEffect
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    AutoDestroy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfProjectileBase::ClientNotifyApplyProjectileEffect(class AActor* InHitActor, const struct FHitResult& InHitResult, bool AutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "ClientNotifyApplyProjectileEffect");

	Params::TgfProjectileBase_ClientNotifyApplyProjectileEffect Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InHitResult = std::move(InHitResult);
	Parms.AutoDestroy = AutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.Explode
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    AutoDestroy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InExcludedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreSelf                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ExplodeCenter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfProjectileBase::Explode(TArray<class AActor*>* OutActors, bool AutoDestroy, class AActor* InExcludedActor, bool IgnoreSelf, const struct FVector& ExplodeCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "Explode");

	Params::TgfProjectileBase_Explode Parms{};

	Parms.AutoDestroy = AutoDestroy;
	Parms.InExcludedActor = InExcludedActor;
	Parms.IgnoreSelf = IgnoreSelf;
	Parms.ExplodeCenter = std::move(ExplodeCenter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function LyraGame.TgfProjectileBase.InitDifferentTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ATgfProjectileBase::InitDifferentTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "InitDifferentTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.InitGameplayEffectContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FProjectileInitParams            Params_0                                               (Parm, NativeAccessSpecifierPublic)

void ATgfProjectileBase::InitGameplayEffectContext(const struct FProjectileInitParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "InitGameplayEffectContext");

	Params::TgfProjectileBase_InitGameplayEffectContext Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.InitGameplayEffectContextInBP
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ATgfProjectileBase::InitGameplayEffectContextInBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "InitGameplayEffectContextInBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfProjectileBase.InitOwnerTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ATgfProjectileBase::InitOwnerTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "InitOwnerTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.InitSameTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ATgfProjectileBase::InitSameTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "InitSameTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.InitUnknownTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ATgfProjectileBase::InitUnknownTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "InitUnknownTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileBase.RemoveGameplayAuras
// (Native, Event, Public, BlueprintEvent)

void ATgfProjectileBase::RemoveGameplayAuras()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileBase", "RemoveGameplayAuras");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfProjectileAnimDrive.CheckHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfProjectileAnimDrive::CheckHit(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfProjectileAnimDrive", "CheckHit");

	Params::TgfProjectileAnimDrive_CheckHit Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlatformEmulationSettings.GetKnownDeviceProfiles
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULyraPlatformEmulationSettings::GetKnownDeviceProfiles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlatformEmulationSettings", "GetKnownDeviceProfiles");

	Params::LyraPlatformEmulationSettings_GetKnownDeviceProfiles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlatformEmulationSettings.GetKnownPlatformIds
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULyraPlatformEmulationSettings::GetKnownPlatformIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlatformEmulationSettings", "GetKnownPlatformIds");

	Params::LyraPlatformEmulationSettings_GetKnownPlatformIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfQuickIntoryWidget.BP_OnViewTargetChanged
// (Event, Public, BlueprintEvent)

void UTgfQuickIntoryWidget::BP_OnViewTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfQuickIntoryWidget", "BP_OnViewTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfQuickIntoryWidget.OnChangeViewTarget
// (Final, Native, Private)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfQuickIntoryWidget::OnChangeViewTarget(class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfQuickIntoryWidget", "OnChangeViewTarget");

	Params::TgfQuickIntoryWidget_OnChangeViewTarget Parms{};

	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRagdollComponent.ApplyPhysicalAnimationProfileBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNotFound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfRagdollComponent::ApplyPhysicalAnimationProfileBelow(class FName BodyName, class FName ProfileName, bool bIncludeSelf, bool bClearNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRagdollComponent", "ApplyPhysicalAnimationProfileBelow");

	Params::TgfRagdollComponent_ApplyPhysicalAnimationProfileBelow Parms{};

	Parms.BodyName = BodyName;
	Parms.ProfileName = ProfileName;
	Parms.bIncludeSelf = bIncludeSelf;
	Parms.bClearNotFound = bClearNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRagdollComponent.SetPhysAnimEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfRagdollComponent::SetPhysAnimEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRagdollComponent", "SetPhysAnimEnabled");

	Params::TgfRagdollComponent_SetPhysAnimEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRagdollComponent.GetPhysAnimComp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicalAnimationComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalAnimationComponent* UTgfRagdollComponent::GetPhysAnimComp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRagdollComponent", "GetPhysAnimComp");

	Params::TgfRagdollComponent_GetPhysAnimComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfRangedWeaponAnimHelperInterface.GetHelperComponent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTgfRangedWeaponAnimHelperComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfRangedWeaponAnimHelperComponent* ITgfRangedWeaponAnimHelperInterface::GetHelperComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperInterface", "GetHelperComponent");

	Params::TgfRangedWeaponAnimHelperInterface_GetHelperComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.ReceiveDraw
// (Event, Protected, BlueprintEvent)

void UTgfRangedWeaponAnimHelperComponent::ReceiveDraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "ReceiveDraw");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.ReceiveFire
// (Event, Protected, BlueprintEvent)

void UTgfRangedWeaponAnimHelperComponent::ReceiveFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "ReceiveFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.ReceiveReload
// (Event, Protected, BlueprintEvent)

void UTgfRangedWeaponAnimHelperComponent::ReceiveReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "ReceiveReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.ReceiveReset
// (Event, Protected, BlueprintEvent)

void UTgfRangedWeaponAnimHelperComponent::ReceiveReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "ReceiveReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.ReceiveToggleADS
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfRangedWeaponAnimHelperComponent::ReceiveToggleADS(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "ReceiveToggleADS");

	Params::TgfRangedWeaponAnimHelperComponent_ReceiveToggleADS Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.ToAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERangedWeaponActionType                 Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MontagePlayRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfRangedWeaponAnimHelperComponent::ToAction(ERangedWeaponActionType Action, float MontagePlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "ToAction");

	Params::TgfRangedWeaponAnimHelperComponent_ToAction Parms{};

	Parms.Action = Action;
	Parms.MontagePlayRate = MontagePlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.TryPlayActionMontage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ERangedWeaponActionType                 Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfRangedWeaponAnimHelperComponent::TryPlayActionMontage(ERangedWeaponActionType Action, float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "TryPlayActionMontage");

	Params::TgfRangedWeaponAnimHelperComponent_TryPlayActionMontage Parms{};

	Parms.Action = Action;
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRangedWeaponAnimHelperComponent.GetStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWeaponAnimStateInfo       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FWeaponAnimStateInfo UTgfRangedWeaponAnimHelperComponent::GetStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRangedWeaponAnimHelperComponent", "GetStatus");

	Params::TgfRangedWeaponAnimHelperComponent_GetStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnActivateRelatedGAFailed
// (Event, Public, BlueprintEvent)

void UTgfSkillWidgetBase::BP_OnActivateRelatedGAFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnActivateRelatedGAFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnBuffAdd
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTgfGameplayEffect*               GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSkillWidgetBase::BP_OnBuffAdd(class UTgfGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle, float RemainTime, float TotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnBuffAdd");

	Params::TgfSkillWidgetBase_BP_OnBuffAdd Parms{};

	Parms.GE = GE;
	Parms.ActiveHandle = std::move(ActiveHandle);
	Parms.RemainTime = RemainTime;
	Parms.TotalTime = TotalTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnCooldownEnd
// (Event, Public, BlueprintEvent)

void UTgfSkillWidgetBase::BP_OnCooldownEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnCooldownEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnCooldownStart
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CooldownTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedHideDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HideDurationLimit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSkillWidgetBase::BP_OnCooldownStart(float CooldownTime, float TotalTime, bool bNeedHideDuration, float HideDurationLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnCooldownStart");

	Params::TgfSkillWidgetBase_BP_OnCooldownStart Parms{};

	Parms.CooldownTime = CooldownTime;
	Parms.TotalTime = TotalTime;
	Parms.bNeedHideDuration = bNeedHideDuration;
	Parms.HideDurationLimit = HideDurationLimit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnGameplayAbilityEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class UGameplayAbility*                 GameplayAbility                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSkillWidgetBase::BP_OnGameplayAbilityEnd(class UGameplayAbility* GameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnGameplayAbilityEnd");

	Params::TgfSkillWidgetBase_BP_OnGameplayAbilityEnd Parms{};

	Parms.GameplayAbility = GameplayAbility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnGEApply
// (Event, Public, BlueprintEvent)
// Parameters:
// class UGameplayEffect*                  GE                                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSkillWidgetBase::BP_OnGEApply(const class UGameplayEffect* GE, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnGEApply");

	Params::TgfSkillWidgetBase_BP_OnGEApply Parms{};

	Parms.GE = GE;
	Parms.ActiveHandle = std::move(ActiveHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnGERemove
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FActiveGameplayEffectHandle      GEHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSkillWidgetBase::BP_OnGERemove(const struct FActiveGameplayEffectHandle& GEHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnGERemove");

	Params::TgfSkillWidgetBase_BP_OnGERemove Parms{};

	Parms.GEHandle = std::move(GEHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSkillWidgetBase.BP_OnSkillResourceChanged
// (Event, Public, BlueprintEvent)

void UTgfSkillWidgetBase::BP_OnSkillResourceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "BP_OnSkillResourceChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfSkillWidgetBase.CheckCostEnough
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfSkillWidgetBase::CheckCostEnough()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "CheckCostEnough");

	Params::TgfSkillWidgetBase_CheckCostEnough Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSkillWidgetBase.CheckHasAdditionalWeapon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfSkillWidgetBase::CheckHasAdditionalWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "CheckHasAdditionalWeapon");

	Params::TgfSkillWidgetBase_CheckHasAdditionalWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSkillWidgetBase.CheckSkillCanActive
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfSkillWidgetBase::CheckSkillCanActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "CheckSkillCanActive");

	Params::TgfSkillWidgetBase_CheckSkillCanActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSkillWidgetBase.FormatCooldownTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   CDTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfSkillWidgetBase::FormatCooldownTime(float CDTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "FormatCooldownTime");

	Params::TgfSkillWidgetBase_FormatCooldownTime Parms{};

	Parms.CDTime = CDTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSkillWidgetBase.StartSkillCooldown
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ShowCDTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSkillWidgetBase::StartSkillCooldown(float ShowCDTime, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSkillWidgetBase", "StartSkillCooldown");

	Params::TgfSkillWidgetBase_StartSkillCooldown Parms{};

	Parms.ShowCDTime = ShowCDTime;
	Parms.DelayTime = DelayTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSnapToTargetDataAsset.GetQueryConfig
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTgfSnapQueryConfig              OutSnapQueryConfig                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfSnapToTargetDataAsset::GetQueryConfig(struct FTgfSnapQueryConfig* OutSnapQueryConfig) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSnapToTargetDataAsset", "GetQueryConfig");

	Params::TgfSnapToTargetDataAsset_GetQueryConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSnapQueryConfig != nullptr)
		*OutSnapQueryConfig = std::move(Parms.OutSnapQueryConfig);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSpectatingActor.OnExperienceLoaded
// (Final, Native, Protected)
// Parameters:
// class ULyraExperienceDefinition*        Experience                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfSpectatingActor::OnExperienceLoaded(const class ULyraExperienceDefinition* Experience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatingActor", "OnExperienceLoaded");

	Params::TgfSpectatingActor_OnExperienceLoaded Parms{};

	Parms.Experience = Experience;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatingActor.DetermineCameraMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraCameraMode>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraCameraMode> ATgfSpectatingActor::DetermineCameraMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatingActor", "DetermineCameraMode");

	Params::TgfSpectatingActor_DetermineCameraMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSpectatorManagerComponent.AddSpectatingActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATgfSpectatingActor*              Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::AddSpectatingActors(class ATgfSpectatingActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "AddSpectatingActors");

	Params::TgfSpectatorManagerComponent_AddSpectatingActors Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.CancelWidgetWhenSwitch
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UTgfSpectatorManagerComponent::CancelWidgetWhenSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "CancelWidgetWhenSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfSpectatorManagerComponent.FinishBlockSpectate
// (Final, Native, Private)

void UTgfSpectatorManagerComponent::FinishBlockSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "FinishBlockSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.ForceSwitchToOwn
// (Final, Native, Public, BlueprintCallable)

void UTgfSpectatorManagerComponent::ForceSwitchToOwn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "ForceSwitchToOwn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.HandlePlayerDeath
// (Final, Native, Public, BlueprintCallable)

void UTgfSpectatorManagerComponent::HandlePlayerDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "HandlePlayerDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.HandlePlayerDeathMithril
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NeedSpectatePlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::HandlePlayerDeathMithril(bool NeedSpectatePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "HandlePlayerDeathMithril");

	Params::TgfSpectatorManagerComponent_HandlePlayerDeathMithril Parms{};

	Parms.NeedSpectatePlayer = NeedSpectatePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.MithrilRebirthCountDown
// (Event, Protected, BlueprintEvent)

void UTgfSpectatorManagerComponent::MithrilRebirthCountDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "MithrilRebirthCountDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfSpectatorManagerComponent.MithrilRebirthNotice
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::MithrilRebirthNotice(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "MithrilRebirthNotice");

	Params::TgfSpectatorManagerComponent_MithrilRebirthNotice Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfSpectatorManagerComponent.OnViewMithrilRebirthExhausted
// (Final, Native, Public)
// Parameters:
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::OnViewMithrilRebirthExhausted(class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "OnViewMithrilRebirthExhausted");

	Params::TgfSpectatorManagerComponent_OnViewMithrilRebirthExhausted Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.OnViewTargetDeathFinish
// (Final, Native, Public)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::OnViewTargetDeathFinish(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "OnViewTargetDeathFinish");

	Params::TgfSpectatorManagerComponent_OnViewTargetDeathFinish Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.OnViewTargetExtractPortal
// (Final, Native, Public)
// Parameters:
// class AActor*                           TargetPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::OnViewTargetExtractPortal(class AActor* TargetPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "OnViewTargetExtractPortal");

	Params::TgfSpectatorManagerComponent_OnViewTargetExtractPortal Parms{};

	Parms.TargetPawn = TargetPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.OpenSpectateNoticeWindow
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// ESpectatingTargetType                   TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::OpenSpectateNoticeWindow(ESpectatingTargetType TargetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "OpenSpectateNoticeWindow");

	Params::TgfSpectatorManagerComponent_OpenSpectateNoticeWindow Parms{};

	Parms.TargetType = TargetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.PVPRebirthCountDown
// (Event, Protected, BlueprintEvent)

void UTgfSpectatorManagerComponent::PVPRebirthCountDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "PVPRebirthCountDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfSpectatorManagerComponent.ServerChangeViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpectatingTargetType                   CurrentType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::ServerChangeViewTarget(class AActor* Target, ESpectatingTargetType CurrentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "ServerChangeViewTarget");

	Params::TgfSpectatorManagerComponent_ServerChangeViewTarget Parms{};

	Parms.Target = Target;
	Parms.CurrentType = CurrentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.SetCurrentViewTarget
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::SetCurrentViewTarget(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "SetCurrentViewTarget");

	Params::TgfSpectatorManagerComponent_SetCurrentViewTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.StopSpectate
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTgfSpectatorManagerComponent::StopSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "StopSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.StopSpectateWhenRebirth
// (Final, Native, Public, BlueprintCallable)

void UTgfSpectatorManagerComponent::StopSpectateWhenRebirth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "StopSpectateWhenRebirth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.TrySpectate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReverseSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpectatorManagerComponent::TrySpectate(bool ReverseSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "TrySpectate");

	Params::TgfSpectatorManagerComponent_TrySpectate Parms{};

	Parms.ReverseSelection = ReverseSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpectatorManagerComponent.WaitingToSpectate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IgnoreNoTarget                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DirectlySpectate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedSpectatePlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfSpectatorManagerComponent::WaitingToSpectate(bool IgnoreNoTarget, bool DirectlySpectate, bool NeedSpectatePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpectatorManagerComponent", "WaitingToSpectate");

	Params::TgfSpectatorManagerComponent_WaitingToSpectate Parms{};

	Parms.IgnoreNoTarget = IgnoreNoTarget;
	Parms.DirectlySpectate = DirectlySpectate;
	Parms.NeedSpectatePlayer = NeedSpectatePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStaffBeamDecal.SetBeamDecalPos
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CurrentPos                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfStaffBeamDecal::SetBeamDecalPos(const struct FVector& CurrentPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaffBeamDecal", "SetBeamDecalPos");

	Params::TgfStaffBeamDecal_SetBeamDecalPos Parms{};

	Parms.CurrentPos = std::move(CurrentPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaffBeamDecal.SetBeamDecalRot
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfStaffBeamDecal::SetBeamDecalRot(const struct FVector& HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaffBeamDecal", "SetBeamDecalRot");

	Params::TgfStaffBeamDecal_SetBeamDecalRot Parms{};

	Parms.HitNormal = std::move(HitNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatBlueprintFunctionLibrary.AddActorIntStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorIntStatisticType               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfStatBlueprintFunctionLibrary::AddActorIntStat(class AActor* Actor, ETgfActorIntStatisticType Type, int32 TypeId, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfStatBlueprintFunctionLibrary", "AddActorIntStat");

	Params::TgfStatBlueprintFunctionLibrary_AddActorIntStat Parms{};

	Parms.Actor = Actor;
	Parms.Type = Type;
	Parms.TypeId = TypeId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatBlueprintFunctionLibrary.AddActorRelationIntStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRelationStatisticType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfStatBlueprintFunctionLibrary::AddActorRelationIntStat(class AActor* Actor, ETgfActorRelationStatisticType Type, class AActor* OtherPlayer, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfStatBlueprintFunctionLibrary", "AddActorRelationIntStat");

	Params::TgfStatBlueprintFunctionLibrary_AddActorRelationIntStat Parms{};

	Parms.Actor = Actor;
	Parms.Type = Type;
	Parms.OtherPlayer = OtherPlayer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatBlueprintFunctionLibrary.AddActorRelationIntStatById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfActorRelationStatisticType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OtherPlayerOpenId                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfStatBlueprintFunctionLibrary::AddActorRelationIntStatById(class AActor* Actor, ETgfActorRelationStatisticType Type, const class FString& OtherPlayerOpenId, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfStatBlueprintFunctionLibrary", "AddActorRelationIntStatById");

	Params::TgfStatBlueprintFunctionLibrary_AddActorRelationIntStatById Parms{};

	Parms.Actor = Actor;
	Parms.Type = Type;
	Parms.OtherPlayerOpenId = std::move(OtherPlayerOpenId);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatBlueprintFunctionLibrary.CompareActorTeams
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          A                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          B                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraTeamComparison                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraTeamComparison UTgfStatBlueprintFunctionLibrary::CompareActorTeams(const class UWorld* World, const class UObject* A, const class UObject* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfStatBlueprintFunctionLibrary", "CompareActorTeams");

	Params::TgfStatBlueprintFunctionLibrary_CompareActorTeams Parms{};

	Parms.World = World;
	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStatBlueprintFunctionLibrary.FindSummonMaster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* UTgfStatBlueprintFunctionLibrary::FindSummonMaster(const class ALyraCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfStatBlueprintFunctionLibrary", "FindSummonMaster");

	Params::TgfStatBlueprintFunctionLibrary_FindSummonMaster Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStaticInteraction.AddRepObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfStaticInteraction::AddRepObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "AddRepObject");

	Params::TgfStaticInteraction_AddRepObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaticInteraction.BindMoonPhaseChangeEvent
// (Final, Native, Public, BlueprintCallable)

void ATgfStaticInteraction::BindMoonPhaseChangeEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "BindMoonPhaseChangeEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaticInteraction.HandleHomelandMoonPhaseChangeEvent
// (Final, Native, Public)
// Parameters:
// class UObject*                          Args                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfStaticInteraction::HandleHomelandMoonPhaseChangeEvent(class UObject* Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "HandleHomelandMoonPhaseChangeEvent");

	Params::TgfStaticInteraction_HandleHomelandMoonPhaseChangeEvent Parms{};

	Parms.Args = Args;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaticInteraction.K2_HandleHomelandMoonPhaseChangeEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   MoonPhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfStaticInteraction::K2_HandleHomelandMoonPhaseChangeEvent(int32 MoonPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_HandleHomelandMoonPhaseChangeEvent");

	Params::TgfStaticInteraction_K2_HandleHomelandMoonPhaseChangeEvent Parms{};

	Parms.MoonPhase = MoonPhase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfStaticInteraction.K2_OnActorChannelOpen
// (Event, Public, BlueprintEvent)

void ATgfStaticInteraction::K2_OnActorChannelOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_OnActorChannelOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfStaticInteraction.K2_OnEndPlay
// (Event, Public, BlueprintEvent)

void ATgfStaticInteraction::K2_OnEndPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_OnEndPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfStaticInteraction.K2_OnNetCleanup
// (Event, Public, BlueprintEvent)

void ATgfStaticInteraction::K2_OnNetCleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_OnNetCleanup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfStaticInteraction.K2_OnPostNetInit
// (Event, Public, BlueprintEvent)

void ATgfStaticInteraction::K2_OnPostNetInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_OnPostNetInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfStaticInteraction.K2_OnPostNetReceive
// (Event, Public, BlueprintEvent)

void ATgfStaticInteraction::K2_OnPostNetReceive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_OnPostNetReceive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfStaticInteraction.K2_OnPreNetReceive
// (Event, Public, BlueprintEvent)

void ATgfStaticInteraction::K2_OnPreNetReceive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "K2_OnPreNetReceive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfStaticInteraction.OnDeathFinished
// (Native, Protected)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfStaticInteraction::OnDeathFinished(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "OnDeathFinished");

	Params::TgfStaticInteraction_OnDeathFinished Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaticInteraction.OnDeathStarted
// (Native, Protected)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfStaticInteraction::OnDeathStarted(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "OnDeathStarted");

	Params::TgfStaticInteraction_OnDeathStarted Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaticInteraction.RemoveRepObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfStaticInteraction::RemoveRepObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "RemoveRepObject");

	Params::TgfStaticInteraction_RemoveRepObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStaticInteraction.GetInterableStatIdList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int32> ATgfStaticInteraction::GetInterableStatIdList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "GetInterableStatIdList");

	Params::TgfStaticInteraction_GetInterableStatIdList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStaticInteraction.GetInterableType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfInterableType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfInterableType ATgfStaticInteraction::GetInterableType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "GetInterableType");

	Params::TgfStaticInteraction_GetInterableType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStaticInteraction.IsDeadOrDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfStaticInteraction::IsDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "IsDeadOrDying");

	Params::TgfStaticInteraction_IsDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStaticInteraction.IsEnableBattle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfStaticInteraction::IsEnableBattle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "IsEnableBattle");

	Params::TgfStaticInteraction_IsEnableBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStaticInteraction.IsLightType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfStaticInteraction::IsLightType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStaticInteraction", "IsLightType");

	Params::TgfStaticInteraction_IsLightType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSystemBlueprintLibrary.OnQuitGame
// (Final, Native, Static, Public, BlueprintCallable)

void UTgfSystemBlueprintLibrary::OnQuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfSystemBlueprintLibrary", "OnQuitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTargetToSnapComponent.GetTargetLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTgfTargetToSnapComponent::GetTargetLocation(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfTargetToSnapComponent", "GetTargetLocation");

	Params::TgfTargetToSnapComponent_GetTargetLocation Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameMode.ChooseDeathPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALyraGameMode::ChooseDeathPoint(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "ChooseDeathPoint");

	Params::LyraGameMode_ChooseDeathPoint Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameMode.ChooseWaitingPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALyraGameMode::ChooseWaitingPoint(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "ChooseWaitingPoint");

	Params::LyraGameMode_ChooseWaitingPoint Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameMode.DestroyCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraGameMode::DestroyCharacter(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "DestroyCharacter");

	Params::LyraGameMode_DestroyCharacter Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameMode.RequestPlayerRestartNextFrame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraGameMode::RequestPlayerRestartNextFrame(class AController* Controller, bool bForceReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "RequestPlayerRestartNextFrame");

	Params::LyraGameMode_RequestPlayerRestartNextFrame Parms{};

	Parms.Controller = Controller;
	Parms.bForceReset = bForceReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameMode.SpawnCharacter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class ALyraAIController>    ControllerClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraAIControllerData*            ControllerData                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAIController* ALyraGameMode::SpawnCharacter(TSubclassOf<class ALyraAIController> ControllerClass, class ULyraAIControllerData* ControllerData, const struct FTransform& Transform, int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "SpawnCharacter");

	Params::LyraGameMode_SpawnCharacter Parms{};

	Parms.ControllerClass = ControllerClass;
	Parms.ControllerData = ControllerData;
	Parms.Transform = std::move(Transform);
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameMode.GetMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfMatchType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfMatchType ALyraGameMode::GetMatchType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "GetMatchType");

	Params::LyraGameMode_GetMatchType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameMode.GetPawnDataForController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      InController                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULyraPawnData*              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraPawnData* ALyraGameMode::GetPawnDataForController(const class AController* InController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "GetPawnDataForController");

	Params::LyraGameMode_GetPawnDataForController Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameMode.IsPvpMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameMode::IsPvpMatchType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameMode", "IsPvpMatchType");

	Params::LyraGameMode_IsPvpMatchType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfTestNetRPCs.ClientCall
// (Net, NetReliable, Native, Event, Protected, NetClient, BlueprintCallable)
// Parameters:
// ECallSource                             CallSource                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfTestNetRPCs::ClientCall(ECallSource CallSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTestNetRPCs", "ClientCall");

	Params::TgfTestNetRPCs_ClientCall Parms{};

	Parms.CallSource = CallSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTestNetRPCs.ServerCall
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// ECallSource                             CallSource                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfTestNetRPCs::ServerCall(ECallSource CallSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTestNetRPCs", "ServerCall");

	Params::TgfTestNetRPCs_ServerCall Parms{};

	Parms.CallSource = CallSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AsyncAction_LevelReady.WaitForLevelReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeoutSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_LevelReady*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_LevelReady* UAsyncAction_LevelReady::WaitForLevelReady(class UObject* WorldContextObject, float TimeoutSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_LevelReady", "WaitForLevelReady");

	Params::AsyncAction_LevelReady_WaitForLevelReady Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TimeoutSeconds = TimeoutSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.AddThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Threat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::AddThreat(class AActor* Actor, float Threat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "AddThreat");

	Params::TGFThreatManagerComponent_AddThreat Parms{};

	Parms.Actor = Actor;
	Parms.Threat = Threat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.ClearTeamThreatList
// (Final, Native, Public, BlueprintCallable)

void UTGFThreatManagerComponent::ClearTeamThreatList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "ClearTeamThreatList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TGFThreatManagerComponent.ClearThreatList
// (Final, Native, Public, BlueprintCallable)

void UTGFThreatManagerComponent::ClearThreatList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "ClearThreatList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TGFThreatManagerComponent.GetHighestThreat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::GetHighestThreat(class AActor** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetHighestThreat");

	Params::TGFThreatManagerComponent_GetHighestThreat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Target != nullptr)
		*Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetLowestThreat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::GetLowestThreat(class AActor** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetLowestThreat");

	Params::TGFThreatManagerComponent_GetLowestThreat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Target != nullptr)
		*Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetSortedTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfMonsterSelectTargetType             SelectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ASC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FThreatInfo>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FThreatInfo> UTGFThreatManagerComponent::GetSortedTargets(ETgfMonsterSelectTargetType SelectType, bool ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetSortedTargets");

	Params::TGFThreatManagerComponent_GetSortedTargets Parms{};

	Parms.SelectType = SelectType;
	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetSortedThreat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    ASC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::GetSortedThreat(bool ASC, int32 Param_Index, class AActor** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetSortedThreat");

	Params::TGFThreatManagerComponent_GetSortedThreat Parms{};

	Parms.ASC = ASC;
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Target != nullptr)
		*Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetTeamThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::GetTeamThreat(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetTeamThreat");

	Params::TGFThreatManagerComponent_GetTeamThreat Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetTeamThreatList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class AActor*, float>              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class AActor*, float> UTGFThreatManagerComponent::GetTeamThreatList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetTeamThreatList");

	Params::TGFThreatManagerComponent_GetTeamThreatList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::GetThreat(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetThreat");

	Params::TGFThreatManagerComponent_GetThreat Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetThreatList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class AActor*, float>              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class AActor*, float> UTGFThreatManagerComponent::GetThreatList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetThreatList");

	Params::TGFThreatManagerComponent_GetThreatList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.GetThreatTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTGFThreatManagerComponent::GetThreatTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "GetThreatTarget");

	Params::TGFThreatManagerComponent_GetThreatTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.HasTeamThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTGFThreatManagerComponent::HasTeamThreat(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "HasTeamThreat");

	Params::TGFThreatManagerComponent_HasTeamThreat Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.HasThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTGFThreatManagerComponent::HasThreat(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "HasThreat");

	Params::TGFThreatManagerComponent_HasThreat Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.HasThreats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTGFThreatManagerComponent::HasThreats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "HasThreats");

	Params::TGFThreatManagerComponent_HasThreats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.RemoveTeamThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTGFThreatManagerComponent::RemoveTeamThreat(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "RemoveTeamThreat");

	Params::TGFThreatManagerComponent_RemoveTeamThreat Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TGFThreatManagerComponent.RemoveThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTGFThreatManagerComponent::RemoveThreat(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "RemoveThreat");

	Params::TGFThreatManagerComponent_RemoveThreat Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TGFThreatManagerComponent.SetTeamThreat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Threat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTGFThreatManagerComponent::SetTeamThreat(class AActor* Actor, float Threat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "SetTeamThreat");

	Params::TGFThreatManagerComponent_SetTeamThreat Parms{};

	Parms.Actor = Actor;
	Parms.Threat = Threat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TGFThreatManagerComponent.SetThreatTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTGFThreatManagerComponent::SetThreatTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "SetThreatTarget");

	Params::TGFThreatManagerComponent_SetThreatTarget Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TGFThreatManagerComponent.SyncThreatList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTGFThreatManagerComponent*       Source                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SyncThreatValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTGFThreatManagerComponent::SyncThreatList(class UTGFThreatManagerComponent* Source, bool SyncThreatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TGFThreatManagerComponent", "SyncThreatList");

	Params::TGFThreatManagerComponent_SyncThreatList Parms{};

	Parms.Source = Source;
	Parms.SyncThreatValue = SyncThreatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ACEReportPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TargetOpenIdAndZoneIdString                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerNameData                  TargetInPlayerNameData                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerController*                SourcePC                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ACEReportPlayer(const class FString& TargetOpenIdAndZoneIdString, const struct FPlayerNameData& TargetInPlayerNameData, class APlayerController* SourcePC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ACEReportPlayer");

	Params::TgfUIBlueprintLibrary_ACEReportPlayer Parms{};

	Parms.TargetOpenIdAndZoneIdString = std::move(TargetOpenIdAndZoneIdString);
	Parms.TargetInPlayerNameData = std::move(TargetInPlayerNameData);
	Parms.SourcePC = SourcePC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ChangeAnimationCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          BindingObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ChangeAnimationCurve(class UWidgetAnimation* InAnimation, class FName TargetTrackName, class UObject* BindingObject, float StartValue, float EndValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ChangeAnimationCurve");

	Params::TgfUIBlueprintLibrary_ChangeAnimationCurve Parms{};

	Parms.InAnimation = InAnimation;
	Parms.TargetTrackName = TargetTrackName;
	Parms.BindingObject = BindingObject;
	Parms.StartValue = StartValue;
	Parms.EndValue = EndValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetActivityOpened
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ActivityId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::GetActivityOpened(int32 ActivityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetActivityOpened");

	Params::TgfUIBlueprintLibrary_GetActivityOpened Parms{};

	Parms.ActivityId = ActivityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetAppVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfUIBlueprintLibrary::GetAppVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetAppVersion");

	Params::TgfUIBlueprintLibrary_GetAppVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetChargeSkillMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::GetChargeSkillMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetChargeSkillMethod");

	Params::TgfUIBlueprintLibrary_GetChargeSkillMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetConfiguredServerFrame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfUIBlueprintLibrary::GetConfiguredServerFrame(float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetConfiguredServerFrame");

	Params::TgfUIBlueprintLibrary_GetConfiguredServerFrame Parms{};

	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetCurrentInputType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonInputType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECommonInputType UTgfUIBlueprintLibrary::GetCurrentInputType(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetCurrentInputType");

	Params::TgfUIBlueprintLibrary_GetCurrentInputType Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetCurrentTimeStamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UTgfUIBlueprintLibrary::GetCurrentTimeStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetCurrentTimeStamp");

	Params::TgfUIBlueprintLibrary_GetCurrentTimeStamp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetIsShowWeaponOperationTips
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::GetIsShowWeaponOperationTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetIsShowWeaponOperationTips");

	Params::TgfUIBlueprintLibrary_GetIsShowWeaponOperationTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetKeyName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UTgfUIBlueprintLibrary::GetKeyName(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetKeyName");

	Params::TgfUIBlueprintLibrary_GetKeyName Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetMouseTargetingMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::GetMouseTargetingMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetMouseTargetingMethod");

	Params::TgfUIBlueprintLibrary_GetMouseTargetingMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetNameFromPlayerNameData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayerNameData                  InPlayerNameData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsForceUseHiddenName                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfUIBlueprintLibrary::GetNameFromPlayerNameData(const struct FPlayerNameData& InPlayerNameData, bool bIsForceUseHiddenName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetNameFromPlayerNameData");

	Params::TgfUIBlueprintLibrary_GetNameFromPlayerNameData Parms{};

	Parms.InPlayerNameData = std::move(InPlayerNameData);
	Parms.bIsForceUseHiddenName = bIsForceUseHiddenName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetPingLevelByConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Ping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfUIBlueprintLibrary::GetPingLevelByConfig(float Ping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetPingLevelByConfig");

	Params::TgfUIBlueprintLibrary_GetPingLevelByConfig Parms{};

	Parms.Ping = Ping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetRoleHeadPortraitIconPathInGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Gender                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FaceId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkinColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RowId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTgfUIBlueprintLibrary::GetRoleHeadPortraitIconPathInGame(int32 TypeId, int32 Gender, int32 FaceId, int32 SkinColor, int32 RowId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetRoleHeadPortraitIconPathInGame");

	Params::TgfUIBlueprintLibrary_GetRoleHeadPortraitIconPathInGame Parms{};

	Parms.TypeId = TypeId;
	Parms.Gender = Gender;
	Parms.FaceId = FaceId;
	Parms.SkinColor = SkinColor;
	Parms.RowId = RowId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetUtcTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UTgfUIBlueprintLibrary::GetUtcTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetUtcTime");

	Params::TgfUIBlueprintLibrary_GetUtcTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.GetWidgetOwnerCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UTgfUIBlueprintLibrary::GetWidgetOwnerCharacter(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "GetWidgetOwnerCharacter");

	Params::TgfUIBlueprintLibrary_GetWidgetOwnerCharacter Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.IsLinuxVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::IsLinuxVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "IsLinuxVersion");

	Params::TgfUIBlueprintLibrary_IsLinuxVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.IsTooltipsAttributeAppendRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::IsTooltipsAttributeAppendRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "IsTooltipsAttributeAppendRange");

	Params::TgfUIBlueprintLibrary_IsTooltipsAttributeAppendRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.IsWolrdTearingDown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::IsWolrdTearingDown(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "IsWolrdTearingDown");

	Params::TgfUIBlueprintLibrary_IsWolrdTearingDown Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.OpenGuideWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      FromWindow                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTgfUIBlueprintLibrary::OpenGuideWindow(class UUserWidget* FromWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "OpenGuideWindow");

	Params::TgfUIBlueprintLibrary_OpenGuideWindow Parms{};

	Parms.FromWindow = FromWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.OpenKeyBindingConflictWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTgfUIBlueprintLibrary::OpenKeyBindingConflictWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "OpenKeyBindingConflictWindow");

	Params::TgfUIBlueprintLibrary_OpenKeyBindingConflictWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.OpenReturnToLobbyConfirmWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      FromWindow                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::OpenReturnToLobbyConfirmWindow(class UUserWidget* FromWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "OpenReturnToLobbyConfirmWindow");

	Params::TgfUIBlueprintLibrary_OpenReturnToLobbyConfirmWindow Parms{};

	Parms.FromWindow = FromWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.OpenSettingWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      FromWindow                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTgfUIBlueprintLibrary::OpenSettingWindow(class UUserWidget* FromWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "OpenSettingWindow");

	Params::TgfUIBlueprintLibrary_OpenSettingWindow Parms{};

	Parms.FromWindow = FromWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.PathExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::PathExists(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "PathExists");

	Params::TgfUIBlueprintLibrary_PathExists Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.SendHomelandInteractTime
// (Final, Native, Static, Public, BlueprintCallable)

void UTgfUIBlueprintLibrary::SendHomelandInteractTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "SendHomelandInteractTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.SendHomelandPickupMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::SendHomelandPickupMessage(int32 ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "SendHomelandPickupMessage");

	Params::TgfUIBlueprintLibrary_SendHomelandPickupMessage Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.SendPVPChallengeReceiveAwardMessage
// (Final, Native, Static, Public, BlueprintCallable)

void UTgfUIBlueprintLibrary::SendPVPChallengeReceiveAwardMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "SendPVPChallengeReceiveAwardMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.SendReport
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FReportRecord                    Record                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::SendReport(const struct FReportRecord& Record)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "SendReport");

	Params::TgfUIBlueprintLibrary_SendReport Parms{};

	Parms.Record = std::move(Record);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.SetInBattlePing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InBattlePing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::SetInBattlePing(int32 InBattlePing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "SetInBattlePing");

	Params::TgfUIBlueprintLibrary_SetInBattlePing Parms{};

	Parms.InBattlePing = InBattlePing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.SetIsShowWeaponOperationTips
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::SetIsShowWeaponOperationTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "SetIsShowWeaponOperationTips");

	Params::TgfUIBlueprintLibrary_SetIsShowWeaponOperationTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShouldDrawDebug
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::ShouldDrawDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShouldDrawDebug");

	Params::TgfUIBlueprintLibrary_ShouldDrawDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShouldShutDownHallGlobalEffects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ShouldShutDownHallGlobalEffects(bool bIsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShouldShutDownHallGlobalEffects");

	Params::TgfUIBlueprintLibrary_ShouldShutDownHallGlobalEffects Parms{};

	Parms.bIsOpen = bIsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShouldTakeDeathScreenshot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::ShouldTakeDeathScreenshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShouldTakeDeathScreenshot");

	Params::TgfUIBlueprintLibrary_ShouldTakeDeathScreenshot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShowToast
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ShowToast(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShowToast");

	Params::TgfUIBlueprintLibrary_ShowToast Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShowToastWithActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// class AActor*                           InputActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ShowToastWithActor(const class FText& Message, class AActor* InputActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShowToastWithActor");

	Params::TgfUIBlueprintLibrary_ShowToastWithActor Parms{};

	Parms.Message = std::move(Message);
	Parms.InputActor = InputActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShowToastWithActorAndTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// class AActor*                           InputActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ShowToastWithActorAndTime(const class FText& Message, class AActor* InputActor, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShowToastWithActorAndTime");

	Params::TgfUIBlueprintLibrary_ShowToastWithActorAndTime Parms{};

	Parms.Message = std::move(Message);
	Parms.InputActor = InputActor;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ShowToastWithObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// class UObject*                          InputObject                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ShowToastWithObject(const class FText& Message, class UObject* InputObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ShowToastWithObject");

	Params::TgfUIBlueprintLibrary_ShowToastWithObject Parms{};

	Parms.Message = std::move(Message);
	Parms.InputObject = InputObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.TakeDeathScreenshot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutShotPath                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfUIBlueprintLibrary::TakeDeathScreenshot(class FString* OutShotPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "TakeDeathScreenshot");

	Params::TgfUIBlueprintLibrary_TakeDeathScreenshot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutShotPath != nullptr)
		*OutShotPath = std::move(Parms.OutShotPath);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfUIBlueprintLibrary.ToggleGvoiceMic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ToggleGvoiceMic(bool bIsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ToggleGvoiceMic");

	Params::TgfUIBlueprintLibrary_ToggleGvoiceMic Parms{};

	Parms.bIsOpen = bIsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfUIBlueprintLibrary.ToggleOptimizationForSceneCapture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfUIBlueprintLibrary::ToggleOptimizationForSceneCapture(bool bIsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfUIBlueprintLibrary", "ToggleOptimizationForSceneCapture");

	Params::TgfUIBlueprintLibrary_ToggleOptimizationForSceneCapture Parms{};

	Parms.bIsOpen = bIsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfVoiceChatBlueprintLibrary.RegisterVoiceChatActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfVoiceChatBlueprintLibrary::RegisterVoiceChatActor(class AActor* Actor, const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfVoiceChatBlueprintLibrary", "RegisterVoiceChatActor");

	Params::TgfVoiceChatBlueprintLibrary_RegisterVoiceChatActor Parms{};

	Parms.Actor = Actor;
	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfVoiceChatBlueprintLibrary.UnregisterVoiceChatActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfVoiceChatBlueprintLibrary::UnregisterVoiceChatActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfVoiceChatBlueprintLibrary", "UnregisterVoiceChatActor");

	Params::TgfVoiceChatBlueprintLibrary_UnregisterVoiceChatActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWaitAbilityTask_TargetMovementMode.CreateWaitTargetMovementMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   CustomMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfWaitAbilityTask_TargetMovementMode*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfWaitAbilityTask_TargetMovementMode* UTgfWaitAbilityTask_TargetMovementMode::CreateWaitTargetMovementMode(class UGameplayAbility* OwningAbility, EMovementMode MovementMode, uint8 CustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWaitAbilityTask_TargetMovementMode", "CreateWaitTargetMovementMode");

	Params::TgfWaitAbilityTask_TargetMovementMode_CreateWaitTargetMovementMode Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.MovementMode = MovementMode;
	Parms.CustomMode = CustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWaitAbilityTask_TargetMovementMode.OnMovementModeChange
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrvMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PrvCustomMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWaitAbilityTask_TargetMovementMode::OnMovementModeChange(class ACharacter* Character, EMovementMode PrvMovementMode, uint8 PrvCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWaitAbilityTask_TargetMovementMode", "OnMovementModeChange");

	Params::TgfWaitAbilityTask_TargetMovementMode_OnMovementModeChange Parms{};

	Parms.Character = Character;
	Parms.PrvMovementMode = PrvMovementMode;
	Parms.PrvCustomMode = PrvCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWeaponAnimDefinition.PickIdleAnimation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsRight                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimSequenceBase*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimSequenceBase* UTgfWeaponAnimDefinition::PickIdleAnimation(const struct FGameplayTagContainer& CosmeticTags, bool* bIsRight) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponAnimDefinition", "PickIdleAnimation");

	Params::TgfWeaponAnimDefinition_PickIdleAnimation Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsRight != nullptr)
		*bIsRight = Parms.bIsRight;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponDefinition.GetWeaponAnimDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfEquipSubType                        AssistSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceSingle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTgfWeaponAnimDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UTgfWeaponAnimDefinition> UTgfWeaponDefinition::GetWeaponAnimDefinition(ETgfEquipSubType AssistSlot, bool ForceSingle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponDefinition", "GetWeaponAnimDefinition");

	Params::TgfWeaponDefinition_GetWeaponAnimDefinition Parms{};

	Parms.AssistSlot = AssistSlot;
	Parms.ForceSingle = ForceSingle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraUserFacingExperienceDefinition.CreateHostingRequest
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UCommonSession_HostSessionRequest*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonSession_HostSessionRequest* ULyraUserFacingExperienceDefinition::CreateHostingRequest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraUserFacingExperienceDefinition", "CreateHostingRequest");

	Params::LyraUserFacingExperienceDefinition_CreateHostingRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetFunctionLibrary.GetGridSlotColumnSpan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGridSlot*                        Slot                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfWidgetFunctionLibrary::GetGridSlotColumnSpan(const class UGridSlot* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWidgetFunctionLibrary", "GetGridSlotColumnSpan");

	Params::TgfWidgetFunctionLibrary_GetGridSlotColumnSpan Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetFunctionLibrary.GetGridSlotRowSpan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGridSlot*                        Slot                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfWidgetFunctionLibrary::GetGridSlotRowSpan(const class UGridSlot* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWidgetFunctionLibrary", "GetGridSlotRowSpan");

	Params::TgfWidgetFunctionLibrary_GetGridSlotRowSpan Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetFunctionLibrary.LoadTextureFromPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTgfWidgetFunctionLibrary::LoadTextureFromPath(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWidgetFunctionLibrary", "LoadTextureFromPath");

	Params::TgfWidgetFunctionLibrary_LoadTextureFromPath Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetFunctionLibrary.MakePopupWindowPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        AnchorPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        AnchorSize                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTgfWidgetFunctionLibrary::MakePopupWindowPosition(const struct FVector2D& AnchorPosition, const struct FVector2D& AnchorSize, const struct FVector2D& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWidgetFunctionLibrary", "MakePopupWindowPosition");

	Params::TgfWidgetFunctionLibrary_MakePopupWindowPosition Parms{};

	Parms.AnchorPosition = std::move(AnchorPosition);
	Parms.AnchorSize = std::move(AnchorSize);
	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetFunctionLibrary.MarkInsightAnchor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InsightDataString                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetFunctionLibrary::MarkInsightAnchor(const class FString& InsightDataString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWidgetFunctionLibrary", "MarkInsightAnchor");

	Params::TgfWidgetFunctionLibrary_MarkInsightAnchor Parms{};

	Parms.InsightDataString = std::move(InsightDataString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.AddCanFocusedWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetGamepadWrapper::AddCanFocusedWidget(class UUserWidget* UserWidget, int32 PageIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "AddCanFocusedWidget");

	Params::TgfWidgetGamepadWrapper_AddCanFocusedWidget Parms{};

	Parms.UserWidget = UserWidget;
	Parms.PageIdx = PageIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.BindCustomNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetGamepadWrapper::BindCustomNavigation(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "BindCustomNavigation");

	Params::TgfWidgetGamepadWrapper_BindCustomNavigation Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.BP_GetDefaultFocusWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTgfWidgetGamepadWrapper::BP_GetDefaultFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "BP_GetDefaultFocusWidget");

	Params::TgfWidgetGamepadWrapper_BP_GetDefaultFocusWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetGamepadWrapper.GetDefaultFocusWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTgfWidgetGamepadWrapper::GetDefaultFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "GetDefaultFocusWidget");

	Params::TgfWidgetGamepadWrapper_GetDefaultFocusWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetGamepadWrapper.GetNextFocWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           Navigation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      FromWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTgfWidgetGamepadWrapper::GetNextFocWidget(EUINavigation Navigation, class UUserWidget* FromWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "GetNextFocWidget");

	Params::TgfWidgetGamepadWrapper_GetNextFocWidget Parms{};

	Parms.Navigation = Navigation;
	Parms.FromWidget = FromWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetGamepadWrapper.GetWidgetCenterLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTgfWidgetGamepadWrapper::GetWidgetCenterLocation(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "GetWidgetCenterLocation");

	Params::TgfWidgetGamepadWrapper_GetWidgetCenterLocation Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetGamepadWrapper.InitWrapper
// (Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Owner                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetGamepadWrapper::InitWrapper(class UUserWidget* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "InitWrapper");

	Params::TgfWidgetGamepadWrapper_InitWrapper Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.RemoveCanFocusedWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetGamepadWrapper::RemoveCanFocusedWidget(class UUserWidget* UserWidget, int32 PageIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "RemoveCanFocusedWidget");

	Params::TgfWidgetGamepadWrapper_RemoveCanFocusedWidget Parms{};

	Parms.UserWidget = UserWidget;
	Parms.PageIdx = PageIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.RemoveDebugPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UUserWidget>          WidgetClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetGamepadWrapper::RemoveDebugPoints(TSubclassOf<class UUserWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "RemoveDebugPoints");

	Params::TgfWidgetGamepadWrapper_RemoveDebugPoints Parms{};

	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.SetInventoryAnalogCursor
// (Final, Native, Public, BlueprintCallable)

void UTgfWidgetGamepadWrapper::SetInventoryAnalogCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "SetInventoryAnalogCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.ShowDebugPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UUserWidget>          WidgetClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfWidgetGamepadWrapper::ShowDebugPoints(TSubclassOf<class UUserWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "ShowDebugPoints");

	Params::TgfWidgetGamepadWrapper_ShowDebugPoints Parms{};

	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWidgetGamepadWrapper.GetCommonInputSubsystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCommonInputSubsystem*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonInputSubsystem* UTgfWidgetGamepadWrapper::GetCommonInputSubsystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "GetCommonInputSubsystem");

	Params::TgfWidgetGamepadWrapper_GetCommonInputSubsystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetGamepadWrapper.GetCurrentInputType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECommonInputType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECommonInputType UTgfWidgetGamepadWrapper::GetCurrentInputType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWidgetGamepadWrapper", "GetCurrentInputType");

	Params::TgfWidgetGamepadWrapper_GetCurrentInputType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWidgetGamepadWrapperLibrary.CreateWidgetGamepadWrapper
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Owner                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfWidgetGamepadWrapper*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfWidgetGamepadWrapper* UTgfWidgetGamepadWrapperLibrary::CreateWidgetGamepadWrapper(class UUserWidget* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfWidgetGamepadWrapperLibrary", "CreateWidgetGamepadWrapper");

	Params::TgfWidgetGamepadWrapperLibrary_CreateWidgetGamepadWrapper Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameplayAbility_Death.FinishDeath
// (Final, Native, Protected, BlueprintCallable)

void ULyraGameplayAbility_Death::FinishDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_Death", "FinishDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility_Death.StartDeath
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EAnimConfigDirection                    DeathDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULyraGameplayAbility_Death::StartDeath(EAnimConfigDirection DeathDirection, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_Death", "StartDeath");

	Params::LyraGameplayAbility_Death_StartDeath Parms{};

	Parms.DeathDirection = DeathDirection;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility_Jump.CharacterJumpStart
// (Final, Native, Protected, BlueprintCallable)

void ULyraGameplayAbility_Jump::CharacterJumpStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_Jump", "CharacterJumpStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility_Jump.CharacterJumpStop
// (Final, Native, Protected, BlueprintCallable)

void ULyraGameplayAbility_Jump::CharacterJumpStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_Jump", "CharacterJumpStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayCueNotify_BurstLatent.OnTgfBurst
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTgfGameplayCueNotify_SpawnResultTgfSpawnResults                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    NeedCulling                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATgfGameplayCueNotify_BurstLatent::OnTgfBurst(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FTgfGameplayCueNotify_SpawnResult& TgfSpawnResults, bool NeedCulling, EPhysicalSurface SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_BurstLatent", "OnTgfBurst");

	Params::TgfGameplayCueNotify_BurstLatent_OnTgfBurst Parms{};

	Parms.Target = Target;
	Parms.Parameters = std::move(Parameters);
	Parms.TgfSpawnResults = std::move(TgfSpawnResults);
	Parms.NeedCulling = NeedCulling;
	Parms.SurfaceType = SurfaceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.TgfGameplayCueNotify_BurstLatent.PrintRecord
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATgfGameplayCueNotify_BurstLatent::PrintRecord(const class FString& TagString, class AActor* Target, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_BurstLatent", "PrintRecord");

	Params::TgfGameplayCueNotify_BurstLatent_PrintRecord Parms{};

	Parms.TagString = std::move(TagString);
	Parms.Target = Target;
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayCueNotify_BurstLatent.ShouldPlayGameplayCue
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATgfGameplayCueNotify_BurstLatent::ShouldPlayGameplayCue(const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayCueNotify_BurstLatent", "ShouldPlayGameplayCue");

	Params::TgfGameplayCueNotify_BurstLatent_ShouldPlayGameplayCue Parms{};

	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AbilityTask_WaitForInteractableTargets_SingleLineTrace.WaitForInteractableTargets_SingleLineTrace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionQuery                Param_InteractionQuery                                 (Parm, NativeAccessSpecifierPublic)
// struct FCollisionProfileName            TraceProfile                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetingLocationInfoParam_StartLocation                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   InteractionScanRange                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionScanRate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowDebug                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitForInteractableTargets_SingleLineTrace*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitForInteractableTargets_SingleLineTrace* UAbilityTask_WaitForInteractableTargets_SingleLineTrace::WaitForInteractableTargets_SingleLineTrace(class UGameplayAbility* OwningAbility, const struct FInteractionQuery& Param_InteractionQuery, const struct FCollisionProfileName& TraceProfile, const struct FGameplayAbilityTargetingLocationInfo& Param_StartLocation, float InteractionScanRange, float InteractionScanRate, bool bShowDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitForInteractableTargets_SingleLineTrace", "WaitForInteractableTargets_SingleLineTrace");

	Params::AbilityTask_WaitForInteractableTargets_SingleLineTrace_WaitForInteractableTargets_SingleLineTrace Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Param_InteractionQuery = std::move(Param_InteractionQuery);
	Parms.TraceProfile = std::move(TraceProfile);
	Parms.Param_StartLocation = std::move(Param_StartLocation);
	Parms.InteractionScanRange = InteractionScanRange;
	Parms.InteractionScanRate = InteractionScanRate;
	Parms.bShowDebug = bShowDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCombatSet.OnRep_BaseDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraCombatSet::OnRep_BaseDamage(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCombatSet", "OnRep_BaseDamage");

	Params::LyraCombatSet_OnRep_BaseDamage Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCombatSet.OnRep_BaseHeal
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraCombatSet::OnRep_BaseHeal(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCombatSet", "OnRep_BaseHeal");

	Params::LyraCombatSet_OnRep_BaseHeal Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHealthSet.OnRep_Health
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraHealthSet::OnRep_Health(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthSet", "OnRep_Health");

	Params::LyraHealthSet_OnRep_Health Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHealthSet.OnRep_MaxHealth
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraHealthSet::OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthSet", "OnRep_MaxHealth");

	Params::LyraHealthSet_OnRep_MaxHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraMovementSet.OnRep_MoveSpeed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraMovementSet::OnRep_MoveSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraMovementSet", "OnRep_MoveSpeed");

	Params::LyraMovementSet_OnRep_MoveSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.ApplyAngleSpeedBaseMod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Mod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::ApplyAngleSpeedBaseMod(float Mod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "ApplyAngleSpeedBaseMod");

	Params::TgfAIAttributeSet_ApplyAngleSpeedBaseMod Parms{};

	Parms.Mod = Mod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_AngleSpeedBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_AngleSpeedBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_AngleSpeedBase");

	Params::TgfAIAttributeSet_OnRep_AngleSpeedBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_AngleSpeedPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_AngleSpeedPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_AngleSpeedPercent");

	Params::TgfAIAttributeSet_OnRep_AngleSpeedPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_HearingDistanceBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_HearingDistanceBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_HearingDistanceBase");

	Params::TgfAIAttributeSet_OnRep_HearingDistanceBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_HearingDistancePercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_HearingDistancePercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_HearingDistancePercent");

	Params::TgfAIAttributeSet_OnRep_HearingDistancePercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_LightDistanceBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_LightDistanceBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_LightDistanceBase");

	Params::TgfAIAttributeSet_OnRep_LightDistanceBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_LightDistancePercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_LightDistancePercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_LightDistancePercent");

	Params::TgfAIAttributeSet_OnRep_LightDistancePercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_SightDistanceBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_SightDistanceBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_SightDistanceBase");

	Params::TgfAIAttributeSet_OnRep_SightDistanceBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.OnRep_SightDistancePercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAIAttributeSet::OnRep_SightDistancePercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "OnRep_SightDistancePercent");

	Params::TgfAIAttributeSet_OnRep_SightDistancePercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAIAttributeSet.GetAngleSpeedFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAIAttributeSet::GetAngleSpeedFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "GetAngleSpeedFinal");

	Params::TgfAIAttributeSet_GetAngleSpeedFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAIAttributeSet.GetHearingDistanceFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAIAttributeSet::GetHearingDistanceFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "GetHearingDistanceFinal");

	Params::TgfAIAttributeSet_GetHearingDistanceFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAIAttributeSet.GetLightDistanceFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAIAttributeSet::GetLightDistanceFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "GetLightDistanceFinal");

	Params::TgfAIAttributeSet_GetLightDistanceFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAIAttributeSet.GetSightDistanceFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAIAttributeSet::GetSightDistanceFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAIAttributeSet", "GetSightDistanceFinal");

	Params::TgfAIAttributeSet_GetSightDistanceFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_AdditionalAttackWeight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_AdditionalAttackWeight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_AdditionalAttackWeight");

	Params::TgfAttackAttributeSet_OnRep_AdditionalAttackWeight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_AdditionalAttGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_AdditionalAttGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_AdditionalAttGearLevel");

	Params::TgfAttackAttributeSet_OnRep_AdditionalAttGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_AdditionalWeaponAttack
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_AdditionalWeaponAttack(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_AdditionalWeaponAttack");

	Params::TgfAttackAttributeSet_OnRep_AdditionalWeaponAttack Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_AttackBonus
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_AttackBonus(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_AttackBonus");

	Params::TgfAttackAttributeSet_OnRep_AttackBonus Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_AttackBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_AttackBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_AttackBoostRate");

	Params::TgfAttackAttributeSet_OnRep_AttackBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_CritDamageRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_CritDamageRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_CritDamageRate");

	Params::TgfAttackAttributeSet_OnRep_CritDamageRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_CriticalRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_CriticalRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_CriticalRate");

	Params::TgfAttackAttributeSet_OnRep_CriticalRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_DefIgnoreBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_DefIgnoreBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_DefIgnoreBase");

	Params::TgfAttackAttributeSet_OnRep_DefIgnoreBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_DefIgnorePercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_DefIgnorePercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_DefIgnorePercent");

	Params::TgfAttackAttributeSet_OnRep_DefIgnorePercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementBoostRateDark
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementBoostRateDark(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementBoostRateDark");

	Params::TgfAttackAttributeSet_OnRep_ElementBoostRateDark Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementBoostRateFire
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementBoostRateFire(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementBoostRateFire");

	Params::TgfAttackAttributeSet_OnRep_ElementBoostRateFire Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementBoostRateIce
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementBoostRateIce(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementBoostRateIce");

	Params::TgfAttackAttributeSet_OnRep_ElementBoostRateIce Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementBoostRateLight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementBoostRateLight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementBoostRateLight");

	Params::TgfAttackAttributeSet_OnRep_ElementBoostRateLight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementBoostRateNone
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementBoostRateNone(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementBoostRateNone");

	Params::TgfAttackAttributeSet_OnRep_ElementBoostRateNone Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementBoostRateThunder
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementBoostRateThunder(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementBoostRateThunder");

	Params::TgfAttackAttributeSet_OnRep_ElementBoostRateThunder Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementResPierceDark
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementResPierceDark(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementResPierceDark");

	Params::TgfAttackAttributeSet_OnRep_ElementResPierceDark Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementResPierceFire
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementResPierceFire(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementResPierceFire");

	Params::TgfAttackAttributeSet_OnRep_ElementResPierceFire Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementResPierceIce
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementResPierceIce(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementResPierceIce");

	Params::TgfAttackAttributeSet_OnRep_ElementResPierceIce Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementResPierceLight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementResPierceLight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementResPierceLight");

	Params::TgfAttackAttributeSet_OnRep_ElementResPierceLight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementResPierceNone
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementResPierceNone(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementResPierceNone");

	Params::TgfAttackAttributeSet_OnRep_ElementResPierceNone Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ElementResPierceThunder
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ElementResPierceThunder(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ElementResPierceThunder");

	Params::TgfAttackAttributeSet_OnRep_ElementResPierceThunder Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_EliteBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_EliteBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_EliteBoostRate");

	Params::TgfAttackAttributeSet_OnRep_EliteBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_ExtraAttGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_ExtraAttGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_ExtraAttGearLevel");

	Params::TgfAttackAttributeSet_OnRep_ExtraAttGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_LeftAttackWeight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_LeftAttackWeight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_LeftAttackWeight");

	Params::TgfAttackAttributeSet_OnRep_LeftAttackWeight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_LeftAttGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_LeftAttGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_LeftAttGearLevel");

	Params::TgfAttackAttributeSet_OnRep_LeftAttGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_LeftWeaponAttack
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_LeftWeaponAttack(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_LeftWeaponAttack");

	Params::TgfAttackAttributeSet_OnRep_LeftWeaponAttack Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_MoveFactorRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_MoveFactorRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_MoveFactorRate");

	Params::TgfAttackAttributeSet_OnRep_MoveFactorRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_RightAttackWeight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_RightAttackWeight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_RightAttackWeight");

	Params::TgfAttackAttributeSet_OnRep_RightAttackWeight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_RightAttGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_RightAttGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_RightAttGearLevel");

	Params::TgfAttackAttributeSet_OnRep_RightAttGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_RightWeaponAttack
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_RightWeaponAttack(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_RightWeaponAttack");

	Params::TgfAttackAttributeSet_OnRep_RightWeaponAttack Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_SkillBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_SkillBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_SkillBoostRate");

	Params::TgfAttackAttributeSet_OnRep_SkillBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.OnRep_UncontrolledBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfAttackAttributeSet::OnRep_UncontrolledBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "OnRep_UncontrolledBoostRate");

	Params::TgfAttackAttributeSet_OnRep_UncontrolledBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAttackAttributeSet.GetAttackWeightWithAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAttackAttributeSet::GetAttackWeightWithAnim(ETgfUseAttackType AttackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "GetAttackWeightWithAnim");

	Params::TgfAttackAttributeSet_GetAttackWeightWithAnim Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttackAttributeSet.GetAttGearLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAttackAttributeSet::GetAttGearLevel(ETgfUseAttackType AttackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "GetAttGearLevel");

	Params::TgfAttackAttributeSet_GetAttGearLevel Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttackAttributeSet.GetDefIgnoreFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAttackAttributeSet::GetDefIgnoreFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "GetDefIgnoreFinal");

	Params::TgfAttackAttributeSet_GetDefIgnoreFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttackAttributeSet.GetElementBoostRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfBattleElement                       Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAttackAttributeSet::GetElementBoostRate(ETgfBattleElement Element) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "GetElementBoostRate");

	Params::TgfAttackAttributeSet_GetElementBoostRate Parms{};

	Parms.Element = Element;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttackAttributeSet.GetElementResPierce
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfBattleElement                       Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAttackAttributeSet::GetElementResPierce(ETgfBattleElement Element) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "GetElementResPierce");

	Params::TgfAttackAttributeSet_GetElementResPierce Parms{};

	Parms.Element = Element;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAttackAttributeSet.GetWeaponAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfUseAttackType                       AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfAttackAttributeSet::GetWeaponAttack(ETgfUseAttackType AttackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfAttackAttributeSet", "GetWeaponAttack");

	Params::TgfAttackAttributeSet_GetWeaponAttack Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BloodingDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BloodingDamage(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BloodingDamage");

	Params::TgfBuffArgAttributeSet_OnRep_BloodingDamage Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BloodingDurationBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BloodingDurationBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BloodingDurationBase");

	Params::TgfBuffArgAttributeSet_OnRep_BloodingDurationBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BloodingDurationPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BloodingDurationPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BloodingDurationPercent");

	Params::TgfBuffArgAttributeSet_OnRep_BloodingDurationPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BloodingIntervalBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BloodingIntervalBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BloodingIntervalBase");

	Params::TgfBuffArgAttributeSet_OnRep_BloodingIntervalBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BloodingIntervalPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BloodingIntervalPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BloodingIntervalPercent");

	Params::TgfBuffArgAttributeSet_OnRep_BloodingIntervalPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BurningDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BurningDamage(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BurningDamage");

	Params::TgfBuffArgAttributeSet_OnRep_BurningDamage Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BurningIntervalBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BurningIntervalBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BurningIntervalBase");

	Params::TgfBuffArgAttributeSet_OnRep_BurningIntervalBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BurningIntervalPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BurningIntervalPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BurningIntervalPercent");

	Params::TgfBuffArgAttributeSet_OnRep_BurningIntervalPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_BurningStack
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_BurningStack(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_BurningStack");

	Params::TgfBuffArgAttributeSet_OnRep_BurningStack Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_FreezingDurationBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_FreezingDurationBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_FreezingDurationBase");

	Params::TgfBuffArgAttributeSet_OnRep_FreezingDurationBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_FreezingDurationPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_FreezingDurationPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_FreezingDurationPercent");

	Params::TgfBuffArgAttributeSet_OnRep_FreezingDurationPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_FreezingRateBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_FreezingRateBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_FreezingRateBase");

	Params::TgfBuffArgAttributeSet_OnRep_FreezingRateBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_FreezingRatePercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_FreezingRatePercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_FreezingRatePercent");

	Params::TgfBuffArgAttributeSet_OnRep_FreezingRatePercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_KillingMaxLayerAttackBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_KillingMaxLayerAttackBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_KillingMaxLayerAttackBoostRate");

	Params::TgfBuffArgAttributeSet_OnRep_KillingMaxLayerAttackBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_KillingMaxLayerCriticalRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_KillingMaxLayerCriticalRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_KillingMaxLayerCriticalRate");

	Params::TgfBuffArgAttributeSet_OnRep_KillingMaxLayerCriticalRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.OnRep_KillingMaxLayerMaxHealthPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfBuffArgAttributeSet::OnRep_KillingMaxLayerMaxHealthPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "OnRep_KillingMaxLayerMaxHealthPercent");

	Params::TgfBuffArgAttributeSet_OnRep_KillingMaxLayerMaxHealthPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBuffArgAttributeSet.GetBloodingDurationFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBuffArgAttributeSet::GetBloodingDurationFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "GetBloodingDurationFinal");

	Params::TgfBuffArgAttributeSet_GetBloodingDurationFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBuffArgAttributeSet.GetBloodingIntervalFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBuffArgAttributeSet::GetBloodingIntervalFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "GetBloodingIntervalFinal");

	Params::TgfBuffArgAttributeSet_GetBloodingIntervalFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBuffArgAttributeSet.GetBurningIntervalFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBuffArgAttributeSet::GetBurningIntervalFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "GetBurningIntervalFinal");

	Params::TgfBuffArgAttributeSet_GetBurningIntervalFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBuffArgAttributeSet.GetFreezingDurationFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBuffArgAttributeSet::GetFreezingDurationFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "GetFreezingDurationFinal");

	Params::TgfBuffArgAttributeSet_GetFreezingDurationFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBuffArgAttributeSet.GetFreezingRateFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfBuffArgAttributeSet::GetFreezingRateFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBuffArgAttributeSet", "GetFreezingRateFinal");

	Params::TgfBuffArgAttributeSet_GetFreezingRateFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.InteractionStatics.GetActorFromInteractableTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IInteractableTarget>InteractableTarget                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<class IInteractableTarget> InteractableTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionStatics", "GetActorFromInteractableTarget");

	Params::InteractionStatics_GetActorFromInteractableTarget Parms{};

	Parms.InteractableTarget = InteractableTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.InteractionStatics.GetInteractableTargetsFromActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TScriptInterface<class IInteractableTarget>>OutInteractableTargets                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UInteractionStatics::GetInteractableTargetsFromActor(class AActor* Actor, TArray<TScriptInterface<class IInteractableTarget>>* OutInteractableTargets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionStatics", "GetInteractableTargetsFromActor");

	Params::InteractionStatics_GetInteractableTargetsFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteractableTargets != nullptr)
		*OutInteractableTargets = std::move(Parms.OutInteractableTargets);
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_AddShield
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_AddShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_AddShield");

	Params::TgfDefendAttributeSet_OnRep_AddShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_CalculatedShield
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_CalculatedShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_CalculatedShield");

	Params::TgfDefendAttributeSet_OnRep_CalculatedShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ChestDefGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ChestDefGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ChestDefGearLevel");

	Params::TgfDefendAttributeSet_OnRep_ChestDefGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_CurHealth
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_CurHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_CurHealth");

	Params::TgfDefendAttributeSet_OnRep_CurHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_CurShield
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_CurShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_CurShield");

	Params::TgfDefendAttributeSet_OnRep_CurShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_DamageReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_DamageReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_DamageReduceRate");

	Params::TgfDefendAttributeSet_OnRep_DamageReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_DamageVulnerRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_DamageVulnerRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_DamageVulnerRate");

	Params::TgfDefendAttributeSet_OnRep_DamageVulnerRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_DefaultDefendValue
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_DefaultDefendValue(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_DefaultDefendValue");

	Params::TgfDefendAttributeSet_OnRep_DefaultDefendValue Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ElementResistanceRateDark
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ElementResistanceRateDark(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ElementResistanceRateDark");

	Params::TgfDefendAttributeSet_OnRep_ElementResistanceRateDark Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ElementResistanceRateFire
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ElementResistanceRateFire(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ElementResistanceRateFire");

	Params::TgfDefendAttributeSet_OnRep_ElementResistanceRateFire Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ElementResistanceRateIce
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ElementResistanceRateIce(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ElementResistanceRateIce");

	Params::TgfDefendAttributeSet_OnRep_ElementResistanceRateIce Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ElementResistanceRateLight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ElementResistanceRateLight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ElementResistanceRateLight");

	Params::TgfDefendAttributeSet_OnRep_ElementResistanceRateLight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ElementResistanceRateNone
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ElementResistanceRateNone(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ElementResistanceRateNone");

	Params::TgfDefendAttributeSet_OnRep_ElementResistanceRateNone Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ElementResistanceRateThunder
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ElementResistanceRateThunder(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ElementResistanceRateThunder");

	Params::TgfDefendAttributeSet_OnRep_ElementResistanceRateThunder Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_EliteReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_EliteReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_EliteReduceRate");

	Params::TgfDefendAttributeSet_OnRep_EliteReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ExtraDefGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ExtraDefGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ExtraDefGearLevel");

	Params::TgfDefendAttributeSet_OnRep_ExtraDefGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_ExtraGuardedDamageReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_ExtraGuardedDamageReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_ExtraGuardedDamageReduceRate");

	Params::TgfDefendAttributeSet_OnRep_ExtraGuardedDamageReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_HelmetDefGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_HelmetDefGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_HelmetDefGearLevel");

	Params::TgfDefendAttributeSet_OnRep_HelmetDefGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_LeftDefendValue
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_LeftDefendValue(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_LeftDefendValue");

	Params::TgfDefendAttributeSet_OnRep_LeftDefendValue Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_LeftDefGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_LeftDefGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_LeftDefGearLevel");

	Params::TgfDefendAttributeSet_OnRep_LeftDefGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_LeftGuardedDamageReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_LeftGuardedDamageReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_LeftGuardedDamageReduceRate");

	Params::TgfDefendAttributeSet_OnRep_LeftGuardedDamageReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_LeftShieldAngle
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_LeftShieldAngle(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_LeftShieldAngle");

	Params::TgfDefendAttributeSet_OnRep_LeftShieldAngle Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_MaxHealthBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_MaxHealthBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_MaxHealthBase");

	Params::TgfDefendAttributeSet_OnRep_MaxHealthBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_MaxHealthExtra
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_MaxHealthExtra(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_MaxHealthExtra");

	Params::TgfDefendAttributeSet_OnRep_MaxHealthExtra Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_MaxHealthPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_MaxHealthPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_MaxHealthPercent");

	Params::TgfDefendAttributeSet_OnRep_MaxHealthPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_PermanintShield
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_PermanintShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_PermanintShield");

	Params::TgfDefendAttributeSet_OnRep_PermanintShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_RightDefendValue
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_RightDefendValue(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_RightDefendValue");

	Params::TgfDefendAttributeSet_OnRep_RightDefendValue Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_RightDefGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_RightDefGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_RightDefGearLevel");

	Params::TgfDefendAttributeSet_OnRep_RightDefGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_RightGuardedDamageReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_RightGuardedDamageReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_RightGuardedDamageReduceRate");

	Params::TgfDefendAttributeSet_OnRep_RightGuardedDamageReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_RightShieldAngle
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_RightShieldAngle(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_RightShieldAngle");

	Params::TgfDefendAttributeSet_OnRep_RightShieldAngle Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_TrousersDefGearLevel
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_TrousersDefGearLevel(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_TrousersDefGearLevel");

	Params::TgfDefendAttributeSet_OnRep_TrousersDefGearLevel Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.OnRep_UncontrolledReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfDefendAttributeSet::OnRep_UncontrolledReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "OnRep_UncontrolledReduceRate");

	Params::TgfDefendAttributeSet_OnRep_UncontrolledReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfDefendAttributeSet.GetCurShieldFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetCurShieldFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetCurShieldFinal");

	Params::TgfDefendAttributeSet_GetCurShieldFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.GetDefendValueWithAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IsGuarded                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetDefendValueWithAnim(bool IsGuarded) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetDefendValueWithAnim");

	Params::TgfDefendAttributeSet_GetDefendValueWithAnim Parms{};

	Parms.IsGuarded = IsGuarded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.GetDefGearLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetDefGearLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetDefGearLevel");

	Params::TgfDefendAttributeSet_GetDefGearLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.GetElementResistanceRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfBattleElement                       Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetElementResistanceRate(ETgfBattleElement Element) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetElementResistanceRate");

	Params::TgfDefendAttributeSet_GetElementResistanceRate Parms{};

	Parms.Element = Element;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.GetFinalElementResistanceRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfBattleElement                       AttackElement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfBattleElement                       DefendElement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetFinalElementResistanceRate(ETgfBattleElement AttackElement, ETgfBattleElement DefendElement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetFinalElementResistanceRate");

	Params::TgfDefendAttributeSet_GetFinalElementResistanceRate Parms{};

	Parms.AttackElement = AttackElement;
	Parms.DefendElement = DefendElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.GetGuardedDamageReduceRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetGuardedDamageReduceRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetGuardedDamageReduceRate");

	Params::TgfDefendAttributeSet_GetGuardedDamageReduceRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.GetMaxHealthFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfDefendAttributeSet::GetMaxHealthFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "GetMaxHealthFinal");

	Params::TgfDefendAttributeSet_GetMaxHealthFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.HasHurtPartHeadTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfDefendAttributeSet::HasHurtPartHeadTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "HasHurtPartHeadTag");

	Params::TgfDefendAttributeSet_HasHurtPartHeadTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfDefendAttributeSet.IsFullHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfDefendAttributeSet::IsFullHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfDefendAttributeSet", "IsFullHP");

	Params::TgfDefendAttributeSet_IsFullHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.AddStatTagStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TagCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryItemInstance::AddStatTagStack(const struct FGameplayTag& Tag, int32 TagCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "AddStatTagStack");

	Params::LyraInventoryItemInstance_AddStatTagStack Parms{};

	Parms.Tag = std::move(Tag);
	Parms.TagCount = TagCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryItemInstance.DuplicateItemInstance
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          NewOuter                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedSkin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* ULyraInventoryItemInstance::DuplicateItemInstance(class UObject* NewOuter, bool NeedSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "DuplicateItemInstance");

	Params::LyraInventoryItemInstance_DuplicateItemInstance Parms{};

	Parms.NewOuter = NewOuter;
	Parms.NeedSkin = NeedSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.OnRep_ItemDef
// (Final, Native, Protected)

void ULyraInventoryItemInstance::OnRep_ItemDef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "OnRep_ItemDef");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryItemInstance.OnRep_StackCount
// (Final, Native, Protected)
// Parameters:
// int32                                   OldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryItemInstance::OnRep_StackCount(int32 OldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "OnRep_StackCount");

	Params::LyraInventoryItemInstance_OnRep_StackCount Parms{};

	Parms.OldCount = OldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryItemInstance.RemoveStatTagStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TagCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryItemInstance::RemoveStatTagStack(const struct FGameplayTag& Tag, int32 TagCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "RemoveStatTagStack");

	Params::LyraInventoryItemInstance_RemoveStatTagStack Parms{};

	Parms.Tag = std::move(Tag);
	Parms.TagCount = TagCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryItemInstance.SetStackCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraInventoryItemInstance::SetStackCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "SetStackCount");

	Params::LyraInventoryItemInstance_SetStackCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraInventoryItemInstance.CanDiscardStack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryItemInstance::CanDiscardStack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "CanDiscardStack");

	Params::LyraInventoryItemInstance_CanDiscardStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.FindFragmentByClass
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemFragment>FragmentClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedSkined                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULyraInventoryItemFragment* ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraInventoryItemFragment* ULyraInventoryItemInstance::FindFragmentByClass(TSubclassOf<class ULyraInventoryItemFragment> FragmentClass, bool NeedSkined) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "FindFragmentByClass");

	Params::LyraInventoryItemInstance_FindFragmentByClass Parms{};

	Parms.FragmentClass = FragmentClass;
	Parms.NeedSkined = NeedSkined;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.GetEquipDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    NeedSkined                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraEquipmentDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraEquipmentDefinition> ULyraInventoryItemInstance::GetEquipDefinition(bool NeedSkined) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "GetEquipDefinition");

	Params::LyraInventoryItemInstance_GetEquipDefinition Parms{};

	Parms.NeedSkined = NeedSkined;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.GetItemDef
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    NeedSkined                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> ULyraInventoryItemInstance::GetItemDef(bool NeedSkined) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "GetItemDef");

	Params::LyraInventoryItemInstance_GetItemDef Parms{};

	Parms.NeedSkined = NeedSkined;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.GetItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraInventoryItemInstance::GetItemId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "GetItemId");

	Params::LyraInventoryItemInstance_GetItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.GetSkinItemDef
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ULyraInventoryItemDefinition> ULyraInventoryItemInstance::GetSkinItemDef() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "GetSkinItemDef");

	Params::LyraInventoryItemInstance_GetSkinItemDef Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.GetStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraInventoryItemInstance::GetStackCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "GetStackCount");

	Params::LyraInventoryItemInstance_GetStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.GetStatTagStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraInventoryItemInstance::GetStatTagStackCount(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "GetStatTagStackCount");

	Params::LyraInventoryItemInstance_GetStatTagStackCount Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryItemInstance.HasStatTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryItemInstance::HasStatTag(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInventoryItemInstance", "HasStatTag");

	Params::LyraInventoryItemInstance_HasStatTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfFirstLevelAttributeSet.IsFirstLevelAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAttribute               Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfFirstLevelAttributeSet::IsFirstLevelAttribute(const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfFirstLevelAttributeSet", "IsFirstLevelAttribute");

	Params::TgfFirstLevelAttributeSet_IsFirstLevelAttribute Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfFirstLevelAttributeSet.IsSatisfiedAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTgfActorRuntimeTalent           Talent                                                 (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULyraAbilitySystemComponent*      Abs                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfFirstLevelAttributeSet::IsSatisfiedAttribute(struct FTgfActorRuntimeTalent* Talent, class ULyraAbilitySystemComponent* Abs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfFirstLevelAttributeSet", "IsSatisfiedAttribute");

	Params::TgfFirstLevelAttributeSet_IsSatisfiedAttribute Parms{};

	Parms.Abs = Abs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Talent != nullptr)
		*Talent = std::move(Parms.Talent);

	return Parms.ReturnValue;
}


// Function LyraGame.TgfFirstLevelAttributeSet.OnRep_Dexterity
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfFirstLevelAttributeSet::OnRep_Dexterity(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfFirstLevelAttributeSet", "OnRep_Dexterity");

	Params::TgfFirstLevelAttributeSet_OnRep_Dexterity Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfFirstLevelAttributeSet.OnRep_Faith
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfFirstLevelAttributeSet::OnRep_Faith(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfFirstLevelAttributeSet", "OnRep_Faith");

	Params::TgfFirstLevelAttributeSet_OnRep_Faith Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfFirstLevelAttributeSet.OnRep_Intelligence
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfFirstLevelAttributeSet::OnRep_Intelligence(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfFirstLevelAttributeSet", "OnRep_Intelligence");

	Params::TgfFirstLevelAttributeSet_OnRep_Intelligence Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfFirstLevelAttributeSet.OnRep_Stamina
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfFirstLevelAttributeSet::OnRep_Stamina(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfFirstLevelAttributeSet", "OnRep_Stamina");

	Params::TgfFirstLevelAttributeSet_OnRep_Stamina Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfFirstLevelAttributeSet.OnRep_Strength
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfFirstLevelAttributeSet::OnRep_Strength(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfFirstLevelAttributeSet", "OnRep_Strength");

	Params::TgfFirstLevelAttributeSet_OnRep_Strength Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfFirstLevelAttributeSet.OnRep_Will
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfFirstLevelAttributeSet::OnRep_Will(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfFirstLevelAttributeSet", "OnRep_Will");

	Params::TgfFirstLevelAttributeSet_OnRep_Will Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_ExpBoostRateOutOfPortal
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_ExpBoostRateOutOfPortal(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_ExpBoostRateOutOfPortal");

	Params::TgfRecoverAttributeSet_OnRep_ExpBoostRateOutOfPortal Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_GainGoldOutOfPortal
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_GainGoldOutOfPortal(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_GainGoldOutOfPortal");

	Params::TgfRecoverAttributeSet_OnRep_GainGoldOutOfPortal Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealBonus
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealBonus(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealBonus");

	Params::TgfRecoverAttributeSet_OnRep_HealBonus Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealBoostRate");

	Params::TgfRecoverAttributeSet_OnRep_HealBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealOnHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealOnHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealOnHit");

	Params::TgfRecoverAttributeSet_OnRep_HealOnHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealOnKill
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealOnKill(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealOnKill");

	Params::TgfRecoverAttributeSet_OnRep_HealOnKill Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealOverTime
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealOverTime(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealOverTime");

	Params::TgfRecoverAttributeSet_OnRep_HealOverTime Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealReceiveRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealReceiveRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealReceiveRate");

	Params::TgfRecoverAttributeSet_OnRep_HealReceiveRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_HealWoundRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_HealWoundRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_HealWoundRate");

	Params::TgfRecoverAttributeSet_OnRep_HealWoundRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_LifeLeachRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_LifeLeachRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_LifeLeachRate");

	Params::TgfRecoverAttributeSet_OnRep_LifeLeachRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_ResCostReduceRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_ResCostReduceRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_ResCostReduceRate");

	Params::TgfRecoverAttributeSet_OnRep_ResCostReduceRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_ResGenerateRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_ResGenerateRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_ResGenerateRate");

	Params::TgfRecoverAttributeSet_OnRep_ResGenerateRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_ShieldBonus
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_ShieldBonus(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_ShieldBonus");

	Params::TgfRecoverAttributeSet_OnRep_ShieldBonus Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_ShieldBoostRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_ShieldBoostRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_ShieldBoostRate");

	Params::TgfRecoverAttributeSet_OnRep_ShieldBoostRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_ShieldReceiveRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_ShieldReceiveRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_ShieldReceiveRate");

	Params::TgfRecoverAttributeSet_OnRep_ShieldReceiveRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfRecoverAttributeSet.OnRep_SkillCooldownScaleRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfRecoverAttributeSet::OnRep_SkillCooldownScaleRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfRecoverAttributeSet", "OnRep_SkillCooldownScaleRate");

	Params::TgfRecoverAttributeSet_OnRep_SkillCooldownScaleRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.ApplySpeedBaseMod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Mod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::ApplySpeedBaseMod(float Mod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "ApplySpeedBaseMod");

	Params::TgfSpeedAttributeSet_ApplySpeedBaseMod Parms{};

	Parms.Mod = Mod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_AttackSpeedRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_AttackSpeedRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_AttackSpeedRate");

	Params::TgfSpeedAttributeSet_OnRep_AttackSpeedRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_DeathZoneTime
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_DeathZoneTime(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_DeathZoneTime");

	Params::TgfSpeedAttributeSet_OnRep_DeathZoneTime Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_LevelInteractSpeedAdditional
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_LevelInteractSpeedAdditional(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_LevelInteractSpeedAdditional");

	Params::TgfSpeedAttributeSet_OnRep_LevelInteractSpeedAdditional Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_LevelInteractSpeedRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_LevelInteractSpeedRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_LevelInteractSpeedRate");

	Params::TgfSpeedAttributeSet_OnRep_LevelInteractSpeedRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_MoveSpeedBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_MoveSpeedBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_MoveSpeedBase");

	Params::TgfSpeedAttributeSet_OnRep_MoveSpeedBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_MoveSpeedPercent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_MoveSpeedPercent(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_MoveSpeedPercent");

	Params::TgfSpeedAttributeSet_OnRep_MoveSpeedPercent Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_RecoverableItemConsumeSpeedRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_RecoverableItemConsumeSpeedRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_RecoverableItemConsumeSpeedRate");

	Params::TgfSpeedAttributeSet_OnRep_RecoverableItemConsumeSpeedRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_SpellCastSpeedAdditional
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_SpellCastSpeedAdditional(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_SpellCastSpeedAdditional");

	Params::TgfSpeedAttributeSet_OnRep_SpellCastSpeedAdditional Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_SpellCastSpeedRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_SpellCastSpeedRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_SpellCastSpeedRate");

	Params::TgfSpeedAttributeSet_OnRep_SpellCastSpeedRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_ThrowableItemConsumeSpeedRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_ThrowableItemConsumeSpeedRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_ThrowableItemConsumeSpeedRate");

	Params::TgfSpeedAttributeSet_OnRep_ThrowableItemConsumeSpeedRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.OnRep_WeaponChangeSpeedRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfSpeedAttributeSet::OnRep_WeaponChangeSpeedRate(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "OnRep_WeaponChangeSpeedRate");

	Params::TgfSpeedAttributeSet_OnRep_WeaponChangeSpeedRate Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfSpeedAttributeSet.GetLevelInteractSpeedFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   BaseTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfSpeedAttributeSet::GetLevelInteractSpeedFinal(float BaseTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "GetLevelInteractSpeedFinal");

	Params::TgfSpeedAttributeSet_GetLevelInteractSpeedFinal Parms{};

	Parms.BaseTime = BaseTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSpeedAttributeSet.GetMoveSpeedFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfSpeedAttributeSet::GetMoveSpeedFinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "GetMoveSpeedFinal");

	Params::TgfSpeedAttributeSet_GetMoveSpeedFinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfSpeedAttributeSet.GetSpellCastSpeedFinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   BaseTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTgfSpeedAttributeSet::GetSpellCastSpeedFinal(float BaseTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfSpeedAttributeSet", "GetSpellCastSpeedFinal");

	Params::TgfSpeedAttributeSet_GetSpellCastSpeedFinal Parms{};

	Parms.BaseTime = BaseTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfStatEffectAttributeSet.OnRep_AttackBoostRateWithFullHealth
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfStatEffectAttributeSet::OnRep_AttackBoostRateWithFullHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStatEffectAttributeSet", "OnRep_AttackBoostRateWithFullHealth");

	Params::TgfStatEffectAttributeSet_OnRep_AttackBoostRateWithFullHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatEffectAttributeSet.OnRep_CriticalRateWithFullHealth
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfStatEffectAttributeSet::OnRep_CriticalRateWithFullHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStatEffectAttributeSet", "OnRep_CriticalRateWithFullHealth");

	Params::TgfStatEffectAttributeSet_OnRep_CriticalRateWithFullHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatEffectAttributeSet.OnRep_CriticalRateWithHitRunning
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfStatEffectAttributeSet::OnRep_CriticalRateWithHitRunning(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStatEffectAttributeSet", "OnRep_CriticalRateWithHitRunning");

	Params::TgfStatEffectAttributeSet_OnRep_CriticalRateWithHitRunning Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatEffectAttributeSet.OnRep_HealOverTimeWithHitRunning
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfStatEffectAttributeSet::OnRep_HealOverTimeWithHitRunning(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStatEffectAttributeSet", "OnRep_HealOverTimeWithHitRunning");

	Params::TgfStatEffectAttributeSet_OnRep_HealOverTimeWithHitRunning Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatEffectAttributeSet.OnRep_LifeLeachRateWithHitRunning
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfStatEffectAttributeSet::OnRep_LifeLeachRateWithHitRunning(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStatEffectAttributeSet", "OnRep_LifeLeachRateWithHitRunning");

	Params::TgfStatEffectAttributeSet_OnRep_LifeLeachRateWithHitRunning Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfStatEffectAttributeSet.OnRep_MoveSpeedWithHitRunning
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfStatEffectAttributeSet::OnRep_MoveSpeedWithHitRunning(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfStatEffectAttributeSet", "OnRep_MoveSpeedWithHitRunning");

	Params::TgfStatEffectAttributeSet_OnRep_MoveSpeedWithHitRunning Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalElementDarkDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalElementDarkDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalElementDarkDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalElementDarkDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalElementFireDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalElementFireDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalElementFireDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalElementFireDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalElementIceDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalElementIceDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalElementIceDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalElementIceDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalElementLightDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalElementLightDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalElementLightDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalElementLightDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalElementNoneDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalElementNoneDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalElementNoneDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalElementNoneDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalElementThunderDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalElementThunderDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalElementThunderDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalElementThunderDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AdditionalFixedDamageOnCausingHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AdditionalFixedDamageOnCausingHit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AdditionalFixedDamageOnCausingHit");

	Params::TgfTriggerEffectAttributeSet_OnRep_AdditionalFixedDamageOnCausingHit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_AddShieldOnCastSkill
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_AddShieldOnCastSkill(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_AddShieldOnCastSkill");

	Params::TgfTriggerEffectAttributeSet_OnRep_AddShieldOnCastSkill Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_DamageOnDefendSuccess
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_DamageOnDefendSuccess(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_DamageOnDefendSuccess");

	Params::TgfTriggerEffectAttributeSet_OnRep_DamageOnDefendSuccess Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_GainGoldOnKill
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_GainGoldOnKill(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_GainGoldOnKill");

	Params::TgfTriggerEffectAttributeSet_OnRep_GainGoldOnKill Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_GainGoldOnOpenChest
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_GainGoldOnOpenChest(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_GainGoldOnOpenChest");

	Params::TgfTriggerEffectAttributeSet_OnRep_GainGoldOnOpenChest Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_HealOnDefendSuccess
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_HealOnDefendSuccess(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_HealOnDefendSuccess");

	Params::TgfTriggerEffectAttributeSet_OnRep_HealOnDefendSuccess Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_HealOnOpenChest
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_HealOnOpenChest(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_HealOnOpenChest");

	Params::TgfTriggerEffectAttributeSet_OnRep_HealOnOpenChest Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfTriggerEffectAttributeSet.OnRep_MagicOnOpenChest
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfTriggerEffectAttributeSet::OnRep_MagicOnOpenChest(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfTriggerEffectAttributeSet", "OnRep_MagicOnOpenChest");

	Params::TgfTriggerEffectAttributeSet_OnRep_MagicOnOpenChest Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfExecutionModifier.TurnOffModifier
// (Native, Public)

void UTgfExecutionModifier::TurnOffModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfExecutionModifier", "TurnOffModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfExecutionModifier.TurnOnGameplayEffectModifier
// (Native, Public, HasOutParams)
// Parameters:
// struct FGameplayEffectSpec              Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTgfExecutionModifier::TurnOnGameplayEffectModifier(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfExecutionModifier", "TurnOnGameplayEffectModifier");

	Params::TgfExecutionModifier_TurnOnGameplayEffectModifier Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.PickupableStatics.AddPickupToInventory
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraInventoryManagerComponent*   InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IPickupable>     Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPickupableStatics::AddPickupToInventory(class ULyraInventoryManagerComponent* InventoryComponent, TScriptInterface<class IPickupable> Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PickupableStatics", "AddPickupToInventory");

	Params::PickupableStatics_AddPickupToInventory Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.PickupableStatics.GetFirstPickupableFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IPickupable>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IPickupable> UPickupableStatics::GetFirstPickupableFromActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PickupableStatics", "GetFirstPickupableFromActor");

	Params::PickupableStatics_GetFirstPickupableFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraContextEffectsLibrary.GetEffects
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Effect                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Context                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
// TArray<class USoundBase*>               Sounds                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UNiagaraSystem*>           NiagaraSystems                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULyraContextEffectsLibrary::GetEffects(const struct FGameplayTag& Effect, const struct FGameplayTagContainer& Context, TArray<class USoundBase*>* Sounds, TArray<class UNiagaraSystem*>* NiagaraSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsLibrary", "GetEffects");

	Params::LyraContextEffectsLibrary_GetEffects Parms{};

	Parms.Effect = std::move(Effect);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Sounds != nullptr)
		*Sounds = std::move(Parms.Sounds);

	if (NiagaraSystems != nullptr)
		*NiagaraSystems = std::move(Parms.NiagaraSystems);
}


// Function LyraGame.LyraContextEffectsLibrary.LoadEffects
// (Final, Native, Public, BlueprintCallable)

void ULyraContextEffectsLibrary::LoadEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsLibrary", "LoadEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ClientEstimatePing
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::ClientEstimatePing(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ClientEstimatePing");

	Params::LyraPlayerController_ClientEstimatePing Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ClientPingEstimationReq
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   Version                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ClientCallTime                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::ClientPingEstimationReq(const int32& Version, const int64& ClientCallTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ClientPingEstimationReq");

	Params::LyraPlayerController_ClientPingEstimationReq Parms{};

	Parms.Version = Version;
	Parms.ClientCallTime = ClientCallTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.GetCurrentViewTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALyraPlayerController::GetCurrentViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetCurrentViewTarget");

	Params::LyraPlayerController_GetCurrentViewTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetPredictPing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALyraPlayerController::GetPredictPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetPredictPing");

	Params::LyraPlayerController_GetPredictPing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetReconnect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerController::GetReconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetReconnect");

	Params::LyraPlayerController_GetReconnect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetSpectatorMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerController::GetSpectatorMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetSpectatorMode");

	Params::LyraPlayerController_GetSpectatorMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.IncreaseAndCheckSecurityInvalidCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::IncreaseAndCheckSecurityInvalidCount(int32 Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "IncreaseAndCheckSecurityInvalidCount");

	Params::LyraPlayerController_IncreaseAndCheckSecurityInvalidCount Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.K2_OnEndAutoRun
// (Event, Protected, BlueprintEvent)

void ALyraPlayerController::K2_OnEndAutoRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "K2_OnEndAutoRun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraPlayerController.K2_OnStartAutoRun
// (Event, Protected, BlueprintEvent)

void ALyraPlayerController::K2_OnStartAutoRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "K2_OnStartAutoRun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraPlayerController.NotifyClientLoaded
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ALyraPlayerController::NotifyClientLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "NotifyClientLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.OnPlayerStateChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::OnPlayerStateChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "OnPlayerStateChangedTeam");

	Params::LyraPlayerController_OnPlayerStateChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerBanQuitGame
// (Final, Native, Public, BlueprintCallable)

void ALyraPlayerController::ServerBanQuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerBanQuitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerCheat
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::ServerCheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerCheat");

	Params::LyraPlayerController_ServerCheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerCheatAll
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::ServerCheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerCheatAll");

	Params::LyraPlayerController_ServerCheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerDeathQuitGame
// (Final, Native, Public, BlueprintCallable)

void ALyraPlayerController::ServerDeathQuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerDeathQuitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerEscapeQuitGame
// (Final, Native, Public, BlueprintCallable)

void ALyraPlayerController::ServerEscapeQuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerEscapeQuitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerPingEstimationRsp
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                                   Version                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   CallTime                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::ServerPingEstimationRsp(const int32& Version, const int64& CallTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerPingEstimationRsp");

	Params::LyraPlayerController_ServerPingEstimationRsp Parms{};

	Parms.Version = Version;
	Parms.CallTime = CallTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerSelfQuitGame
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ALyraPlayerController::ServerSelfQuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerSelfQuitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.ServerTeleportToWaitingRoom
// (Final, Native, Public, BlueprintCallable)

void ALyraPlayerController::ServerTeleportToWaitingRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "ServerTeleportToWaitingRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.SetIgnoreFlushPressedKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UInputAction*>             IgnoreInputActions                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALyraPlayerController::SetIgnoreFlushPressedKeys(const TArray<class UInputAction*>& IgnoreInputActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "SetIgnoreFlushPressedKeys");

	Params::LyraPlayerController_SetIgnoreFlushPressedKeys Parms{};

	Parms.IgnoreInputActions = std::move(IgnoreInputActions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.SetIsAutoRunning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerController::SetIsAutoRunning(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "SetIsAutoRunning");

	Params::LyraPlayerController_SetIsAutoRunning Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.Teleport
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ALyraPlayerController::Teleport(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "Teleport");

	Params::LyraPlayerController_Teleport Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerController.TryToRecordClientReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerController::TryToRecordClientReplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "TryToRecordClientReplay");

	Params::LyraPlayerController_TryToRecordClientReplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetIsAutoRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerController::GetIsAutoRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetIsAutoRunning");

	Params::LyraPlayerController_GetIsAutoRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ALyraPlayerController::GetLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetLyraAbilitySystemComponent");

	Params::LyraPlayerController_GetLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetLyraHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraHUD*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraHUD* ALyraPlayerController::GetLyraHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetLyraHUD");

	Params::LyraPlayerController_GetLyraHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.GetLyraPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraPlayerState*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerState* ALyraPlayerController::GetLyraPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "GetLyraPlayerState");

	Params::LyraPlayerController_GetLyraPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerController.IsOnlyAliving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerController::IsOnlyAliving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerController", "IsOnlyAliving");

	Params::LyraPlayerController_IsOnlyAliving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraContextEffectComponent.AnimMotionEffect_Implementation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             bone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MotionEffect                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RotationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitSuccess                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Contexts                                               (Parm, NativeAccessSpecifierPublic)
// struct FVector                          VFXScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioPitch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraContextEffectComponent::AnimMotionEffect_Implementation(const class FName bone, const struct FGameplayTag& MotionEffect, class USceneComponent* StaticMeshComponent, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const class UAnimSequenceBase* AnimationSequence, const bool bHitSuccess, const struct FHitResult& HitResult, const struct FGameplayTagContainer& Contexts, const struct FVector& VFXScale, float AudioVolume, float AudioPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectComponent", "AnimMotionEffect_Implementation");

	Params::LyraContextEffectComponent_AnimMotionEffect_Implementation Parms{};

	Parms.bone = bone;
	Parms.MotionEffect = std::move(MotionEffect);
	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.AnimationSequence = AnimationSequence;
	Parms.bHitSuccess = bHitSuccess;
	Parms.HitResult = std::move(HitResult);
	Parms.Contexts = std::move(Contexts);
	Parms.VFXScale = std::move(VFXScale);
	Parms.AudioVolume = AudioVolume;
	Parms.AudioPitch = AudioPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraContextEffectComponent.UpdateEffectContexts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            NewEffectContexts                                      (Parm, NativeAccessSpecifierPublic)

void ULyraContextEffectComponent::UpdateEffectContexts(const struct FGameplayTagContainer& NewEffectContexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectComponent", "UpdateEffectContexts");

	Params::LyraContextEffectComponent_UpdateEffectContexts Parms{};

	Parms.NewEffectContexts = std::move(NewEffectContexts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraContextEffectComponent.UpdateLibraries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>>NewContextEffectsLibraries                             (Parm, UObjectWrapper, NativeAccessSpecifierPublic)

void ULyraContextEffectComponent::UpdateLibraries(const TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>>& NewContextEffectsLibraries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectComponent", "UpdateLibraries");

	Params::LyraContextEffectComponent_UpdateLibraries Parms{};

	Parms.NewContextEffectsLibraries = std::move(NewContextEffectsLibraries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySet.DealAdditionalAbilitySystem
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      LyraASC                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLyraAbilitySet_GrantedHandles   OutGrantedHandles                                      (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULyraAbilitySet::DealAdditionalAbilitySystem(class ULyraAbilitySystemComponent* LyraASC, struct FLyraAbilitySet_GrantedHandles* OutGrantedHandles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySet", "DealAdditionalAbilitySystem");

	Params::LyraAbilitySet_DealAdditionalAbilitySystem Parms{};

	Parms.LyraASC = LyraASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGrantedHandles != nullptr)
		*OutGrantedHandles = std::move(Parms.OutGrantedHandles);
}


// Function LyraGame.LyraAbilitySet.GetGrantedGameplayAbilityClasses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSubclassOf<class ULyraGameplayAbility>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ULyraGameplayAbility>> ULyraAbilitySet::GetGrantedGameplayAbilityClasses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySet", "GetGrantedGameplayAbilityClasses");

	Params::LyraAbilitySet_GetGrantedGameplayAbilityClasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySet.GiveToAbilitySystem
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      LyraASC                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLyraAbilitySet_GrantedHandles   OutGrantedHandles                                      (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETgfEquipAttrParseType                  AttrParseType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySet::GiveToAbilitySystem(class ULyraAbilitySystemComponent* LyraASC, struct FLyraAbilitySet_GrantedHandles* OutGrantedHandles, class UObject* SourceObject, ETgfEquipAttrParseType AttrParseType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySet", "GiveToAbilitySystem");

	Params::LyraAbilitySet_GiveToAbilitySystem Parms{};

	Parms.LyraASC = LyraASC;
	Parms.SourceObject = SourceObject;
	Parms.AttrParseType = AttrParseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGrantedHandles != nullptr)
		*OutGrantedHandles = std::move(Parms.OutGrantedHandles);
}


// Function LyraGame.LyraAbilitySet.NeedEnableInAdditionalSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraAbilitySet::NeedEnableInAdditionalSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySet", "NeedEnableInAdditionalSlot");

	Params::LyraAbilitySet_NeedEnableInAdditionalSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraLocalPlayer.OnCompletedAudioDeviceSwap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSwapAudioOutputResult           SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraLocalPlayer::OnCompletedAudioDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "OnCompletedAudioDeviceSwap");

	Params::LyraLocalPlayer_OnCompletedAudioDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraLocalPlayer.OnControllerChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraLocalPlayer::OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "OnControllerChangedTeam");

	Params::LyraLocalPlayer_OnControllerChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraLocalPlayer.GetLocalSettings
// (Final, Native, Public, Const)
// Parameters:
// class ULyraSettingsLocal*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraSettingsLocal* ULyraLocalPlayer::GetLocalSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "GetLocalSettings");

	Params::LyraLocalPlayer_GetLocalSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraLocalPlayer.GetSharedSettings
// (Final, Native, Public, Const)
// Parameters:
// class ULyraSettingsShared*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraSettingsShared* ULyraLocalPlayer::GetSharedSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "GetSharedSettings");

	Params::LyraLocalPlayer_GetSharedSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.AbilityInputTagPressed
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::AbilityInputTagPressed(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "AbilityInputTagPressed");

	Params::LyraAbilitySystemComponent_AbilityInputTagPressed Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.AbilityInputTagReleased
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::AbilityInputTagReleased(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "AbilityInputTagReleased");

	Params::LyraAbilitySystemComponent_AbilityInputTagReleased Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.AddInputTagDelayOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::AddInputTagDelayOverride(const struct FGameplayTag& Tag, double Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "AddInputTagDelayOverride");

	Params::LyraAbilitySystemComponent_AddInputTagDelayOverride Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.ApplyDumpedGameplayEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTGFDumpedGameplayEffect> DumpedArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::ApplyDumpedGameplayEffect(const TArray<struct FTGFDumpedGameplayEffect>& DumpedArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "ApplyDumpedGameplayEffect");

	Params::LyraAbilitySystemComponent_ApplyDumpedGameplayEffect Parms{};

	Parms.DumpedArray = std::move(DumpedArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.CancelAbilitiesOnOwnClient
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            WithTags                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            WithoutTags                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::CancelAbilitiesOnOwnClient(const struct FGameplayTagContainer& WithTags, const struct FGameplayTagContainer& WithoutTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "CancelAbilitiesOnOwnClient");

	Params::LyraAbilitySystemComponent_CancelAbilitiesOnOwnClient Parms{};

	Parms.WithTags = std::move(WithTags);
	Parms.WithoutTags = std::move(WithoutTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.ClientNotifyAbilityFailed
// (Net, Native, Event, Protected, NetClient)
// Parameters:
// class UGameplayAbility*                 Ability                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            FailureReason                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::ClientNotifyAbilityFailed(const class UGameplayAbility* Ability, const struct FGameplayTagContainer& FailureReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "ClientNotifyAbilityFailed");

	Params::LyraAbilitySystemComponent_ClientNotifyAbilityFailed Parms{};

	Parms.Ability = Ability;
	Parms.FailureReason = std::move(FailureReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.GetAbilityWithTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle       OutHandler                                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraAbilitySystemComponent::GetAbilityWithTag(struct FGameplayAbilitySpecHandle* OutHandler, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetAbilityWithTag");

	Params::LyraAbilitySystemComponent_GetAbilityWithTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandler != nullptr)
		*OutHandler = std::move(Parms.OutHandler);

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetAllActiveGameplayAbilitys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UGameplayAbility*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGameplayAbility*> ULyraAbilitySystemComponent::GetAllActiveGameplayAbilitys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetAllActiveGameplayAbilitys");

	Params::LyraAbilitySystemComponent_GetAllActiveGameplayAbilitys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetAttributeComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfAttributeComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAttributeComponent* ULyraAbilitySystemComponent::GetAttributeComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetAttributeComponent");

	Params::LyraAbilitySystemComponent_GetAttributeComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetAuraManagerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfAuraManagerComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAuraManagerComponent* ULyraAbilitySystemComponent::GetAuraManagerComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetAuraManagerComponent");

	Params::LyraAbilitySystemComponent_GetAuraManagerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetCharaMoveExtComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTgfCharacterMovementExtensionComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfCharacterMovementExtensionComponent* ULyraAbilitySystemComponent::GetCharaMoveExtComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetCharaMoveExtComponent");

	Params::LyraAbilitySystemComponent_GetCharaMoveExtComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetGameplayAbilityByDynamicAbilityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayAbility*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGameplayAbility*> ULyraAbilitySystemComponent::GetGameplayAbilityByDynamicAbilityTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetGameplayAbilityByDynamicAbilityTag");

	Params::LyraAbilitySystemComponent_GetGameplayAbilityByDynamicAbilityTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetInputDelayTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraGameplayAbility*             Ability                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraAbilitySystemComponent::GetInputDelayTime(const class ULyraGameplayAbility* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetInputDelayTime");

	Params::LyraAbilitySystemComponent_GetInputDelayTime Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GetOwnerLyraCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALyraCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraCharacter* ULyraAbilitySystemComponent::GetOwnerLyraCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetOwnerLyraCharacter");

	Params::LyraAbilitySystemComponent_GetOwnerLyraCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.GiveAbilityByInputTag
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AbilityLevel                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle ULyraAbilitySystemComponent::GiveAbilityByInputTag(TSubclassOf<class UGameplayAbility> Ability, const struct FGameplayTag& InputTag, const int32 AbilityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GiveAbilityByInputTag");

	Params::LyraAbilitySystemComponent_GiveAbilityByInputTag Parms{};

	Parms.Ability = Ability;
	Parms.InputTag = std::move(InputTag);
	Parms.AbilityLevel = AbilityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.InterruptAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle       Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::InterruptAbility(const struct FGameplayAbilitySpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "InterruptAbility");

	Params::LyraAbilitySystemComponent_InterruptAbility Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.InterruptAbilityByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::InterruptAbilityByClass(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "InterruptAbilityByClass");

	Params::LyraAbilitySystemComponent_InterruptAbilityByClass Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.InterruptAbilityByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::InterruptAbilityByTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "InterruptAbilityByTag");

	Params::LyraAbilitySystemComponent_InterruptAbilityByTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.InterruptAbilityByTagContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            TagContainer                                           (Parm, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::InterruptAbilityByTagContainer(const struct FGameplayTagContainer& TagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "InterruptAbilityByTagContainer");

	Params::LyraAbilitySystemComponent_InterruptAbilityByTagContainer Parms{};

	Parms.TagContainer = std::move(TagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.IsAbilityCoolingDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraAbilitySystemComponent::IsAbilityCoolingDown(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "IsAbilityCoolingDown");

	Params::LyraAbilitySystemComponent_IsAbilityCoolingDown Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.IsImmuneDamageFromSource
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULyraAbilitySystemComponent*      Source                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AddContainer                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraAbilitySystemComponent::IsImmuneDamageFromSource(class ULyraAbilitySystemComponent* Source, struct FGameplayTagContainer* AddContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "IsImmuneDamageFromSource");

	Params::LyraAbilitySystemComponent_IsImmuneDamageFromSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AddContainer != nullptr)
		*AddContainer = std::move(Parms.AddContainer);

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.PopAbilityTagClick
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::PopAbilityTagClick(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "PopAbilityTagClick");

	Params::LyraAbilitySystemComponent_PopAbilityTagClick Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.RemoveAbilityCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraAbilitySystemComponent::RemoveAbilityCooldown(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "RemoveAbilityCooldown");

	Params::LyraAbilitySystemComponent_RemoveAbilityCooldown Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.RemoveActiveEffectByHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraAbilitySystemComponent::RemoveActiveEffectByHandle(const struct FActiveGameplayEffectHandle& Handle, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "RemoveActiveEffectByHandle");

	Params::LyraAbilitySystemComponent_RemoveActiveEffectByHandle Parms{};

	Parms.Handle = std::move(Handle);
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAbilitySystemComponent.RemoveInputTagDelayOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::RemoveInputTagDelayOverride(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "RemoveInputTagDelayOverride");

	Params::LyraAbilitySystemComponent_RemoveInputTagDelayOverride Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.ReportClientTaskProgress
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// ETGFInGameRookieTaskType                TaskType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   InstigatorCharacter                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::ReportClientTaskProgress(ETGFInGameRookieTaskType TaskType, class ALyraCharacter* InstigatorCharacter, int64 Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "ReportClientTaskProgress");

	Params::LyraAbilitySystemComponent_ReportClientTaskProgress Parms{};

	Parms.TaskType = TaskType;
	Parms.InstigatorCharacter = InstigatorCharacter;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.SendGameplayEventToClient
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::SendGameplayEventToClient(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "SendGameplayEventToClient");

	Params::LyraAbilitySystemComponent_SendGameplayEventToClient Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.TryActivateAbilitiesOnSpawn
// (Final, Native, Public, BlueprintCallable)

void ULyraAbilitySystemComponent::TryActivateAbilitiesOnSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "TryActivateAbilitiesOnSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAbilitySystemComponent.DumpGameplayEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FTGFDumpedGameplayEffect> OutArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULyraAbilitySystemComponent::DumpGameplayEffect(TArray<struct FTGFDumpedGameplayEffect>* OutArray) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "DumpGameplayEffect");

	Params::LyraAbilitySystemComponent_DumpGameplayEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);
}


// Function LyraGame.LyraAbilitySystemComponent.GetRandomActiveEffects
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> ULyraAbilitySystemComponent::GetRandomActiveEffects(const struct FGameplayTagContainer& Tags, int32 Num) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAbilitySystemComponent", "GetRandomActiveEffects");

	Params::LyraAbilitySystemComponent_GetRandomActiveEffects Parms{};

	Parms.Tags = std::move(Tags);
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.AddStatTagStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::AddStatTagStack(const struct FGameplayTag& Tag, int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "AddStatTagStack");

	Params::LyraPlayerState_AddStatTagStack Parms{};

	Parms.Tag = std::move(Tag);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ClientBroadcastMessage
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FLyraVerbMessage                 Message                                                (ConstParm, Parm, NativeAccessSpecifierPublic)

void ALyraPlayerState::ClientBroadcastMessage(const struct FLyraVerbMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ClientBroadcastMessage");

	Params::LyraPlayerState_ClientBroadcastMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ClientSelfQuit
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ALyraPlayerState::ClientSelfQuit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ClientSelfQuit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.GetIsDisconnected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsDisconnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsDisconnected");

	Params::LyraPlayerState_GetIsDisconnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetPlayerNameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPlayerNameData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerNameData ALyraPlayerState::GetPlayerNameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetPlayerNameData");

	Params::LyraPlayerState_GetPlayerNameData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetTeamColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfPVPTeamColor                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfPVPTeamColor ALyraPlayerState::GetTeamColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetTeamColor");

	Params::LyraPlayerState_GetTeamColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GMSetPlayerName
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::GMSetPlayerName(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GMSetPlayerName");

	Params::LyraPlayerState_GMSetPlayerName Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_FloatStatistics
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPlayerFloatStatisticItemEntry   FloatStatisticItem                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALyraPlayerState::OnRep_FloatStatistics(const struct FPlayerFloatStatisticItemEntry& FloatStatisticItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_FloatStatistics");

	Params::LyraPlayerState_OnRep_FloatStatistics Parms{};

	Parms.FloatStatisticItem = std::move(FloatStatisticItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_ForceType
// (Final, Native, Private)

void ALyraPlayerState::OnRep_ForceType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_ForceType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_IntStatistics
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPlayerIntStatisticItemEntry     IntStatisticItem                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALyraPlayerState::OnRep_IntStatistics(const struct FPlayerIntStatisticItemEntry& IntStatisticItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_IntStatistics");

	Params::LyraPlayerState_OnRep_IntStatistics Parms{};

	Parms.IntStatisticItem = std::move(IntStatisticItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_IsTeleportToWaitingRoom
// (Final, Native, Private)

void ALyraPlayerState::OnRep_IsTeleportToWaitingRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_IsTeleportToWaitingRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MithrilRemainingRebirthChances
// (Final, Native, Private)

void ALyraPlayerState::OnRep_MithrilRemainingRebirthChances()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MithrilRemainingRebirthChances");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MyOpenId
// (Final, Native, Private)

void ALyraPlayerState::OnRep_MyOpenId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MyOpenId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MyRoleGuid
// (Final, Native, Private)

void ALyraPlayerState::OnRep_MyRoleGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MyRoleGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MySquadID
// (Final, Native, Private)

void ALyraPlayerState::OnRep_MySquadID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MySquadID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MyTeamID
// (Final, Native, Private)
// Parameters:
// struct FGenericTeamId                   OldTeamID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MyTeamID");

	Params::LyraPlayerState_OnRep_MyTeamID Parms{};

	Parms.OldTeamID = std::move(OldTeamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MyUserID
// (Final, Native, Private)

void ALyraPlayerState::OnRep_MyUserID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MyUserID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_MyZoneID
// (Final, Native, Private)

void ALyraPlayerState::OnRep_MyZoneID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_MyZoneID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_PawnData
// (Final, Native, Protected)

void ALyraPlayerState::OnRep_PawnData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_PawnData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_RelationIntStatistics
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPlayerRelationIntStatisticItemEntryRelationIntStatisticItem                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALyraPlayerState::OnRep_RelationIntStatistics(const struct FPlayerRelationIntStatisticItemEntry& RelationIntStatisticItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_RelationIntStatistics");

	Params::LyraPlayerState_OnRep_RelationIntStatistics Parms{};

	Parms.RelationIntStatisticItem = std::move(RelationIntStatisticItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.OnRep_SceneTag
// (Final, Native, Private)

void ALyraPlayerState::OnRep_SceneTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "OnRep_SceneTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.PlayerAddExp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ExpCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::PlayerAddExp(int32 ExpCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "PlayerAddExp");

	Params::LyraPlayerState_PlayerAddExp Parms{};

	Parms.ExpCount = ExpCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.RemoveStatTagStack
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::RemoveStatTagStack(const struct FGameplayTag& Tag, int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "RemoveStatTagStack");

	Params::LyraPlayerState_RemoveStatTagStack Parms{};

	Parms.Tag = std::move(Tag);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ServerCallBanQuit
// (Final, Native, Public)

void ALyraPlayerState::ServerCallBanQuit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ServerCallBanQuit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ServerCallDeathQuit
// (Final, Native, Public)

void ALyraPlayerState::ServerCallDeathQuit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ServerCallDeathQuit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ServerCallEscapeQuit
// (Final, Native, Public)
// Parameters:
// bool                                    JudgeTeammateDeathQuit                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::ServerCallEscapeQuit(bool JudgeTeammateDeathQuit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ServerCallEscapeQuit");

	Params::LyraPlayerState_ServerCallEscapeQuit Parms{};

	Parms.JudgeTeammateDeathQuit = JudgeTeammateDeathQuit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ServerCallSelfQuit
// (Final, Native, Public)

void ALyraPlayerState::ServerCallSelfQuit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ServerCallSelfQuit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.ServerCallTeleportToWaitingRoom
// (Final, Native, Public)

void ALyraPlayerState::ServerCallTeleportToWaitingRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "ServerCallTeleportToWaitingRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.SetFloatStatisticsRepType
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// ETgfActorFloatStatisticType             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::SetFloatStatisticsRepType(ETgfActorFloatStatisticType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "SetFloatStatisticsRepType");

	Params::LyraPlayerState_SetFloatStatisticsRepType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.SetIntStatisticsRepType
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// ETgfActorIntStatisticType               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::SetIntStatisticsRepType(ETgfActorIntStatisticType Type, int32 TypeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "SetIntStatisticsRepType");

	Params::LyraPlayerState_SetIntStatisticsRepType Parms{};

	Parms.Type = Type;
	Parms.TypeId = TypeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.SetIsDisconnected
// (Final, Native, Public)
// Parameters:
// bool                                    IsOk                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::SetIsDisconnected(bool IsOk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "SetIsDisconnected");

	Params::LyraPlayerState_SetIsDisconnected Parms{};

	Parms.IsOk = IsOk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.SetPlayerSceneTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfPlayerSceneTag                      Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::SetPlayerSceneTag(ETgfPlayerSceneTag Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "SetPlayerSceneTag");

	Params::LyraPlayerState_SetPlayerSceneTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.SetRelationIntStatisticsRepType
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// ETgfActorRelationStatisticType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OpenID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerState::SetRelationIntStatisticsRepType(ETgfActorRelationStatisticType Type, const class FString& OpenID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "SetRelationIntStatisticsRepType");

	Params::LyraPlayerState_SetRelationIntStatisticsRepType Parms{};

	Parms.Type = Type;
	Parms.OpenID = std::move(OpenID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.SettleDisconnectTimeDuration
// (Final, Native, Public, BlueprintCallable)

void ALyraPlayerState::SettleDisconnectTimeDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "SettleDisconnectTimeDuration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerState.GetDisconnectedTimeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALyraPlayerState::GetDisconnectedTimeDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetDisconnectedTimeDuration");

	Params::LyraPlayerState_GetDisconnectedTimeDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetIsBanQuit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsBanQuit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsBanQuit");

	Params::LyraPlayerState_GetIsBanQuit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetIsDeathQuit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsDeathQuit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsDeathQuit");

	Params::LyraPlayerState_GetIsDeathQuit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetIsEscapeQuit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsEscapeQuit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsEscapeQuit");

	Params::LyraPlayerState_GetIsEscapeQuit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetIsMithrilCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsMithrilCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsMithrilCharacter");

	Params::LyraPlayerState_GetIsMithrilCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetIsSelfQuit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsSelfQuit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsSelfQuit");

	Params::LyraPlayerState_GetIsSelfQuit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetIsTeleportToWaitingRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::GetIsTeleportToWaitingRoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetIsTeleportToWaitingRoom");

	Params::LyraPlayerState_GetIsTeleportToWaitingRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ALyraPlayerState::GetLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetLyraAbilitySystemComponent");

	Params::LyraPlayerState_GetLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetLyraPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALyraPlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALyraPlayerController* ALyraPlayerState::GetLyraPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetLyraPlayerController");

	Params::LyraPlayerState_GetLyraPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetMithrilRemainingRebirthChances
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerState::GetMithrilRemainingRebirthChances() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetMithrilRemainingRebirthChances");

	Params::LyraPlayerState_GetMithrilRemainingRebirthChances Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetOpenId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALyraPlayerState::GetOpenId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetOpenId");

	Params::LyraPlayerState_GetOpenId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetPlayerConnectionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraPlayerConnectionType               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraPlayerConnectionType ALyraPlayerState::GetPlayerConnectionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetPlayerConnectionType");

	Params::LyraPlayerState_GetPlayerConnectionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetPlayerSceneTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfPlayerSceneTag                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfPlayerSceneTag ALyraPlayerState::GetPlayerSceneTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetPlayerSceneTag");

	Params::LyraPlayerState_GetPlayerSceneTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetRoleGuid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ALyraPlayerState::GetRoleGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetRoleGuid");

	Params::LyraPlayerState_GetRoleGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetSquadId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerState::GetSquadId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetSquadId");

	Params::LyraPlayerState_GetSquadId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetStatTagStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerState::GetStatTagStackCount(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetStatTagStackCount");

	Params::LyraPlayerState_GetStatTagStackCount Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerState::GetTeamId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetTeamId");

	Params::LyraPlayerState_GetTeamId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetTotalExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerState::GetTotalExp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetTotalExp");

	Params::LyraPlayerState_GetTotalExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetUserId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ALyraPlayerState::GetUserId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetUserId");

	Params::LyraPlayerState_GetUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.GetZoneId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerState::GetZoneId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "GetZoneId");

	Params::LyraPlayerState_GetZoneId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.HasStatTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::HasStatTag(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "HasStatTag");

	Params::LyraPlayerState_HasStatTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerState.NeedIgnoreAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerState::NeedIgnoreAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerState", "NeedIgnoreAlive");

	Params::LyraPlayerState_NeedIgnoreAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGlobalAbilitySystem.ApplyAbilityToAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGlobalAbilitySystem::ApplyAbilityToAll(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGlobalAbilitySystem", "ApplyAbilityToAll");

	Params::LyraGlobalAbilitySystem_ApplyAbilityToAll Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGlobalAbilitySystem.ApplyEffectToAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      Effect                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGlobalAbilitySystem::ApplyEffectToAll(TSubclassOf<class UGameplayEffect> Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGlobalAbilitySystem", "ApplyEffectToAll");

	Params::LyraGlobalAbilitySystem_ApplyEffectToAll Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGlobalAbilitySystem.RemoveAbilityFromAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGlobalAbilitySystem::RemoveAbilityFromAll(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGlobalAbilitySystem", "RemoveAbilityFromAll");

	Params::LyraGlobalAbilitySystem_RemoveAbilityFromAll Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGlobalAbilitySystem.RemoveEffectFromAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      Effect                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGlobalAbilitySystem::RemoveEffectFromAll(TSubclassOf<class UGameplayEffect> Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGlobalAbilitySystem", "RemoveEffectFromAll");

	Params::LyraGlobalAbilitySystem_RemoveEffectFromAll Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerSpawningManagerComponent.GetFirstRandomPlayerStartsInRegion
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStart*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStart* ULyraPlayerSpawningManagerComponent::GetFirstRandomPlayerStartsInRegion(class AController* Controller, const struct FVector& Center, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerSpawningManagerComponent", "GetFirstRandomPlayerStartsInRegion");

	Params::LyraPlayerSpawningManagerComponent_GetFirstRandomPlayerStartsInRegion Parms{};

	Parms.Controller = Controller;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerSpawningManagerComponent.GetRandomPlayerStartOutRegion
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasDeathZone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DeathZoneCenter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeathZoneRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStart*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStart* ULyraPlayerSpawningManagerComponent::GetRandomPlayerStartOutRegion(class AController* Controller, const struct FVector& Center, float Radius, bool HasDeathZone, const struct FVector& DeathZoneCenter, float DeathZoneRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerSpawningManagerComponent", "GetRandomPlayerStartOutRegion");

	Params::LyraPlayerSpawningManagerComponent_GetRandomPlayerStartOutRegion Parms{};

	Parms.Controller = Controller;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.HasDeathZone = HasDeathZone;
	Parms.DeathZoneCenter = std::move(DeathZoneCenter);
	Parms.DeathZoneRadius = DeathZoneRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerSpawningManagerComponent.K2_OnFinishRestartPlayer
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         StartRotation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULyraPlayerSpawningManagerComponent::K2_OnFinishRestartPlayer(class AController* Player, const struct FRotator& StartRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerSpawningManagerComponent", "K2_OnFinishRestartPlayer");

	Params::LyraPlayerSpawningManagerComponent_K2_OnFinishRestartPlayer Parms{};

	Parms.Player = Player;
	Parms.StartRotation = std::move(StartRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraGamePhaseAbility.EndPhase
// (Event, Public, BlueprintEvent)

void ULyraGamePhaseAbility::EndPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGamePhaseAbility", "EndPhase");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.LyraGamePhaseAbility.SetAllActorAliveTime
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    OnlyRefreshStart                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGamePhaseAbility::SetAllActorAliveTime(bool OnlyRefreshStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGamePhaseAbility", "SetAllActorAliveTime");

	Params::LyraGamePhaseAbility_SetAllActorAliveTime Parms{};

	Parms.OnlyRefreshStart = OnlyRefreshStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGamePhaseSubsystem.K2_StartPhase
// (Final, BlueprintAuthorityOnly, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraGamePhaseAbility>Phase                                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class ULyraGamePhaseAbility* Phase)>PhaseEnded                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGamePhaseSubsystem::K2_StartPhase(TSubclassOf<class ULyraGamePhaseAbility> Phase, const TDelegate<void(class ULyraGamePhaseAbility* Phase)>& PhaseEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGamePhaseSubsystem", "K2_StartPhase");

	Params::LyraGamePhaseSubsystem_K2_StartPhase Parms{};

	Parms.Phase = Phase;
	Parms.PhaseEnded = PhaseEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGamePhaseSubsystem.K2_WhenPhaseEnds
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     PhaseTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhaseTagMatchType                      MatchType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(struct FGameplayTag& PhaseTag)>WhenPhaseEnd                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGamePhaseSubsystem::K2_WhenPhaseEnds(const struct FGameplayTag& PhaseTag, EPhaseTagMatchType MatchType, TDelegate<void(struct FGameplayTag& PhaseTag)> WhenPhaseEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGamePhaseSubsystem", "K2_WhenPhaseEnds");

	Params::LyraGamePhaseSubsystem_K2_WhenPhaseEnds Parms{};

	Parms.PhaseTag = std::move(PhaseTag);
	Parms.MatchType = MatchType;
	Parms.WhenPhaseEnd = WhenPhaseEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGamePhaseSubsystem.K2_WhenPhaseStartsOrIsActive
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     PhaseTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhaseTagMatchType                      MatchType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(struct FGameplayTag& PhaseTag)>WhenPhaseActive                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraGamePhaseSubsystem::K2_WhenPhaseStartsOrIsActive(const struct FGameplayTag& PhaseTag, EPhaseTagMatchType MatchType, TDelegate<void(struct FGameplayTag& PhaseTag)> WhenPhaseActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGamePhaseSubsystem", "K2_WhenPhaseStartsOrIsActive");

	Params::LyraGamePhaseSubsystem_K2_WhenPhaseStartsOrIsActive Parms{};

	Parms.PhaseTag = std::move(PhaseTag);
	Parms.MatchType = MatchType;
	Parms.WhenPhaseActive = WhenPhaseActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGamePhaseSubsystem.IsPhaseActive
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FGameplayTag                     PhaseTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraGamePhaseSubsystem::IsPhaseActive(const struct FGameplayTag& PhaseTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGamePhaseSubsystem", "IsPhaseActive");

	Params::LyraGamePhaseSubsystem_IsPhaseActive Parms{};

	Parms.PhaseTag = std::move(PhaseTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AbilityTask_ApplyTgfMoveToForce.ApplyTgfMoveToForce
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_RootMotionPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Param_TargetLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Duration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bUpdateRotation                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Param_TargetRotation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Param_RotateDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bSetNewMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bRestrictSpeedToExpected                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     Param_PathOffsetCurve                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_IgnoreZLimit                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SetVelocityOnFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_ApplyTgfMoveToForce* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_ApplyTgfMoveToForce* UAbilityTask_ApplyTgfMoveToForce::ApplyTgfMoveToForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, const struct FVector& Param_TargetLocation, float Param_Duration, bool Param_bUpdateRotation, const struct FRotator& Param_TargetRotation, float Param_RotateDuration, bool Param_bSetNewMovementMode, EMovementMode MovementMode, bool Param_bRestrictSpeedToExpected, class UCurveVector* Param_PathOffsetCurve, float Param_IgnoreZLimit, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_ApplyTgfMoveToForce", "ApplyTgfMoveToForce");

	Params::AbilityTask_ApplyTgfMoveToForce_ApplyTgfMoveToForce Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Param_RootMotionPriority = Param_RootMotionPriority;
	Parms.Param_TargetLocation = std::move(Param_TargetLocation);
	Parms.Param_Duration = Param_Duration;
	Parms.Param_bUpdateRotation = Param_bUpdateRotation;
	Parms.Param_TargetRotation = std::move(Param_TargetRotation);
	Parms.Param_RotateDuration = Param_RotateDuration;
	Parms.Param_bSetNewMovementMode = Param_bSetNewMovementMode;
	Parms.MovementMode = MovementMode;
	Parms.Param_bRestrictSpeedToExpected = Param_bRestrictSpeedToExpected;
	Parms.Param_PathOffsetCurve = Param_PathOffsetCurve;
	Parms.Param_IgnoreZLimit = Param_IgnoreZLimit;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinish = std::move(SetVelocityOnFinish);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AbilityTask_MoveActor.ApplyMoveActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_RootMotionPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Duration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     Param_LocationCurve                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bIsExtractRootMotionCurve                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bShouldIgnoreZAccumulate                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bSetNewMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bRestrictSpeedToExpected                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SetVelocityOnFinished                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_MoveActor*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_MoveActor* UAbilityTask_MoveActor::ApplyMoveActor(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, float Param_Duration, class UCurveVector* Param_LocationCurve, bool Param_bIsExtractRootMotionCurve, bool Param_bShouldIgnoreZAccumulate, bool Param_bSetNewMovementMode, EMovementMode MovementMode, bool Param_bRestrictSpeedToExpected, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinished, float ClampVelocityOnFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_MoveActor", "ApplyMoveActor");

	Params::AbilityTask_MoveActor_ApplyMoveActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Param_RootMotionPriority = Param_RootMotionPriority;
	Parms.Param_Duration = Param_Duration;
	Parms.Param_LocationCurve = Param_LocationCurve;
	Parms.Param_bIsExtractRootMotionCurve = Param_bIsExtractRootMotionCurve;
	Parms.Param_bShouldIgnoreZAccumulate = Param_bShouldIgnoreZAccumulate;
	Parms.Param_bSetNewMovementMode = Param_bSetNewMovementMode;
	Parms.MovementMode = MovementMode;
	Parms.Param_bRestrictSpeedToExpected = Param_bRestrictSpeedToExpected;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinished = std::move(SetVelocityOnFinished);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerStartSet.GetTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraPlayerStartSet::GetTeamId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerStartSet", "GetTeamId");

	Params::LyraPlayerStartSet_GetTeamId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerStartSet.SetTeamId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerStartSet::SetTeamId(int32 Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerStartSet", "SetTeamId");

	Params::LyraPlayerStartSet_SetTeamId Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AbilityTask_SnapToTarget.ApplySnapToTargetTask
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_RootMotionPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param_TargetActor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Duration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      TargetLerpSpeedHorizontal                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      TargetLerpSpeedVertical                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_TargetRotationLerpSpeed                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bSetNewMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MoveFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bRestrictSpeedToExpected                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      LocationCurve                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      RotationCurve                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Param_TimeMappingCurve                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SetVelocityOnFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bDisableDestinationReachedInterrupt              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_SnapToTarget*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_SnapToTarget* UAbilityTask_SnapToTarget::ApplySnapToTargetTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, class AActor* Param_TargetActor, float Param_Duration, class UCurveFloat* TargetLerpSpeedHorizontal, class UCurveFloat* TargetLerpSpeedVertical, float Param_TargetRotationLerpSpeed, bool Param_bSetNewMovementMode, EMovementMode MovementMode, int32 MoveFlags, bool Param_bRestrictSpeedToExpected, class UCurveFloat* LocationCurve, class UCurveFloat* RotationCurve, class UCurveFloat* Param_TimeMappingCurve, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool Param_bDisableDestinationReachedInterrupt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_SnapToTarget", "ApplySnapToTargetTask");

	Params::AbilityTask_SnapToTarget_ApplySnapToTargetTask Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Param_RootMotionPriority = Param_RootMotionPriority;
	Parms.Param_TargetActor = Param_TargetActor;
	Parms.Param_Duration = Param_Duration;
	Parms.TargetLerpSpeedHorizontal = TargetLerpSpeedHorizontal;
	Parms.TargetLerpSpeedVertical = TargetLerpSpeedVertical;
	Parms.Param_TargetRotationLerpSpeed = Param_TargetRotationLerpSpeed;
	Parms.Param_bSetNewMovementMode = Param_bSetNewMovementMode;
	Parms.MovementMode = MovementMode;
	Parms.MoveFlags = MoveFlags;
	Parms.Param_bRestrictSpeedToExpected = Param_bRestrictSpeedToExpected;
	Parms.LocationCurve = LocationCurve;
	Parms.RotationCurve = RotationCurve;
	Parms.Param_TimeMappingCurve = Param_TimeMappingCurve;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinish = std::move(SetVelocityOnFinish);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;
	Parms.Param_bDisableDestinationReachedInterrupt = Param_bDisableDestinationReachedInterrupt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AbilityTask_SnapToTarget.OnRep_TargetLocation
// (Final, Native, Protected)

void UAbilityTask_SnapToTarget::OnRep_TargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_SnapToTarget", "OnRep_TargetLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AbilityTask_SnapToTarget.OnRep_TargetRotation
// (Final, Native, Protected)

void UAbilityTask_SnapToTarget::OnRep_TargetRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_SnapToTarget", "OnRep_TargetRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfAbilityTask_ApplyConstantDynamicForce.ApplyConstantDynamicForce
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_RootMotionPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Param_WorldDirection                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Strength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Duration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bKeepActorForwardDirection                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bIsAdditive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Param_StrengthOverTime                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SetVelocityOnFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bEnableGravity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfAbilityTask_ApplyConstantDynamicForce*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAbilityTask_ApplyConstantDynamicForce* UTgfAbilityTask_ApplyConstantDynamicForce::ApplyConstantDynamicForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, const struct FVector& Param_WorldDirection, float Param_Strength, float Param_Duration, bool Param_bKeepActorForwardDirection, bool Param_bIsAdditive, class UCurveFloat* Param_StrengthOverTime, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool Param_bEnableGravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilityTask_ApplyConstantDynamicForce", "ApplyConstantDynamicForce");

	Params::TgfAbilityTask_ApplyConstantDynamicForce_ApplyConstantDynamicForce Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Param_RootMotionPriority = Param_RootMotionPriority;
	Parms.Param_WorldDirection = std::move(Param_WorldDirection);
	Parms.Param_Strength = Param_Strength;
	Parms.Param_Duration = Param_Duration;
	Parms.Param_bKeepActorForwardDirection = Param_bKeepActorForwardDirection;
	Parms.Param_bIsAdditive = Param_bIsAdditive;
	Parms.Param_StrengthOverTime = Param_StrengthOverTime;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinish = std::move(SetVelocityOnFinish);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;
	Parms.Param_bEnableGravity = Param_bEnableGravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfAbilityTask_TrackConstantForce.ApplyTrackConstantForce
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_RootMotionPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param_TargetActor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Strength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_Duration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTgfDashTrackingSettings         Param_TrackingSettings                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Param_bIsAdditive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Param_StrengthOverTime                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SetVelocityOnFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bEnableGravity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTgfAbilityTask_TrackConstantForce*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTgfAbilityTask_TrackConstantForce* UTgfAbilityTask_TrackConstantForce::ApplyTrackConstantForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, int32 Param_RootMotionPriority, class AActor* Param_TargetActor, float Param_Strength, float Param_Duration, const struct FTgfDashTrackingSettings& Param_TrackingSettings, bool Param_bIsAdditive, class UCurveFloat* Param_StrengthOverTime, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool Param_bEnableGravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TgfAbilityTask_TrackConstantForce", "ApplyTrackConstantForce");

	Params::TgfAbilityTask_TrackConstantForce_ApplyTrackConstantForce Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Param_RootMotionPriority = Param_RootMotionPriority;
	Parms.Param_TargetActor = Param_TargetActor;
	Parms.Param_Strength = Param_Strength;
	Parms.Param_Duration = Param_Duration;
	Parms.Param_TrackingSettings = std::move(Param_TrackingSettings);
	Parms.Param_bIsAdditive = Param_bIsAdditive;
	Parms.Param_StrengthOverTime = Param_StrengthOverTime;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinish = std::move(SetVelocityOnFinish);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;
	Parms.Param_bEnableGravity = Param_bEnableGravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetActiveTagAnimSetIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FGameplayTag>             Tags                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraAnimInstance::GetActiveTagAnimSetIndex(const TArray<struct FGameplayTag>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetActiveTagAnimSetIndex");

	Params::LyraAnimInstance_GetActiveTagAnimSetIndex Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetCurrentWeaponVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          RightVec                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpVec                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ForwardVec                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAnimInstance::GetCurrentWeaponVector(struct FVector* RightVec, struct FVector* UpVec, struct FVector* ForwardVec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetCurrentWeaponVector");

	Params::LyraAnimInstance_GetCurrentWeaponVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RightVec != nullptr)
		*RightVec = std::move(Parms.RightVec);

	if (UpVec != nullptr)
		*UpVec = std::move(Parms.UpVec);

	if (ForwardVec != nullptr)
		*ForwardVec = std::move(Parms.ForwardVec);
}


// Function LyraGame.LyraAnimInstance.GetFootLand
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FFootLandHitInfo                 Right                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FFootLandHitInfo                 Left                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          BipHeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDis                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRelative                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraAnimInstance::GetFootLand(struct FFootLandHitInfo* Right, struct FFootLandHitInfo* Left, struct FVector* BipHeight, float MaxDis, bool bRelative, bool bDebug, float DebugRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetFootLand");

	Params::LyraAnimInstance_GetFootLand Parms{};

	Parms.MaxDis = MaxDis;
	Parms.bRelative = bRelative;
	Parms.bDebug = bDebug;
	Parms.DebugRadius = DebugRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Right != nullptr)
		*Right = std::move(Parms.Right);

	if (Left != nullptr)
		*Left = std::move(Parms.Left);

	if (BipHeight != nullptr)
		*BipHeight = std::move(Parms.BipHeight);

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetLeftHandSwordLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HandHelperRate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULyraAnimInstance::GetLeftHandSwordLocation(float Offset, float HandHelperRate, bool bDebug, float DebugRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetLeftHandSwordLocation");

	Params::LyraAnimInstance_GetLeftHandSwordLocation Parms{};

	Parms.Offset = Offset;
	Parms.HandHelperRate = HandHelperRate;
	Parms.bDebug = bDebug;
	Parms.DebugRadius = DebugRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetWeaponSocketLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               TemplateBase                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULyraAnimInstance::GetWeaponSocketLocation(class FName SocketName, TSubclassOf<class AActor> TemplateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetWeaponSocketLocation");

	Params::LyraAnimInstance_GetWeaponSocketLocation Parms{};

	Parms.SocketName = SocketName;
	Parms.TemplateBase = TemplateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetWeaponSocketTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               TemplateBase                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ULyraAnimInstance::GetWeaponSocketTransform(class FName SocketName, TSubclassOf<class AActor> TemplateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetWeaponSocketTransform");

	Params::LyraAnimInstance_GetWeaponSocketTransform Parms{};

	Parms.SocketName = SocketName;
	Parms.TemplateBase = TemplateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.Montage_GetModifyPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraPlayRateModifyKey                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraAnimInstance::Montage_GetModifyPlayRate(const class UAnimMontage* Montage, ELyraPlayRateModifyKey Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "Montage_GetModifyPlayRate");

	Params::LyraAnimInstance_Montage_GetModifyPlayRate Parms{};

	Parms.Montage = Montage;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.Montage_SetModifyPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELyraPlayRateModifyKey                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ModifyRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraAnimInstance::Montage_SetModifyPlayRate(const class UAnimMontage* Montage, ELyraPlayRateModifyKey Key, float ModifyRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "Montage_SetModifyPlayRate");

	Params::LyraAnimInstance_Montage_SetModifyPlayRate Parms{};

	Parms.Montage = Montage;
	Parms.Key = Key;
	Parms.ModifyRate = ModifyRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraAnimInstance.GetBone2BoneZOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             First                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Second                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraAnimInstance::GetBone2BoneZOffset(class FName First, class FName Second) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetBone2BoneZOffset");

	Params::LyraAnimInstance_GetBone2BoneZOffset Parms{};

	Parms.First = First;
	Parms.Second = Second;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetBoneComponentLocationZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraAnimInstance::GetBoneComponentLocationZ(class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetBoneComponentLocationZ");

	Params::LyraAnimInstance_GetBoneComponentLocationZ Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetBoneTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ULyraAnimInstance::GetBoneTransform(class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetBoneTransform");

	Params::LyraAnimInstance_GetBoneTransform Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetCurrentDeathAnimationLength
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraAnimInstance::GetCurrentDeathAnimationLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetCurrentDeathAnimationLength");

	Params::LyraAnimInstance_GetCurrentDeathAnimationLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraAnimInstance.GetDeathAnimationLength
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EAnimConfigDirection                    DeathDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraAnimInstance::GetDeathAnimationLength(EAnimConfigDirection DeathDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraAnimInstance", "GetDeathAnimationLength");

	Params::LyraAnimInstance_GetDeathAnimationLength Parms{};

	Parms.DeathDirection = DeathDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingValueDiscreteDynamic_AudioOutputDevice.DefaultDeviceChanged
// (Final, Native, Public)
// Parameters:
// EAudioDeviceChangedRole                 InRole                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::DefaultDeviceChanged(EAudioDeviceChangedRole InRole, const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "DefaultDeviceChanged");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_DefaultDeviceChanged Parms{};

	Parms.InRole = InRole;
	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingValueDiscreteDynamic_AudioOutputDevice.DeviceAddedOrRemoved
// (Final, Native, Public)
// Parameters:
// class FString                           DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::DeviceAddedOrRemoved(const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "DeviceAddedOrRemoved");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_DeviceAddedOrRemoved Parms{};

	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingValueDiscreteDynamic_AudioOutputDevice.OnAudioOutputDevicesObtained
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FAudioOutputDeviceInfo>   AvailableDevices                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::OnAudioOutputDevicesObtained(const TArray<struct FAudioOutputDeviceInfo>& AvailableDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "OnAudioOutputDevicesObtained");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_OnAudioOutputDevicesObtained Parms{};

	Parms.AvailableDevices = std::move(AvailableDevices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingValueDiscreteDynamic_AudioOutputDevice.OnCompletedDeviceSwap
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSwapAudioOutputResult           SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::OnCompletedDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "OnCompletedDeviceSwap");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_OnCompletedDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraBrightnessEditor.HandleBackClicked
// (Final, Native, Private)

void ULyraBrightnessEditor::HandleBackClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBrightnessEditor", "HandleBackClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraBrightnessEditor.HandleDoneClicked
// (Final, Native, Private)

void ULyraBrightnessEditor::HandleDoneClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBrightnessEditor", "HandleDoneClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCameraComponent.FindCameraComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraCameraComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraCameraComponent* ULyraCameraComponent::FindCameraComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraCameraComponent", "FindCameraComponent");

	Params::LyraCameraComponent_FindCameraComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCameraComponent.ChangeAspectRatio
// (Final, Native, Private)
// Parameters:
// uint32                                  ResX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ResY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCameraComponent::ChangeAspectRatio(uint32 ResX, uint32 ResY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCameraComponent", "ChangeAspectRatio");

	Params::LyraCameraComponent_ChangeAspectRatio Parms{};

	Parms.ResX = ResX;
	Parms.ResY = ResY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReplaySubsystem.DoesPlatformSupportReplays
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraReplaySubsystem::DoesPlatformSupportReplays()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraReplaySubsystem", "DoesPlatformSupportReplays");

	Params::LyraReplaySubsystem_DoesPlatformSupportReplays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplaySubsystem.CleanupLocalReplays
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumReplaysToKeep                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraReplaySubsystem::CleanupLocalReplays(class ULocalPlayer* LocalPlayer, int32 NumReplaysToKeep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "CleanupLocalReplays");

	Params::LyraReplaySubsystem_CleanupLocalReplays Parms{};

	Parms.LocalPlayer = LocalPlayer;
	Parms.NumReplaysToKeep = NumReplaysToKeep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReplaySubsystem.PlayReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraReplayListEntry*             Replay                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraReplaySubsystem::PlayReplay(class ULyraReplayListEntry* Replay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "PlayReplay");

	Params::LyraReplaySubsystem_PlayReplay Parms{};

	Parms.Replay = Replay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReplaySubsystem.RecordClientReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraReplaySubsystem::RecordClientReplay(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "RecordClientReplay");

	Params::LyraReplaySubsystem_RecordClientReplay Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReplaySubsystem.RecordReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsClient                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraReplaySubsystem::RecordReplay(bool IsClient, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "RecordReplay");

	Params::LyraReplaySubsystem_RecordReplay Parms{};

	Parms.IsClient = IsClient;
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReplaySubsystem.SeekInActiveReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraReplaySubsystem::SeekInActiveReplay(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "SeekInActiveReplay");

	Params::LyraReplaySubsystem_SeekInActiveReplay Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraReplaySubsystem.GetReplayCurrentTime
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraReplaySubsystem::GetReplayCurrentTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "GetReplayCurrentTime");

	Params::LyraReplaySubsystem_GetReplayCurrentTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplaySubsystem.GetReplayLengthInSeconds
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraReplaySubsystem::GetReplayLengthInSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplaySubsystem", "GetReplayLengthInSeconds");

	Params::LyraReplaySubsystem_GetReplayLengthInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacterMovementComponent.BlendToTargetTurnAngle
// (Final, Native, Protected, BlueprintCallable)

void ULyraCharacterMovementComponent::BlendToTargetTurnAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "BlendToTargetTurnAngle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.EndPantherState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCharacterMovementComponent::EndPantherState(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "EndPantherState");

	Params::LyraCharacterMovementComponent_EndPantherState Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.GetGroundInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FLyraCharacterGroundInfo   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FLyraCharacterGroundInfo ULyraCharacterMovementComponent::GetGroundInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "GetGroundInfo");

	Params::LyraCharacterMovementComponent_GetGroundInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCharacterMovementComponent.InitializeWithAbilitySystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCharacterMovementComponent::InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "InitializeWithAbilitySystem");

	Params::LyraCharacterMovementComponent_InitializeWithAbilitySystem Parms{};

	Parms.InASC = InASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.PreventTurnAngle
// (Final, Native, Protected, BlueprintCallable)

void ULyraCharacterMovementComponent::PreventTurnAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "PreventTurnAngle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.ResetSimulateTurnToDefault
// (Final, Native, Public, BlueprintCallable)

void ULyraCharacterMovementComponent::ResetSimulateTurnToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "ResetSimulateTurnToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.SetCanWalkOffLedges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCharacterMovementComponent::SetCanWalkOffLedges(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "SetCanWalkOffLedges");

	Params::LyraCharacterMovementComponent_SetCanWalkOffLedges Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.SetUseLooseServerDistCheck
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCharacterMovementComponent::SetUseLooseServerDistCheck(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "SetUseLooseServerDistCheck");

	Params::LyraCharacterMovementComponent_SetUseLooseServerDistCheck Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.StartPantherState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCharacterMovementComponent::StartPantherState(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "StartPantherState");

	Params::LyraCharacterMovementComponent_StartPantherState Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.ToggleSimulateTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCharacterMovementComponent::ToggleSimulateTurn(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "ToggleSimulateTurn");

	Params::LyraCharacterMovementComponent_ToggleSimulateTurn Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.UninitializeFromAbilitySystem
// (Final, Native, Public, BlueprintCallable)

void ULyraCharacterMovementComponent::UninitializeFromAbilitySystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "UninitializeFromAbilitySystem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCharacterMovementComponent.IsJumping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraCharacterMovementComponent::IsJumping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCharacterMovementComponent", "IsJumping");

	Params::LyraCharacterMovementComponent_IsJumping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHealthComponent.FindHealthComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraHealthComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraHealthComponent* ULyraHealthComponent::FindHealthComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraHealthComponent", "FindHealthComponent");

	Params::LyraHealthComponent_FindHealthComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHealthComponent.InitializeWithAbilitySystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHealthComponent::InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "InitializeWithAbilitySystem");

	Params::LyraHealthComponent_InitializeWithAbilitySystem Parms{};

	Parms.InASC = InASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHealthComponent.OnRep_DeathState
// (Native, Protected)
// Parameters:
// ELyraDeathState                         OldDeathState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraHealthComponent::OnRep_DeathState(ELyraDeathState OldDeathState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "OnRep_DeathState");

	Params::LyraHealthComponent_OnRep_DeathState Parms{};

	Parms.OldDeathState = OldDeathState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHealthComponent.UninitializeFromAbilitySystem
// (Final, Native, Public, BlueprintCallable)

void ULyraHealthComponent::UninitializeFromAbilitySystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "UninitializeFromAbilitySystem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraHealthComponent.GetDeathState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraDeathState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraDeathState ULyraHealthComponent::GetDeathState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "GetDeathState");

	Params::LyraHealthComponent_GetDeathState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHealthComponent.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraHealthComponent::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "GetHealth");

	Params::LyraHealthComponent_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHealthComponent.GetHealthNormalized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraHealthComponent::GetHealthNormalized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "GetHealthNormalized");

	Params::LyraHealthComponent_GetHealthNormalized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHealthComponent.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraHealthComponent::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "GetMaxHealth");

	Params::LyraHealthComponent_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraHealthComponent.IsDeadOrDying
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraHealthComponent::IsDeadOrDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraHealthComponent", "IsDeadOrDying");

	Params::LyraHealthComponent_IsDeadOrDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawn.OnControllerChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPawn::OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawn", "OnControllerChangedTeam");

	Params::LyraPawn_OnControllerChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawn.OnRep_MyTeamID
// (Final, Native, Private)
// Parameters:
// struct FGenericTeamId                   OldTeamID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPawn::OnRep_MyTeamID(const struct FGenericTeamId& OldTeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawn", "OnRep_MyTeamID");

	Params::LyraPawn_OnRep_MyTeamID Parms{};

	Parms.OldTeamID = std::move(OldTeamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnExtensionComponent.FindPawnExtensionComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraPawnExtensionComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraPawnExtensionComponent* ULyraPawnExtensionComponent::FindPawnExtensionComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraPawnExtensionComponent", "FindPawnExtensionComponent");

	Params::LyraPawnExtensionComponent_FindPawnExtensionComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnExtensionComponent.HandleAppearanceCaptureEvent
// (Final, Native, Public)
// Parameters:
// int64                                   RoleID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SlateBrush                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraPawnExtensionComponent::HandleAppearanceCaptureEvent(int64 RoleID, class UObject* SlateBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnExtensionComponent", "HandleAppearanceCaptureEvent");

	Params::LyraPawnExtensionComponent_HandleAppearanceCaptureEvent Parms{};

	Parms.RoleID = RoleID;
	Parms.SlateBrush = SlateBrush;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnExtensionComponent.HandleSettingScreenDestruct
// (Final, Native, Public)
// Parameters:
// class UObject*                          Args                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraPawnExtensionComponent::HandleSettingScreenDestruct(class UObject* Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnExtensionComponent", "HandleSettingScreenDestruct");

	Params::LyraPawnExtensionComponent_HandleSettingScreenDestruct Parms{};

	Parms.Args = Args;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnExtensionComponent.OnRep_PawnData
// (Final, Native, Protected)

void ULyraPawnExtensionComponent::OnRep_PawnData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnExtensionComponent", "OnRep_PawnData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnExtensionComponent.GetLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ULyraPawnExtensionComponent::GetLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnExtensionComponent", "GetLyraAbilitySystemComponent");

	Params::LyraPawnExtensionComponent_GetLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBattleSecurityComponent.CheckActiveEffectBlocking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfGameplayEffect*               GameplayEffect                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBattleSecurityComponent::CheckActiveEffectBlocking(const class UTgfGameplayEffect* GameplayEffect, class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBattleSecurityComponent", "CheckActiveEffectBlocking");

	Params::TgfBattleSecurityComponent_CheckActiveEffectBlocking Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBattleSecurityComponent.CheckActiveSkillBlocking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraGameplayAbility*             GameplayAbility                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfBattleSecurityComponent::CheckActiveSkillBlocking(const class ULyraGameplayAbility* GameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBattleSecurityComponent", "CheckActiveSkillBlocking");

	Params::TgfBattleSecurityComponent_CheckActiveSkillBlocking Parms{};

	Parms.GameplayAbility = GameplayAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfBattleSecurityComponent.InitializeWithAbilitySystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraAbilitySystemComponent*      InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBattleSecurityComponent::InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBattleSecurityComponent", "InitializeWithAbilitySystem");

	Params::TgfBattleSecurityComponent_InitializeWithAbilitySystem Parms{};

	Parms.InASC = InASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBattleSecurityComponent.UpdateActiveEffectCD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTgfGameplayEffect*               GameplayEffect                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALyraCharacter*                   Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBattleSecurityComponent::UpdateActiveEffectCD(class UTgfGameplayEffect* GameplayEffect, class ALyraCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBattleSecurityComponent", "UpdateActiveEffectCD");

	Params::TgfBattleSecurityComponent_UpdateActiveEffectCD Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfBattleSecurityComponent.UpdateActiveSkillCD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraGameplayAbility*             GameplayAbility                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfBattleSecurityComponent::UpdateActiveSkillCD(class ULyraGameplayAbility* GameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfBattleSecurityComponent", "UpdateActiveSkillCD");

	Params::TgfBattleSecurityComponent_UpdateActiveSkillCD Parms{};

	Parms.GameplayAbility = GameplayAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCosmeticCheats.AddCharacterPart
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuppressNaturalParts                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCosmeticCheats::AddCharacterPart(const class FString& AssetName, bool bSuppressNaturalParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCosmeticCheats", "AddCharacterPart");

	Params::LyraCosmeticCheats_AddCharacterPart Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.bSuppressNaturalParts = bSuppressNaturalParts;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCosmeticCheats.AddCosmeticSplitPart
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCosmeticCheats::AddCosmeticSplitPart(const class FString& AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCosmeticCheats", "AddCosmeticSplitPart");

	Params::LyraCosmeticCheats_AddCosmeticSplitPart Parms{};

	Parms.AssetName = std::move(AssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCosmeticCheats.ClearCharacterPartOverrides
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)

void ULyraCosmeticCheats::ClearCharacterPartOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCosmeticCheats", "ClearCharacterPartOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCosmeticCheats.RemoveCosmeticSplitPart
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCosmeticCheats::RemoveCosmeticSplitPart(const class FString& AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCosmeticCheats", "RemoveCosmeticSplitPart");

	Params::LyraCosmeticCheats_RemoveCosmeticSplitPart Parms{};

	Parms.AssetName = std::move(AssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCosmeticCheats.ReplaceCharacterPart
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuppressNaturalParts                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCosmeticCheats::ReplaceCharacterPart(const class FString& AssetName, bool bSuppressNaturalParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCosmeticCheats", "ReplaceCharacterPart");

	Params::LyraCosmeticCheats_ReplaceCharacterPart Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.bSuppressNaturalParts = bSuppressNaturalParts;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.AddCharacterPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPart               NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLyraCharacterPartHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLyraCharacterPartHandle ULyraPawnComponent_CharacterParts::AddCharacterPart(const struct FLyraCharacterPart& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "AddCharacterPart");

	Params::LyraPawnComponent_CharacterParts_AddCharacterPart Parms{};

	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.AddCharacterPartViaPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPart               NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::AddCharacterPartViaPart(const struct FLyraCharacterPart& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "AddCharacterPartViaPart");

	Params::LyraPawnComponent_CharacterParts_AddCharacterPartViaPart Parms{};

	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.ForceUseThirdPersonMesh
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPartHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bThirdPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::ForceUseThirdPersonMesh(const struct FLyraCharacterPartHandle& Handle, bool bThirdPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "ForceUseThirdPersonMesh");

	Params::LyraPawnComponent_CharacterParts_ForceUseThirdPersonMesh Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bThirdPerson = bThirdPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.GetValidFirstCharacterPartActor
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULyraPawnComponent_CharacterParts::GetValidFirstCharacterPartActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "GetValidFirstCharacterPartActor");

	Params::LyraPawnComponent_CharacterParts_GetValidFirstCharacterPartActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.InitializeWithAbilitySystem
// (Event, Public, BlueprintEvent)
// Parameters:
// class ULyraAbilitySystemComponent*      InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::InitializeWithAbilitySystem(class ULyraAbilitySystemComponent* InASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "InitializeWithAbilitySystem");

	Params::LyraPawnComponent_CharacterParts_InitializeWithAbilitySystem Parms{};

	Parms.InASC = InASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraPawnComponent_CharacterParts.LinkDefaultAnimLayers
// (Final, Native, Public, BlueprintCallable)

void ULyraPawnComponent_CharacterParts::LinkDefaultAnimLayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "LinkDefaultAnimLayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.OnPawnForceUseThirdPersonMesh
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bThirdPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::OnPawnForceUseThirdPersonMesh(bool bThirdPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "OnPawnForceUseThirdPersonMesh");

	Params::LyraPawnComponent_CharacterParts_OnPawnForceUseThirdPersonMesh Parms{};

	Parms.bThirdPerson = bThirdPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.RemoveAllCharacterParts
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULyraPawnComponent_CharacterParts::RemoveAllCharacterParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "RemoveAllCharacterParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.RemoveCharacterPart
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPartHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::RemoveCharacterPart(const struct FLyraCharacterPartHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "RemoveCharacterPart");

	Params::LyraPawnComponent_CharacterParts_RemoveCharacterPart Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.RemoveCharacterPartMesh
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharaPart                           PartTypeToRemove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraPawnComponent_CharacterParts::RemoveCharacterPartMesh(ETgfCharaPart PartTypeToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "RemoveCharacterPartMesh");

	Params::LyraPawnComponent_CharacterParts_RemoveCharacterPartMesh Parms{};

	Parms.PartTypeToRemove = PartTypeToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.RemoveCharacterPartMeshForActorSpawn
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ETgfCharaPart                           PartTypeToRemove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraPawnComponent_CharacterParts::RemoveCharacterPartMeshForActorSpawn(ETgfCharaPart PartTypeToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "RemoveCharacterPartMeshForActorSpawn");

	Params::LyraPawnComponent_CharacterParts_RemoveCharacterPartMeshForActorSpawn Parms{};

	Parms.PartTypeToRemove = PartTypeToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.RemoveCharacterPartViaPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPart               NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::RemoveCharacterPartViaPart(const struct FLyraCharacterPart& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "RemoveCharacterPartViaPart");

	Params::LyraPawnComponent_CharacterParts_RemoveCharacterPartViaPart Parms{};

	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.ToggleCharacterPartMeshVisible
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPartHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraPawnComponent_CharacterParts::ToggleCharacterPartMeshVisible(const struct FLyraCharacterPartHandle& Handle, bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "ToggleCharacterPartMeshVisible");

	Params::LyraPawnComponent_CharacterParts_ToggleCharacterPartMeshVisible Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.UpdateCharacterAllPartMesh
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTgfCharaPartChangeConfig        NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraPawnComponent_CharacterParts::UpdateCharacterAllPartMesh(const struct FTgfCharaPartChangeConfig& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "UpdateCharacterAllPartMesh");

	Params::LyraPawnComponent_CharacterParts_UpdateCharacterAllPartMesh Parms{};

	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.UpdateCharacterAllPartMeshForActorSpawn
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfCharaPartSpawnActor          SpawnActorInfo                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraPawnComponent_CharacterParts::UpdateCharacterAllPartMeshForActorSpawn(const struct FTgfCharaPartSpawnActor& SpawnActorInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "UpdateCharacterAllPartMeshForActorSpawn");

	Params::LyraPawnComponent_CharacterParts_UpdateCharacterAllPartMeshForActorSpawn Parms{};

	Parms.SpawnActorInfo = std::move(SpawnActorInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.UpdateCharacterPart
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraCharacterPartHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTgfCharaPartChangeConfig        NewPart                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraPawnComponent_CharacterParts::UpdateCharacterPart(const struct FLyraCharacterPartHandle& Handle, const struct FTgfCharaPartChangeConfig& NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "UpdateCharacterPart");

	Params::LyraPawnComponent_CharacterParts_UpdateCharacterPart Parms{};

	Parms.Handle = std::move(Handle);
	Parms.NewPart = std::move(NewPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.GetCharacterPartActors
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ULyraPawnComponent_CharacterParts::GetCharacterPartActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "GetCharacterPartActors");

	Params::LyraPawnComponent_CharacterParts_GetCharacterPartActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.GetCombinedTags
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, Const)
// Parameters:
// struct FGameplayTag                     RequiredPrefix                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer ULyraPawnComponent_CharacterParts::GetCombinedTags(const struct FGameplayTag& RequiredPrefix) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "GetCombinedTags");

	Params::LyraPawnComponent_CharacterParts_GetCombinedTags Parms{};

	Parms.RequiredPrefix = std::move(RequiredPrefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPawnComponent_CharacterParts.GetCombinedTagsRealTime
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, Const)
// Parameters:
// struct FGameplayTag                     RequiredPrefix                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer ULyraPawnComponent_CharacterParts::GetCombinedTagsRealTime(const struct FGameplayTag& RequiredPrefix) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPawnComponent_CharacterParts", "GetCombinedTagsRealTime");

	Params::LyraPawnComponent_CharacterParts_GetCombinedTagsRealTime Parms{};

	Parms.RequiredPrefix = std::move(RequiredPrefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraBotCheats.AddAIPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   AddCnt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraBotCheats::AddAIPlayers(int32 AddCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBotCheats", "AddAIPlayers");

	Params::LyraBotCheats_AddAIPlayers Parms{};

	Parms.AddCnt = AddCnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraBotCheats.RemoveAIPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   RemoveCnt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraBotCheats::RemoveAIPlayers(int32 RemoveCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBotCheats", "RemoveAIPlayers");

	Params::LyraBotCheats_RemoveAIPlayers Parms{};

	Parms.RemoveCnt = RemoveCnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility_FromEquipment.GetAssociatedEquipment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraEquipmentInstance*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraEquipmentInstance* UTgfGameplayAbility_FromEquipment::GetAssociatedEquipment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_FromEquipment", "GetAssociatedEquipment");

	Params::TgfGameplayAbility_FromEquipment_GetAssociatedEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfGameplayAbility_FromEquipment.GetAssociatedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraInventoryItemInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraInventoryItemInstance* UTgfGameplayAbility_FromEquipment::GetAssociatedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_FromEquipment", "GetAssociatedItem");

	Params::TgfGameplayAbility_FromEquipment_GetAssociatedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraContextEffectsSubsystem.GetContextFromSurfaceType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Context                                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraContextEffectsSubsystem::GetContextFromSurfaceType(EPhysicalSurface PhysicalSurface, struct FGameplayTag* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsSubsystem", "GetContextFromSurfaceType");

	Params::LyraContextEffectsSubsystem_GetContextFromSurfaceType Parms{};

	Parms.PhysicalSurface = PhysicalSurface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);

	return Parms.ReturnValue;
}


// Function LyraGame.LyraContextEffectsSubsystem.LoadAndAddContextEffectsLibraries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>>ContextEffectsLibraries                                (Parm, UObjectWrapper, NativeAccessSpecifierPublic)

void ULyraContextEffectsSubsystem::LoadAndAddContextEffectsLibraries(class AActor* OwningActor, const TSet<TSoftObjectPtr<class ULyraContextEffectsLibrary>>& ContextEffectsLibraries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsSubsystem", "LoadAndAddContextEffectsLibraries");

	Params::LyraContextEffectsSubsystem_LoadAndAddContextEffectsLibraries Parms{};

	Parms.OwningActor = OwningActor;
	Parms.ContextEffectsLibraries = std::move(ContextEffectsLibraries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraContextEffectsSubsystem.SpawnContextEffects
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           SpawningActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPoint                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RotationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Effect                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Contexts                                               (Parm, NativeAccessSpecifierPublic)
// TArray<class UAudioComponent*>          AudioOut                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        NiagaraOut                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          VFXScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioPitch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraContextEffectsSubsystem::SpawnContextEffects(const class AActor* SpawningActor, class USceneComponent* AttachToComponent, const class FName AttachPoint, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const struct FGameplayTag& Effect, const struct FGameplayTagContainer& Contexts, TArray<class UAudioComponent*>* AudioOut, TArray<class UNiagaraComponent*>* NiagaraOut, const struct FVector& VFXScale, float AudioVolume, float AudioPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsSubsystem", "SpawnContextEffects");

	Params::LyraContextEffectsSubsystem_SpawnContextEffects Parms{};

	Parms.SpawningActor = SpawningActor;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPoint = AttachPoint;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.Effect = std::move(Effect);
	Parms.Contexts = std::move(Contexts);
	Parms.VFXScale = std::move(VFXScale);
	Parms.AudioVolume = AudioVolume;
	Parms.AudioPitch = AudioPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AudioOut != nullptr)
		*AudioOut = std::move(Parms.AudioOut);

	if (NiagaraOut != nullptr)
		*NiagaraOut = std::move(Parms.NiagaraOut);
}


// Function LyraGame.LyraContextEffectsSubsystem.UnloadAndRemoveContextEffectsLibraries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraContextEffectsSubsystem::UnloadAndRemoveContextEffectsLibraries(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraContextEffectsSubsystem", "UnloadAndRemoveContextEffectsLibraries");

	Params::LyraContextEffectsSubsystem_UnloadAndRemoveContextEffectsLibraries Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraBotCreationComponent.CheatAddBot
// (Final, Native, Public)
// Parameters:
// int32                                   AddBotCnt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraBotCreationComponent::CheatAddBot(int32 AddBotCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBotCreationComponent", "CheatAddBot");

	Params::LyraBotCreationComponent_CheatAddBot Parms{};

	Parms.AddBotCnt = AddBotCnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraBotCreationComponent.CheatRemoveBot
// (Final, Native, Public)
// Parameters:
// int32                                   RemoveBotCnt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraBotCreationComponent::CheatRemoveBot(int32 RemoveBotCnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBotCreationComponent", "CheatRemoveBot");

	Params::LyraBotCreationComponent_CheatRemoveBot Parms{};

	Parms.RemoveBotCnt = RemoveBotCnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraBotCreationComponent.MakeBotsAllDead
// (Final, Native, Public, BlueprintCallable)

void ULyraBotCreationComponent::MakeBotsAllDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBotCreationComponent", "MakeBotsAllDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraExperienceManagerComponent.OnRep_CurrentExperience
// (Final, Native, Private)

void ULyraExperienceManagerComponent::OnRep_CurrentExperience()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraExperienceManagerComponent", "OnRep_CurrentExperience");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.AddOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraGameState::AddOption(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "AddOption");

	Params::LyraGameState_AddOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.ClearAllDeadPlayers
// (Final, Native, Protected, BlueprintCallable)

void ALyraGameState::ClearAllDeadPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "ClearAllDeadPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.GetReplicatedWorldTimeSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALyraGameState::GetReplicatedWorldTimeSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "GetReplicatedWorldTimeSeconds");

	Params::LyraGameState_GetReplicatedWorldTimeSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.MulticastMessageToClients
// (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// struct FLyraVerbMessage                 Message                                                (ConstParm, Parm, NativeAccessSpecifierPublic)

void ALyraGameState::MulticastMessageToClients(const struct FLyraVerbMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "MulticastMessageToClients");

	Params::LyraGameState_MulticastMessageToClients Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.MulticastReliableMessageToClients
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// struct FLyraVerbMessage                 Message                                                (ConstParm, Parm, NativeAccessSpecifierPublic)

void ALyraGameState::MulticastReliableMessageToClients(const struct FLyraVerbMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "MulticastReliableMessageToClients");

	Params::LyraGameState_MulticastReliableMessageToClients Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.OnRep_BattleId
// (Final, Native, Protected)

void ALyraGameState::OnRep_BattleId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "OnRep_BattleId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.OnRep_MatchType
// (Final, Native, Public)

void ALyraGameState::OnRep_MatchType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "OnRep_MatchType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.OnRep_RecorderPlayerState
// (Final, Native, Protected)

void ALyraGameState::OnRep_RecorderPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "OnRep_RecorderPlayerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.RemoveOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraGameState::RemoveOption(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "RemoveOption");

	Params::LyraGameState_RemoveOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.SetMatchType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfMatchType                           NewMatchType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraGameState::SetMatchType(ETgfMatchType NewMatchType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "SetMatchType");

	Params::LyraGameState_SetMatchType Parms{};

	Parms.NewMatchType = NewMatchType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameState.GetLyraAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraAbilitySystemComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraAbilitySystemComponent* ALyraGameState::GetLyraAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "GetLyraAbilitySystemComponent");

	Params::LyraGameState_GetLyraAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.GetServerFPS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALyraGameState::GetServerFPS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "GetServerFPS");

	Params::LyraGameState_GetServerFPS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.HasAllOptions
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           IDs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameState::HasAllOptions(const TArray<int32>& IDs) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "HasAllOptions");

	Params::LyraGameState_HasAllOptions Parms{};

	Parms.IDs = std::move(IDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.HasAnyOption
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           IDs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameState::HasAnyOption(const TArray<int32>& IDs) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "HasAnyOption");

	Params::LyraGameState_HasAnyOption Parms{};

	Parms.IDs = std::move(IDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.HasOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameState::HasOption(int32 ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "HasOption");

	Params::LyraGameState_HasOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.IsHomelandMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameState::IsHomelandMatchType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "IsHomelandMatchType");

	Params::LyraGameState_IsHomelandMatchType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.IsPvpMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameState::IsPvpMatchType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "IsPvpMatchType");

	Params::LyraGameState_IsPvpMatchType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraGameState.IsPVPSingleMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraGameState::IsPVPSingleMatchType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameState", "IsPVPSingleMatchType");

	Params::LyraGameState_IsPVPSingleMatchType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraRuntimeOptions.GetRuntimeOptions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULyraRuntimeOptions*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraRuntimeOptions* ULyraRuntimeOptions::GetRuntimeOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraRuntimeOptions", "GetRuntimeOptions");

	Params::LyraRuntimeOptions_GetRuntimeOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInputConfig.FindAbilityInputActionForTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogNotFound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* ULyraInputConfig::FindAbilityInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInputConfig", "FindAbilityInputActionForTag");

	Params::LyraInputConfig_FindAbilityInputActionForTag Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bLogNotFound = bLogNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInputConfig.FindNativeInputActionForTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogNotFound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* ULyraInputConfig::FindNativeInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraInputConfig", "FindNativeInputActionForTag");

	Params::LyraInputConfig_FindNativeInputActionForTag Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bLogNotFound = bLogNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.MappableConfigPairHelper.RegisterPair
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMappableConfigPair              Pair                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMappableConfigPairHelper::RegisterPair(const struct FMappableConfigPair& Pair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MappableConfigPairHelper", "RegisterPair");

	Params::MappableConfigPairHelper_RegisterPair Parms{};

	Parms.Pair = std::move(Pair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.MappableConfigPairHelper.UnregisterPair
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMappableConfigPair              Pair                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMappableConfigPairHelper::UnregisterPair(const struct FMappableConfigPair& Pair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MappableConfigPairHelper", "UnregisterPair");

	Params::MappableConfigPairHelper_UnregisterPair Parms{};

	Parms.Pair = std::move(Pair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility_Interact.TriggerInteraction
// (Final, Native, Public, BlueprintCallable)

void UTgfGameplayAbility_Interact::TriggerInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Interact", "TriggerInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfGameplayAbility_Interact.UpdateInteractions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FInteractionOption>       InteractiveOptions                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTgfGameplayAbility_Interact::UpdateInteractions(const TArray<struct FInteractionOption>& InteractiveOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfGameplayAbility_Interact", "UpdateInteractions");

	Params::TgfGameplayAbility_Interact_UpdateInteractions Parms{};

	Parms.InteractiveOptions = std::move(InteractiveOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AbilityTask_GrantNearbyInteraction.GrantAbilitiesForNearbyInteractors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionScanRange                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionScanRate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_GrantNearbyInteraction*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(class UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_GrantNearbyInteraction", "GrantAbilitiesForNearbyInteractors");

	Params::AbilityTask_GrantNearbyInteraction_GrantAbilitiesForNearbyInteractors Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InteractionScanRange = InteractionScanRange;
	Parms.InteractionScanRate = InteractionScanRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.Pickupable.GetPickupInventory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInventoryPickup                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryPickup IPickupable::GetPickupInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pickupable", "GetPickupInventory");

	Params::Pickupable_GetPickupInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryFunctionLibrary.FindItemDefinitionFragment
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>ItemDef                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULyraInventoryItemFragment>FragmentClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULyraInventoryItemFragment* ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULyraInventoryItemFragment* ULyraInventoryFunctionLibrary::FindItemDefinitionFragment(TSubclassOf<class ULyraInventoryItemDefinition> ItemDef, TSubclassOf<class ULyraInventoryItemFragment> FragmentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraInventoryFunctionLibrary", "FindItemDefinitionFragment");

	Params::LyraInventoryFunctionLibrary_FindItemDefinitionFragment Parms{};

	Parms.ItemDef = ItemDef;
	Parms.FragmentClass = FragmentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraInventoryFunctionLibrary.IsTwoHandWeapon
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfEquipSubType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraInventoryFunctionLibrary::IsTwoHandWeapon(ETgfEquipSubType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraInventoryFunctionLibrary", "IsTwoHandWeapon");

	Params::LyraInventoryFunctionLibrary_IsTwoHandWeapon Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.AddAdditionalAmmoRecover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DeltaRecover                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryItemInstance::AddAdditionalAmmoRecover(int32 DeltaRecover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "AddAdditionalAmmoRecover");

	Params::TgfInventoryItemInstance_AddAdditionalAmmoRecover Parms{};

	Parms.DeltaRecover = DeltaRecover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.AddDeltaAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DeltaAmmo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryItemInstance::AddDeltaAmmo(int32 DeltaAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "AddDeltaAmmo");

	Params::TgfInventoryItemInstance_AddDeltaAmmo Parms{};

	Parms.DeltaAmmo = DeltaAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.AffixDisplayConfigAttached
// (Final, Native, Public)

void UTgfInventoryItemInstance::AffixDisplayConfigAttached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "AffixDisplayConfigAttached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.GetAffixDisplayConfig
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FAffixDisplayConfig>      Out                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      MainBasic                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      TopAffix                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      Gem                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FAffixDisplayConfig>      GearSet                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTgfInventoryItemInstance::GetAffixDisplayConfig(TArray<struct FAffixDisplayConfig>* Out, TArray<struct FAffixDisplayConfig>* MainBasic, TArray<struct FAffixDisplayConfig>* TopAffix, TArray<struct FAffixDisplayConfig>* Gem, TArray<struct FAffixDisplayConfig>* GearSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetAffixDisplayConfig");

	Params::TgfInventoryItemInstance_GetAffixDisplayConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);

	if (MainBasic != nullptr)
		*MainBasic = std::move(Parms.MainBasic);

	if (TopAffix != nullptr)
		*TopAffix = std::move(Parms.TopAffix);

	if (Gem != nullptr)
		*Gem = std::move(Parms.Gem);

	if (GearSet != nullptr)
		*GearSet = std::move(Parms.GearSet);
}


// Function LyraGame.TgfInventoryItemInstance.GetCorruptionId
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetCorruptionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetCorruptionId");

	Params::TgfInventoryItemInstance_GetCorruptionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetGearLevel
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetGearLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetGearLevel");

	Params::TgfInventoryItemInstance_GetGearLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetHeirloomOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTgfPlayerIDKey                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTgfPlayerIDKey UTgfInventoryItemInstance::GetHeirloomOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetHeirloomOwner");

	Params::TgfInventoryItemInstance_GetHeirloomOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FTgfPlayerIDKey>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTgfPlayerIDKey> UTgfInventoryItemInstance::GetOwnership()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetOwnership");

	Params::TgfInventoryItemInstance_GetOwnership Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetTypeId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetTypeId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetTypeId");

	Params::TgfInventoryItemInstance_GetTypeId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.IsAffixDisplayConfigAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemInstance::IsAffixDisplayConfigAttached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "IsAffixDisplayConfigAttached");

	Params::TgfInventoryItemInstance_IsAffixDisplayConfigAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.OnRep_AmmoCount
// (Final, Native, Protected)

void UTgfInventoryItemInstance::OnRep_AmmoCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "OnRep_AmmoCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.OnRep_DItemBuffer
// (Final, Native, Protected)

void UTgfInventoryItemInstance::OnRep_DItemBuffer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "OnRep_DItemBuffer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.OnRep_DurabilityChange
// (Final, Native, Protected)

void UTgfInventoryItemInstance::OnRep_DurabilityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "OnRep_DurabilityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.OnRep_TypeId
// (Final, Native, Protected)

void UTgfInventoryItemInstance::OnRep_TypeId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "OnRep_TypeId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.SetEquiped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryItemInstance::SetEquiped(bool bEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "SetEquiped");

	Params::TgfInventoryItemInstance_SetEquiped Parms{};

	Parms.bEquipped = bEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.SetHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHeld                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfInventoryItemInstance::SetHeld(bool bHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "SetHeld");

	Params::TgfInventoryItemInstance_SetHeld Parms{};

	Parms.bHeld = bHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfInventoryItemInstance.GetAmmoCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetAmmoCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetAmmoCount");

	Params::TgfInventoryItemInstance_GetAmmoCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetAutoAmmoRecover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetAutoAmmoRecover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetAutoAmmoRecover");

	Params::TgfInventoryItemInstance_GetAutoAmmoRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetBattleElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfBattleElement                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfBattleElement UTgfInventoryItemInstance::GetBattleElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetBattleElement");

	Params::TgfInventoryItemInstance_GetBattleElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetDurabilityPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetDurabilityPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetDurabilityPoint");

	Params::TgfInventoryItemInstance_GetDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetEquipAttrItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FTgfEquipAttrItem>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FTgfEquipAttrItem> UTgfInventoryItemInstance::GetEquipAttrItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetEquipAttrItems");

	Params::TgfInventoryItemInstance_GetEquipAttrItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetGemConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FItemGemConfig             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemGemConfig UTgfInventoryItemInstance::GetGemConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetGemConfig");

	Params::TgfInventoryItemInstance_GetGemConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetHoldAttrItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FTgfEquipAttrItem>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FTgfEquipAttrItem> UTgfInventoryItemInstance::GetHoldAttrItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetHoldAttrItems");

	Params::TgfInventoryItemInstance_GetHoldAttrItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetLoosePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetLoosePoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetLoosePoint");

	Params::TgfInventoryItemInstance_GetLoosePoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetMaxDurabilityPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetMaxDurabilityPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetMaxDurabilityPoint");

	Params::TgfInventoryItemInstance_GetMaxDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetRestrictLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetRestrictLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetRestrictLevel");

	Params::TgfInventoryItemInstance_GetRestrictLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetRoleGuid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UTgfInventoryItemInstance::GetRoleGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetRoleGuid");

	Params::TgfInventoryItemInstance_GetRoleGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.GetTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfInventoryItemInstance::GetTeamId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "GetTeamId");

	Params::TgfInventoryItemInstance_GetTeamId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.HasDurabilityPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemInstance::HasDurabilityPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "HasDurabilityPoint");

	Params::TgfInventoryItemInstance_HasDurabilityPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemInstance::IsEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "IsEquipped");

	Params::TgfInventoryItemInstance_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.IsHeld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemInstance::IsHeld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "IsHeld");

	Params::TgfInventoryItemInstance_IsHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfInventoryItemInstance.IsLockedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfInventoryItemInstance::IsLockedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfInventoryItemInstance", "IsLockedItem");

	Params::TgfInventoryItemInstance_IsLockedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraVerbMessageHelpers.CueParametersToVerbMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayCueParameters           Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLyraVerbMessage                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLyraVerbMessage ULyraVerbMessageHelpers::CueParametersToVerbMessage(const struct FGameplayCueParameters& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraVerbMessageHelpers", "CueParametersToVerbMessage");

	Params::LyraVerbMessageHelpers_CueParametersToVerbMessage Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraVerbMessageHelpers.GetPawnFromObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ULyraVerbMessageHelpers::GetPawnFromObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraVerbMessageHelpers", "GetPawnFromObject");

	Params::LyraVerbMessageHelpers_GetPawnFromObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraVerbMessageHelpers.GetPlayerControllerFromObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* ULyraVerbMessageHelpers::GetPlayerControllerFromObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraVerbMessageHelpers", "GetPlayerControllerFromObject");

	Params::LyraVerbMessageHelpers_GetPlayerControllerFromObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraVerbMessageHelpers.GetPlayerStateFromObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* ULyraVerbMessageHelpers::GetPlayerStateFromObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraVerbMessageHelpers", "GetPlayerStateFromObject");

	Params::LyraVerbMessageHelpers_GetPlayerStateFromObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraVerbMessageHelpers.VerbMessageToCueParameters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraVerbMessage                 Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayCueParameters ULyraVerbMessageHelpers::VerbMessageToCueParameters(const struct FLyraVerbMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraVerbMessageHelpers", "VerbMessageToCueParameters");

	Params::LyraVerbMessageHelpers_VerbMessageToCueParameters Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPerformanceStatSubsystem.GetCachedStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraDisplayablePerformanceStat         Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraPerformanceStatSubsystem::GetCachedStat(ELyraDisplayablePerformanceStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerformanceStatSubsystem", "GetCachedStat");

	Params::LyraPerformanceStatSubsystem_GetCachedStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraCheatManager.AddTagToSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::AddTagToSelf(const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "AddTagToSelf");

	Params::LyraCheatManager_AddTagToSelf Parms{};

	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.CancelActivatedAbilities
// (BlueprintAuthorityOnly, Exec, Native, Public)

void ULyraCheatManager::CancelActivatedAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "CancelActivatedAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.Cheat
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::Cheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "Cheat");

	Params::LyraCheatManager_Cheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.CheatAll
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::CheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "CheatAll");

	Params::LyraCheatManager_CheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.CycleAbilitySystemDebug
// (Exec, Native, Public)

void ULyraCheatManager::CycleAbilitySystemDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "CycleAbilitySystemDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.CycleDebugCameras
// (Exec, Native, Public)

void ULyraCheatManager::CycleDebugCameras()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "CycleDebugCameras");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.DamageSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::DamageSelf(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "DamageSelf");

	Params::LyraCheatManager_DamageSelf Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.DamageSelfDestruct
// (BlueprintAuthorityOnly, Exec, Native, Public)

void ULyraCheatManager::DamageSelfDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "DamageSelfDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.HealSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::HealSelf(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "HealSelf");

	Params::LyraCheatManager_HealSelf Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.HealTarget
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::HealTarget(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "HealTarget");

	Params::LyraCheatManager_HealTarget Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.PlayNextGame
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)

void ULyraCheatManager::PlayNextGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "PlayNextGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.RemoveTagFromSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::RemoveTagFromSelf(const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "RemoveTagFromSelf");

	Params::LyraCheatManager_RemoveTagFromSelf Parms{};

	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.SetInteractionOutlineWeight
// (Exec, Native, Public)
// Parameters:
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::SetInteractionOutlineWeight(float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "SetInteractionOutlineWeight");

	Params::LyraCheatManager_SetInteractionOutlineWeight Parms{};

	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.ToggleFixedCamera
// (Exec, Native, Public)

void ULyraCheatManager::ToggleFixedCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "ToggleFixedCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraCheatManager.UnlimitedHealth
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraCheatManager::UnlimitedHealth(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraCheatManager", "UnlimitedHealth");

	Params::LyraCheatManager_UnlimitedHealth Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerBotController.OnPlayerStateChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerBotController::OnPlayerStateChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerBotController", "OnPlayerStateChangedTeam");

	Params::LyraPlayerBotController_OnPlayerStateChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerBotController.UpdateTeamAttitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAIPerceptionComponent*           AIPerception                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraPlayerBotController::UpdateTeamAttitude(class UAIPerceptionComponent* AIPerception)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerBotController", "UpdateTeamAttitude");

	Params::LyraPlayerBotController_UpdateTeamAttitude Parms{};

	Parms.AIPerception = AIPerception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraPlayerStart.IsDeathPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerStart::IsDeathPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerStart", "IsDeathPoint");

	Params::LyraPlayerStart_IsDeathPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPlayerStart.IsWaitingPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraPlayerStart::IsWaitingPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlayerStart", "IsWaitingPoint");

	Params::LyraPlayerStart_IsWaitingPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_QueryReplays.QueryReplays
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_QueryReplays*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_QueryReplays* UAsyncAction_QueryReplays::QueryReplays(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_QueryReplays", "QueryReplays");

	Params::AsyncAction_QueryReplays_QueryReplays Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplayListEntry.GetDuration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan ULyraReplayListEntry::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplayListEntry", "GetDuration");

	Params::LyraReplayListEntry_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplayListEntry.GetFriendlyName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraReplayListEntry::GetFriendlyName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplayListEntry", "GetFriendlyName");

	Params::LyraReplayListEntry_GetFriendlyName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplayListEntry.GetIsLive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraReplayListEntry::GetIsLive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplayListEntry", "GetIsLive");

	Params::LyraReplayListEntry_GetIsLive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplayListEntry.GetNumViewers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraReplayListEntry::GetNumViewers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplayListEntry", "GetNumViewers");

	Params::LyraReplayListEntry_GetNumViewers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraReplayListEntry.GetTimestamp
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ULyraReplayListEntry::GetTimestamp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraReplayListEntry", "GetTimestamp");

	Params::LyraReplayListEntry_GetTimestamp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.ChangeBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InKeyBindSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             NewKey                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingKeyboardInput::ChangeBinding(int32 InKeyBindSlot, const struct FKey& NewKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "ChangeBinding");

	Params::LyraSettingKeyboardInput_ChangeBinding Parms{};

	Parms.InKeyBindSlot = InKeyBindSlot;
	Parms.NewKey = std::move(NewKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEnhancedActionKeyMapping        BaseMapping                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UPlayerMappableInputConfig*       InOwningConfig                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InKeyBindSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEnhancedActionKeyMapping        ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FEnhancedActionKeyMapping ULyraSettingKeyboardInput::SetData(const struct FEnhancedActionKeyMapping& BaseMapping, const class UPlayerMappableInputConfig* InOwningConfig, int32 InKeyBindSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "SetData");

	Params::LyraSettingKeyboardInput_SetData Parms{};

	Parms.BaseMapping = std::move(BaseMapping);
	Parms.InOwningConfig = InOwningConfig;
	Parms.InKeyBindSlot = InKeyBindSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.GetAllMappedActionsFromKey
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InKeyBindSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutActionNames                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULyraSettingKeyboardInput::GetAllMappedActionsFromKey(int32 InKeyBindSlot, const struct FKey& Key, TArray<class FName>* OutActionNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "GetAllMappedActionsFromKey");

	Params::LyraSettingKeyboardInput_GetAllMappedActionsFromKey Parms{};

	Parms.InKeyBindSlot = InKeyBindSlot;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActionNames != nullptr)
		*OutActionNames = std::move(Parms.OutActionNames);
}


// Function LyraGame.LyraSettingKeyboardInput.GetKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey ULyraSettingKeyboardInput::GetKey() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "GetKey");

	Params::LyraSettingKeyboardInput_GetKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.GetPrimaryKeyText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULyraSettingKeyboardInput::GetPrimaryKeyText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "GetPrimaryKeyText");

	Params::LyraSettingKeyboardInput_GetPrimaryKeyText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.GetSettingDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULyraSettingKeyboardInput::GetSettingDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "GetSettingDescription");

	Params::LyraSettingKeyboardInput_GetSettingDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.GetSettingDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULyraSettingKeyboardInput::GetSettingDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "GetSettingDisplayName");

	Params::LyraSettingKeyboardInput_GetSettingDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingKeyboardInput.GetSettingName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULyraSettingKeyboardInput::GetSettingName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingKeyboardInput", "GetSettingName");

	Params::LyraSettingKeyboardInput_GetSettingName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingValueDiscrete_Resolution.GetAppropriateDiscreteOptionIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingValueDiscrete_Resolution::GetAppropriateDiscreteOptionIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscrete_Resolution", "GetAppropriateDiscreteOptionIndex");

	Params::LyraSettingValueDiscrete_Resolution_GetAppropriateDiscreteOptionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingValueDiscrete_Resolution.GetAppropriateDiscreteOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> ULyraSettingValueDiscrete_Resolution::GetAppropriateDiscreteOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscrete_Resolution", "GetAppropriateDiscreteOptions");

	Params::LyraSettingValueDiscrete_Resolution_GetAppropriateDiscreteOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingValueDiscrete_Resolution.Initialize
// (Final, Native, Public, BlueprintCallable)

void ULyraSettingValueDiscrete_Resolution::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscrete_Resolution", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingValueDiscrete_Resolution.SetAppropriateDiscreteOptionByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscrete_Resolution::SetAppropriateDiscreteOptionByIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscrete_Resolution", "SetAppropriateDiscreteOptionByIndex");

	Params::LyraSettingValueDiscrete_Resolution_SetAppropriateDiscreteOptionByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.ApplyScalabilitySettings
// (Final, Native, Public, BlueprintCallable)

void ULyraSettingsLocal::ApplyScalabilitySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "ApplyScalabilitySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.BindDisplayMonitorChangedDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UUserWidget>       Window                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::BindDisplayMonitorChangedDelegate(TSoftObjectPtr<class UUserWidget> Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "BindDisplayMonitorChangedDelegate");

	Params::LyraSettingsLocal_BindDisplayMonitorChangedDelegate Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.BindVideoSettingModifiedDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UUserWidget>       Window                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::BindVideoSettingModifiedDelegate(TSoftObjectPtr<class UUserWidget> Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "BindVideoSettingModifiedDelegate");

	Params::LyraSettingsLocal_BindVideoSettingModifiedDelegate Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.GetFrameRateLimitIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetFrameRateLimitIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimitIndex");

	Params::LyraSettingsLocal_GetFrameRateLimitIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetResolutionOptionIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetResolutionOptionIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetResolutionOptionIndex");

	Params::LyraSettingsLocal_GetResolutionOptionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetResolutionOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> ULyraSettingsLocal::GetResolutionOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetResolutionOptions");

	Params::LyraSettingsLocal_GetResolutionOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSSModeOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> ULyraSettingsLocal::GetSSModeOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSSModeOptions");

	Params::LyraSettingsLocal_GetSSModeOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.InitVolume
// (Final, Native, Public)

void ULyraSettingsLocal::InitVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "InitVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.IsDisplayMonitorChanged
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsDisplayMonitorChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsDisplayMonitorChanged");

	Params::LyraSettingsLocal_IsDisplayMonitorChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.OnAllModuleLoaded
// (Final, Native, Public)

void ULyraSettingsLocal::OnAllModuleLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "OnAllModuleLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.OnFullScreenModeDirty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::OnFullScreenModeDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "OnFullScreenModeDirty");

	Params::LyraSettingsLocal_OnFullScreenModeDirty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.OnPostEngineInit
// (Final, Native, Public)

void ULyraSettingsLocal::OnPostEngineInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "OnPostEngineInit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.OnTGFActivateApp
// (Final, Native, Public)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::OnTGFActivateApp(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "OnTGFActivateApp");

	Params::LyraSettingsLocal_OnTGFActivateApp Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.OnViewportCreated
// (Final, Native, Public)

void ULyraSettingsLocal::OnViewportCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "OnViewportCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.ResetKeybindingsToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULyraLocalPlayer*                 LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::ResetKeybindingsToDefault(class ULyraLocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "ResetKeybindingsToDefault");

	Params::LyraSettingsLocal_ResetKeybindingsToDefault Parms{};

	Parms.LocalPlayer = LocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.ResetToDPDefaultSettings
// (Final, Native, Public, BlueprintCallable)

void ULyraSettingsLocal::ResetToDPDefaultSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "ResetToDPDefaultSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.RunAutoBenchmark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSaveImmediately                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::RunAutoBenchmark(bool bSaveImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "RunAutoBenchmark");

	Params::LyraSettingsLocal_RunAutoBenchmark Parms{};

	Parms.bSaveImmediately = bSaveImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.RunAutoBenchmarkIfNecessary
// (Final, Native, Public, BlueprintCallable)

void ULyraSettingsLocal::RunAutoBenchmarkIfNecessary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "RunAutoBenchmarkIfNecessary");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetAntiAliasingQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetAntiAliasingQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetAntiAliasingQualityByIndex");

	Params::LyraSettingsLocal_SetAntiAliasingQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetAudioOutputDeviceId
// (Final, Native, Public)
// Parameters:
// class FString                           InAudioOutputDeviceId                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetAudioOutputDeviceId(const class FString& InAudioOutputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetAudioOutputDeviceId");

	Params::LyraSettingsLocal_SetAudioOutputDeviceId Parms{};

	Parms.InAudioOutputDeviceId = std::move(InAudioOutputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetCameraShakesByMoving
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetCameraShakesByMoving(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetCameraShakesByMoving");

	Params::LyraSettingsLocal_SetCameraShakesByMoving Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetChatMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsAllOpen                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetChatMode(bool IsAllOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetChatMode");

	Params::LyraSettingsLocal_SetChatMode Parms{};

	Parms.IsAllOpen = IsAllOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetControllerPlatform
// (Final, Native, Public)
// Parameters:
// class FName                             InControllerPlatform                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetControllerPlatform(const class FName InControllerPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetControllerPlatform");

	Params::LyraSettingsLocal_SetControllerPlatform Parms{};

	Parms.InControllerPlatform = InControllerPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetDesiredDeviceProfileQualitySuffix
// (Final, Native, Public)
// Parameters:
// class FString                           InDesiredSuffix                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDesiredDeviceProfileQualitySuffix(const class FString& InDesiredSuffix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDesiredDeviceProfileQualitySuffix");

	Params::LyraSettingsLocal_SetDesiredDeviceProfileQualitySuffix Parms{};

	Parms.InDesiredSuffix = std::move(InDesiredSuffix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetDialogueVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDialogueVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDialogueVolume");

	Params::LyraSettingsLocal_SetDialogueVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetDisplayGamma
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InGamma                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDisplayGamma(float InGamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDisplayGamma");

	Params::LyraSettingsLocal_SetDisplayGamma Parms{};

	Parms.InGamma = InGamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetDLSSEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDLSSEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDLSSEnabled");

	Params::LyraSettingsLocal_SetDLSSEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFOV
// (Final, Native, Public)
// Parameters:
// float                                   InFOV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFOV(float InFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFOV");

	Params::LyraSettingsLocal_SetFOV Parms{};

	Parms.InFOV = InFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFrameRateLimit_Always
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_Always(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_Always");

	Params::LyraSettingsLocal_SetFrameRateLimit_Always Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFrameRateLimit_InMenu
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_InMenu(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_InMenu");

	Params::LyraSettingsLocal_SetFrameRateLimit_InMenu Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFrameRateLimit_OnBattery
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_OnBattery(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_OnBattery");

	Params::LyraSettingsLocal_SetFrameRateLimit_OnBattery Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFrameRateLimit_WhenBackgrounded
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_WhenBackgrounded(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_WhenBackgrounded");

	Params::LyraSettingsLocal_SetFrameRateLimit_WhenBackgrounded Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFrameRateLimitByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimitByIndex(const int32& InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimitByIndex");

	Params::LyraSettingsLocal_SetFrameRateLimitByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetFSREnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFSREnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFSREnabled");

	Params::LyraSettingsLocal_SetFSREnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetGlobalIlluminationQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetGlobalIlluminationQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetGlobalIlluminationQualityByIndex");

	Params::LyraSettingsLocal_SetGlobalIlluminationQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetHDRAudioModeEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetHDRAudioModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetHDRAudioModeEnabled");

	Params::LyraSettingsLocal_SetHDRAudioModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetHeadphoneModeEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetHeadphoneModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetHeadphoneModeEnabled");

	Params::LyraSettingsLocal_SetHeadphoneModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetIsLiveMode
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetIsLiveMode(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetIsLiveMode");

	Params::LyraSettingsLocal_SetIsLiveMode Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetKilledScreenshotAutoDelete
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetKilledScreenshotAutoDelete(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetKilledScreenshotAutoDelete");

	Params::LyraSettingsLocal_SetKilledScreenshotAutoDelete Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetKilledScreenshotPath
// (Final, Native, Public)
// Parameters:
// class FString                           NewValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetKilledScreenshotPath(const class FString& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetKilledScreenshotPath");

	Params::LyraSettingsLocal_SetKilledScreenshotPath Parms{};

	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetKilledScreenshotStorageLimit
// (Final, Native, Public)
// Parameters:
// EStorageLimit                           NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetKilledScreenshotStorageLimit(EStorageLimit NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetKilledScreenshotStorageLimit");

	Params::LyraSettingsLocal_SetKilledScreenshotStorageLimit Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetMicrophoneVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetMicrophoneVolume");

	Params::LyraSettingsLocal_SetMicrophoneVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetMusicVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetMusicVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetMusicVolume");

	Params::LyraSettingsLocal_SetMusicVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetNumberOfReplaysToKeep
// (Final, Native, Public)
// Parameters:
// int32                                   InNumberOfReplays                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetNumberOfReplaysToKeep(int32 InNumberOfReplays)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetNumberOfReplaysToKeep");

	Params::LyraSettingsLocal_SetNumberOfReplaysToKeep Parms{};

	Parms.InNumberOfReplays = InNumberOfReplays;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetOverallVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetOverallVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetOverallVolume");

	Params::LyraSettingsLocal_SetOverallVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetPostProcessQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetPostProcessQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetPostProcessQualityByIndex");

	Params::LyraSettingsLocal_SetPostProcessQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetReflectionQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetReflectionQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetReflectionQualityByIndex");

	Params::LyraSettingsLocal_SetReflectionQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetSafeZone
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSafeZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSafeZone");

	Params::LyraSettingsLocal_SetSafeZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetSaveKillScreenshot
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSaveKillScreenshot(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSaveKillScreenshot");

	Params::LyraSettingsLocal_SetSaveKillScreenshot Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetShouldAutoRecordReplays
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetShouldAutoRecordReplays(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetShouldAutoRecordReplays");

	Params::LyraSettingsLocal_SetShouldAutoRecordReplays Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetSoundFXVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSoundFXVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSoundFXVolume");

	Params::LyraSettingsLocal_SetSoundFXVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetSpeakerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSpeakerVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSpeakerVolume");

	Params::LyraSettingsLocal_SetSpeakerVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetSSModeByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InEnumIndex                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSSModeByIndex(const int32& InEnumIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSSModeByIndex");

	Params::LyraSettingsLocal_SetSSModeByIndex Parms{};

	Parms.InEnumIndex = InEnumIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetSuperSamplingMode
// (Final, Native, Public, HasOutParams)
// Parameters:
// ETGFSSMode                              SSMode                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSuperSamplingMode(const ETGFSSMode& SSMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSuperSamplingMode");

	Params::LyraSettingsLocal_SetSuperSamplingMode Parms{};

	Parms.SSMode = SSMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetTextureQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetTextureQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetTextureQualityByIndex");

	Params::LyraSettingsLocal_SetTextureQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetTGFOverallScalabilityLevelByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetTGFOverallScalabilityLevelByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetTGFOverallScalabilityLevelByIndex");

	Params::LyraSettingsLocal_SetTGFOverallScalabilityLevelByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetTGFResolutionByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetTGFResolutionByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetTGFResolutionByIndex");

	Params::LyraSettingsLocal_SetTGFResolutionByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetTGFWindowModeByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Mode                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetTGFWindowModeByIndex(const int32& Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetTGFWindowModeByIndex");

	Params::LyraSettingsLocal_SetTGFWindowModeByIndex Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetViewDistanceQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetViewDistanceQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetViewDistanceQualityByIndex");

	Params::LyraSettingsLocal_SetViewDistanceQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetVisualEffectQualityByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetVisualEffectQualityByIndex(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetVisualEffectQualityByIndex");

	Params::LyraSettingsLocal_SetVisualEffectQualityByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetVoiceChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetVoiceChat(bool IsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetVoiceChat");

	Params::LyraSettingsLocal_SetVoiceChat Parms{};

	Parms.IsOn = IsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetVoiceChatVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetVoiceChatVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetVoiceChatVolume");

	Params::LyraSettingsLocal_SetVoiceChatVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SetXeSSEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetXeSSEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetXeSSEnabled");

	Params::LyraSettingsLocal_SetXeSSEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.SyncDisplayMonitorIndex
// (Final, Native, Public)

void ULyraSettingsLocal::SyncDisplayMonitorIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SyncDisplayMonitorIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.UnBindDisplayMonitorChangedDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UUserWidget>       Window                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::UnBindDisplayMonitorChangedDelegate(TSoftObjectPtr<class UUserWidget> Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "UnBindDisplayMonitorChangedDelegate");

	Params::LyraSettingsLocal_UnBindDisplayMonitorChangedDelegate Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.UnBindVideoSettingModifiedDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UUserWidget>       Window                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::UnBindVideoSettingModifiedDelegate(TSoftObjectPtr<class UUserWidget> Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "UnBindVideoSettingModifiedDelegate");

	Params::LyraSettingsLocal_UnBindVideoSettingModifiedDelegate Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsLocal.CanModifyHeadphoneModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::CanModifyHeadphoneModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "CanModifyHeadphoneModeEnabled");

	Params::LyraSettingsLocal_CanModifyHeadphoneModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.CanRunAutoBenchmark
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::CanRunAutoBenchmark() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "CanRunAutoBenchmark");

	Params::LyraSettingsLocal_CanRunAutoBenchmark Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetAllRegisteredInputConfigs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FLoadedMappableConfigPair>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FLoadedMappableConfigPair> ULyraSettingsLocal::GetAllRegisteredInputConfigs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetAllRegisteredInputConfigs");

	Params::LyraSettingsLocal_GetAllRegisteredInputConfigs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetAudioOutputDeviceId
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetAudioOutputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetAudioOutputDeviceId");

	Params::LyraSettingsLocal_GetAudioOutputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetCameraShakesByMoving
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetCameraShakesByMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetCameraShakesByMoving");

	Params::LyraSettingsLocal_GetCameraShakesByMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetChatMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetChatMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetChatMode");

	Params::LyraSettingsLocal_GetChatMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetControllerPlatform
// (Final, Native, Public, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULyraSettingsLocal::GetControllerPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetControllerPlatform");

	Params::LyraSettingsLocal_GetControllerPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetCustomPlayerInputConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, struct FKey>    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<class FName, struct FKey> ULyraSettingsLocal::GetCustomPlayerInputConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetCustomPlayerInputConfig");

	Params::LyraSettingsLocal_GetCustomPlayerInputConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetDefaultKilledScreenshotPath
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetDefaultKilledScreenshotPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDefaultKilledScreenshotPath");

	Params::LyraSettingsLocal_GetDefaultKilledScreenshotPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetDefaultSharpness
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetDefaultSharpness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDefaultSharpness");

	Params::LyraSettingsLocal_GetDefaultSharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetDesiredDeviceProfileQualitySuffix
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetDesiredDeviceProfileQualitySuffix() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDesiredDeviceProfileQualitySuffix");

	Params::LyraSettingsLocal_GetDesiredDeviceProfileQualitySuffix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetDialogueVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetDialogueVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDialogueVolume");

	Params::LyraSettingsLocal_GetDialogueVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetDisplayGamma
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetDisplayGamma() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDisplayGamma");

	Params::LyraSettingsLocal_GetDisplayGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetDLSSModeIndex
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetDLSSModeIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDLSSModeIndex");

	Params::LyraSettingsLocal_GetDLSSModeIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetFOV
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFOV");

	Params::LyraSettingsLocal_GetFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetFrameRateLimit_Always
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_Always() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_Always");

	Params::LyraSettingsLocal_GetFrameRateLimit_Always Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetFrameRateLimit_InMenu
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_InMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_InMenu");

	Params::LyraSettingsLocal_GetFrameRateLimit_InMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetFrameRateLimit_OnBattery
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_OnBattery() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_OnBattery");

	Params::LyraSettingsLocal_GetFrameRateLimit_OnBattery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetFrameRateLimit_WhenBackgrounded
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_WhenBackgrounded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_WhenBackgrounded");

	Params::LyraSettingsLocal_GetFrameRateLimit_WhenBackgrounded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetFrameRateLimitListText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> ULyraSettingsLocal::GetFrameRateLimitListText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimitListText");

	Params::LyraSettingsLocal_GetFrameRateLimitListText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetInputConfigByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ConfigName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPlayerMappableInputConfig* ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPlayerMappableInputConfig* ULyraSettingsLocal::GetInputConfigByName(class FName ConfigName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetInputConfigByName");

	Params::LyraSettingsLocal_GetInputConfigByName Parms{};

	Parms.ConfigName = ConfigName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetIsLiveMode
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetIsLiveMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetIsLiveMode");

	Params::LyraSettingsLocal_GetIsLiveMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetKilledScreenshotAutoDelete
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetKilledScreenshotAutoDelete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetKilledScreenshotAutoDelete");

	Params::LyraSettingsLocal_GetKilledScreenshotAutoDelete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetKilledScreenshotPath
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetKilledScreenshotPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetKilledScreenshotPath");

	Params::LyraSettingsLocal_GetKilledScreenshotPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetKilledScreenshotStorageLimit
// (Final, Native, Public, Const)
// Parameters:
// EStorageLimit                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStorageLimit ULyraSettingsLocal::GetKilledScreenshotStorageLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetKilledScreenshotStorageLimit");

	Params::LyraSettingsLocal_GetKilledScreenshotStorageLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetKilledScreenshotStorageLimitIndex
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetKilledScreenshotStorageLimitIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetKilledScreenshotStorageLimitIndex");

	Params::LyraSettingsLocal_GetKilledScreenshotStorageLimitIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetMaxResolutionScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetMaxResolutionScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMaxResolutionScale");

	Params::LyraSettingsLocal_GetMaxResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetMicrophoneVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMicrophoneVolume");

	Params::LyraSettingsLocal_GetMicrophoneVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetMinResolutionScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetMinResolutionScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMinResolutionScale");

	Params::LyraSettingsLocal_GetMinResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetMusicVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetMusicVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMusicVolume");

	Params::LyraSettingsLocal_GetMusicVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetNumberOfReplaysToKeep
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetNumberOfReplaysToKeep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetNumberOfReplaysToKeep");

	Params::LyraSettingsLocal_GetNumberOfReplaysToKeep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetOverallLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetOverallLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetOverallLevel");

	Params::LyraSettingsLocal_GetOverallLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetOverallVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetOverallVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetOverallVolume");

	Params::LyraSettingsLocal_GetOverallVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSafeZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetSafeZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSafeZone");

	Params::LyraSettingsLocal_GetSafeZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSaveKillScreenshot
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetSaveKillScreenshot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSaveKillScreenshot");

	Params::LyraSettingsLocal_GetSaveKillScreenshot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSoundFXVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetSoundFXVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSoundFXVolume");

	Params::LyraSettingsLocal_GetSoundFXVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSpeakerVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetSpeakerVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSpeakerVolume");

	Params::LyraSettingsLocal_GetSpeakerVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSuperSamplingMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETGFSSMode                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETGFSSMode ULyraSettingsLocal::GetSuperSamplingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSuperSamplingMode");

	Params::LyraSettingsLocal_GetSuperSamplingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetSystemResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint ULyraSettingsLocal::GetSystemResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSystemResolution");

	Params::LyraSettingsLocal_GetSystemResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetVoiceChat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetVoiceChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetVoiceChat");

	Params::LyraSettingsLocal_GetVoiceChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.GetVoiceChatVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetVoiceChatVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetVoiceChatVolume");

	Params::LyraSettingsLocal_GetVoiceChatVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.IsDLSSEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsDLSSEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsDLSSEnabled");

	Params::LyraSettingsLocal_IsDLSSEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.IsFSREnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsFSREnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsFSREnabled");

	Params::LyraSettingsLocal_IsFSREnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.IsHDRAudioModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsHDRAudioModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsHDRAudioModeEnabled");

	Params::LyraSettingsLocal_IsHDRAudioModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.IsHeadphoneModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsHeadphoneModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsHeadphoneModeEnabled");

	Params::LyraSettingsLocal_IsHeadphoneModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.IsSafeZoneSet
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsSafeZoneSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsSafeZoneSet");

	Params::LyraSettingsLocal_IsSafeZoneSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.IsXeSSEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsXeSSEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsXeSSEnabled");

	Params::LyraSettingsLocal_IsXeSSEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.ShouldAutoRecordReplays
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::ShouldAutoRecordReplays() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "ShouldAutoRecordReplays");

	Params::LyraSettingsLocal_ShouldAutoRecordReplays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsLocal.ShouldRunAutoBenchmarkAtStartup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::ShouldRunAutoBenchmarkAtStartup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "ShouldRunAutoBenchmarkAtStartup");

	Params::LyraSettingsLocal_ShouldRunAutoBenchmarkAtStartup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.SetAllowAudioInBackgroundSetting
// (Final, Native, Public)
// Parameters:
// ELyraAllowBackgroundAudioSetting        NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetAllowAudioInBackgroundSetting(ELyraAllowBackgroundAudioSetting NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetAllowAudioInBackgroundSetting");

	Params::LyraSettingsShared_SetAllowAudioInBackgroundSetting Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetAllowPrivateChat
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetAllowPrivateChat(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetAllowPrivateChat");

	Params::LyraSettingsShared_SetAllowPrivateChat Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetAllowTeamInvite
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetAllowTeamInvite(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetAllowTeamInvite");

	Params::LyraSettingsShared_SetAllowTeamInvite Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetChargeSkillMethod
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetChargeSkillMethod(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetChargeSkillMethod");

	Params::LyraSettingsShared_SetChargeSkillMethod Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetCheckedActivities
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<int32>                           Activities                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetCheckedActivities(const TArray<int32>& Activities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetCheckedActivities");

	Params::LyraSettingsShared_SetCheckedActivities Parms{};

	Parms.Activities = std::move(Activities);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetColorBlindMode
// (Final, Native, Public)
// Parameters:
// EColorBlindMode                         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetColorBlindMode(EColorBlindMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetColorBlindMode");

	Params::LyraSettingsShared_SetColorBlindMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetColorBlindStrength
// (Final, Native, Public)
// Parameters:
// int32                                   InColorBlindStrength                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetColorBlindStrength(int32 InColorBlindStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetColorBlindStrength");

	Params::LyraSettingsShared_SetColorBlindStrength Parms{};

	Parms.InColorBlindStrength = InColorBlindStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetDailyLoginCheck
// (Final, Native, Public)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetDailyLoginCheck(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetDailyLoginCheck");

	Params::LyraSettingsShared_SetDailyLoginCheck Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetForceFeedbackEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetForceFeedbackEnabled(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetForceFeedbackEnabled");

	Params::LyraSettingsShared_SetForceFeedbackEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetGamepadLookStickDeadZone
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetGamepadLookStickDeadZone(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetGamepadLookStickDeadZone");

	Params::LyraSettingsShared_SetGamepadLookStickDeadZone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetGamepadMoveStickDeadZone
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetGamepadMoveStickDeadZone(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetGamepadMoveStickDeadZone");

	Params::LyraSettingsShared_SetGamepadMoveStickDeadZone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetGamepadTargetingSensitivityPreset
// (Final, Native, Public)
// Parameters:
// ELyraGamepadSensitivity                 NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetGamepadTargetingSensitivityPreset(ELyraGamepadSensitivity NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetGamepadTargetingSensitivityPreset");

	Params::LyraSettingsShared_SetGamepadTargetingSensitivityPreset Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetInventoryAutoQuality
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<ETgfEquipQuality>                NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInventoryAutoQuality(const TArray<ETgfEquipQuality>& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInventoryAutoQuality");

	Params::LyraSettingsShared_SetInventoryAutoQuality Parms{};

	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetInventoryOpened
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<int64>                           NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInventoryOpened(const TArray<int64>& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInventoryOpened");

	Params::LyraSettingsShared_SetInventoryOpened Parms{};

	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetInventorySee
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInventorySee(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInventorySee");

	Params::LyraSettingsShared_SetInventorySee Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetInventoryTalentTips
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInventoryTalentTips(int32 Key, const TArray<int64>& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInventoryTalentTips");

	Params::LyraSettingsShared_SetInventoryTalentTips Parms{};

	Parms.Key = Key;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetInvertHorizontalAxis
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInvertHorizontalAxis(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInvertHorizontalAxis");

	Params::LyraSettingsShared_SetInvertHorizontalAxis Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetInvertVerticalAxis
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInvertVerticalAxis(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInvertVerticalAxis");

	Params::LyraSettingsShared_SetInvertVerticalAxis Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetLookSensitivityPreset
// (Final, Native, Public)
// Parameters:
// ELyraGamepadSensitivity                 NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetLookSensitivityPreset(ELyraGamepadSensitivity NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetLookSensitivityPreset");

	Params::LyraSettingsShared_SetLookSensitivityPreset Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetMithrilInventoryOpened
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<int64>                           NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetMithrilInventoryOpened(const TArray<int64>& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetMithrilInventoryOpened");

	Params::LyraSettingsShared_SetMithrilInventoryOpened Parms{};

	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetMoonInterationTime
// (Final, Native, Public)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetMoonInterationTime(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetMoonInterationTime");

	Params::LyraSettingsShared_SetMoonInterationTime Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetMouseSensitivityNonSmooth
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetMouseSensitivityNonSmooth(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetMouseSensitivityNonSmooth");

	Params::LyraSettingsShared_SetMouseSensitivityNonSmooth Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetMouseTargetingMethod
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetMouseTargetingMethod(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetMouseTargetingMethod");

	Params::LyraSettingsShared_SetMouseTargetingMethod Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetOpenOperationTips
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetOpenOperationTips(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetOpenOperationTips");

	Params::LyraSettingsShared_SetOpenOperationTips Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetPrivateRoomInvitePermission
// (Final, Native, Public)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetPrivateRoomInvitePermission(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetPrivateRoomInvitePermission");

	Params::LyraSettingsShared_SetPrivateRoomInvitePermission Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetProcessingTaskIds
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FString                           LocalUserKey                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           TaskIds                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetProcessingTaskIds(const class FString& LocalUserKey, const TArray<int32>& TaskIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetProcessingTaskIds");

	Params::LyraSettingsShared_SetProcessingTaskIds Parms{};

	Parms.LocalUserKey = std::move(LocalUserKey);
	Parms.TaskIds = std::move(TaskIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetShowAttributeRange
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetShowAttributeRange(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetShowAttributeRange");

	Params::LyraSettingsShared_SetShowAttributeRange Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetShowWeaponOperationTips
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetShowWeaponOperationTips(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetShowWeaponOperationTips");

	Params::LyraSettingsShared_SetShowWeaponOperationTips Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetSquatDownMethod
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetSquatDownMethod(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetSquatDownMethod");

	Params::LyraSettingsShared_SetSquatDownMethod Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetSubtitlesEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetSubtitlesEnabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetSubtitlesEnabled");

	Params::LyraSettingsShared_SetSubtitlesEnabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetTalents
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<int32>                           Talents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTalents(const TArray<int32>& Talents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTalents");

	Params::LyraSettingsShared_SetTalents Parms{};

	Parms.Talents = std::move(Talents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetTargetingMultiplierNonSmooth
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTargetingMultiplierNonSmooth(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTargetingMultiplierNonSmooth");

	Params::LyraSettingsShared_SetTargetingMultiplierNonSmooth Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetTriggerHapticsEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerHapticsEnabled(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerHapticsEnabled");

	Params::LyraSettingsShared_SetTriggerHapticsEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetTriggerHapticStartPosition
// (Final, Native, Public)
// Parameters:
// uint8                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerHapticStartPosition(const uint8 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerHapticStartPosition");

	Params::LyraSettingsShared_SetTriggerHapticStartPosition Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetTriggerHapticStrength
// (Final, Native, Public)
// Parameters:
// uint8                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerHapticStrength(const uint8 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerHapticStrength");

	Params::LyraSettingsShared_SetTriggerHapticStrength Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.SetTriggerPullUsesHapticThreshold
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerPullUsesHapticThreshold(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerPullUsesHapticThreshold");

	Params::LyraSettingsShared_SetTriggerPullUsesHapticThreshold Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSettingsShared.GetAllowAudioInBackgroundSetting
// (Final, Native, Public, Const)
// Parameters:
// ELyraAllowBackgroundAudioSetting        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraAllowBackgroundAudioSetting ULyraSettingsShared::GetAllowAudioInBackgroundSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetAllowAudioInBackgroundSetting");

	Params::LyraSettingsShared_GetAllowAudioInBackgroundSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetAllowPrivateChat
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetAllowPrivateChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetAllowPrivateChat");

	Params::LyraSettingsShared_GetAllowPrivateChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetAllowTeamInvite
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetAllowTeamInvite() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetAllowTeamInvite");

	Params::LyraSettingsShared_GetAllowTeamInvite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetAttributeTalents
// (Final, Native, Public, Const)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int32> ULyraSettingsShared::GetAttributeTalents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetAttributeTalents");

	Params::LyraSettingsShared_GetAttributeTalents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetChargeSkillMethod
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetChargeSkillMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetChargeSkillMethod");

	Params::LyraSettingsShared_GetChargeSkillMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetCheckedActivities
// (Final, Native, Public, Const)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int32> ULyraSettingsShared::GetCheckedActivities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetCheckedActivities");

	Params::LyraSettingsShared_GetCheckedActivities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetColorBlindMode
// (Final, Native, Public, Const)
// Parameters:
// EColorBlindMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorBlindMode ULyraSettingsShared::GetColorBlindMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetColorBlindMode");

	Params::LyraSettingsShared_GetColorBlindMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetColorBlindStrength
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsShared::GetColorBlindStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetColorBlindStrength");

	Params::LyraSettingsShared_GetColorBlindStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetDailyLoginCheck
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsShared::GetDailyLoginCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetDailyLoginCheck");

	Params::LyraSettingsShared_GetDailyLoginCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetForceFeedbackEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetForceFeedbackEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetForceFeedbackEnabled");

	Params::LyraSettingsShared_GetForceFeedbackEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetGamepadLookSensitivityPreset
// (Final, Native, Public, Const)
// Parameters:
// ELyraGamepadSensitivity                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraGamepadSensitivity ULyraSettingsShared::GetGamepadLookSensitivityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadLookSensitivityPreset");

	Params::LyraSettingsShared_GetGamepadLookSensitivityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetGamepadLookStickDeadZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsShared::GetGamepadLookStickDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadLookStickDeadZone");

	Params::LyraSettingsShared_GetGamepadLookStickDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetGamepadMoveStickDeadZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsShared::GetGamepadMoveStickDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadMoveStickDeadZone");

	Params::LyraSettingsShared_GetGamepadMoveStickDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetGamepadTargetingSensitivityPreset
// (Final, Native, Public, Const)
// Parameters:
// ELyraGamepadSensitivity                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraGamepadSensitivity ULyraSettingsShared::GetGamepadTargetingSensitivityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadTargetingSensitivityPreset");

	Params::LyraSettingsShared_GetGamepadTargetingSensitivityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetInventoryAutoQuality
// (Final, Native, Public, Const)
// Parameters:
// const TArray<ETgfEquipQuality>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<ETgfEquipQuality> ULyraSettingsShared::GetInventoryAutoQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInventoryAutoQuality");

	Params::LyraSettingsShared_GetInventoryAutoQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetInventoryOpened
// (Final, Native, Public, Const)
// Parameters:
// const TArray<int64>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int64> ULyraSettingsShared::GetInventoryOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInventoryOpened");

	Params::LyraSettingsShared_GetInventoryOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetInventorySee
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInventorySee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInventorySee");

	Params::LyraSettingsShared_GetInventorySee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetInventoryTalentTips
// (Final, Native, Public, Const)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int64>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int64> ULyraSettingsShared::GetInventoryTalentTips(int32 Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInventoryTalentTips");

	Params::LyraSettingsShared_GetInventoryTalentTips Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetInvertHorizontalAxis
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInvertHorizontalAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInvertHorizontalAxis");

	Params::LyraSettingsShared_GetInvertHorizontalAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetInvertVerticalAxis
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInvertVerticalAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInvertVerticalAxis");

	Params::LyraSettingsShared_GetInvertVerticalAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetMithrilInventoryOpened
// (Final, Native, Public, Const)
// Parameters:
// const TArray<int64>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int64> ULyraSettingsShared::GetMithrilInventoryOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetMithrilInventoryOpened");

	Params::LyraSettingsShared_GetMithrilInventoryOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetMoonInterationTime
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsShared::GetMoonInterationTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetMoonInterationTime");

	Params::LyraSettingsShared_GetMoonInterationTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetMouseSensitivityNonSmooth
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraSettingsShared::GetMouseSensitivityNonSmooth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetMouseSensitivityNonSmooth");

	Params::LyraSettingsShared_GetMouseSensitivityNonSmooth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetMouseTargetingMethod
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetMouseTargetingMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetMouseTargetingMethod");

	Params::LyraSettingsShared_GetMouseTargetingMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetOpenOperationTips
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetOpenOperationTips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetOpenOperationTips");

	Params::LyraSettingsShared_GetOpenOperationTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetPrivateRoomInvitePermission
// (Final, Native, Public, Const)
// Parameters:
// ESocialPermission                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESocialPermission ULyraSettingsShared::GetPrivateRoomInvitePermission() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetPrivateRoomInvitePermission");

	Params::LyraSettingsShared_GetPrivateRoomInvitePermission Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetPrivateRoomInvitePermissionIndex
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsShared::GetPrivateRoomInvitePermissionIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetPrivateRoomInvitePermissionIndex");

	Params::LyraSettingsShared_GetPrivateRoomInvitePermissionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetProcessingTaskIds
// (Final, Native, Public, Const)
// Parameters:
// class FString                           LocalUserKey                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> ULyraSettingsShared::GetProcessingTaskIds(const class FString& LocalUserKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetProcessingTaskIds");

	Params::LyraSettingsShared_GetProcessingTaskIds Parms{};

	Parms.LocalUserKey = std::move(LocalUserKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetShowAttributeRange
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetShowAttributeRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetShowAttributeRange");

	Params::LyraSettingsShared_GetShowAttributeRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetShowWeaponOperationTips
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetShowWeaponOperationTips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetShowWeaponOperationTips");

	Params::LyraSettingsShared_GetShowWeaponOperationTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetSquatDownMethod
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetSquatDownMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetSquatDownMethod");

	Params::LyraSettingsShared_GetSquatDownMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetSubtitlesEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetSubtitlesEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetSubtitlesEnabled");

	Params::LyraSettingsShared_GetSubtitlesEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetTargetingMultiplierNonSmooth
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraSettingsShared::GetTargetingMultiplierNonSmooth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTargetingMultiplierNonSmooth");

	Params::LyraSettingsShared_GetTargetingMultiplierNonSmooth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetTriggerHapticsEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetTriggerHapticsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerHapticsEnabled");

	Params::LyraSettingsShared_GetTriggerHapticsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetTriggerHapticStartPosition
// (Final, Native, Public, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ULyraSettingsShared::GetTriggerHapticStartPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerHapticStartPosition");

	Params::LyraSettingsShared_GetTriggerHapticStartPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetTriggerHapticStrength
// (Final, Native, Public, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ULyraSettingsShared::GetTriggerHapticStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerHapticStrength");

	Params::LyraSettingsShared_GetTriggerHapticStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSettingsShared.GetTriggerPullUsesHapticThreshold
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetTriggerPullUsesHapticThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerPullUsesHapticThreshold");

	Params::LyraSettingsShared_GetTriggerPullUsesHapticThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSafeZoneEditor.HandleBackClicked
// (Final, Native, Private)

void ULyraSafeZoneEditor::HandleBackClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSafeZoneEditor", "HandleBackClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSafeZoneEditor.HandleDoneClicked
// (Final, Native, Private)

void ULyraSafeZoneEditor::HandleDoneClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSafeZoneEditor", "HandleDoneClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.AddFloatStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorFloatStatisticType             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::AddFloatStat(ETgfActorFloatStatisticType Type, double Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "AddFloatStat");

	Params::TgfActorStatisticComponent_AddFloatStat Parms{};

	Parms.Type = Type;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.AddIntStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorIntStatisticType               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::AddIntStat(ETgfActorIntStatisticType Type, int32 TypeId, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "AddIntStat");

	Params::TgfActorStatisticComponent_AddIntStat Parms{};

	Parms.Type = Type;
	Parms.TypeId = TypeId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.AddRelationIntStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorRelationStatisticType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OpenID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::AddRelationIntStat(ETgfActorRelationStatisticType Type, const class FString& OpenID, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "AddRelationIntStat");

	Params::TgfActorStatisticComponent_AddRelationIntStat Parms{};

	Parms.Type = Type;
	Parms.OpenID = std::move(OpenID);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.FillOssLogPlayerInteraction
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class ALyraCharacter*                   SourceCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InHandleTargetName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InHandleLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::FillOssLogPlayerInteraction(class ALyraCharacter* SourceCharacter, const class FString& InHandleTargetName, const struct FVector& InHandleLocation, int32 ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "FillOssLogPlayerInteraction");

	Params::TgfActorStatisticComponent_FillOssLogPlayerInteraction Parms{};

	Parms.SourceCharacter = SourceCharacter;
	Parms.InHandleTargetName = std::move(InHandleTargetName);
	Parms.InHandleLocation = std::move(InHandleLocation);
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.GetFloatStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorFloatStatisticType             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UTgfActorStatisticComponent::GetFloatStat(ETgfActorFloatStatisticType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "GetFloatStat");

	Params::TgfActorStatisticComponent_GetFloatStat Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfActorStatisticComponent.GetIntStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorIntStatisticType               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfActorStatisticComponent::GetIntStat(ETgfActorIntStatisticType Type, int32 TypeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "GetIntStat");

	Params::TgfActorStatisticComponent_GetIntStat Parms{};

	Parms.Type = Type;
	Parms.TypeId = TypeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfActorStatisticComponent.GetRelationIntStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETgfActorRelationStatisticType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OpenID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfActorStatisticComponent::GetRelationIntStat(ETgfActorRelationStatisticType Type, const class FString& OpenID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "GetRelationIntStat");

	Params::TgfActorStatisticComponent_GetRelationIntStat Parms{};

	Parms.Type = Type;
	Parms.OpenID = std::move(OpenID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfActorStatisticComponent.RefreshStartTime
// (Final, Native, Public, BlueprintCallable)

void UTgfActorStatisticComponent::RefreshStartTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "RefreshStartTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.SetFloatStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorFloatStatisticType             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::SetFloatStat(ETgfActorFloatStatisticType Type, double Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "SetFloatStat");

	Params::TgfActorStatisticComponent_SetFloatStat Parms{};

	Parms.Type = Type;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.SetIntStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorIntStatisticType               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TypeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::SetIntStat(ETgfActorIntStatisticType Type, int32 TypeId, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "SetIntStat");

	Params::TgfActorStatisticComponent_SetIntStat Parms{};

	Parms.Type = Type;
	Parms.TypeId = TypeId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.SetRelationIntStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETgfActorRelationStatisticType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OpenID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTgfActorStatisticComponent::SetRelationIntStat(ETgfActorRelationStatisticType Type, const class FString& OpenID, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "SetRelationIntStat");

	Params::TgfActorStatisticComponent_SetRelationIntStat Parms{};

	Parms.Type = Type;
	Parms.OpenID = std::move(OpenID);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfActorStatisticComponent.UpdateAlivingTime
// (Final, Native, Public, BlueprintCallable)

void UTgfActorStatisticComponent::UpdateAlivingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfActorStatisticComponent", "UpdateAlivingTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraActorUtilities.SwitchOnNetMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBlueprintExposedNetMode                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlueprintExposedNetMode ULyraActorUtilities::SwitchOnNetMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraActorUtilities", "SwitchOnNetMode");

	Params::LyraActorUtilities_SwitchOnNetMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSystemStatics.FindComponentsByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> ULyraSystemStatics::FindComponentsByClass(class AActor* TargetActor, TSubclassOf<class UActorComponent> ComponentClass, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "FindComponentsByClass");

	Params::LyraSystemStatics_FindComponentsByClass Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ComponentClass = ComponentClass;
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSystemStatics.GetPrimaryAssetIdFromUserFacingExperienceName
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           AdvertisedExperienceID                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ULyraSystemStatics::GetPrimaryAssetIdFromUserFacingExperienceName(const class FString& AdvertisedExperienceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "GetPrimaryAssetIdFromUserFacingExperienceName");

	Params::LyraSystemStatics_GetPrimaryAssetIdFromUserFacingExperienceName Parms{};

	Parms.AdvertisedExperienceID = std::move(AdvertisedExperienceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSystemStatics.GetTypedSoftObjectReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ExpectedAssetType                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> ULyraSystemStatics::GetTypedSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId, TSubclassOf<class UObject> ExpectedAssetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "GetTypedSoftObjectReferenceFromPrimaryAssetId");

	Params::LyraSystemStatics_GetTypedSoftObjectReferenceFromPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);
	Parms.ExpectedAssetType = ExpectedAssetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraSystemStatics.PlayNextGame
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSystemStatics::PlayNextGame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "PlayNextGame");

	Params::LyraSystemStatics_PlayNextGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSystemStatics.SetColorParameterValueOnAllMeshComponents
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSystemStatics::SetColorParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const struct FLinearColor& ParameterValue, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "SetColorParameterValueOnAllMeshComponents");

	Params::LyraSystemStatics_SetColorParameterValueOnAllMeshComponents Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSystemStatics.SetScalarParameterValueOnAllMeshComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSystemStatics::SetScalarParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const float ParameterValue, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "SetScalarParameterValueOnAllMeshComponents");

	Params::LyraSystemStatics_SetScalarParameterValueOnAllMeshComponents Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraSystemStatics.SetVectorParameterValueOnAllMeshComponents
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSystemStatics::SetVectorParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const struct FVector& ParameterValue, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraSystemStatics", "SetVectorParameterValueOnAllMeshComponents");

	Params::LyraSystemStatics_SetVectorParameterValueOnAllMeshComponents Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.AsyncAction_ObserveTeam.ObserveTeam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_ObserveTeam*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_ObserveTeam* UAsyncAction_ObserveTeam::ObserveTeam(class UObject* TeamAgent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_ObserveTeam", "ObserveTeam");

	Params::AsyncAction_ObserveTeam_ObserveTeam Parms{};

	Parms.TeamAgent = TeamAgent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.AsyncAction_ObserveTeam.OnWatchedAgentChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_ObserveTeam::OnWatchedAgentChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_ObserveTeam", "OnWatchedAgentChangedTeam");

	Params::AsyncAction_ObserveTeam_OnWatchedAgentChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamCheats.CycleTeam
// (BlueprintAuthorityOnly, Exec, Native, Public)

void ULyraTeamCheats::CycleTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamCheats", "CycleTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamCheats.ListTeams
// (Exec, Native, Public)

void ULyraTeamCheats::ListTeams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamCheats", "ListTeams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamCheats.SetTeam
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamCheats::SetTeam(int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamCheats", "SetTeam");

	Params::LyraTeamCheats_SetTeam Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamDisplayAsset.ApplyToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamDisplayAsset::ApplyToActor(class AActor* TargetActor, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamDisplayAsset", "ApplyToActor");

	Params::LyraTeamDisplayAsset_ApplyToActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamDisplayAsset.ApplyToMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamDisplayAsset::ApplyToMaterial(class UMaterialInstanceDynamic* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamDisplayAsset", "ApplyToMaterial");

	Params::LyraTeamDisplayAsset_ApplyToMaterial Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamDisplayAsset.ApplyToMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamDisplayAsset::ApplyToMeshComponent(class UMeshComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamDisplayAsset", "ApplyToMeshComponent");

	Params::LyraTeamDisplayAsset_ApplyToMeshComponent Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamDisplayAsset.ApplyToNiagaraComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamDisplayAsset::ApplyToNiagaraComponent(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTeamDisplayAsset", "ApplyToNiagaraComponent");

	Params::LyraTeamDisplayAsset_ApplyToNiagaraComponent Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTeamStatics.FindTeamFromObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Agent                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPartOfTeam                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraTeamDisplayAsset*            DisplayAsset                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogIfNotSet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTeamStatics::FindTeamFromObject(const class UObject* Agent, bool* bIsPartOfTeam, int32* TeamId, class ULyraTeamDisplayAsset** DisplayAsset, bool bLogIfNotSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraTeamStatics", "FindTeamFromObject");

	Params::LyraTeamStatics_FindTeamFromObject Parms{};

	Parms.Agent = Agent;
	Parms.bLogIfNotSet = bLogIfNotSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsPartOfTeam != nullptr)
		*bIsPartOfTeam = Parms.bIsPartOfTeam;

	if (TeamId != nullptr)
		*TeamId = Parms.TeamId;

	if (DisplayAsset != nullptr)
		*DisplayAsset = Parms.DisplayAsset;
}


// Function LyraGame.LyraTeamStatics.GetTeamColorWithFallback
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULyraTeamDisplayAsset*            DisplayAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ULyraTeamStatics::GetTeamColorWithFallback(class ULyraTeamDisplayAsset* DisplayAsset, class FName ParameterName, const struct FLinearColor& DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraTeamStatics", "GetTeamColorWithFallback");

	Params::LyraTeamStatics_GetTeamColorWithFallback Parms{};

	Parms.DisplayAsset = DisplayAsset;
	Parms.ParameterName = ParameterName;
	Parms.DefaultValue = std::move(DefaultValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamStatics.GetTeamDisplayAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraTeamDisplayAsset*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraTeamDisplayAsset* ULyraTeamStatics::GetTeamDisplayAsset(const class UObject* WorldContextObject, int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraTeamStatics", "GetTeamDisplayAsset");

	Params::LyraTeamStatics_GetTeamDisplayAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamStatics.GetTeamScalarWithFallback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraTeamDisplayAsset*            DisplayAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraTeamStatics::GetTeamScalarWithFallback(class ULyraTeamDisplayAsset* DisplayAsset, class FName ParameterName, float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraTeamStatics", "GetTeamScalarWithFallback");

	Params::LyraTeamStatics_GetTeamScalarWithFallback Parms{};

	Parms.DisplayAsset = DisplayAsset;
	Parms.ParameterName = ParameterName;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTeamStatics.GetTeamTextureWithFallback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULyraTeamDisplayAsset*            DisplayAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         DefaultValue                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* ULyraTeamStatics::GetTeamTextureWithFallback(class ULyraTeamDisplayAsset* DisplayAsset, class FName ParameterName, class UTexture* DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraTeamStatics", "GetTeamTextureWithFallback");

	Params::LyraTeamStatics_GetTeamTextureWithFallback Parms{};

	Parms.DisplayAsset = DisplayAsset;
	Parms.ParameterName = ParameterName;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraTabButtonInterface.SetTabLabelInfo
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLyraTabDescriptor               TabDescriptor                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ILyraTabButtonInterface::SetTabLabelInfo(const struct FLyraTabDescriptor& TabDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabButtonInterface", "SetTabLabelInfo");

	Params::LyraTabButtonInterface_SetTabLabelInfo Parms{};

	Parms.TabDescriptor = std::move(TabDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWidgetFactory.FindWidgetClassForData
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UObject*                          Data                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> ULyraWidgetFactory::FindWidgetClassForData(const class UObject* Data) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWidgetFactory", "FindWidgetClassForData");

	Params::LyraWidgetFactory_FindWidgetClassForData Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraConfirmationScreen.HandleTapToCloseZoneMouseButtonDown
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply ULyraConfirmationScreen::HandleTapToCloseZoneMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraConfirmationScreen", "HandleTapToCloseZoneMouseButtonDown");

	Params::LyraConfirmationScreen_HandleTapToCloseZoneMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraLoadingScreenSubsystem.SetLoadingScreenContentWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UUserWidget>          NewWidgetClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraLoadingScreenSubsystem::SetLoadingScreenContentWidget(TSubclassOf<class UUserWidget> NewWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLoadingScreenSubsystem", "SetLoadingScreenContentWidget");

	Params::LyraLoadingScreenSubsystem_SetLoadingScreenContentWidget Parms{};

	Parms.NewWidgetClass = NewWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraLoadingScreenSubsystem.GetLoadingScreenContentWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> ULyraLoadingScreenSubsystem::GetLoadingScreenContentWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLoadingScreenSubsystem", "GetLoadingScreenContentWidget");

	Params::LyraLoadingScreenSubsystem_GetLoadingScreenContentWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraFrontendStateComponent.OnUserInitialized
// (Final, Native, Private)
// Parameters:
// class UCommonUserInfo*                  UserInfo                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Error                                                  (Parm, NativeAccessSpecifierPublic)
// ECommonUserPrivilege                    RequestedPrivilege                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonUserOnlineContext                OnlineContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraFrontendStateComponent::OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraFrontendStateComponent", "OnUserInitialized");

	Params::LyraFrontendStateComponent_OnUserInitialized Parms{};

	Parms.UserInfo = UserInfo;
	Parms.bSuccess = bSuccess;
	Parms.Error = std::move(Error);
	Parms.RequestedPrivilege = RequestedPrivilege;
	Parms.OnlineContext = OnlineContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetAutoRemoveWhenIndicatorComponentIsNull
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CanAutomaticallyRemove                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetAutoRemoveWhenIndicatorComponentIsNull(bool CanAutomaticallyRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetAutoRemoveWhenIndicatorComponentIsNull");

	Params::IndicatorDescriptor_SetAutoRemoveWhenIndicatorComponentIsNull Parms{};

	Parms.CanAutomaticallyRemove = CanAutomaticallyRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetBoundingBoxAnchor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InBoundingBoxAnchor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetBoundingBoxAnchor(const struct FVector& InBoundingBoxAnchor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetBoundingBoxAnchor");

	Params::IndicatorDescriptor_SetBoundingBoxAnchor Parms{};

	Parms.InBoundingBoxAnchor = std::move(InBoundingBoxAnchor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetClampToScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetClampToScreen(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetClampToScreen");

	Params::IndicatorDescriptor_SetClampToScreen Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetComponentSocketName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetComponentSocketName(class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetComponentSocketName");

	Params::IndicatorDescriptor_SetComponentSocketName Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetDataObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InDataObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetDataObject(class UObject* InDataObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetDataObject");

	Params::IndicatorDescriptor_SetDataObject Parms{};

	Parms.InDataObject = InDataObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetDesiredVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetDesiredVisibility(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetDesiredVisibility");

	Params::IndicatorDescriptor_SetDesiredVisibility Parms{};

	Parms.InVisible = InVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetHAlign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHAlignment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetHAlign(EHorizontalAlignment InHAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetHAlign");

	Params::IndicatorDescriptor_SetHAlign Parms{};

	Parms.InHAlignment = InHAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetIndicatorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             InIndicatorWidgetClass                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetIndicatorClass(TSoftClassPtr<class UClass> InIndicatorWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetIndicatorClass");

	Params::IndicatorDescriptor_SetIndicatorClass Parms{};

	Parms.InIndicatorWidgetClass = InIndicatorWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetPriority(int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetPriority");

	Params::IndicatorDescriptor_SetPriority Parms{};

	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetProjectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActorCanvasProjectionMode              InProjectionMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetProjectionMode(EActorCanvasProjectionMode InProjectionMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetProjectionMode");

	Params::IndicatorDescriptor_SetProjectionMode Parms{};

	Parms.InProjectionMode = InProjectionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetSceneComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetSceneComponent(class USceneComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetSceneComponent");

	Params::IndicatorDescriptor_SetSceneComponent Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetScreenSpaceOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetScreenSpaceOffset(const struct FVector2D& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetScreenSpaceOffset");

	Params::IndicatorDescriptor_SetScreenSpaceOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetShowClampToScreenArrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetShowClampToScreenArrow(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetShowClampToScreenArrow");

	Params::IndicatorDescriptor_SetShowClampToScreenArrow Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetVAlign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVAlignment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetVAlign(EVerticalAlignment InVAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetVAlign");

	Params::IndicatorDescriptor_SetVAlign Parms{};

	Parms.InVAlignment = InVAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.SetWorldPositionOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetWorldPositionOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetWorldPositionOffset");

	Params::IndicatorDescriptor_SetWorldPositionOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.UnregisterIndicator
// (Final, Native, Public, BlueprintCallable)

void UIndicatorDescriptor::UnregisterIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "UnregisterIndicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.IndicatorDescriptor.GetAutoRemoveWhenIndicatorComponentIsNull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetAutoRemoveWhenIndicatorComponentIsNull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetAutoRemoveWhenIndicatorComponentIsNull");

	Params::IndicatorDescriptor_GetAutoRemoveWhenIndicatorComponentIsNull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetBoundingBoxAnchor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIndicatorDescriptor::GetBoundingBoxAnchor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetBoundingBoxAnchor");

	Params::IndicatorDescriptor_GetBoundingBoxAnchor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetClampToScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetClampToScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetClampToScreen");

	Params::IndicatorDescriptor_GetClampToScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetComponentSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UIndicatorDescriptor::GetComponentSocketName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetComponentSocketName");

	Params::IndicatorDescriptor_GetComponentSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetDataObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UIndicatorDescriptor::GetDataObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetDataObject");

	Params::IndicatorDescriptor_GetDataObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetHAlign
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHorizontalAlignment                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHorizontalAlignment UIndicatorDescriptor::GetHAlign() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetHAlign");

	Params::IndicatorDescriptor_GetHAlign Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetIndicatorClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UIndicatorDescriptor::GetIndicatorClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetIndicatorClass");

	Params::IndicatorDescriptor_GetIndicatorClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetIsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetIsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetIsVisible");

	Params::IndicatorDescriptor_GetIsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndicatorDescriptor::GetPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetPriority");

	Params::IndicatorDescriptor_GetPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetProjectionMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActorCanvasProjectionMode              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActorCanvasProjectionMode UIndicatorDescriptor::GetProjectionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetProjectionMode");

	Params::IndicatorDescriptor_GetProjectionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetSceneComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UIndicatorDescriptor::GetSceneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetSceneComponent");

	Params::IndicatorDescriptor_GetSceneComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetScreenSpaceOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIndicatorDescriptor::GetScreenSpaceOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetScreenSpaceOffset");

	Params::IndicatorDescriptor_GetScreenSpaceOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetShowClampToScreenArrow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetShowClampToScreenArrow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetShowClampToScreenArrow");

	Params::IndicatorDescriptor_GetShowClampToScreenArrow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetVAlign
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVerticalAlignment                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVerticalAlignment UIndicatorDescriptor::GetVAlign() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetVAlign");

	Params::IndicatorDescriptor_GetVAlign Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorDescriptor.GetWorldPositionOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIndicatorDescriptor::GetWorldPositionOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetWorldPositionOffset");

	Params::IndicatorDescriptor_GetWorldPositionOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.IndicatorLibrary.GetIndicatorManagerComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraIndicatorManagerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraIndicatorManagerComponent* UIndicatorLibrary::GetIndicatorManagerComponent(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndicatorLibrary", "GetIndicatorManagerComponent");

	Params::IndicatorLibrary_GetIndicatorManagerComponent Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraJoystickWidget.UpdateSitckVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        MoveStickOffset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraJoystickWidget::UpdateSitckVector(const struct FVector2D& MoveStickOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraJoystickWidget", "UpdateSitckVector");

	Params::LyraJoystickWidget_UpdateSitckVector Parms{};

	Parms.MoveStickOffset = std::move(MoveStickOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraTouchRegion.ShouldSimulateInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTouchRegion::ShouldSimulateInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTouchRegion", "ShouldSimulateInput");

	Params::LyraTouchRegion_ShouldSimulateInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPerfStatWidgetBase.FetchStatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraPerfStatWidgetBase::FetchStatValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerfStatWidgetBase", "FetchStatValue");

	Params::LyraPerfStatWidgetBase_FetchStatValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraPerfStatWidgetBase.GetStatToDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraDisplayablePerformanceStat         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraDisplayablePerformanceStat ULyraPerfStatWidgetBase::GetStatToDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerfStatWidgetBase", "GetStatToDisplay");

	Params::LyraPerfStatWidgetBase_GetStatToDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponUserInterface.OnWeaponChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ULyraWeaponInstance*              OldWeapon                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraWeaponInstance*              NewWeapon                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraWeaponUserInterface::OnWeaponChanged(class ULyraWeaponInstance* OldWeapon, class ULyraWeaponInstance* NewWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponUserInterface", "OnWeaponChanged");

	Params::LyraWeaponUserInterface_OnWeaponChanged Parms{};

	Parms.OldWeapon = OldWeapon;
	Parms.NewWeapon = NewWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraGameplayAbility_RangedWeapon.OnRangedWeaponTargetDataReady
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraGameplayAbility_RangedWeapon::OnRangedWeaponTargetDataReady(const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_RangedWeapon", "OnRangedWeaponTargetDataReady");

	Params::LyraGameplayAbility_RangedWeapon_OnRangedWeaponTargetDataReady Parms{};

	Parms.TargetData = std::move(TargetData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LyraGame.LyraGameplayAbility_RangedWeapon.StartRangedWeaponTargeting
// (Final, Native, Protected, BlueprintCallable)

void ULyraGameplayAbility_RangedWeapon::StartRangedWeaponTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_RangedWeapon", "StartRangedWeaponTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraGameplayAbility_RangedWeapon.GetWeaponInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULyraRangedWeaponInstance*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraRangedWeaponInstance* ULyraGameplayAbility_RangedWeapon::GetWeaponInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraGameplayAbility_RangedWeapon", "GetWeaponInstance");

	Params::LyraGameplayAbility_RangedWeapon_GetWeaponInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponInstance.UpdateFiringTime
// (Final, Native, Public, BlueprintCallable)

void ULyraWeaponInstance::UpdateFiringTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponInstance", "UpdateFiringTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponInstance.GetTimeSinceLastInteractedWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraWeaponInstance::GetTimeSinceLastInteractedWith() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponInstance", "GetTimeSinceLastInteractedWith");

	Params::LyraWeaponInstance_GetTimeSinceLastInteractedWith Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponInstance.PickBestAnimLayer
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> ULyraWeaponInstance::PickBestAnimLayer(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponInstance", "PickBestAnimLayer");

	Params::LyraWeaponInstance_PickBestAnimLayer Parms{};

	Parms.bEquipped = bEquipped;
	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponInstance.PickBestEquipMontage
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULyraWeaponInstance::PickBestEquipMontage(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponInstance", "PickBestEquipMontage");

	Params::LyraWeaponInstance_PickBestEquipMontage Parms{};

	Parms.bEquipped = bEquipped;
	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponSpawner.GetDefaultStatFromItemDef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>WeaponItemClass                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     StatTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALyraWeaponSpawner::GetDefaultStatFromItemDef(const TSubclassOf<class ULyraInventoryItemDefinition> WeaponItemClass, const struct FGameplayTag& StatTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraWeaponSpawner", "GetDefaultStatFromItemDef");

	Params::LyraWeaponSpawner_GetDefaultStatFromItemDef Parms{};

	Parms.WeaponItemClass = WeaponItemClass;
	Parms.StatTag = std::move(StatTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponSpawner.AttemptPickUpWeapon
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALyraWeaponSpawner::AttemptPickUpWeapon(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "AttemptPickUpWeapon");

	Params::LyraWeaponSpawner_AttemptPickUpWeapon Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponSpawner.GiveWeapon
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class ULyraInventoryItemDefinition>WeaponItemClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReceivingPawn                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALyraWeaponSpawner::GiveWeapon(TSubclassOf<class ULyraInventoryItemDefinition> WeaponItemClass, class APawn* ReceivingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "GiveWeapon");

	Params::LyraWeaponSpawner_GiveWeapon Parms{};

	Parms.WeaponItemClass = WeaponItemClass;
	Parms.ReceivingPawn = ReceivingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LyraGame.LyraWeaponSpawner.OnCoolDownTimerComplete
// (Final, Native, Public)

void ALyraWeaponSpawner::OnCoolDownTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "OnCoolDownTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponSpawner.OnOverlapBegin
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALyraWeaponSpawner::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "OnOverlapBegin");

	Params::LyraWeaponSpawner_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepHitResult = std::move(SweepHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponSpawner.OnRep_WeaponAvailability
// (Final, Native, Public)

void ALyraWeaponSpawner::OnRep_WeaponAvailability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "OnRep_WeaponAvailability");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponSpawner.PlayPickupEffects
// (Native, Event, Public, BlueprintEvent)

void ALyraWeaponSpawner::PlayPickupEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "PlayPickupEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponSpawner.PlayRespawnEffects
// (Native, Event, Public, BlueprintEvent)

void ALyraWeaponSpawner::PlayRespawnEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "PlayRespawnEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.LyraWeaponSpawner.ResetCoolDown
// (Final, Native, Public, BlueprintCallable)

void ALyraWeaponSpawner::ResetCoolDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWeaponSpawner", "ResetCoolDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWeaponAnimInstance.K2_OnRedrawWeapon
// (Event, Protected, BlueprintEvent)

void UTgfWeaponAnimInstance::K2_OnRedrawWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponAnimInstance", "K2_OnRedrawWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LyraGame.TgfWeaponAnimInstance.PickBestWeaponInspectionAnimation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UTgfWeaponAnimInstance::PickBestWeaponInspectionAnimation(const struct FGameplayTagContainer& CosmeticTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponAnimInstance", "PickBestWeaponInspectionAnimation");

	Params::TgfWeaponAnimInstance_PickBestWeaponInspectionAnimation Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponAnimInstance.PickIdleAnimation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsRightIdle                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimSequenceBase*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimSequenceBase* UTgfWeaponAnimInstance::PickIdleAnimation(const struct FGameplayTagContainer& CosmeticTags, bool* bIsRightIdle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponAnimInstance", "PickIdleAnimation");

	Params::TgfWeaponAnimInstance_PickIdleAnimation Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsRightIdle != nullptr)
		*bIsRightIdle = Parms.bIsRightIdle;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponAnimInstance.PickBestAnimLayer
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UTgfWeaponAnimInstance::PickBestAnimLayer(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponAnimInstance", "PickBestAnimLayer");

	Params::TgfWeaponAnimInstance_PickBestAnimLayer Parms{};

	Parms.bEquipped = bEquipped;
	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponAnimInstance.PickBestEquipMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IsRight                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UTgfWeaponAnimInstance::PickBestEquipMontage(bool bEquipped, const struct FGameplayTagContainer& CosmeticTags, bool* IsRight) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponAnimInstance", "PickBestEquipMontage");

	Params::TgfWeaponAnimInstance_PickBestEquipMontage Parms{};

	Parms.bEquipped = bEquipped;
	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsRight != nullptr)
		*IsRight = Parms.IsRight;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponInstance.SetWeaponHeld
// (Final, Native, Public, BlueprintCallable)

void UTgfWeaponInstance::SetWeaponHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "SetWeaponHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWeaponInstance.SetWeaponUnHeld
// (Final, Native, Public, BlueprintCallable)

void UTgfWeaponInstance::SetWeaponUnHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "SetWeaponUnHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function LyraGame.TgfWeaponInstance.GetAmmoCanAdd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfWeaponInstance::GetAmmoCanAdd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "GetAmmoCanAdd");

	Params::TgfWeaponInstance_GetAmmoCanAdd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponInstance.GetLeftAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTgfWeaponInstance::GetLeftAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "GetLeftAmmo");

	Params::TgfWeaponInstance_GetLeftAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponInstance.GetSkillEquipType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfWeaponEquipType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfWeaponEquipType UTgfWeaponInstance::GetSkillEquipType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "GetSkillEquipType");

	Params::TgfWeaponInstance_GetSkillEquipType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponInstance.GetStencilDef
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETgfStencilRef                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETgfStencilRef UTgfWeaponInstance::GetStencilDef() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "GetStencilDef");

	Params::TgfWeaponInstance_GetStencilDef Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function LyraGame.TgfWeaponInstance.IsHeld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTgfWeaponInstance::IsHeld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TgfWeaponInstance", "IsHeld");

	Params::TgfWeaponInstance_IsHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

