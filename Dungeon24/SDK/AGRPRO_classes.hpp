#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AGRPRO

#include "Basic.hpp"

#include "AGRPRO_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Class AGRPRO.AGRAnimMasterComponent
// 0x00D8 (0x0180 - 0x00A8)
class UAGRAnimMasterComponent final : public UActorComponent
{
public:
	struct FGameplayTag                           BasePose;                                          // 0x00A8(0x0008)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OverlayPose;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBasePoseChanged;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlayPoseChanged;                              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimOffset;                                         // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AnimModTags;                                       // 0x0110(0x0020)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	EAGR_RotationMethod                           RotationMethod;                                    // 0x0130(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationSpeed;                                     // 0x0134(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnStartAngle;                                    // 0x0138(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnStopTolerance;                                 // 0x013C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAGR_AimOffsets                               AimOffsetType;                                     // 0x0140(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAGR_AimOffsetClamp                           AimOffsetBehavior;                                 // 0x0141(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimClamp;                                          // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CameraBased;                                       // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AimSocketName;                                     // 0x014C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtSocketName;                                  // 0x0154(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x015C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwningCharacter;                                   // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            OwnerMovementComponent;                            // 0x0168(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFirstPerson;                                     // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddTag(const struct FGameplayTag& InTag);
	void AimTick();
	void ChangeAimOffset(const EAGR_AimOffsets InAimOffsetType);
	void ChangeRotation(const EAGR_RotationMethod InRotationMethod);
	void NetMultiSetAimOffset(const struct FRotator& InAimOffset);
	void NetMultiSetLookAt(const struct FVector& LookAt);
	void OnRep_RotationMethod();
	void OnRep_RotationSpeed();
	bool RemoveTag(const struct FGameplayTag& InTag);
	void ServerChangeAimOffset(const EAGR_AimOffsets InAimOffsetType);
	void ServerChangeRotation(const EAGR_RotationMethod InRotationMethod);
	void ServerSetAimOffset(const struct FRotator& InAimOffset);
	void ServerSetBasePose(const struct FGameplayTag& InBasePose);
	void ServerSetLookAt(const struct FVector& LookAt);
	void ServerSetOverlayPose(const struct FGameplayTag& InOverlayPose);
	void ServerSetRotation(const EAGR_RotationMethod InRotationMethod, const float InRotationSpeed, const float InTurnStartAngle, const float InTurnStopTolerance);
	void ServerSetupAimOffset(const EAGR_AimOffsets InAimOffsetType, const EAGR_AimOffsetClamp InAimBehavior);
	void SetupAimOffset(const EAGR_AimOffsets InAimOffsetType, const EAGR_AimOffsetClamp InAimBehavior, const float InAimClamp, const bool InCameraBased, const class FName InAimSocketName, const class FName InLookAtSocketName);
	void SetupBasePose(const struct FGameplayTag& InBasePose);
	void SetupFpp(bool bInFirstPerson);
	void SetupOverlayPose(const struct FGameplayTag& InOverlayPose);
	void SetupRotation(const EAGR_RotationMethod InRotationMethod, const float InRotationSpeed, const float InTurnStartAngle, const float InTurnStopTolerance);
	void TurnInPlaceTick();

	void OnRep_BasePose(const struct FGameplayTag& OldValue) const;
	void OnRep_OverlayPose(const struct FGameplayTag& OldValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRAnimMasterComponent">();
	}
	static class UAGRAnimMasterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGRAnimMasterComponent>();
	}
};
static_assert(alignof(UAGRAnimMasterComponent) == 0x000008, "Wrong alignment on UAGRAnimMasterComponent");
static_assert(sizeof(UAGRAnimMasterComponent) == 0x000180, "Wrong size on UAGRAnimMasterComponent");
static_assert(offsetof(UAGRAnimMasterComponent, BasePose) == 0x0000A8, "Member 'UAGRAnimMasterComponent::BasePose' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, OverlayPose) == 0x0000B0, "Member 'UAGRAnimMasterComponent::OverlayPose' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, OnBasePoseChanged) == 0x0000B8, "Member 'UAGRAnimMasterComponent::OnBasePoseChanged' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, OnOverlayPoseChanged) == 0x0000C8, "Member 'UAGRAnimMasterComponent::OnOverlayPoseChanged' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, bFirstPerson) == 0x0000D8, "Member 'UAGRAnimMasterComponent::bFirstPerson' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, AimOffset) == 0x0000E0, "Member 'UAGRAnimMasterComponent::AimOffset' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, LookAtLocation) == 0x0000F8, "Member 'UAGRAnimMasterComponent::LookAtLocation' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, AnimModTags) == 0x000110, "Member 'UAGRAnimMasterComponent::AnimModTags' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, RotationMethod) == 0x000130, "Member 'UAGRAnimMasterComponent::RotationMethod' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, RotationSpeed) == 0x000134, "Member 'UAGRAnimMasterComponent::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, TurnStartAngle) == 0x000138, "Member 'UAGRAnimMasterComponent::TurnStartAngle' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, TurnStopTolerance) == 0x00013C, "Member 'UAGRAnimMasterComponent::TurnStopTolerance' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, AimOffsetType) == 0x000140, "Member 'UAGRAnimMasterComponent::AimOffsetType' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, AimOffsetBehavior) == 0x000141, "Member 'UAGRAnimMasterComponent::AimOffsetBehavior' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, AimClamp) == 0x000144, "Member 'UAGRAnimMasterComponent::AimClamp' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, CameraBased) == 0x000148, "Member 'UAGRAnimMasterComponent::CameraBased' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, AimSocketName) == 0x00014C, "Member 'UAGRAnimMasterComponent::AimSocketName' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, LookAtSocketName) == 0x000154, "Member 'UAGRAnimMasterComponent::LookAtSocketName' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, TraceChannel) == 0x00015C, "Member 'UAGRAnimMasterComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, OwningCharacter) == 0x000160, "Member 'UAGRAnimMasterComponent::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, OwnerMovementComponent) == 0x000168, "Member 'UAGRAnimMasterComponent::OwnerMovementComponent' has a wrong offset!");
static_assert(offsetof(UAGRAnimMasterComponent, OnFirstPerson) == 0x000170, "Member 'UAGRAnimMasterComponent::OnFirstPerson' has a wrong offset!");

// Class AGRPRO.AGRCharacter
// 0x0000 (0x0630 - 0x0630)
class AAGRCharacter final : public ACharacter
{
public:
	class UAGRAnimMasterComponent*                AGRAnimMasterComponent;                            // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRCharacter">();
	}
	static class AAGRCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAGRCharacter>();
	}
};
static_assert(alignof(AAGRCharacter) == 0x000010, "Wrong alignment on AAGRCharacter");
static_assert(sizeof(AAGRCharacter) == 0x000630, "Wrong size on AAGRCharacter");
static_assert(offsetof(AAGRCharacter, AGRAnimMasterComponent) == 0x000628, "Member 'AAGRCharacter::AGRAnimMasterComponent' has a wrong offset!");

// Class AGRPRO.AGRCoreAnimInstance
// 0x0130 (0x0480 - 0x0350)
class UAGRCoreAnimInstance final : public UAnimInstance
{
public:
	class ACharacter*                             OwningCharacter;                                   // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            OwnerMovementComponent;                            // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAGRAnimMasterComponent*                AnimMasterComponent;                               // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ModificationTags;                                  // 0x0360(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BasePose;                                          // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OverlayPose;                                       // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RawAimOffset;                                      // 0x0390(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAGR_AimOffsets                               AimOffsetType;                                     // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAGR_AimOffsetClamp                           AimOffsetBehavior;                                 // 0x03A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtLocation;                                    // 0x03B0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FinalAimOffset;                                    // 0x03C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimClamp;                                          // 0x03D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAGR_RotationMethod                           RotationMethod;                                    // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaTick;                                         // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PreviousRotation;                                  // 0x03E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreviousFrameAim;                                  // 0x0400(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardVelocity;                                   // 0x041C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeVelocity;                                    // 0x0420(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpVelocity;                                        // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InputAcceleration;                                 // 0x0430(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdle;                                             // 0x0449(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAir;                                            // 0x044A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStanding;                                         // 0x044B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwimming;                                         // 0x044C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouching;                                        // 0x044D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrounded;                                         // 0x044E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkingState;                                     // 0x044F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlying;                                           // 0x0450(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFalling;                                          // 0x0451(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x0452(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_453[0x1];                                      // 0x0453(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lean;                                              // 0x0454(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimDelta;                                          // 0x0458(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFrameRate;                                   // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanSmooth;                                        // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSmooth;                                         // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  PawnReference;                                     // 0x0478(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRCoreAnimInstance">();
	}
	static class UAGRCoreAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGRCoreAnimInstance>();
	}
};
static_assert(alignof(UAGRCoreAnimInstance) == 0x000010, "Wrong alignment on UAGRCoreAnimInstance");
static_assert(sizeof(UAGRCoreAnimInstance) == 0x000480, "Wrong size on UAGRCoreAnimInstance");
static_assert(offsetof(UAGRCoreAnimInstance, OwningCharacter) == 0x000348, "Member 'UAGRCoreAnimInstance::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, OwnerMovementComponent) == 0x000350, "Member 'UAGRCoreAnimInstance::OwnerMovementComponent' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AnimMasterComponent) == 0x000358, "Member 'UAGRCoreAnimInstance::AnimMasterComponent' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, ModificationTags) == 0x000360, "Member 'UAGRCoreAnimInstance::ModificationTags' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, BasePose) == 0x000380, "Member 'UAGRCoreAnimInstance::BasePose' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, OverlayPose) == 0x000388, "Member 'UAGRCoreAnimInstance::OverlayPose' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, RawAimOffset) == 0x000390, "Member 'UAGRCoreAnimInstance::RawAimOffset' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AimOffsetType) == 0x0003A8, "Member 'UAGRCoreAnimInstance::AimOffsetType' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AimOffsetBehavior) == 0x0003A9, "Member 'UAGRCoreAnimInstance::AimOffsetBehavior' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, LookAtLocation) == 0x0003B0, "Member 'UAGRCoreAnimInstance::LookAtLocation' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, FinalAimOffset) == 0x0003C8, "Member 'UAGRCoreAnimInstance::FinalAimOffset' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AimClamp) == 0x0003D8, "Member 'UAGRCoreAnimInstance::AimClamp' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AimPitch) == 0x0003DC, "Member 'UAGRCoreAnimInstance::AimPitch' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, RotationMethod) == 0x0003E0, "Member 'UAGRCoreAnimInstance::RotationMethod' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, DeltaTick) == 0x0003E4, "Member 'UAGRCoreAnimInstance::DeltaTick' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, PreviousRotation) == 0x0003E8, "Member 'UAGRCoreAnimInstance::PreviousRotation' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, PreviousFrameAim) == 0x000400, "Member 'UAGRCoreAnimInstance::PreviousFrameAim' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, Velocity) == 0x000418, "Member 'UAGRCoreAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, ForwardVelocity) == 0x00041C, "Member 'UAGRCoreAnimInstance::ForwardVelocity' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, StrafeVelocity) == 0x000420, "Member 'UAGRCoreAnimInstance::StrafeVelocity' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, UpVelocity) == 0x000424, "Member 'UAGRCoreAnimInstance::UpVelocity' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, Direction) == 0x000428, "Member 'UAGRCoreAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, InputAcceleration) == 0x000430, "Member 'UAGRCoreAnimInstance::InputAcceleration' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bFirstPerson) == 0x000448, "Member 'UAGRCoreAnimInstance::bFirstPerson' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bIdle) == 0x000449, "Member 'UAGRCoreAnimInstance::bIdle' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bInAir) == 0x00044A, "Member 'UAGRCoreAnimInstance::bInAir' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bStanding) == 0x00044B, "Member 'UAGRCoreAnimInstance::bStanding' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bSwimming) == 0x00044C, "Member 'UAGRCoreAnimInstance::bSwimming' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bCrouching) == 0x00044D, "Member 'UAGRCoreAnimInstance::bCrouching' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bGrounded) == 0x00044E, "Member 'UAGRCoreAnimInstance::bGrounded' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bWalkingState) == 0x00044F, "Member 'UAGRCoreAnimInstance::bWalkingState' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bFlying) == 0x000450, "Member 'UAGRCoreAnimInstance::bFlying' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, bFalling) == 0x000451, "Member 'UAGRCoreAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, MovementMode) == 0x000452, "Member 'UAGRCoreAnimInstance::MovementMode' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, Lean) == 0x000454, "Member 'UAGRCoreAnimInstance::Lean' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AimDelta) == 0x000458, "Member 'UAGRCoreAnimInstance::AimDelta' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, TargetFrameRate) == 0x000468, "Member 'UAGRCoreAnimInstance::TargetFrameRate' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, LeanSmooth) == 0x00046C, "Member 'UAGRCoreAnimInstance::LeanSmooth' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, AimSmooth) == 0x000470, "Member 'UAGRCoreAnimInstance::AimSmooth' has a wrong offset!");
static_assert(offsetof(UAGRCoreAnimInstance, PawnReference) == 0x000478, "Member 'UAGRCoreAnimInstance::PawnReference' has a wrong offset!");

// Class AGRPRO.AGRDebuggerController
// 0x0010 (0x0038 - 0x0028)
class UAGRDebuggerController final : public UObject
{
public:
	class UAGRUWDebugWidget*                      DebugWidget;                                       // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      CachedPlayerController;                            // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRDebuggerController">();
	}
	static class UAGRDebuggerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGRDebuggerController>();
	}
};
static_assert(alignof(UAGRDebuggerController) == 0x000008, "Wrong alignment on UAGRDebuggerController");
static_assert(sizeof(UAGRDebuggerController) == 0x000038, "Wrong size on UAGRDebuggerController");
static_assert(offsetof(UAGRDebuggerController, DebugWidget) == 0x000028, "Member 'UAGRDebuggerController::DebugWidget' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerController, CachedPlayerController) == 0x000030, "Member 'UAGRDebuggerController::CachedPlayerController' has a wrong offset!");

// Class AGRPRO.AGRDebuggerSettings
// 0x0140 (0x0168 - 0x0028)
class UAGRDebuggerSettings final : public UObject
{
public:
	struct FAGRDebuggerSettingsKey                ActivationKey;                                     // 0x0028(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryAnimState;                                 // 0x0048(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryAimOffset;                                 // 0x0068(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryRotation;                                  // 0x0088(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryRuntime;                                   // 0x00A8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryMovement;                                  // 0x00C8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryState;                                     // 0x00E8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryLeans;                                     // 0x0108(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategorySetup;                                     // 0x0128(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FAGRDebuggerSettingsKey                CategoryCustom;                                    // 0x0148(0x0020)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRDebuggerSettings">();
	}
	static class UAGRDebuggerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGRDebuggerSettings>();
	}
};
static_assert(alignof(UAGRDebuggerSettings) == 0x000008, "Wrong alignment on UAGRDebuggerSettings");
static_assert(sizeof(UAGRDebuggerSettings) == 0x000168, "Wrong size on UAGRDebuggerSettings");
static_assert(offsetof(UAGRDebuggerSettings, ActivationKey) == 0x000028, "Member 'UAGRDebuggerSettings::ActivationKey' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryAnimState) == 0x000048, "Member 'UAGRDebuggerSettings::CategoryAnimState' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryAimOffset) == 0x000068, "Member 'UAGRDebuggerSettings::CategoryAimOffset' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryRotation) == 0x000088, "Member 'UAGRDebuggerSettings::CategoryRotation' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryRuntime) == 0x0000A8, "Member 'UAGRDebuggerSettings::CategoryRuntime' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryMovement) == 0x0000C8, "Member 'UAGRDebuggerSettings::CategoryMovement' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryState) == 0x0000E8, "Member 'UAGRDebuggerSettings::CategoryState' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryLeans) == 0x000108, "Member 'UAGRDebuggerSettings::CategoryLeans' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategorySetup) == 0x000128, "Member 'UAGRDebuggerSettings::CategorySetup' has a wrong offset!");
static_assert(offsetof(UAGRDebuggerSettings, CategoryCustom) == 0x000148, "Member 'UAGRDebuggerSettings::CategoryCustom' has a wrong offset!");

// Class AGRPRO.AGRLibrary
// 0x0000 (0x0028 - 0x0028)
class UAGRLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAGRAnimMasterComponent* K2_GetAnimationMaster(class AActor* Actor);
	static class UAGR_CombatManager* K2_GetCombatManager(class AActor* Actor);
	static class UAGR_EquipmentManager* K2_GetEquipment(class AActor* Actor);
	static class UAGR_InventoryManager* K2_GetInventory(class AActor* Actor);
	static class UAGR_ItemComponent* K2_GetItemComponent(class AActor* Actor);
	static class UAGR_SoundMaster* K2_GetSound(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRLibrary">();
	}
	static class UAGRLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGRLibrary>();
	}
};
static_assert(alignof(UAGRLibrary) == 0x000008, "Wrong alignment on UAGRLibrary");
static_assert(sizeof(UAGRLibrary) == 0x000028, "Wrong size on UAGRLibrary");

// Class AGRPRO.AGRUWDebugWidget
// 0x0000 (0x0278 - 0x0278)
class UAGRUWDebugWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGRUWDebugWidget">();
	}
	static class UAGRUWDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGRUWDebugWidget>();
	}
};
static_assert(alignof(UAGRUWDebugWidget) == 0x000008, "Wrong alignment on UAGRUWDebugWidget");
static_assert(sizeof(UAGRUWDebugWidget) == 0x000278, "Wrong size on UAGRUWDebugWidget");

// Class AGRPRO.AGR_Attack_NotifyState
// 0x0038 (0x0068 - 0x0030)
class UAGR_Attack_NotifyState : public UAnimNotifyState
{
public:
	class FName                                   OnlyEffectiveStart;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnlyEffectiveEnd;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAGRAttackNotifyStateDataExtra         ExtraData;                                         // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_Attack_NotifyState">();
	}
	static class UAGR_Attack_NotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_Attack_NotifyState>();
	}
};
static_assert(alignof(UAGR_Attack_NotifyState) == 0x000008, "Wrong alignment on UAGR_Attack_NotifyState");
static_assert(sizeof(UAGR_Attack_NotifyState) == 0x000068, "Wrong size on UAGR_Attack_NotifyState");
static_assert(offsetof(UAGR_Attack_NotifyState, OnlyEffectiveStart) == 0x000030, "Member 'UAGR_Attack_NotifyState::OnlyEffectiveStart' has a wrong offset!");
static_assert(offsetof(UAGR_Attack_NotifyState, OnlyEffectiveEnd) == 0x000038, "Member 'UAGR_Attack_NotifyState::OnlyEffectiveEnd' has a wrong offset!");
static_assert(offsetof(UAGR_Attack_NotifyState, ExtraData) == 0x000040, "Member 'UAGR_Attack_NotifyState::ExtraData' has a wrong offset!");

// Class AGRPRO.AGR_CombatManager
// 0x0110 (0x01B8 - 0x00A8)
class UAGR_CombatManager final : public UActorComponent
{
public:
	ETraceTypeQuery                               TraceChannel;                                      // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TracePrecision;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSize;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAttackHitEvent;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreAttackHitEvent;                               // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartAttack;                                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndAttack;                                       // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 TraceColor1;                                       // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TraceColor2;                                       // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x54];                                     // 0x0104(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoredActors;                                     // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EPhysicalSurface>                      IgnoredSurfaceTypes;                               // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        PreviousStarts;                                    // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        PreviousEnds;                                      // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x4];                                      // 0x01A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnlyEffectiveStart;                                // 0x01A4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   OnlyEffectiveEnd;                                  // 0x01AC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddTraceMesh(class UPrimitiveComponent* Mesh, class FName InStart, class FName InEnd, const EAGR_CombatColliderType CollisionHandling);
	int32 AddWeapopnTraceMesh(class UPrimitiveComponent* Mesh, class FName InStart, class FName InEnd, class FName AttachBoneName, const EAGR_CombatColliderType CollisionHandling, const struct FTransform& StartOffset, const struct FTransform& EndOffset);
	void ClearAllMeshes();
	void EndTrace();
	void GetAllWeapons(TArray<class AActor*>* OutWeapons);
	void RefreshIgnoredActors();
	bool RemoveTraceMesh(int32 KeyIndex);
	void SetupDebug(const bool bInDebug);
	void StartTrace(const class UAnimSequenceBase* Animation, const class UAnimMontage* Montage, class FName InOnlyEffectiveStart, class FName InOnlyEffectiveEnd, float StartTime, const struct FAGRAttackNotifyStateDataExtra& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_CombatManager">();
	}
	static class UAGR_CombatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_CombatManager>();
	}
};
static_assert(alignof(UAGR_CombatManager) == 0x000008, "Wrong alignment on UAGR_CombatManager");
static_assert(sizeof(UAGR_CombatManager) == 0x0001B8, "Wrong size on UAGR_CombatManager");
static_assert(offsetof(UAGR_CombatManager, TraceChannel) == 0x0000A8, "Member 'UAGR_CombatManager::TraceChannel' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, bTraceComplex) == 0x0000A9, "Member 'UAGR_CombatManager::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, TracePrecision) == 0x0000AC, "Member 'UAGR_CombatManager::TracePrecision' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, TraceSize) == 0x0000B0, "Member 'UAGR_CombatManager::TraceSize' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, OnAttackHitEvent) == 0x0000B8, "Member 'UAGR_CombatManager::OnAttackHitEvent' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, OnPreAttackHitEvent) == 0x0000C8, "Member 'UAGR_CombatManager::OnPreAttackHitEvent' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, OnStartAttack) == 0x0000D8, "Member 'UAGR_CombatManager::OnStartAttack' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, OnEndAttack) == 0x0000E8, "Member 'UAGR_CombatManager::OnEndAttack' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, bDebug) == 0x0000F8, "Member 'UAGR_CombatManager::bDebug' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, TraceColor1) == 0x0000FC, "Member 'UAGR_CombatManager::TraceColor1' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, TraceColor2) == 0x000100, "Member 'UAGR_CombatManager::TraceColor2' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, IgnoredActors) == 0x000158, "Member 'UAGR_CombatManager::IgnoredActors' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, IgnoredSurfaceTypes) == 0x000168, "Member 'UAGR_CombatManager::IgnoredSurfaceTypes' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, PreviousStarts) == 0x000180, "Member 'UAGR_CombatManager::PreviousStarts' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, PreviousEnds) == 0x000190, "Member 'UAGR_CombatManager::PreviousEnds' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, OnlyEffectiveStart) == 0x0001A4, "Member 'UAGR_CombatManager::OnlyEffectiveStart' has a wrong offset!");
static_assert(offsetof(UAGR_CombatManager, OnlyEffectiveEnd) == 0x0001AC, "Member 'UAGR_CombatManager::OnlyEffectiveEnd' has a wrong offset!");

// Class AGRPRO.AGR_EquipmentManager
// 0x0060 (0x0108 - 0x00A8)
class UAGR_EquipmentManager final : public UActorComponent
{
public:
	TArray<struct FEquipment>                     EquipmentList;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              References;                                        // 0x00B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	bool EquipItemInSlot(const class FName Slot, class AActor* ItemActor, class AActor** OutPreviousItem, class AActor** OutNewItem);
	bool GetAllItems(TArray<class AActor*>* OutItems);
	bool GetItemInSlot(const class FName Slot, class AActor** OutItem);
	bool GetShortcutReference(const class FName Key, class AActor** OutActor);
	void SaveShortcutReference(const class FName Key, class AActor* Item);
	void SetupDefineSlots(const TArray<struct FEquipment>& InEquipmentList);
	bool UnEquipByReference(class AActor* ItemActor, class FText* OutNote);
	bool UnEquipItemFromSlot(const class FName Slot, class AActor** OutItemUnequipped);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_EquipmentManager">();
	}
	static class UAGR_EquipmentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_EquipmentManager>();
	}
};
static_assert(alignof(UAGR_EquipmentManager) == 0x000008, "Wrong alignment on UAGR_EquipmentManager");
static_assert(sizeof(UAGR_EquipmentManager) == 0x000108, "Wrong size on UAGR_EquipmentManager");
static_assert(offsetof(UAGR_EquipmentManager, EquipmentList) == 0x0000A8, "Member 'UAGR_EquipmentManager::EquipmentList' has a wrong offset!");
static_assert(offsetof(UAGR_EquipmentManager, References) == 0x0000B8, "Member 'UAGR_EquipmentManager::References' has a wrong offset!");

// Class AGRPRO.AGR_Footstep_Notify
// 0x0010 (0x0048 - 0x0038)
class UAGR_Footstep_Notify final : public UAnimNotify
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FootKey;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_Footstep_Notify">();
	}
	static class UAGR_Footstep_Notify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_Footstep_Notify>();
	}
};
static_assert(alignof(UAGR_Footstep_Notify) == 0x000008, "Wrong alignment on UAGR_Footstep_Notify");
static_assert(sizeof(UAGR_Footstep_Notify) == 0x000048, "Wrong size on UAGR_Footstep_Notify");
static_assert(offsetof(UAGR_Footstep_Notify, FootKey) == 0x000040, "Member 'UAGR_Footstep_Notify::FootKey' has a wrong offset!");

// Class AGRPRO.AGR_InventoryManager
// 0x0038 (0x00E0 - 0x00A8)
class UAGR_InventoryManager final : public UActorComponent
{
public:
	struct FGuid                                  InventoryId;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InventoryStorage;                                  // 0x00B8(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemUpdated;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddItemsOfClass(const TSubclassOf<class AActor> Param_Class, const int32 Quantity, class FText* OutNote);
	void AddItemToInventoryDirectly(class AActor* Item);
	TArray<class AActor*> GetAllItems();
	bool GetAllItemsOfClass(const TSubclassOf<class AActor> Param_Class, TArray<class AActor*>* OutFilteredArray);
	bool GetAllItemsOfTagSlotType(const struct FGameplayTag& SlotTypeFilter, TArray<class AActor*>* OutItemsWithTag);
	bool HasEnoughItems(const TSubclassOf<class AActor> Item, const int32 Quantity, class FText* OutNote);
	bool HasExactItem(class AActor* Item);
	void OverwriteId(const struct FGuid& InInventoryId);
	bool RemoveItemsOfClass(const TSubclassOf<class AActor> Param_Class, const int32 Quantity, class FText* OutNote);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_InventoryManager">();
	}
	static class UAGR_InventoryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_InventoryManager>();
	}
};
static_assert(alignof(UAGR_InventoryManager) == 0x000008, "Wrong alignment on UAGR_InventoryManager");
static_assert(sizeof(UAGR_InventoryManager) == 0x0000E0, "Wrong size on UAGR_InventoryManager");
static_assert(offsetof(UAGR_InventoryManager, InventoryId) == 0x0000A8, "Member 'UAGR_InventoryManager::InventoryId' has a wrong offset!");
static_assert(offsetof(UAGR_InventoryManager, InventoryStorage) == 0x0000B8, "Member 'UAGR_InventoryManager::InventoryStorage' has a wrong offset!");
static_assert(offsetof(UAGR_InventoryManager, bDebug) == 0x0000C0, "Member 'UAGR_InventoryManager::bDebug' has a wrong offset!");
static_assert(offsetof(UAGR_InventoryManager, OnItemUpdated) == 0x0000C8, "Member 'UAGR_InventoryManager::OnItemUpdated' has a wrong offset!");

// Class AGRPRO.AGR_ItemComponent
// 0x00E0 (0x0188 - 0x00A8)
class UAGR_ItemComponent final : public UActorComponent
{
public:
	struct FGuid                                  ItemId;                                            // 0x00A8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  InventoryId;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  OwnerId;                                           // 0x00C8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStackable;                                        // 0x00D8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStack;                                          // 0x00DC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStack;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x00E8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpaceSlots;                                        // 0x00EC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemName;                                          // 0x00F0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateWhenDropped;                              // 0x00F8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ItemTagSlotType;                                   // 0x00FC(0x0008)(Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPickup;                                          // 0x0108(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FOnSplitStack;                                     // 0x0118(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHiddenShown;                                     // 0x0128(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemDropped;                                     // 0x0138(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemUsed;                                        // 0x0148(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEquip;                                           // 0x0158(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnEquip;                                         // 0x0168(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDestroy;                                         // 0x0178(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DestroyItem();
	void DropItem();
	void PickUpItem(class UAGR_InventoryManager* InventoryPicking);
	bool SplitItems(const int32 SplitSize);
	void UseItem(class AActor* User, const struct FGameplayTag& GameplayTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_ItemComponent">();
	}
	static class UAGR_ItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_ItemComponent>();
	}
};
static_assert(alignof(UAGR_ItemComponent) == 0x000008, "Wrong alignment on UAGR_ItemComponent");
static_assert(sizeof(UAGR_ItemComponent) == 0x000188, "Wrong size on UAGR_ItemComponent");
static_assert(offsetof(UAGR_ItemComponent, ItemId) == 0x0000A8, "Member 'UAGR_ItemComponent::ItemId' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, InventoryId) == 0x0000B8, "Member 'UAGR_ItemComponent::InventoryId' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OwnerId) == 0x0000C8, "Member 'UAGR_ItemComponent::OwnerId' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, bStackable) == 0x0000D8, "Member 'UAGR_ItemComponent::bStackable' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, MaxStack) == 0x0000DC, "Member 'UAGR_ItemComponent::MaxStack' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, CurrentStack) == 0x0000E0, "Member 'UAGR_ItemComponent::CurrentStack' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, Weight) == 0x0000E4, "Member 'UAGR_ItemComponent::Weight' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, Volume) == 0x0000E8, "Member 'UAGR_ItemComponent::Volume' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, SpaceSlots) == 0x0000EC, "Member 'UAGR_ItemComponent::SpaceSlots' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, ItemName) == 0x0000F0, "Member 'UAGR_ItemComponent::ItemName' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, bSimulateWhenDropped) == 0x0000F8, "Member 'UAGR_ItemComponent::bSimulateWhenDropped' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, ItemTagSlotType) == 0x0000FC, "Member 'UAGR_ItemComponent::ItemTagSlotType' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnPickup) == 0x000108, "Member 'UAGR_ItemComponent::OnPickup' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, FOnSplitStack) == 0x000118, "Member 'UAGR_ItemComponent::FOnSplitStack' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnHiddenShown) == 0x000128, "Member 'UAGR_ItemComponent::OnHiddenShown' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnItemDropped) == 0x000138, "Member 'UAGR_ItemComponent::OnItemDropped' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnItemUsed) == 0x000148, "Member 'UAGR_ItemComponent::OnItemUsed' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnEquip) == 0x000158, "Member 'UAGR_ItemComponent::OnEquip' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnUnEquip) == 0x000168, "Member 'UAGR_ItemComponent::OnUnEquip' has a wrong offset!");
static_assert(offsetof(UAGR_ItemComponent, OnDestroy) == 0x000178, "Member 'UAGR_ItemComponent::OnDestroy' has a wrong offset!");

// Class AGRPRO.AGR_SoundMaster
// 0x00B8 (0x0160 - 0x00A8)
class UAGR_SoundMaster final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             CharacterMadeFootstepSound;                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceTraceLength;                                // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_AGR_FootstepConfig*                 FootstepSetup;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                FeetDefinitions;                                   // 0x00C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAutoPlace;                                        // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeCycle;                                      // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoVolume;                                       // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerAsCharacter;                                  // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AutoFootstepsArray;                                // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PreviousFoot;                                      // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x16];                                     // 0x014A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FootstepEffect(const struct FHitResult& Hit, class UAudioComponent** Sound, class UNiagaraSystem** Particle);
	void OverwritePickSurface(const EPhysicalSurface& InSurface, EPhysicalSurface* OutSurface);
	void TestAllFeetForCollision();
	bool TryTraceFootstep(const class FName Key);

	float OverwriteCalcVolume() const;
	struct FVector OverwriteParticleScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGR_SoundMaster">();
	}
	static class UAGR_SoundMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGR_SoundMaster>();
	}
};
static_assert(alignof(UAGR_SoundMaster) == 0x000008, "Wrong alignment on UAGR_SoundMaster");
static_assert(sizeof(UAGR_SoundMaster) == 0x000160, "Wrong size on UAGR_SoundMaster");
static_assert(offsetof(UAGR_SoundMaster, CharacterMadeFootstepSound) == 0x0000A8, "Member 'UAGR_SoundMaster::CharacterMadeFootstepSound' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, VolumeMultiplier) == 0x0000B8, "Member 'UAGR_SoundMaster::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, SurfaceTraceLength) == 0x0000BC, "Member 'UAGR_SoundMaster::SurfaceTraceLength' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, FootstepSetup) == 0x0000C0, "Member 'UAGR_SoundMaster::FootstepSetup' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, FeetDefinitions) == 0x0000C8, "Member 'UAGR_SoundMaster::FeetDefinitions' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, bAutoPlace) == 0x000118, "Member 'UAGR_SoundMaster::bAutoPlace' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, MinTimeCycle) == 0x00011C, "Member 'UAGR_SoundMaster::MinTimeCycle' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, bAutoVolume) == 0x000120, "Member 'UAGR_SoundMaster::bAutoVolume' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, OwnerAsCharacter) == 0x000128, "Member 'UAGR_SoundMaster::OwnerAsCharacter' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, AutoFootstepsArray) == 0x000130, "Member 'UAGR_SoundMaster::AutoFootstepsArray' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, PreviousFoot) == 0x000140, "Member 'UAGR_SoundMaster::PreviousFoot' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, bTraceComplex) == 0x000148, "Member 'UAGR_SoundMaster::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UAGR_SoundMaster, TraceChannel) == 0x000149, "Member 'UAGR_SoundMaster::TraceChannel' has a wrong offset!");

// Class AGRPRO.DA_AGR_FootstepConfig
// 0x00B8 (0x00E8 - 0x0030)
class UDA_AGR_FootstepConfig final : public UDataAsset
{
public:
	float                                         MinVelocity;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, class USoundCue*>      Sounds;                                            // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, class UNiagaraSystem*> Particles;                                         // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      Attenuation;                                       // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      Concurrency;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetSurfaceReaction(EPhysicalSurface InputParam, class USoundCue** Sound, class UNiagaraSystem** Particle);

	void GetFootStepSettings(class USoundAttenuation** AttenuationRef, class USoundConcurrency** ConcurrencyRef) const;
	void GetVelocityRange(float* MinRange, float* MaxRange) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_AGR_FootstepConfig">();
	}
	static class UDA_AGR_FootstepConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_AGR_FootstepConfig>();
	}
};
static_assert(alignof(UDA_AGR_FootstepConfig) == 0x000008, "Wrong alignment on UDA_AGR_FootstepConfig");
static_assert(sizeof(UDA_AGR_FootstepConfig) == 0x0000E8, "Wrong size on UDA_AGR_FootstepConfig");
static_assert(offsetof(UDA_AGR_FootstepConfig, MinVelocity) == 0x000030, "Member 'UDA_AGR_FootstepConfig::MinVelocity' has a wrong offset!");
static_assert(offsetof(UDA_AGR_FootstepConfig, MaxVelocity) == 0x000034, "Member 'UDA_AGR_FootstepConfig::MaxVelocity' has a wrong offset!");
static_assert(offsetof(UDA_AGR_FootstepConfig, Sounds) == 0x000038, "Member 'UDA_AGR_FootstepConfig::Sounds' has a wrong offset!");
static_assert(offsetof(UDA_AGR_FootstepConfig, Particles) == 0x000088, "Member 'UDA_AGR_FootstepConfig::Particles' has a wrong offset!");
static_assert(offsetof(UDA_AGR_FootstepConfig, Attenuation) == 0x0000D8, "Member 'UDA_AGR_FootstepConfig::Attenuation' has a wrong offset!");
static_assert(offsetof(UDA_AGR_FootstepConfig, Concurrency) == 0x0000E0, "Member 'UDA_AGR_FootstepConfig::Concurrency' has a wrong offset!");

}

