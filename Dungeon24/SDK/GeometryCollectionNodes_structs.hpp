#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GeometryCollectionNodes

#include "Basic.hpp"

#include "Chaos_structs.hpp"
#include "DataflowCore_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum GeometryCollectionNodes.EMakeBoxDataTypeEnum
// NumValues: 0x0003
enum class EMakeBoxDataTypeEnum : uint8
{
	Dataflow_MakeBox_DataType_MinMax         = 0,
	Dataflow_MakeBox_DataType_CenterSize     = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EFloatToIntFunctionEnum
// NumValues: 0x0005
enum class EFloatToIntFunctionEnum : uint8
{
	Dataflow_FloatToInt_Function_Floor       = 0,
	Dataflow_FloatToInt_Function_Ceil        = 1,
	Dataflow_FloatToInt_Function_Round       = 2,
	Dataflow_FloatToInt_Function_Truncate    = 3,
	Dataflow_Max                             = 4,
};

// Enum GeometryCollectionNodes.EMathConstantsEnum
// NumValues: 0x000F
enum class EMathConstantsEnum : uint8
{
	Dataflow_MathConstants_Pi                = 0,
	Dataflow_MathConstants_HalfPi            = 1,
	Dataflow_MathConstants_TwoPi             = 2,
	Dataflow_MathConstants_FourPi            = 3,
	Dataflow_MathConstants_InvPi             = 4,
	Dataflow_MathConstants_InvTwoPi          = 5,
	Dataflow_MathConstants_Sqrt2             = 6,
	Dataflow_MathConstants_InvSqrt2          = 7,
	Dataflow_MathConstants_Sqrt3             = 8,
	Dataflow_MathConstants_InvSqrt3          = 9,
	Dataflow_FloatToInt_Function_E           = 10,
	Dataflow_FloatToInt_Function_Gamma       = 11,
	Dataflow_FloatToInt_Function_GoldenRatio = 12,
	Dataflow_FloatToInt_Function_ZeroTolerance = 13,
	Dataflow_Max                             = 14,
};

// ScriptStruct GeometryCollectionNodes.PrintStringDataflowNode
// 0x0020 (0x00F0 - 0x00D0)
struct FPrintStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          PrintToScreen;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrintToLog;                                        // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrintStringDataflowNode) == 0x000008, "Wrong alignment on FPrintStringDataflowNode");
static_assert(sizeof(FPrintStringDataflowNode) == 0x0000F0, "Wrong size on FPrintStringDataflowNode");
static_assert(offsetof(FPrintStringDataflowNode, PrintToScreen) == 0x0000D0, "Member 'FPrintStringDataflowNode::PrintToScreen' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, PrintToLog) == 0x0000D1, "Member 'FPrintStringDataflowNode::PrintToLog' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, Color) == 0x0000D4, "Member 'FPrintStringDataflowNode::Color' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, Duration) == 0x0000D8, "Member 'FPrintStringDataflowNode::Duration' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, String) == 0x0000E0, "Member 'FPrintStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CloseGeometryOnCollectionDataflowNode
// 0x00B0 (0x0180 - 0x00D0)
struct FCloseGeometryOnCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloseGeometryOnCollectionDataflowNode) == 0x000008, "Wrong alignment on FCloseGeometryOnCollectionDataflowNode");
static_assert(sizeof(FCloseGeometryOnCollectionDataflowNode) == 0x000180, "Wrong size on FCloseGeometryOnCollectionDataflowNode");
static_assert(offsetof(FCloseGeometryOnCollectionDataflowNode, Collection) == 0x0000D0, "Member 'FCloseGeometryOnCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SkeletalMeshToCollectionDataflowNode
// 0x00B8 (0x0188 - 0x00D0)
struct FSkeletalMeshToCollectionDataflowNode final : public FDataflowNode
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00D8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshToCollectionDataflowNode) == 0x000008, "Wrong alignment on FSkeletalMeshToCollectionDataflowNode");
static_assert(sizeof(FSkeletalMeshToCollectionDataflowNode) == 0x000188, "Wrong size on FSkeletalMeshToCollectionDataflowNode");
static_assert(offsetof(FSkeletalMeshToCollectionDataflowNode, SkeletalMesh) == 0x0000D0, "Member 'FSkeletalMeshToCollectionDataflowNode::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshToCollectionDataflowNode, Collection) == 0x0000D8, "Member 'FSkeletalMeshToCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GenerateTetrahedralCollectionDataflowNodes
// 0x00B0 (0x0180 - 0x00D0)
struct FGenerateTetrahedralCollectionDataflowNodes final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenerateTetrahedralCollectionDataflowNodes) == 0x000008, "Wrong alignment on FGenerateTetrahedralCollectionDataflowNodes");
static_assert(sizeof(FGenerateTetrahedralCollectionDataflowNodes) == 0x000180, "Wrong size on FGenerateTetrahedralCollectionDataflowNodes");
static_assert(offsetof(FGenerateTetrahedralCollectionDataflowNodes, Collection) == 0x0000D0, "Member 'FGenerateTetrahedralCollectionDataflowNodes::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCollectionAssetDataflowNode
// 0x00B0 (0x0180 - 0x00D0)
struct FGetCollectionAssetDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Output;                                            // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCollectionAssetDataflowNode) == 0x000008, "Wrong alignment on FGetCollectionAssetDataflowNode");
static_assert(sizeof(FGetCollectionAssetDataflowNode) == 0x000180, "Wrong size on FGetCollectionAssetDataflowNode");
static_assert(offsetof(FGetCollectionAssetDataflowNode, Output) == 0x0000D0, "Member 'FGetCollectionAssetDataflowNode::Output' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExampleCollectionEditDataflowNode
// 0x00B8 (0x0188 - 0x00D0)
struct FExampleCollectionEditDataflowNode final : public FDataflowNode
{
public:
	float                                         Scale;                                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00D8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FExampleCollectionEditDataflowNode) == 0x000008, "Wrong alignment on FExampleCollectionEditDataflowNode");
static_assert(sizeof(FExampleCollectionEditDataflowNode) == 0x000188, "Wrong size on FExampleCollectionEditDataflowNode");
static_assert(offsetof(FExampleCollectionEditDataflowNode, Scale) == 0x0000D0, "Member 'FExampleCollectionEditDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FExampleCollectionEditDataflowNode, Collection) == 0x0000D8, "Member 'FExampleCollectionEditDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetCollectionAssetDataflowNode
// 0x00B0 (0x0180 - 0x00D0)
struct FSetCollectionAssetDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetCollectionAssetDataflowNode) == 0x000008, "Wrong alignment on FSetCollectionAssetDataflowNode");
static_assert(sizeof(FSetCollectionAssetDataflowNode) == 0x000180, "Wrong size on FSetCollectionAssetDataflowNode");
static_assert(offsetof(FSetCollectionAssetDataflowNode, Collection) == 0x0000D0, "Member 'FSetCollectionAssetDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ResetGeometryCollectionDataflowNode
// 0x00B0 (0x0180 - 0x00D0)
struct FResetGeometryCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FResetGeometryCollectionDataflowNode) == 0x000008, "Wrong alignment on FResetGeometryCollectionDataflowNode");
static_assert(sizeof(FResetGeometryCollectionDataflowNode) == 0x000180, "Wrong size on FResetGeometryCollectionDataflowNode");
static_assert(offsetof(FResetGeometryCollectionDataflowNode, Collection) == 0x0000D0, "Member 'FResetGeometryCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LogStringDataflowNode
// 0x0018 (0x00E8 - 0x00D0)
struct FLogStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          PrintToLog;                                        // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogStringDataflowNode) == 0x000008, "Wrong alignment on FLogStringDataflowNode");
static_assert(sizeof(FLogStringDataflowNode) == 0x0000E8, "Wrong size on FLogStringDataflowNode");
static_assert(offsetof(FLogStringDataflowNode, PrintToLog) == 0x0000D0, "Member 'FLogStringDataflowNode::PrintToLog' has a wrong offset!");
static_assert(offsetof(FLogStringDataflowNode, String) == 0x0000D8, "Member 'FLogStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralStringDataflowNode
// 0x0020 (0x00F0 - 0x00D0)
struct FMakeLiteralStringDataflowNode final : public FDataflowNode
{
public:
	class FString                                 Value;                                             // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralStringDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralStringDataflowNode");
static_assert(sizeof(FMakeLiteralStringDataflowNode) == 0x0000F0, "Wrong size on FMakeLiteralStringDataflowNode");
static_assert(offsetof(FMakeLiteralStringDataflowNode, Value) == 0x0000D0, "Member 'FMakeLiteralStringDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralStringDataflowNode, String) == 0x0000E0, "Member 'FMakeLiteralStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoundingBoxDataflowNode
// 0x00E8 (0x01B8 - 0x00D0)
struct FBoundingBoxDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x0180(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoundingBoxDataflowNode) == 0x000008, "Wrong alignment on FBoundingBoxDataflowNode");
static_assert(sizeof(FBoundingBoxDataflowNode) == 0x0001B8, "Wrong size on FBoundingBoxDataflowNode");
static_assert(offsetof(FBoundingBoxDataflowNode, Collection) == 0x0000D0, "Member 'FBoundingBoxDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FBoundingBoxDataflowNode, BoundingBox) == 0x000180, "Member 'FBoundingBoxDataflowNode::BoundingBox' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpandBoundingBoxDataflowNode
// 0x00A0 (0x0170 - 0x00D0)
struct FExpandBoundingBoxDataflowNode final : public FDataflowNode
{
public:
	struct FBox                                   BoundingBox;                                       // 0x00D0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0138(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfExtents;                                       // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpandBoundingBoxDataflowNode) == 0x000008, "Wrong alignment on FExpandBoundingBoxDataflowNode");
static_assert(sizeof(FExpandBoundingBoxDataflowNode) == 0x000170, "Wrong size on FExpandBoundingBoxDataflowNode");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, BoundingBox) == 0x0000D0, "Member 'FExpandBoundingBoxDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Min) == 0x000108, "Member 'FExpandBoundingBoxDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Max) == 0x000120, "Member 'FExpandBoundingBoxDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Center) == 0x000138, "Member 'FExpandBoundingBoxDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, HalfExtents) == 0x000150, "Member 'FExpandBoundingBoxDataflowNode::HalfExtents' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Volume) == 0x000168, "Member 'FExpandBoundingBoxDataflowNode::Volume' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VectorToStringDataflowNode
// 0x0028 (0x00F8 - 0x00D0)
struct FVectorToStringDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorToStringDataflowNode) == 0x000008, "Wrong alignment on FVectorToStringDataflowNode");
static_assert(sizeof(FVectorToStringDataflowNode) == 0x0000F8, "Wrong size on FVectorToStringDataflowNode");
static_assert(offsetof(FVectorToStringDataflowNode, Vector) == 0x0000D0, "Member 'FVectorToStringDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FVectorToStringDataflowNode, String) == 0x0000E8, "Member 'FVectorToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToStringDataflowNode
// 0x0018 (0x00E8 - 0x00D0)
struct FFloatToStringDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatToStringDataflowNode) == 0x000008, "Wrong alignment on FFloatToStringDataflowNode");
static_assert(sizeof(FFloatToStringDataflowNode) == 0x0000E8, "Wrong size on FFloatToStringDataflowNode");
static_assert(offsetof(FFloatToStringDataflowNode, Float) == 0x0000D0, "Member 'FFloatToStringDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToStringDataflowNode, String) == 0x0000D8, "Member 'FFloatToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakePointsDataflowNode
// 0x0020 (0x00F0 - 0x00D0)
struct FMakePointsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Point;                                             // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakePointsDataflowNode) == 0x000008, "Wrong alignment on FMakePointsDataflowNode");
static_assert(sizeof(FMakePointsDataflowNode) == 0x0000F0, "Wrong size on FMakePointsDataflowNode");
static_assert(offsetof(FMakePointsDataflowNode, Point) == 0x0000D0, "Member 'FMakePointsDataflowNode::Point' has a wrong offset!");
static_assert(offsetof(FMakePointsDataflowNode, Points) == 0x0000E0, "Member 'FMakePointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeBoxDataflowNode
// 0x00A0 (0x0170 - 0x00D0)
struct FMakeBoxDataflowNode final : public FDataflowNode
{
public:
	EMakeBoxDataTypeEnum                          DataType;                                          // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Min;                                               // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0108(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0138(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeBoxDataflowNode) == 0x000008, "Wrong alignment on FMakeBoxDataflowNode");
static_assert(sizeof(FMakeBoxDataflowNode) == 0x000170, "Wrong size on FMakeBoxDataflowNode");
static_assert(offsetof(FMakeBoxDataflowNode, DataType) == 0x0000D0, "Member 'FMakeBoxDataflowNode::DataType' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Min) == 0x0000D8, "Member 'FMakeBoxDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Max) == 0x0000F0, "Member 'FMakeBoxDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Center) == 0x000108, "Member 'FMakeBoxDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Size) == 0x000120, "Member 'FMakeBoxDataflowNode::Size' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Box) == 0x000138, "Member 'FMakeBoxDataflowNode::Box' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformScatterPointsDataflowNode
// 0x0058 (0x0128 - 0x00D0)
struct FUniformScatterPointsDataflowNode final : public FDataflowNode
{
public:
	int32                                         MinNumberOfPoints;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfPoints;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   BoundingBox;                                       // 0x00E0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniformScatterPointsDataflowNode) == 0x000008, "Wrong alignment on FUniformScatterPointsDataflowNode");
static_assert(sizeof(FUniformScatterPointsDataflowNode) == 0x000128, "Wrong size on FUniformScatterPointsDataflowNode");
static_assert(offsetof(FUniformScatterPointsDataflowNode, MinNumberOfPoints) == 0x0000D0, "Member 'FUniformScatterPointsDataflowNode::MinNumberOfPoints' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, MaxNumberOfPoints) == 0x0000D4, "Member 'FUniformScatterPointsDataflowNode::MaxNumberOfPoints' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, RandomSeed) == 0x0000D8, "Member 'FUniformScatterPointsDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, BoundingBox) == 0x0000E0, "Member 'FUniformScatterPointsDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, Points) == 0x000118, "Member 'FUniformScatterPointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialScatterPointsDataflowNode
// 0x0058 (0x0128 - 0x00D0)
struct FRadialScatterPointsDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Center;                                            // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularSteps;                                      // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RadialSteps;                                       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffset;                                       // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variability;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialScatterPointsDataflowNode) == 0x000008, "Wrong alignment on FRadialScatterPointsDataflowNode");
static_assert(sizeof(FRadialScatterPointsDataflowNode) == 0x000128, "Wrong size on FRadialScatterPointsDataflowNode");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Center) == 0x0000D0, "Member 'FRadialScatterPointsDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Normal) == 0x0000E8, "Member 'FRadialScatterPointsDataflowNode::Normal' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Radius) == 0x000100, "Member 'FRadialScatterPointsDataflowNode::Radius' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, AngularSteps) == 0x000104, "Member 'FRadialScatterPointsDataflowNode::AngularSteps' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, RadialSteps) == 0x000108, "Member 'FRadialScatterPointsDataflowNode::RadialSteps' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, AngleOffset) == 0x00010C, "Member 'FRadialScatterPointsDataflowNode::AngleOffset' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Variability) == 0x000110, "Member 'FRadialScatterPointsDataflowNode::Variability' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, RandomSeed) == 0x000114, "Member 'FRadialScatterPointsDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Points) == 0x000118, "Member 'FRadialScatterPointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralFloatDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FMakeLiteralFloatDataflowNode final : public FDataflowNode
{
public:
	float                                         Value;                                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralFloatDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralFloatDataflowNode");
static_assert(sizeof(FMakeLiteralFloatDataflowNode) == 0x0000D8, "Wrong size on FMakeLiteralFloatDataflowNode");
static_assert(offsetof(FMakeLiteralFloatDataflowNode, Value) == 0x0000D0, "Member 'FMakeLiteralFloatDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralFloatDataflowNode, Float) == 0x0000D4, "Member 'FMakeLiteralFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralIntDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FMakeLiteralIntDataflowNode final : public FDataflowNode
{
public:
	int32                                         Value;                                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralIntDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralIntDataflowNode");
static_assert(sizeof(FMakeLiteralIntDataflowNode) == 0x0000D8, "Wrong size on FMakeLiteralIntDataflowNode");
static_assert(offsetof(FMakeLiteralIntDataflowNode, Value) == 0x0000D0, "Member 'FMakeLiteralIntDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralIntDataflowNode, Int) == 0x0000D4, "Member 'FMakeLiteralIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralBoolDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FMakeLiteralBoolDataflowNode final : public FDataflowNode
{
public:
	bool                                          Value;                                             // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bool;                                              // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMakeLiteralBoolDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralBoolDataflowNode");
static_assert(sizeof(FMakeLiteralBoolDataflowNode) == 0x0000D8, "Wrong size on FMakeLiteralBoolDataflowNode");
static_assert(offsetof(FMakeLiteralBoolDataflowNode, Value) == 0x0000D0, "Member 'FMakeLiteralBoolDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralBoolDataflowNode, Bool) == 0x0000D1, "Member 'FMakeLiteralBoolDataflowNode::Bool' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralVectorDataflowNode
// 0x0030 (0x0100 - 0x00D0)
struct FMakeLiteralVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Value;                                             // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x00E8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralVectorDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralVectorDataflowNode");
static_assert(sizeof(FMakeLiteralVectorDataflowNode) == 0x000100, "Wrong size on FMakeLiteralVectorDataflowNode");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Value) == 0x0000D0, "Member 'FMakeLiteralVectorDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Vector) == 0x0000E8, "Member 'FMakeLiteralVectorDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToStringDataflowNode
// 0x0018 (0x00E8 - 0x00D0)
struct FIntToStringDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToStringDataflowNode) == 0x000008, "Wrong alignment on FIntToStringDataflowNode");
static_assert(sizeof(FIntToStringDataflowNode) == 0x0000E8, "Wrong size on FIntToStringDataflowNode");
static_assert(offsetof(FIntToStringDataflowNode, Int) == 0x0000D0, "Member 'FIntToStringDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToStringDataflowNode, String) == 0x0000D8, "Member 'FIntToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoolToStringDataflowNode
// 0x0018 (0x00E8 - 0x00D0)
struct FBoolToStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          Bool;                                              // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolToStringDataflowNode) == 0x000008, "Wrong alignment on FBoolToStringDataflowNode");
static_assert(sizeof(FBoolToStringDataflowNode) == 0x0000E8, "Wrong size on FBoolToStringDataflowNode");
static_assert(offsetof(FBoolToStringDataflowNode, Bool) == 0x0000D0, "Member 'FBoolToStringDataflowNode::Bool' has a wrong offset!");
static_assert(offsetof(FBoolToStringDataflowNode, String) == 0x0000D8, "Member 'FBoolToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpandVectorDataflowNode
// 0x0028 (0x00F8 - 0x00D0)
struct FExpandVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpandVectorDataflowNode) == 0x000008, "Wrong alignment on FExpandVectorDataflowNode");
static_assert(sizeof(FExpandVectorDataflowNode) == 0x0000F8, "Wrong size on FExpandVectorDataflowNode");
static_assert(offsetof(FExpandVectorDataflowNode, Vector) == 0x0000D0, "Member 'FExpandVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, X) == 0x0000E8, "Member 'FExpandVectorDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, Y) == 0x0000EC, "Member 'FExpandVectorDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, Z) == 0x0000F0, "Member 'FExpandVectorDataflowNode::Z' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToFloatDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FIntToFloatDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToFloatDataflowNode) == 0x000008, "Wrong alignment on FIntToFloatDataflowNode");
static_assert(sizeof(FIntToFloatDataflowNode) == 0x0000D8, "Wrong size on FIntToFloatDataflowNode");
static_assert(offsetof(FIntToFloatDataflowNode, Int) == 0x0000D0, "Member 'FIntToFloatDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToFloatDataflowNode, Float) == 0x0000D4, "Member 'FIntToFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VoronoiFractureDataflowNode
// 0x00F0 (0x01C0 - 0x00D0)
struct FVoronoiFractureDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToFracture;                                  // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GroupFracture;                                     // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Grout;                                             // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Persistence;                                       // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lacunarity;                                        // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OctaveNumber;                                      // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSpacing;                                      // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddSamplesForCollision;                            // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionSampleSpacing;                            // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoronoiFractureDataflowNode) == 0x000008, "Wrong alignment on FVoronoiFractureDataflowNode");
static_assert(sizeof(FVoronoiFractureDataflowNode) == 0x0001C0, "Wrong size on FVoronoiFractureDataflowNode");
static_assert(offsetof(FVoronoiFractureDataflowNode, Collection) == 0x0000D0, "Member 'FVoronoiFractureDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Points) == 0x000180, "Member 'FVoronoiFractureDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, RandomSeed) == 0x000190, "Member 'FVoronoiFractureDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, ChanceToFracture) == 0x000194, "Member 'FVoronoiFractureDataflowNode::ChanceToFracture' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, GroupFracture) == 0x000198, "Member 'FVoronoiFractureDataflowNode::GroupFracture' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Grout) == 0x00019C, "Member 'FVoronoiFractureDataflowNode::Grout' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Amplitude) == 0x0001A0, "Member 'FVoronoiFractureDataflowNode::Amplitude' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Frequency) == 0x0001A4, "Member 'FVoronoiFractureDataflowNode::Frequency' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Persistence) == 0x0001A8, "Member 'FVoronoiFractureDataflowNode::Persistence' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Lacunarity) == 0x0001AC, "Member 'FVoronoiFractureDataflowNode::Lacunarity' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, OctaveNumber) == 0x0001B0, "Member 'FVoronoiFractureDataflowNode::OctaveNumber' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, PointSpacing) == 0x0001B4, "Member 'FVoronoiFractureDataflowNode::PointSpacing' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, AddSamplesForCollision) == 0x0001B8, "Member 'FVoronoiFractureDataflowNode::AddSamplesForCollision' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, CollisionSampleSpacing) == 0x0001BC, "Member 'FVoronoiFractureDataflowNode::CollisionSampleSpacing' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.StringAppendDataflowNode
// 0x0030 (0x0100 - 0x00D0)
struct FStringAppendDataflowNode final : public FDataflowNode
{
public:
	class FString                                 String1;                                           // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String2;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStringAppendDataflowNode) == 0x000008, "Wrong alignment on FStringAppendDataflowNode");
static_assert(sizeof(FStringAppendDataflowNode) == 0x000100, "Wrong size on FStringAppendDataflowNode");
static_assert(offsetof(FStringAppendDataflowNode, String1) == 0x0000D0, "Member 'FStringAppendDataflowNode::String1' has a wrong offset!");
static_assert(offsetof(FStringAppendDataflowNode, String2) == 0x0000E0, "Member 'FStringAppendDataflowNode::String2' has a wrong offset!");
static_assert(offsetof(FStringAppendDataflowNode, String) == 0x0000F0, "Member 'FStringAppendDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomFloatDataflowNode
// 0x0010 (0x00E0 - 0x00D0)
struct FRandomFloatDataflowNode final : public FDataflowNode
{
public:
	bool                                          Deterministic;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomFloatDataflowNode) == 0x000008, "Wrong alignment on FRandomFloatDataflowNode");
static_assert(sizeof(FRandomFloatDataflowNode) == 0x0000E0, "Wrong size on FRandomFloatDataflowNode");
static_assert(offsetof(FRandomFloatDataflowNode, Deterministic) == 0x0000D0, "Member 'FRandomFloatDataflowNode::Deterministic' has a wrong offset!");
static_assert(offsetof(FRandomFloatDataflowNode, RandomSeed) == 0x0000D4, "Member 'FRandomFloatDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomFloatDataflowNode, Float) == 0x0000D8, "Member 'FRandomFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomFloatInRangeDataflowNode
// 0x0018 (0x00E8 - 0x00D0)
struct FRandomFloatInRangeDataflowNode final : public FDataflowNode
{
public:
	bool                                          Deterministic;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomFloatInRangeDataflowNode) == 0x000008, "Wrong alignment on FRandomFloatInRangeDataflowNode");
static_assert(sizeof(FRandomFloatInRangeDataflowNode) == 0x0000E8, "Wrong size on FRandomFloatInRangeDataflowNode");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Deterministic) == 0x0000D0, "Member 'FRandomFloatInRangeDataflowNode::Deterministic' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, RandomSeed) == 0x0000D4, "Member 'FRandomFloatInRangeDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Min) == 0x0000D8, "Member 'FRandomFloatInRangeDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Max) == 0x0000DC, "Member 'FRandomFloatInRangeDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Float) == 0x0000E0, "Member 'FRandomFloatInRangeDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomUnitVectorDataflowNode
// 0x0020 (0x00F0 - 0x00D0)
struct FRandomUnitVectorDataflowNode final : public FDataflowNode
{
public:
	bool                                          Deterministic;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomUnitVectorDataflowNode) == 0x000008, "Wrong alignment on FRandomUnitVectorDataflowNode");
static_assert(sizeof(FRandomUnitVectorDataflowNode) == 0x0000F0, "Wrong size on FRandomUnitVectorDataflowNode");
static_assert(offsetof(FRandomUnitVectorDataflowNode, Deterministic) == 0x0000D0, "Member 'FRandomUnitVectorDataflowNode::Deterministic' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorDataflowNode, RandomSeed) == 0x0000D4, "Member 'FRandomUnitVectorDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorDataflowNode, Vector) == 0x0000D8, "Member 'FRandomUnitVectorDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomUnitVectorInConeDataflowNode
// 0x0040 (0x0110 - 0x00D0)
struct FRandomUnitVectorInConeDataflowNode final : public FDataflowNode
{
public:
	bool                                          Deterministic;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeDirection;                                     // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomUnitVectorInConeDataflowNode) == 0x000008, "Wrong alignment on FRandomUnitVectorInConeDataflowNode");
static_assert(sizeof(FRandomUnitVectorInConeDataflowNode) == 0x000110, "Wrong size on FRandomUnitVectorInConeDataflowNode");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, Deterministic) == 0x0000D0, "Member 'FRandomUnitVectorInConeDataflowNode::Deterministic' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, RandomSeed) == 0x0000D4, "Member 'FRandomUnitVectorInConeDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ConeDirection) == 0x0000D8, "Member 'FRandomUnitVectorInConeDataflowNode::ConeDirection' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ConeHalfAngle) == 0x0000F0, "Member 'FRandomUnitVectorInConeDataflowNode::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, Vector) == 0x0000F8, "Member 'FRandomUnitVectorInConeDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadiansToDegreesDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FRadiansToDegreesDataflowNode final : public FDataflowNode
{
public:
	float                                         Radians;                                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Degrees;                                           // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadiansToDegreesDataflowNode) == 0x000008, "Wrong alignment on FRadiansToDegreesDataflowNode");
static_assert(sizeof(FRadiansToDegreesDataflowNode) == 0x0000D8, "Wrong size on FRadiansToDegreesDataflowNode");
static_assert(offsetof(FRadiansToDegreesDataflowNode, Radians) == 0x0000D0, "Member 'FRadiansToDegreesDataflowNode::Radians' has a wrong offset!");
static_assert(offsetof(FRadiansToDegreesDataflowNode, Degrees) == 0x0000D4, "Member 'FRadiansToDegreesDataflowNode::Degrees' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DegreesToRadiansDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FDegreesToRadiansDataflowNode final : public FDataflowNode
{
public:
	float                                         Degrees;                                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radians;                                           // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDegreesToRadiansDataflowNode) == 0x000008, "Wrong alignment on FDegreesToRadiansDataflowNode");
static_assert(sizeof(FDegreesToRadiansDataflowNode) == 0x0000D8, "Wrong size on FDegreesToRadiansDataflowNode");
static_assert(offsetof(FDegreesToRadiansDataflowNode, Degrees) == 0x0000D0, "Member 'FDegreesToRadiansDataflowNode::Degrees' has a wrong offset!");
static_assert(offsetof(FDegreesToRadiansDataflowNode, Radians) == 0x0000D4, "Member 'FDegreesToRadiansDataflowNode::Radians' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExplodedViewDataflowNode
// 0x00D0 (0x01A0 - 0x00D0)
struct FExplodedViewDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0188(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplodedViewDataflowNode) == 0x000008, "Wrong alignment on FExplodedViewDataflowNode");
static_assert(sizeof(FExplodedViewDataflowNode) == 0x0001A0, "Wrong size on FExplodedViewDataflowNode");
static_assert(offsetof(FExplodedViewDataflowNode, Collection) == 0x0000D0, "Member 'FExplodedViewDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FExplodedViewDataflowNode, UniformScale) == 0x000180, "Member 'FExplodedViewDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FExplodedViewDataflowNode, Scale) == 0x000188, "Member 'FExplodedViewDataflowNode::Scale' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CreateNonOverlappingConvexHullsDataflowNode
// 0x00C0 (0x0190 - 0x00D0)
struct FCreateNonOverlappingConvexHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
	float                                         CanRemoveFraction;                                 // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanExceedFraction;                                 // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplificationDistanceThreshold;                   // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateNonOverlappingConvexHullsDataflowNode) == 0x000008, "Wrong alignment on FCreateNonOverlappingConvexHullsDataflowNode");
static_assert(sizeof(FCreateNonOverlappingConvexHullsDataflowNode) == 0x000190, "Wrong size on FCreateNonOverlappingConvexHullsDataflowNode");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, Collection) == 0x0000D0, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, CanRemoveFraction) == 0x000180, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::CanRemoveFraction' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, CanExceedFraction) == 0x000184, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::CanExceedFraction' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, SimplificationDistanceThreshold) == 0x000188, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::SimplificationDistanceThreshold' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PlaneCutterDataflowNode
// 0x0118 (0x01E8 - 0x00D0)
struct FPlaneCutterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00D0(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x0180(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumPlanes;                                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Grout;                                             // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Persistence;                                       // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lacunarity;                                        // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OctaveNumber;                                      // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSpacing;                                      // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddSamplesForCollision;                            // 0x01DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionSampleSpacing;                            // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaneCutterDataflowNode) == 0x000008, "Wrong alignment on FPlaneCutterDataflowNode");
static_assert(sizeof(FPlaneCutterDataflowNode) == 0x0001E8, "Wrong size on FPlaneCutterDataflowNode");
static_assert(offsetof(FPlaneCutterDataflowNode, Collection) == 0x0000D0, "Member 'FPlaneCutterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, BoundingBox) == 0x000180, "Member 'FPlaneCutterDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, NumPlanes) == 0x0001B8, "Member 'FPlaneCutterDataflowNode::NumPlanes' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, RandomSeed) == 0x0001BC, "Member 'FPlaneCutterDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Grout) == 0x0001C0, "Member 'FPlaneCutterDataflowNode::Grout' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Amplitude) == 0x0001C4, "Member 'FPlaneCutterDataflowNode::Amplitude' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Frequency) == 0x0001C8, "Member 'FPlaneCutterDataflowNode::Frequency' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Persistence) == 0x0001CC, "Member 'FPlaneCutterDataflowNode::Persistence' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Lacunarity) == 0x0001D0, "Member 'FPlaneCutterDataflowNode::Lacunarity' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, OctaveNumber) == 0x0001D4, "Member 'FPlaneCutterDataflowNode::OctaveNumber' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, PointSpacing) == 0x0001D8, "Member 'FPlaneCutterDataflowNode::PointSpacing' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, AddSamplesForCollision) == 0x0001DC, "Member 'FPlaneCutterDataflowNode::AddSamplesForCollision' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, CollisionSampleSpacing) == 0x0001E0, "Member 'FPlaneCutterDataflowNode::CollisionSampleSpacing' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.HashStringDataflowNode
// 0x0018 (0x00E8 - 0x00D0)
struct FHashStringDataflowNode final : public FDataflowNode
{
public:
	class FString                                 String;                                            // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hash;                                              // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHashStringDataflowNode) == 0x000008, "Wrong alignment on FHashStringDataflowNode");
static_assert(sizeof(FHashStringDataflowNode) == 0x0000E8, "Wrong size on FHashStringDataflowNode");
static_assert(offsetof(FHashStringDataflowNode, String) == 0x0000D0, "Member 'FHashStringDataflowNode::String' has a wrong offset!");
static_assert(offsetof(FHashStringDataflowNode, Hash) == 0x0000E0, "Member 'FHashStringDataflowNode::Hash' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.HashVectorDataflowNode
// 0x0020 (0x00F0 - 0x00D0)
struct FHashVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hash;                                              // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHashVectorDataflowNode) == 0x000008, "Wrong alignment on FHashVectorDataflowNode");
static_assert(sizeof(FHashVectorDataflowNode) == 0x0000F0, "Wrong size on FHashVectorDataflowNode");
static_assert(offsetof(FHashVectorDataflowNode, Vector) == 0x0000D0, "Member 'FHashVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FHashVectorDataflowNode, Hash) == 0x0000E8, "Member 'FHashVectorDataflowNode::Hash' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToIntDataflowNode
// 0x0010 (0x00E0 - 0x00D0)
struct FFloatToIntDataflowNode final : public FDataflowNode
{
public:
	EFloatToIntFunctionEnum                       Function;                                          // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Float;                                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatToIntDataflowNode) == 0x000008, "Wrong alignment on FFloatToIntDataflowNode");
static_assert(sizeof(FFloatToIntDataflowNode) == 0x0000E0, "Wrong size on FFloatToIntDataflowNode");
static_assert(offsetof(FFloatToIntDataflowNode, Function) == 0x0000D0, "Member 'FFloatToIntDataflowNode::Function' has a wrong offset!");
static_assert(offsetof(FFloatToIntDataflowNode, Float) == 0x0000D4, "Member 'FFloatToIntDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToIntDataflowNode, Int) == 0x0000D8, "Member 'FFloatToIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MathConstantsDataflowNode
// 0x0008 (0x00D8 - 0x00D0)
struct FMathConstantsDataflowNode final : public FDataflowNode
{
public:
	EMathConstantsEnum                            Constant;                                          // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Float;                                             // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathConstantsDataflowNode) == 0x000008, "Wrong alignment on FMathConstantsDataflowNode");
static_assert(sizeof(FMathConstantsDataflowNode) == 0x0000D8, "Wrong size on FMathConstantsDataflowNode");
static_assert(offsetof(FMathConstantsDataflowNode, Constant) == 0x0000D0, "Member 'FMathConstantsDataflowNode::Constant' has a wrong offset!");
static_assert(offsetof(FMathConstantsDataflowNode, Float) == 0x0000D4, "Member 'FMathConstantsDataflowNode::Float' has a wrong offset!");

}

