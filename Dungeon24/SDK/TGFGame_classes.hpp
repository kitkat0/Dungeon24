#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TGFGame

#include "Basic.hpp"

#include "TGFFramework_classes.hpp"
#include "LyraGame_structs.hpp"
#include "LyraGame_classes.hpp"
#include "TGFGame_structs.hpp"
#include "UMG_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CommonUI_classes.hpp"
#include "TGFBattleProtocol_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameSettings_classes.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class TGFGame.TGFTradeSalesOrderResponseEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeSalesOrderResponseEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSalesOrderResponseEvent">();
	}
	static class UTGFTradeSalesOrderResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSalesOrderResponseEvent>();
	}
};
static_assert(alignof(UTGFTradeSalesOrderResponseEvent) == 0x000008, "Wrong alignment on UTGFTradeSalesOrderResponseEvent");
static_assert(sizeof(UTGFTradeSalesOrderResponseEvent) == 0x000028, "Wrong size on UTGFTradeSalesOrderResponseEvent");

// Class TGFGame.ACEReportService
// 0x0010 (0x0040 - 0x0030)
class UACEReportService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lua_ACEReportPlayerInBattle(int64 TargetOpenId, int32 TargetZoneId, const class FString& TargetPlayerName, class APlayerController* SourcePC);
	void SendACEReportRequest(class UTGFProtoTgfCSReportActionReqReportBodyPublic* Body);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ACEReportService">();
	}
	static class UACEReportService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UACEReportService>();
	}
};
static_assert(alignof(UACEReportService) == 0x000008, "Wrong alignment on UACEReportService");
static_assert(sizeof(UACEReportService) == 0x000040, "Wrong size on UACEReportService");

// Class TGFGame.ACEService
// 0x0018 (0x0048 - 0x0030)
class UACEService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameLoginSuccess(class UTGFEventArgs* Args);
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);
	void OnNetworkManagerExitState(class UTGFEventArgs* Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ACEService">();
	}
	static class UACEService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UACEService>();
	}
};
static_assert(alignof(UACEService) == 0x000008, "Wrong alignment on UACEService");
static_assert(sizeof(UACEService) == 0x000048, "Wrong size on UACEService");

// Class TGFGame.TGFTradeTradeUnlockStateUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeTradeUnlockStateUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeTradeUnlockStateUpdateEvent">();
	}
	static class UTGFTradeTradeUnlockStateUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeTradeUnlockStateUpdateEvent>();
	}
};
static_assert(alignof(UTGFTradeTradeUnlockStateUpdateEvent) == 0x000008, "Wrong alignment on UTGFTradeTradeUnlockStateUpdateEvent");
static_assert(sizeof(UTGFTradeTradeUnlockStateUpdateEvent) == 0x000028, "Wrong size on UTGFTradeTradeUnlockStateUpdateEvent");

// Class TGFGame.ActivityCenterListRsponse
// 0x0008 (0x0030 - 0x0028)
class UActivityCenterListRsponse final : public UTGFEventArgs
{
public:
	class UTGFProtoTgfDUserActivityDataList*      List;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityCenterListRsponse">();
	}
	static class UActivityCenterListRsponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityCenterListRsponse>();
	}
};
static_assert(alignof(UActivityCenterListRsponse) == 0x000008, "Wrong alignment on UActivityCenterListRsponse");
static_assert(sizeof(UActivityCenterListRsponse) == 0x000030, "Wrong size on UActivityCenterListRsponse");
static_assert(offsetof(UActivityCenterListRsponse, List) == 0x000028, "Member 'UActivityCenterListRsponse::List' has a wrong offset!");

// Class TGFGame.ActivityCenterUpdate
// 0x0008 (0x0030 - 0x0028)
class UActivityCenterUpdate final : public UTGFEventArgs
{
public:
	class UTGFProtoTgfDUserActivityDataList*      List;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityCenterUpdate">();
	}
	static class UActivityCenterUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityCenterUpdate>();
	}
};
static_assert(alignof(UActivityCenterUpdate) == 0x000008, "Wrong alignment on UActivityCenterUpdate");
static_assert(sizeof(UActivityCenterUpdate) == 0x000030, "Wrong size on UActivityCenterUpdate");
static_assert(offsetof(UActivityCenterUpdate, List) == 0x000028, "Member 'UActivityCenterUpdate::List' has a wrong offset!");

// Class TGFGame.TGFResolutionService
// 0x0070 (0x00A0 - 0x0030)
class UTGFResolutionService final : public UGameInstanceSubsystem
{
public:
	TArray<struct FTGFScreenResolutionPackage>    ResolutionPacks;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIntPoint>                      DPLimitFullScreenResolutionList;                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Version;                                           // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFResolutionService">();
	}
	static class UTGFResolutionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFResolutionService>();
	}
};
static_assert(alignof(UTGFResolutionService) == 0x000008, "Wrong alignment on UTGFResolutionService");
static_assert(sizeof(UTGFResolutionService) == 0x0000A0, "Wrong size on UTGFResolutionService");
static_assert(offsetof(UTGFResolutionService, ResolutionPacks) == 0x000030, "Member 'UTGFResolutionService::ResolutionPacks' has a wrong offset!");
static_assert(offsetof(UTGFResolutionService, DPLimitFullScreenResolutionList) == 0x000070, "Member 'UTGFResolutionService::DPLimitFullScreenResolutionList' has a wrong offset!");
static_assert(offsetof(UTGFResolutionService, Version) == 0x000088, "Member 'UTGFResolutionService::Version' has a wrong offset!");

// Class TGFGame.ActivityCenterService
// 0x0010 (0x0040 - 0x0030)
class UActivityCenterService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfDUserActivityDataList*      ActivityCenterData;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UTGFProtoTgfDUserActivityDataList* GetActivityCenterData();
	bool IsActivityListEmpty();
	void SendActivityCenterListReq();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityCenterService">();
	}
	static class UActivityCenterService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityCenterService>();
	}
};
static_assert(alignof(UActivityCenterService) == 0x000008, "Wrong alignment on UActivityCenterService");
static_assert(sizeof(UActivityCenterService) == 0x000040, "Wrong size on UActivityCenterService");
static_assert(offsetof(UActivityCenterService, ActivityCenterData) == 0x000038, "Member 'UActivityCenterService::ActivityCenterData' has a wrong offset!");

// Class TGFGame.TGFReceiveActivityRandomRewardEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFReceiveActivityRandomRewardEvent final : public UTGFEventArgs
{
public:
	TArray<class UTGFProtoTgfDItemBasic*>         ItemBasics;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFReceiveActivityRandomRewardEvent">();
	}
	static class UTGFReceiveActivityRandomRewardEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFReceiveActivityRandomRewardEvent>();
	}
};
static_assert(alignof(UTGFReceiveActivityRandomRewardEvent) == 0x000008, "Wrong alignment on UTGFReceiveActivityRandomRewardEvent");
static_assert(sizeof(UTGFReceiveActivityRandomRewardEvent) == 0x000038, "Wrong size on UTGFReceiveActivityRandomRewardEvent");
static_assert(offsetof(UTGFReceiveActivityRandomRewardEvent, ItemBasics) == 0x000028, "Member 'UTGFReceiveActivityRandomRewardEvent::ItemBasics' has a wrong offset!");

// Class TGFGame.TGFNetworkManagerExitStateEvent
// 0x0020 (0x0048 - 0x0028)
class UTGFNetworkManagerExitStateEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFNetworkManagerExitStateEvent">();
	}
	static class UTGFNetworkManagerExitStateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFNetworkManagerExitStateEvent>();
	}
};
static_assert(alignof(UTGFNetworkManagerExitStateEvent) == 0x000008, "Wrong alignment on UTGFNetworkManagerExitStateEvent");
static_assert(sizeof(UTGFNetworkManagerExitStateEvent) == 0x000048, "Wrong size on UTGFNetworkManagerExitStateEvent");

// Class TGFGame.ActivityRewardService
// 0x0008 (0x0038 - 0x0030)
class UActivityRewardService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetActivityRandomReward(int32 ActivityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityRewardService">();
	}
	static class UActivityRewardService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityRewardService>();
	}
};
static_assert(alignof(UActivityRewardService) == 0x000008, "Wrong alignment on UActivityRewardService");
static_assert(sizeof(UActivityRewardService) == 0x000038, "Wrong size on UActivityRewardService");

// Class TGFGame.AlertWindow
// 0x0008 (0x02C0 - 0x02B8)
class UAlertWindow final : public UTGFWindow
{
public:
	class UAlertWindowArgs*                       AlertWindowArgs;                                   // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertWindow">();
	}
	static class UAlertWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlertWindow>();
	}
};
static_assert(alignof(UAlertWindow) == 0x000008, "Wrong alignment on UAlertWindow");
static_assert(sizeof(UAlertWindow) == 0x0002C0, "Wrong size on UAlertWindow");
static_assert(offsetof(UAlertWindow, AlertWindowArgs) == 0x0002B8, "Member 'UAlertWindow::AlertWindowArgs' has a wrong offset!");

// Class TGFGame.TGFTradeAuctionInfoResponseEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeAuctionInfoResponseEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeAuctionInfoResponseEvent">();
	}
	static class UTGFTradeAuctionInfoResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeAuctionInfoResponseEvent>();
	}
};
static_assert(alignof(UTGFTradeAuctionInfoResponseEvent) == 0x000008, "Wrong alignment on UTGFTradeAuctionInfoResponseEvent");
static_assert(sizeof(UTGFTradeAuctionInfoResponseEvent) == 0x000028, "Wrong size on UTGFTradeAuctionInfoResponseEvent");

// Class TGFGame.AlertWindowArgs
// 0x0040 (0x0070 - 0x0030)
class UAlertWindowArgs final : public UTGFWindowArgs
{
public:
	class FText                                   Message;                                           // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ConfirmText;                                       // 0x0048(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertWindowArgs">();
	}
	static class UAlertWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlertWindowArgs>();
	}
};
static_assert(alignof(UAlertWindowArgs) == 0x000008, "Wrong alignment on UAlertWindowArgs");
static_assert(sizeof(UAlertWindowArgs) == 0x000070, "Wrong size on UAlertWindowArgs");
static_assert(offsetof(UAlertWindowArgs, Message) == 0x000030, "Member 'UAlertWindowArgs::Message' has a wrong offset!");
static_assert(offsetof(UAlertWindowArgs, ConfirmText) == 0x000048, "Member 'UAlertWindowArgs::ConfirmText' has a wrong offset!");

// Class TGFGame.AppService
// 0x00D0 (0x0100 - 0x0030)
class UAppService final : public UTGFService
{
public:
	uint8                                         Pad_30[0xD0];                                      // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastGameLogoutEvent();
	void ChangeHallState(const EHallState& InHallState);
	void CleanWindows();
	class AActor* GetWardrobeAvatarFromPool();
	void LogoutGame();
	void Lua_OnEnterStateHall();
	void OnCreateRoleLevelLoaded();
	void OnCreateRoleLevelShown();
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);
	void OnWardrobeLevelHidden();
	void OnWardrobeLevelLoaded();
	void OnWardrobeLevelShown();
	class UUserWidget* OpenWindow(const class FString& Path, class UTGFWindowArgs* Args, bool bIsUnique);
	void RecycleWardrobeAvatar(class AActor* InRecycleActor);
	void RollbackHallState();
	void SetCreateRoleLevelVisible(bool bValue);
	void SetWardrobeLevelVisible(bool bValue);
	void ShouldShutDownHallGlobalEffects(bool bIsOpen);
	class AActor* SpawnActorToWardrobeLevel(class UClass* Param_Class, const struct FVector& Location, const struct FRotator& Rotation);
	void ToggleCurrentLevelCompRegistration(bool bValue);
	void ToggleOptimizationForSceneCapture(bool bIsOpen);

	bool CheckAboutToQuit() const;
	void ConfirmToQuit() const;
	EAppState GetAppState() const;
	EHallState GetHallState() const;
	void LoadHall() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppService">();
	}
	static class UAppService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppService>();
	}
};
static_assert(alignof(UAppService) == 0x000008, "Wrong alignment on UAppService");
static_assert(sizeof(UAppService) == 0x000100, "Wrong size on UAppService");

// Class TGFGame.TGFNetworkManager
// 0x0078 (0x00A8 - 0x0030)
class UTGFNetworkManager final : public UTGFSubsystem
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameLoginFailed(class UTGFEventArgs* Args);
	void OnGameLoginSuccess(class UTGFEventArgs* Args);
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnGamePreLoginFailed(class UTGFEventArgs* Args);
	void OnGamePreLoginSuccess(class UTGFEventArgs* Args);
	void OnSyncPlayerInfoSuccess(class UTGFEventArgs* Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFNetworkManager">();
	}
	static class UTGFNetworkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFNetworkManager>();
	}
};
static_assert(alignof(UTGFNetworkManager) == 0x000008, "Wrong alignment on UTGFNetworkManager");
static_assert(sizeof(UTGFNetworkManager) == 0x0000A8, "Wrong size on UTGFNetworkManager");

// Class TGFGame.AsyncAction_ShowAlert
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_ShowAlert final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnResult;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAlertWindowArgs*                       Args;                                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncAction_ShowAlert* ShowAlert(class UObject* InWorldContextObject, const class FText& Message, const class FText& ConfirmText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_ShowAlert">();
	}
	static class UAsyncAction_ShowAlert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_ShowAlert>();
	}
};
static_assert(alignof(UAsyncAction_ShowAlert) == 0x000008, "Wrong alignment on UAsyncAction_ShowAlert");
static_assert(sizeof(UAsyncAction_ShowAlert) == 0x000050, "Wrong size on UAsyncAction_ShowAlert");
static_assert(offsetof(UAsyncAction_ShowAlert, OnResult) == 0x000030, "Member 'UAsyncAction_ShowAlert::OnResult' has a wrong offset!");
static_assert(offsetof(UAsyncAction_ShowAlert, WorldContextObject) == 0x000040, "Member 'UAsyncAction_ShowAlert::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UAsyncAction_ShowAlert, Args) == 0x000048, "Member 'UAsyncAction_ShowAlert::Args' has a wrong offset!");

// Class TGFGame.AsyncAction_ShowConfirm
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_ShowConfirm final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnResult;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfirmWindowArgs*                     Args;                                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncAction_ShowConfirm* ShowConfirm(class UObject* InWorldContextObject, const class FText& Message, const class FText& ConfirmText, const class FText& CancelText, class UObject* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_ShowConfirm">();
	}
	static class UAsyncAction_ShowConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_ShowConfirm>();
	}
};
static_assert(alignof(UAsyncAction_ShowConfirm) == 0x000008, "Wrong alignment on UAsyncAction_ShowConfirm");
static_assert(sizeof(UAsyncAction_ShowConfirm) == 0x000050, "Wrong size on UAsyncAction_ShowConfirm");
static_assert(offsetof(UAsyncAction_ShowConfirm, OnResult) == 0x000030, "Member 'UAsyncAction_ShowConfirm::OnResult' has a wrong offset!");
static_assert(offsetof(UAsyncAction_ShowConfirm, WorldContextObject) == 0x000040, "Member 'UAsyncAction_ShowConfirm::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UAsyncAction_ShowConfirm, Args) == 0x000048, "Member 'UAsyncAction_ShowConfirm::Args' has a wrong offset!");

// Class TGFGame.RoleAttributeCoreInfo
// 0x0020 (0x0048 - 0x0028)
class URoleAttributeCoreInfo final : public UObject
{
public:
	float                                         Health;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dexterity;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stamina;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intelligence;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Will;                                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Faith;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipLevel;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleAttributeCoreInfo">();
	}
	static class URoleAttributeCoreInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleAttributeCoreInfo>();
	}
};
static_assert(alignof(URoleAttributeCoreInfo) == 0x000008, "Wrong alignment on URoleAttributeCoreInfo");
static_assert(sizeof(URoleAttributeCoreInfo) == 0x000048, "Wrong size on URoleAttributeCoreInfo");
static_assert(offsetof(URoleAttributeCoreInfo, Health) == 0x000028, "Member 'URoleAttributeCoreInfo::Health' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, Strength) == 0x00002C, "Member 'URoleAttributeCoreInfo::Strength' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, Dexterity) == 0x000030, "Member 'URoleAttributeCoreInfo::Dexterity' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, Stamina) == 0x000034, "Member 'URoleAttributeCoreInfo::Stamina' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, Intelligence) == 0x000038, "Member 'URoleAttributeCoreInfo::Intelligence' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, Will) == 0x00003C, "Member 'URoleAttributeCoreInfo::Will' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, Faith) == 0x000040, "Member 'URoleAttributeCoreInfo::Faith' has a wrong offset!");
static_assert(offsetof(URoleAttributeCoreInfo, EquipLevel) == 0x000044, "Member 'URoleAttributeCoreInfo::EquipLevel' has a wrong offset!");

// Class TGFGame.TGFBannerUpdateConfigEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFBannerUpdateConfigEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBannerUpdateConfigEvent">();
	}
	static class UTGFBannerUpdateConfigEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBannerUpdateConfigEvent>();
	}
};
static_assert(alignof(UTGFBannerUpdateConfigEvent) == 0x000008, "Wrong alignment on UTGFBannerUpdateConfigEvent");
static_assert(sizeof(UTGFBannerUpdateConfigEvent) == 0x000028, "Wrong size on UTGFBannerUpdateConfigEvent");

// Class TGFGame.BannerScrollView
// 0x0000 (0x0278 - 0x0278)
class UBannerScrollView final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannerScrollView">();
	}
	static class UBannerScrollView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannerScrollView>();
	}
};
static_assert(alignof(UBannerScrollView) == 0x000008, "Wrong alignment on UBannerScrollView");
static_assert(sizeof(UBannerScrollView) == 0x000278, "Wrong size on UBannerScrollView");

// Class TGFGame.UnlockBanWindowArgs
// 0x0030 (0x0060 - 0x0030)
class UUnlockBanWindowArgs final : public UTGFWindowArgs
{
public:
	class FText                                   Message;                                           // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCustomerService;                                  // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x17];                                      // 0x0049(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockBanWindowArgs">();
	}
	static class UUnlockBanWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockBanWindowArgs>();
	}
};
static_assert(alignof(UUnlockBanWindowArgs) == 0x000008, "Wrong alignment on UUnlockBanWindowArgs");
static_assert(sizeof(UUnlockBanWindowArgs) == 0x000060, "Wrong size on UUnlockBanWindowArgs");
static_assert(offsetof(UUnlockBanWindowArgs, Message) == 0x000030, "Member 'UUnlockBanWindowArgs::Message' has a wrong offset!");
static_assert(offsetof(UUnlockBanWindowArgs, bCustomerService) == 0x000048, "Member 'UUnlockBanWindowArgs::bCustomerService' has a wrong offset!");

// Class TGFGame.BannerSubsystem
// 0x0060 (0x0090 - 0x0030)
class UBannerSubsystem final : public UTGFSubsystem
{
public:
	int32                                         MyConfigExpiredTime;                               // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MyLastUpdateConfigTimestamp;                       // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FBannerConfig>             MyBannerConfigMap;                                 // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	bool GetBannerConfigList(TArray<struct FBannerConfig>* BannerConfigList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannerSubsystem">();
	}
	static class UBannerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannerSubsystem>();
	}
};
static_assert(alignof(UBannerSubsystem) == 0x000008, "Wrong alignment on UBannerSubsystem");
static_assert(sizeof(UBannerSubsystem) == 0x000090, "Wrong size on UBannerSubsystem");
static_assert(offsetof(UBannerSubsystem, MyConfigExpiredTime) == 0x000030, "Member 'UBannerSubsystem::MyConfigExpiredTime' has a wrong offset!");
static_assert(offsetof(UBannerSubsystem, MyLastUpdateConfigTimestamp) == 0x000038, "Member 'UBannerSubsystem::MyLastUpdateConfigTimestamp' has a wrong offset!");
static_assert(offsetof(UBannerSubsystem, MyBannerConfigMap) == 0x000040, "Member 'UBannerSubsystem::MyBannerConfigMap' has a wrong offset!");

// Class TGFGame.TGFBattlePassPassportInfoUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFBattlePassPassportInfoUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattlePassPassportInfoUpdateEvent">();
	}
	static class UTGFBattlePassPassportInfoUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattlePassPassportInfoUpdateEvent>();
	}
};
static_assert(alignof(UTGFBattlePassPassportInfoUpdateEvent) == 0x000008, "Wrong alignment on UTGFBattlePassPassportInfoUpdateEvent");
static_assert(sizeof(UTGFBattlePassPassportInfoUpdateEvent) == 0x000028, "Wrong size on UTGFBattlePassPassportInfoUpdateEvent");

// Class TGFGame.TradeSaleService
// 0x0028 (0x0058 - 0x0030)
class UTradeSaleService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTradeSaleItem*>                 SaleableItems;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	TArray<class UTradeSaleItem*> GetSaleableItems(const int32 MarketId, const TArray<ETGFProtoTgfEnGearEquipSubType>& Types, ETGFProtoTgfEnItemRarity Rarity, bool SortByPriceUp);
	void OnGameLogout(class UTGFEventArgs* Args);
	void PublishAuctionOrder(int32 MarketId, const struct FTGFItem& SaleItem, int32 Price, int32 CostType, int32 FixedPrice);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeSaleService">();
	}
	static class UTradeSaleService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeSaleService>();
	}
};
static_assert(alignof(UTradeSaleService) == 0x000008, "Wrong alignment on UTradeSaleService");
static_assert(sizeof(UTradeSaleService) == 0x000058, "Wrong size on UTradeSaleService");
static_assert(offsetof(UTradeSaleService, SaleableItems) == 0x000048, "Member 'UTradeSaleService::SaleableItems' has a wrong offset!");

// Class TGFGame.TGFBattleBuyPassPassportEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFBattleBuyPassPassportEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattleBuyPassPassportEvent">();
	}
	static class UTGFBattleBuyPassPassportEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattleBuyPassPassportEvent>();
	}
};
static_assert(alignof(UTGFBattleBuyPassPassportEvent) == 0x000008, "Wrong alignment on UTGFBattleBuyPassPassportEvent");
static_assert(sizeof(UTGFBattleBuyPassPassportEvent) == 0x000028, "Wrong size on UTGFBattleBuyPassPassportEvent");

// Class TGFGame.TGFBattlePassPassportReceiveRewardsEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFBattlePassPassportReceiveRewardsEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattlePassPassportReceiveRewardsEvent">();
	}
	static class UTGFBattlePassPassportReceiveRewardsEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattlePassPassportReceiveRewardsEvent>();
	}
};
static_assert(alignof(UTGFBattlePassPassportReceiveRewardsEvent) == 0x000008, "Wrong alignment on UTGFBattlePassPassportReceiveRewardsEvent");
static_assert(sizeof(UTGFBattlePassPassportReceiveRewardsEvent) == 0x000028, "Wrong size on UTGFBattlePassPassportReceiveRewardsEvent");

// Class TGFGame.UnlockService
// 0x01F0 (0x0220 - 0x0030)
class UUnlockService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMyHaveBeenKicked;                                 // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBanModule                             MyBanModule;                                       // 0x0040(0x0088)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUnlockModuleMap                       MyGlobalUnlockModuleMap;                           // 0x00C8(0x0058)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUnlockModuleMap                       MyUserUnlockModuleMap;                             // 0x0120(0x0058)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FModuleCircularCfgDataMap              MyModuleCircularQueueMap;                          // 0x0178(0x0058)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FTimerHandle>              MyModuleCircularTimerMap;                          // 0x01D0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetModuleBannedMessage(int32 InModuleId);
	class FText GetModuleCircularLockMessage(int32 InModuleId);
	class FText GetModuleCircularNextTimeMessage(int32 InModuleId);
	class FText GetModuleGlobalForbidMessage(int32 InModuleId);
	class FText GetModuleLockMessage(int32 InModuleId);
	class FText GetModuleNextTimeMessage(int32 InModuleId);
	class FText GetModuleTimeLockMessage(int32 InModuleId);
	bool IsModuleAllowed(int32 InModuleId, bool bIsAlert, bool bIsToast);
	bool IsModuleBanned(int32 InModuleId, bool bIsAlert, bool bIsToast);
	bool IsModuleCircularLock(int32 InModuleId, bool bIsAlert, bool bIsToast);
	bool IsModuleGlobalForbid(int32 InModuleId, bool bIsAlert, bool bIsToast);
	bool IsModuleLock(int32 InModuleId, bool bIsAlert, bool bIsToast);
	bool IsModuleTimeLock(int32 InModuleId, bool bIsAlert, bool bIsToast);
	void ShowGameKickedAlert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockService">();
	}
	static class UUnlockService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockService>();
	}
};
static_assert(alignof(UUnlockService) == 0x000008, "Wrong alignment on UUnlockService");
static_assert(sizeof(UUnlockService) == 0x000220, "Wrong size on UUnlockService");
static_assert(offsetof(UUnlockService, bMyHaveBeenKicked) == 0x000038, "Member 'UUnlockService::bMyHaveBeenKicked' has a wrong offset!");
static_assert(offsetof(UUnlockService, MyBanModule) == 0x000040, "Member 'UUnlockService::MyBanModule' has a wrong offset!");
static_assert(offsetof(UUnlockService, MyGlobalUnlockModuleMap) == 0x0000C8, "Member 'UUnlockService::MyGlobalUnlockModuleMap' has a wrong offset!");
static_assert(offsetof(UUnlockService, MyUserUnlockModuleMap) == 0x000120, "Member 'UUnlockService::MyUserUnlockModuleMap' has a wrong offset!");
static_assert(offsetof(UUnlockService, MyModuleCircularQueueMap) == 0x000178, "Member 'UUnlockService::MyModuleCircularQueueMap' has a wrong offset!");
static_assert(offsetof(UUnlockService, MyModuleCircularTimerMap) == 0x0001D0, "Member 'UUnlockService::MyModuleCircularTimerMap' has a wrong offset!");

// Class TGFGame.TGFBattlePassPassportReceiveCycleRewardsEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFBattlePassPassportReceiveCycleRewardsEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattlePassPassportReceiveCycleRewardsEvent">();
	}
	static class UTGFBattlePassPassportReceiveCycleRewardsEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattlePassPassportReceiveCycleRewardsEvent>();
	}
};
static_assert(alignof(UTGFBattlePassPassportReceiveCycleRewardsEvent) == 0x000008, "Wrong alignment on UTGFBattlePassPassportReceiveCycleRewardsEvent");
static_assert(sizeof(UTGFBattlePassPassportReceiveCycleRewardsEvent) == 0x000028, "Wrong size on UTGFBattlePassPassportReceiveCycleRewardsEvent");

// Class TGFGame.TGFBattlePassPassportRefreshQuestEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFBattlePassPassportRefreshQuestEvent final : public UTGFEventArgs
{
public:
	int32                                         QuestId;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattlePassPassportRefreshQuestEvent">();
	}
	static class UTGFBattlePassPassportRefreshQuestEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattlePassPassportRefreshQuestEvent>();
	}
};
static_assert(alignof(UTGFBattlePassPassportRefreshQuestEvent) == 0x000008, "Wrong alignment on UTGFBattlePassPassportRefreshQuestEvent");
static_assert(sizeof(UTGFBattlePassPassportRefreshQuestEvent) == 0x000030, "Wrong size on UTGFBattlePassPassportRefreshQuestEvent");
static_assert(offsetof(UTGFBattlePassPassportRefreshQuestEvent, QuestId) == 0x000028, "Member 'UTGFBattlePassPassportRefreshQuestEvent::QuestId' has a wrong offset!");

// Class TGFGame.VelocityService
// 0x0108 (0x0138 - 0x0030)
class UVelocityService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTGFRegionDetailData                   Region_detail;                                     // 0x0040(0x0098)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTGFRegionData                         CurSelectRegionData;                               // 0x00F8(0x0040)(NativeAccessSpecifierPrivate)

public:
	void CdnHTTPRequest(const class FString& URL);
	void ClosePersistentSend();
	struct FTGFRegionData GetCurSelectRegionData();
	int32 GetLatencyByRegionId(const class FString& RegionId);
	const struct FTGFRegionDetailData GetRegionDetailData();
	void OpenPersistentSend();
	void SetCurSelectRegionData(const struct FTGFRegionData& RegionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelocityService">();
	}
	static class UVelocityService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelocityService>();
	}
};
static_assert(alignof(UVelocityService) == 0x000008, "Wrong alignment on UVelocityService");
static_assert(sizeof(UVelocityService) == 0x000138, "Wrong size on UVelocityService");
static_assert(offsetof(UVelocityService, Region_detail) == 0x000040, "Member 'UVelocityService::Region_detail' has a wrong offset!");
static_assert(offsetof(UVelocityService, CurSelectRegionData) == 0x0000F8, "Member 'UVelocityService::CurSelectRegionData' has a wrong offset!");

// Class TGFGame.BattlePassRewardService
// 0x0020 (0x0050 - 0x0030)
class UBattlePassRewardService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfDUserActivityData*          PassportActivityInfo;                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBattlePassUnlocked();
	void Lua_Initialized();
	void OnActivityCenterListResponse(class UTGFEventArgs* Args);
	void OnActivityCenterUpdate(class UTGFEventArgs* Args);
	void SendBuyPassportReq(int32 InActivityId);
	void SendReceiveCycleRewardsReq(int32 InActivityId, int32 InGradeQty, const TArray<struct FTGFItemOffset>& InRewardItems);
	void SendReceiveRewardsReq(int32 InActivityId, int32 InRewardId, const TArray<struct FTGFItemOffset>& InRewardItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassRewardService">();
	}
	static class UBattlePassRewardService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassRewardService>();
	}
};
static_assert(alignof(UBattlePassRewardService) == 0x000008, "Wrong alignment on UBattlePassRewardService");
static_assert(sizeof(UBattlePassRewardService) == 0x000050, "Wrong size on UBattlePassRewardService");
static_assert(offsetof(UBattlePassRewardService, PassportActivityInfo) == 0x000040, "Member 'UBattlePassRewardService::PassportActivityInfo' has a wrong offset!");

// Class TGFGame.BattlePassTaskService
// 0x0018 (0x0048 - 0x0030)
class UBattlePassTaskService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lua_Initialized();
	void SendRefreshQuestReq(int32 InActivityId, int32 InQuestId);
	void SetDailyTaskToastShowed(bool bShowed);

	bool GetDailyTaskToastShowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassTaskService">();
	}
	static class UBattlePassTaskService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassTaskService>();
	}
};
static_assert(alignof(UBattlePassTaskService) == 0x000008, "Wrong alignment on UBattlePassTaskService");
static_assert(sizeof(UBattlePassTaskService) == 0x000048, "Wrong size on UBattlePassTaskService");

// Class TGFGame.UserRoleCacheService
// 0x0330 (0x0360 - 0x0030)
class UUserRoleCacheService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TickUpdateTimerHandle;                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         CurrentUpdateHandler;                              // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int64, struct FPlayerKey>                UpdateHandlerKeyMap;                               // 0x0050(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FPlayerKey, struct FUpdateHandlerArray> UpdateHandlerArrayMap;                             // 0x00A0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FPlayerKey, struct FUpdateHandlerArray> SubscribeHandlerArrayMap;                          // 0x00F0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x40];                                     // 0x0140(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUserKey, class UUserInfo*>       UserCacheMap;                                      // 0x0180(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int64, struct FUserUpdateCallback>       UserUpdateCallbackMap;                             // 0x01D0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FRoleKey, class URoleInfo*>       RoleCacheMap;                                      // 0x0220(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int64, struct FRoleUpdateCallback>       RoleUpdateCallbackMap;                             // 0x0270(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGlobalUserKey, class UGlobalUserInfo*> GlobalUserCacheMap;                                // 0x02C0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int64, struct FGlobalUserUpdateCallback> GlobalUserUpdateCallbackMap;                       // 0x0310(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	class UGlobalUserInfo* GetGlobalUserInfo(const struct FGlobalUserKey& GlobalUserKey);
	class URoleInfo* GetRoleInfoByKey(const struct FRoleKey& RoleKey, bool bMustValid);
	int64 GetRoleInfoCallbackHandler(const struct FRoleKey& RoleKey, bool bIsSubscribe);
	TMap<struct FRoleKey, class URoleInfo*> GetRoleInfoMapByKeySet(const TSet<struct FRoleKey>& RoleKeySet, bool bMustValid, bool* bOutAllValid);
	int64 GetRoleInfoMapCallbackHandler(const TSet<struct FRoleKey>& RoleKeySet);
	class UUserInfo* GetUserInfoByKey(const struct FUserKey& UserKey, bool bMustValid);
	int64 GetUserInfoCallbackHandler(const struct FUserKey& UserKey, bool bIsSubscribe);
	TMap<struct FUserKey, class UUserInfo*> GetUserInfoMapByKeySet(const TSet<struct FUserKey>& UserKeySet, bool bMustValid, bool* bOutAllValid);
	int64 GetUserInfoMapCallbackHandler(const TSet<struct FUserKey>& UserKeySet);
	void Lua_AppearanceCaptureFinish(int64 RoleGuid, class UObject* AppearanceTexture);
	void Lua_ExecuteUpdateEvent(int64 UpdateHandler);
	void Lua_Initialized();
	void OnAppearanceTextureCaptureFinish(int64 RoleGuid, class UObject* SlateBrush);
	void OnHostPlayerEquipChange(class UTGFEventArgs* Args);
	void OnUpdateItemsNoti(class UTGFEventArgs* Args);
	void RemoveUpdateHandler(int64 UpdateHandler);
	void ResetAllRoleInfo();
	void ResetAllUserInfo();
	void ResetRoleInfoByKey(const struct FRoleKey& RoleKey);
	void ResetUserInfoByKey(const struct FUserKey& UserKey);

	struct FRoleKey GetSelfRoleKey() const;
	struct FUserKey GetSelfUserKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserRoleCacheService">();
	}
	static class UUserRoleCacheService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserRoleCacheService>();
	}
};
static_assert(alignof(UUserRoleCacheService) == 0x000008, "Wrong alignment on UUserRoleCacheService");
static_assert(sizeof(UUserRoleCacheService) == 0x000360, "Wrong size on UUserRoleCacheService");
static_assert(offsetof(UUserRoleCacheService, TickUpdateTimerHandle) == 0x000040, "Member 'UUserRoleCacheService::TickUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, CurrentUpdateHandler) == 0x000048, "Member 'UUserRoleCacheService::CurrentUpdateHandler' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, UpdateHandlerKeyMap) == 0x000050, "Member 'UUserRoleCacheService::UpdateHandlerKeyMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, UpdateHandlerArrayMap) == 0x0000A0, "Member 'UUserRoleCacheService::UpdateHandlerArrayMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, SubscribeHandlerArrayMap) == 0x0000F0, "Member 'UUserRoleCacheService::SubscribeHandlerArrayMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, UserCacheMap) == 0x000180, "Member 'UUserRoleCacheService::UserCacheMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, UserUpdateCallbackMap) == 0x0001D0, "Member 'UUserRoleCacheService::UserUpdateCallbackMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, RoleCacheMap) == 0x000220, "Member 'UUserRoleCacheService::RoleCacheMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, RoleUpdateCallbackMap) == 0x000270, "Member 'UUserRoleCacheService::RoleUpdateCallbackMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, GlobalUserCacheMap) == 0x0002C0, "Member 'UUserRoleCacheService::GlobalUserCacheMap' has a wrong offset!");
static_assert(offsetof(UUserRoleCacheService, GlobalUserUpdateCallbackMap) == 0x000310, "Member 'UUserRoleCacheService::GlobalUserUpdateCallbackMap' has a wrong offset!");

// Class TGFGame.TGFBattlePassTaskInfo
// 0x0070 (0x0098 - 0x0028)
class UTGFBattlePassTaskInfo final : public UObject
{
public:
	int32                                         ID;                                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETGFProtoTgfEnQuestProgressType, int64>  MapProgressTypeValue;                              // 0x0030(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnQuestStatus                     Status;                                            // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderWeight;                                       // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_TGFBattlePassTaskInfo;                       // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayPosition;                                   // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeadTask;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddProgressValue(int32 ProgressType, int64 Value);
	void ClearProgressValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattlePassTaskInfo">();
	}
	static class UTGFBattlePassTaskInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattlePassTaskInfo>();
	}
};
static_assert(alignof(UTGFBattlePassTaskInfo) == 0x000008, "Wrong alignment on UTGFBattlePassTaskInfo");
static_assert(sizeof(UTGFBattlePassTaskInfo) == 0x000098, "Wrong size on UTGFBattlePassTaskInfo");
static_assert(offsetof(UTGFBattlePassTaskInfo, ID) == 0x000028, "Member 'UTGFBattlePassTaskInfo::ID' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskInfo, MapProgressTypeValue) == 0x000030, "Member 'UTGFBattlePassTaskInfo::MapProgressTypeValue' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskInfo, Status) == 0x000080, "Member 'UTGFBattlePassTaskInfo::Status' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskInfo, OrderWeight) == 0x000084, "Member 'UTGFBattlePassTaskInfo::OrderWeight' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskInfo, Index_TGFBattlePassTaskInfo) == 0x000088, "Member 'UTGFBattlePassTaskInfo::Index_TGFBattlePassTaskInfo' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskInfo, DisplayPosition) == 0x00008C, "Member 'UTGFBattlePassTaskInfo::DisplayPosition' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskInfo, IsDeadTask) == 0x000090, "Member 'UTGFBattlePassTaskInfo::IsDeadTask' has a wrong offset!");

// Class TGFGame.TGFBattlePassTaskListItemObject
// 0x0028 (0x0050 - 0x0028)
class UTGFBattlePassTaskListItemObject final : public UObject
{
public:
	ETGFBattlePassTaskType                        Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressValue;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnQuestStatus                     Status;                                            // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RefreshLimit;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NextResetTimestamp;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_TGFBattlePassTaskListItemObject;             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFBattlePassTaskListItemObject">();
	}
	static class UTGFBattlePassTaskListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFBattlePassTaskListItemObject>();
	}
};
static_assert(alignof(UTGFBattlePassTaskListItemObject) == 0x000008, "Wrong alignment on UTGFBattlePassTaskListItemObject");
static_assert(sizeof(UTGFBattlePassTaskListItemObject) == 0x000050, "Wrong size on UTGFBattlePassTaskListItemObject");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, Type) == 0x000028, "Member 'UTGFBattlePassTaskListItemObject::Type' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, ID) == 0x00002C, "Member 'UTGFBattlePassTaskListItemObject::ID' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, ProgressValue) == 0x000030, "Member 'UTGFBattlePassTaskListItemObject::ProgressValue' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, Status) == 0x000034, "Member 'UTGFBattlePassTaskListItemObject::Status' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, RefreshLimit) == 0x000038, "Member 'UTGFBattlePassTaskListItemObject::RefreshLimit' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, NextResetTimestamp) == 0x000040, "Member 'UTGFBattlePassTaskListItemObject::NextResetTimestamp' has a wrong offset!");
static_assert(offsetof(UTGFBattlePassTaskListItemObject, Index_TGFBattlePassTaskListItemObject) == 0x000048, "Member 'UTGFBattlePassTaskListItemObject::Index_TGFBattlePassTaskListItemObject' has a wrong offset!");

// Class TGFGame.UnlockBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UUnlockBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetModuleBannedMessage(int32 ModuleId);
	static class FText GetModuleCircularNextTimeMessage(int32 ModuleId);
	static class FText GetModuleGlobalForbidMessage(int32 ModuleId);
	static class FText GetModuleLockMessage(int32 ModuleId);
	static class FText GetModuleNextTimeMessage(int32 ModuleId);
	static class FText GetModuleTimeLockMessage(int32 ModuleId);
	static bool IsModuleAllowed(int32 ModuleId, bool bIsAlert, bool bIsToast);
	static bool IsModuleBanned(int32 ModuleId, bool bIsAlert, bool bIsToast);
	static bool IsModuleGlobalForbid(int32 ModuleId, bool bIsAlert, bool bIsToast);
	static bool IsModuleLock(int32 ModuleId, bool bIsAlert, bool bIsToast);
	static bool IsModuleTimeLock(int32 ModuleId, bool bIsAlert, bool bIsToast);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockBlueprintLibrary">();
	}
	static class UUnlockBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockBlueprintLibrary>();
	}
};
static_assert(alignof(UUnlockBlueprintLibrary) == 0x000008, "Wrong alignment on UUnlockBlueprintLibrary");
static_assert(sizeof(UUnlockBlueprintLibrary) == 0x000028, "Wrong size on UUnlockBlueprintLibrary");

// Class TGFGame.MoonPhaseChangeEvent
// 0x0008 (0x0030 - 0x0028)
class UMoonPhaseChangeEvent final : public UTGFEventArgs
{
public:
	int32                                         Phase;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonPhaseChangeEvent">();
	}
	static class UMoonPhaseChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonPhaseChangeEvent>();
	}
};
static_assert(alignof(UMoonPhaseChangeEvent) == 0x000008, "Wrong alignment on UMoonPhaseChangeEvent");
static_assert(sizeof(UMoonPhaseChangeEvent) == 0x000030, "Wrong size on UMoonPhaseChangeEvent");
static_assert(offsetof(UMoonPhaseChangeEvent, Phase) == 0x000028, "Member 'UMoonPhaseChangeEvent::Phase' has a wrong offset!");

// Class TGFGame.BattleService
// 0x0030 (0x0060 - 0x0030)
class UBattleService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           MoonPhaseTimer;                                    // 0x0048(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartBeginnerLevel(class FName MapName, bool EnterFromHall);
	void StartLocalBattle(class FName MapName);
	void StartLocalFlawlessBattle(class FName MapName, bool Flawless, int32 WinCount, bool RewardsAvailable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleService">();
	}
	static class UBattleService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleService>();
	}
};
static_assert(alignof(UBattleService) == 0x000008, "Wrong alignment on UBattleService");
static_assert(sizeof(UBattleService) == 0x000060, "Wrong size on UBattleService");
static_assert(offsetof(UBattleService, MoonPhaseTimer) == 0x000048, "Member 'UBattleService::MoonPhaseTimer' has a wrong offset!");

// Class TGFGame.UserInfo
// 0x0098 (0x00C0 - 0x0028)
class UUserInfo final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnUserTableDataVersion            DataVersion;                                       // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UpdateTimestamp;                                   // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserKey                               UserKey;                                           // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleKey                               CurrentRoleKey;                                    // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnline;                                         // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LoginTimestamp;                                    // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LogoutTimestamp;                                   // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMatching;                                       // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBattle;                                       // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         TeamId;                                            // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamMemberCount;                                   // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserNickName;                                      // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NickNameBanTimestamp;                              // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoomKey                               RoomKey;                                           // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AvatarTypeId;                                      // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvatarBoxTypeId;                                   // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TitleTypeId;                                       // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsExpired() const;
	bool GetIsUnregistered() const;
	bool GetIsValid() const;
	class FString GetNickname() const;
	int64 GetTimeOffline() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserInfo">();
	}
	static class UUserInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserInfo>();
	}
};
static_assert(alignof(UUserInfo) == 0x000008, "Wrong alignment on UUserInfo");
static_assert(sizeof(UUserInfo) == 0x0000C0, "Wrong size on UUserInfo");
static_assert(offsetof(UUserInfo, bIsValid) == 0x000028, "Member 'UUserInfo::bIsValid' has a wrong offset!");
static_assert(offsetof(UUserInfo, DataVersion) == 0x000029, "Member 'UUserInfo::DataVersion' has a wrong offset!");
static_assert(offsetof(UUserInfo, UpdateTimestamp) == 0x000030, "Member 'UUserInfo::UpdateTimestamp' has a wrong offset!");
static_assert(offsetof(UUserInfo, UserKey) == 0x000038, "Member 'UUserInfo::UserKey' has a wrong offset!");
static_assert(offsetof(UUserInfo, CurrentRoleKey) == 0x000048, "Member 'UUserInfo::CurrentRoleKey' has a wrong offset!");
static_assert(offsetof(UUserInfo, bIsOnline) == 0x000058, "Member 'UUserInfo::bIsOnline' has a wrong offset!");
static_assert(offsetof(UUserInfo, LoginTimestamp) == 0x000060, "Member 'UUserInfo::LoginTimestamp' has a wrong offset!");
static_assert(offsetof(UUserInfo, LogoutTimestamp) == 0x000068, "Member 'UUserInfo::LogoutTimestamp' has a wrong offset!");
static_assert(offsetof(UUserInfo, bIsMatching) == 0x000070, "Member 'UUserInfo::bIsMatching' has a wrong offset!");
static_assert(offsetof(UUserInfo, bIsInBattle) == 0x000071, "Member 'UUserInfo::bIsInBattle' has a wrong offset!");
static_assert(offsetof(UUserInfo, TeamId) == 0x000078, "Member 'UUserInfo::TeamId' has a wrong offset!");
static_assert(offsetof(UUserInfo, TeamMemberCount) == 0x000080, "Member 'UUserInfo::TeamMemberCount' has a wrong offset!");
static_assert(offsetof(UUserInfo, UserNickName) == 0x000088, "Member 'UUserInfo::UserNickName' has a wrong offset!");
static_assert(offsetof(UUserInfo, NickNameBanTimestamp) == 0x000098, "Member 'UUserInfo::NickNameBanTimestamp' has a wrong offset!");
static_assert(offsetof(UUserInfo, RoomKey) == 0x0000A0, "Member 'UUserInfo::RoomKey' has a wrong offset!");
static_assert(offsetof(UUserInfo, AvatarTypeId) == 0x0000B0, "Member 'UUserInfo::AvatarTypeId' has a wrong offset!");
static_assert(offsetof(UUserInfo, AvatarBoxTypeId) == 0x0000B4, "Member 'UUserInfo::AvatarBoxTypeId' has a wrong offset!");
static_assert(offsetof(UUserInfo, TitleTypeId) == 0x0000B8, "Member 'UUserInfo::TitleTypeId' has a wrong offset!");

// Class TGFGame.TGFSwitchForgeTabEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFSwitchForgeTabEvent final : public UTGFEventArgs
{
public:
	class FName                                   TabId;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSwitchForgeTabEvent">();
	}
	static class UTGFSwitchForgeTabEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSwitchForgeTabEvent>();
	}
};
static_assert(alignof(UTGFSwitchForgeTabEvent) == 0x000008, "Wrong alignment on UTGFSwitchForgeTabEvent");
static_assert(sizeof(UTGFSwitchForgeTabEvent) == 0x000030, "Wrong size on UTGFSwitchForgeTabEvent");
static_assert(offsetof(UTGFSwitchForgeTabEvent, TabId) == 0x000028, "Member 'UTGFSwitchForgeTabEvent::TabId' has a wrong offset!");

// Class TGFGame.TGFSelectRepairEquipmentEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFSelectRepairEquipmentEvent final : public UTGFEventArgs
{
public:
	class UTgfInventoryItemWrapper*               SelectedItem;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSelectRepairEquipmentEvent">();
	}
	static class UTGFSelectRepairEquipmentEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSelectRepairEquipmentEvent>();
	}
};
static_assert(alignof(UTGFSelectRepairEquipmentEvent) == 0x000008, "Wrong alignment on UTGFSelectRepairEquipmentEvent");
static_assert(sizeof(UTGFSelectRepairEquipmentEvent) == 0x000030, "Wrong size on UTGFSelectRepairEquipmentEvent");
static_assert(offsetof(UTGFSelectRepairEquipmentEvent, SelectedItem) == 0x000028, "Member 'UTGFSelectRepairEquipmentEvent::SelectedItem' has a wrong offset!");

// Class TGFGame.TGFSelectDismantleEquipmentEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFSelectDismantleEquipmentEvent final : public UTGFEventArgs
{
public:
	class UTgfInventoryItemWrapper*               SelectedItem;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTgfInventoryWrapper*                   Context;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSelectDismantleEquipmentEvent">();
	}
	static class UTGFSelectDismantleEquipmentEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSelectDismantleEquipmentEvent>();
	}
};
static_assert(alignof(UTGFSelectDismantleEquipmentEvent) == 0x000008, "Wrong alignment on UTGFSelectDismantleEquipmentEvent");
static_assert(sizeof(UTGFSelectDismantleEquipmentEvent) == 0x000038, "Wrong size on UTGFSelectDismantleEquipmentEvent");
static_assert(offsetof(UTGFSelectDismantleEquipmentEvent, SelectedItem) == 0x000028, "Member 'UTGFSelectDismantleEquipmentEvent::SelectedItem' has a wrong offset!");
static_assert(offsetof(UTGFSelectDismantleEquipmentEvent, Context) == 0x000030, "Member 'UTGFSelectDismantleEquipmentEvent::Context' has a wrong offset!");

// Class TGFGame.TGFGearRepairFinishEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGearRepairFinishEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearRepairFinishEvent">();
	}
	static class UTGFGearRepairFinishEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearRepairFinishEvent>();
	}
};
static_assert(alignof(UTGFGearRepairFinishEvent) == 0x000008, "Wrong alignment on UTGFGearRepairFinishEvent");
static_assert(sizeof(UTGFGearRepairFinishEvent) == 0x000028, "Wrong size on UTGFGearRepairFinishEvent");

// Class TGFGame.TGFGameSettingRegistry
// 0x0038 (0x00E8 - 0x00B0)
class UTGFGameSettingRegistry final : public UGameSettingRegistry
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameSettingCollection*                 VideoSettings;                                     // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameSettingCollection*                 AudioSettings;                                     // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameSettingCollection*                 MouseAndKeyboardSettings;                          // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameSettingCollection*                 PreferenceSettings;                                // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameSettingCollection*                 ComplianceSettings;                                // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameSettingRegistry">();
	}
	static class UTGFGameSettingRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameSettingRegistry>();
	}
};
static_assert(alignof(UTGFGameSettingRegistry) == 0x000008, "Wrong alignment on UTGFGameSettingRegistry");
static_assert(sizeof(UTGFGameSettingRegistry) == 0x0000E8, "Wrong size on UTGFGameSettingRegistry");
static_assert(offsetof(UTGFGameSettingRegistry, VideoSettings) == 0x0000C0, "Member 'UTGFGameSettingRegistry::VideoSettings' has a wrong offset!");
static_assert(offsetof(UTGFGameSettingRegistry, AudioSettings) == 0x0000C8, "Member 'UTGFGameSettingRegistry::AudioSettings' has a wrong offset!");
static_assert(offsetof(UTGFGameSettingRegistry, MouseAndKeyboardSettings) == 0x0000D0, "Member 'UTGFGameSettingRegistry::MouseAndKeyboardSettings' has a wrong offset!");
static_assert(offsetof(UTGFGameSettingRegistry, PreferenceSettings) == 0x0000D8, "Member 'UTGFGameSettingRegistry::PreferenceSettings' has a wrong offset!");
static_assert(offsetof(UTGFGameSettingRegistry, ComplianceSettings) == 0x0000E0, "Member 'UTGFGameSettingRegistry::ComplianceSettings' has a wrong offset!");

// Class TGFGame.TGFGearRepairEquipmentUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGearRepairEquipmentUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearRepairEquipmentUpdateEvent">();
	}
	static class UTGFGearRepairEquipmentUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearRepairEquipmentUpdateEvent>();
	}
};
static_assert(alignof(UTGFGearRepairEquipmentUpdateEvent) == 0x000008, "Wrong alignment on UTGFGearRepairEquipmentUpdateEvent");
static_assert(sizeof(UTGFGearRepairEquipmentUpdateEvent) == 0x000028, "Wrong size on UTGFGearRepairEquipmentUpdateEvent");

// Class TGFGame.TGFGearRepairInventoryUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGearRepairInventoryUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearRepairInventoryUpdateEvent">();
	}
	static class UTGFGearRepairInventoryUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearRepairInventoryUpdateEvent>();
	}
};
static_assert(alignof(UTGFGearRepairInventoryUpdateEvent) == 0x000008, "Wrong alignment on UTGFGearRepairInventoryUpdateEvent");
static_assert(sizeof(UTGFGearRepairInventoryUpdateEvent) == 0x000028, "Wrong size on UTGFGearRepairInventoryUpdateEvent");

// Class TGFGame.TGFUpdateRoleInfoEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFUpdateRoleInfoEvent final : public UTGFEventArgs
{
public:
	class URoleInfo*                              RoleInfo;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFUpdateRoleInfoEvent">();
	}
	static class UTGFUpdateRoleInfoEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFUpdateRoleInfoEvent>();
	}
};
static_assert(alignof(UTGFUpdateRoleInfoEvent) == 0x000008, "Wrong alignment on UTGFUpdateRoleInfoEvent");
static_assert(sizeof(UTGFUpdateRoleInfoEvent) == 0x000030, "Wrong size on UTGFUpdateRoleInfoEvent");
static_assert(offsetof(UTGFUpdateRoleInfoEvent, RoleInfo) == 0x000028, "Member 'UTGFUpdateRoleInfoEvent::RoleInfo' has a wrong offset!");

// Class TGFGame.TGFGearDismantleSuccessEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFGearDismantleSuccessEvent final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItem>                       Rewards;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearDismantleSuccessEvent">();
	}
	static class UTGFGearDismantleSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearDismantleSuccessEvent>();
	}
};
static_assert(alignof(UTGFGearDismantleSuccessEvent) == 0x000008, "Wrong alignment on UTGFGearDismantleSuccessEvent");
static_assert(sizeof(UTGFGearDismantleSuccessEvent) == 0x000038, "Wrong size on UTGFGearDismantleSuccessEvent");
static_assert(offsetof(UTGFGearDismantleSuccessEvent, Rewards) == 0x000028, "Member 'UTGFGearDismantleSuccessEvent::Rewards' has a wrong offset!");

// Class TGFGame.TGFGearDismantleFinishEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFGearDismantleFinishEvent final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItem>                       Rewards;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearDismantleFinishEvent">();
	}
	static class UTGFGearDismantleFinishEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearDismantleFinishEvent>();
	}
};
static_assert(alignof(UTGFGearDismantleFinishEvent) == 0x000008, "Wrong alignment on UTGFGearDismantleFinishEvent");
static_assert(sizeof(UTGFGearDismantleFinishEvent) == 0x000038, "Wrong size on UTGFGearDismantleFinishEvent");
static_assert(offsetof(UTGFGearDismantleFinishEvent, Rewards) == 0x000028, "Member 'UTGFGearDismantleFinishEvent::Rewards' has a wrong offset!");

// Class TGFGame.TGFDismantleStateChangeEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFDismantleStateChangeEvent final : public UTGFEventArgs
{
public:
	bool                                          bDismantleState;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETgfEquipQuality                              DismantleQuality;                                  // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFDismantleStateChangeEvent">();
	}
	static class UTGFDismantleStateChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFDismantleStateChangeEvent>();
	}
};
static_assert(alignof(UTGFDismantleStateChangeEvent) == 0x000008, "Wrong alignment on UTGFDismantleStateChangeEvent");
static_assert(sizeof(UTGFDismantleStateChangeEvent) == 0x000030, "Wrong size on UTGFDismantleStateChangeEvent");
static_assert(offsetof(UTGFDismantleStateChangeEvent, bDismantleState) == 0x000028, "Member 'UTGFDismantleStateChangeEvent::bDismantleState' has a wrong offset!");
static_assert(offsetof(UTGFDismantleStateChangeEvent, DismantleQuality) == 0x000029, "Member 'UTGFDismantleStateChangeEvent::DismantleQuality' has a wrong offset!");

// Class TGFGame.BlacksmithService
// 0x0038 (0x0068 - 0x0030)
class UBlacksmithService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDismantleState;                                   // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETgfEquipQuality                              DismantleQuality;                                  // 0x0041(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x26];                                      // 0x0042(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DismantleEquipments(const TArray<struct FTGFItem>& InEquipments);
	TArray<class UTGFItemBarData*> GetRepairMaterialListEntry(const TArray<struct FTGFItem>& Equipments, bool* bCanRepair);
	void Lua_Initialized();
	void OnSwitchForgeTab(class UTGFEventArgs* Args);
	void SendGearRepairReq(const TArray<struct FTGFItem>& InEquipments);
	void SetPendingTabId(int32 Param_Index);
	void TurnDismantleState(bool bIsOpen, ETgfEquipQuality Quality);

	TArray<class UTGFItemBarData*> GetOwnMaterials() const;
	class FName GetPendingTabId() const;
	TArray<class UTGFProtoTgfDItemOffset*> GetRepairMaterials(int32 InEquipmentId) const;
	class FText GetSlotName() const;
	class FName GetTabId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlacksmithService">();
	}
	static class UBlacksmithService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlacksmithService>();
	}
};
static_assert(alignof(UBlacksmithService) == 0x000008, "Wrong alignment on UBlacksmithService");
static_assert(sizeof(UBlacksmithService) == 0x000068, "Wrong size on UBlacksmithService");
static_assert(offsetof(UBlacksmithService, bDismantleState) == 0x000040, "Member 'UBlacksmithService::bDismantleState' has a wrong offset!");
static_assert(offsetof(UBlacksmithService, DismantleQuality) == 0x000041, "Member 'UBlacksmithService::DismantleQuality' has a wrong offset!");

// Class TGFGame.TGFChatDisplayChannelChangedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFChatDisplayChannelChangedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatDisplayChannelChangedEvent">();
	}
	static class UTGFChatDisplayChannelChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatDisplayChannelChangedEvent>();
	}
};
static_assert(alignof(UTGFChatDisplayChannelChangedEvent) == 0x000008, "Wrong alignment on UTGFChatDisplayChannelChangedEvent");
static_assert(sizeof(UTGFChatDisplayChannelChangedEvent) == 0x000028, "Wrong size on UTGFChatDisplayChannelChangedEvent");

// Class TGFGame.TGFChatSendChannelChangedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFChatSendChannelChangedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatSendChannelChangedEvent">();
	}
	static class UTGFChatSendChannelChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatSendChannelChangedEvent>();
	}
};
static_assert(alignof(UTGFChatSendChannelChangedEvent) == 0x000008, "Wrong alignment on UTGFChatSendChannelChangedEvent");
static_assert(sizeof(UTGFChatSendChannelChangedEvent) == 0x000028, "Wrong size on UTGFChatSendChannelChangedEvent");

// Class TGFGame.TGFChatChangeToChannelEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFChatChangeToChannelEvent final : public UTGFEventArgs
{
public:
	ETGFProtoTgfEnChatChannelType                 ChannelType;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatChangeToChannelEvent">();
	}
	static class UTGFChatChangeToChannelEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatChangeToChannelEvent>();
	}
};
static_assert(alignof(UTGFChatChangeToChannelEvent) == 0x000008, "Wrong alignment on UTGFChatChangeToChannelEvent");
static_assert(sizeof(UTGFChatChangeToChannelEvent) == 0x000030, "Wrong size on UTGFChatChangeToChannelEvent");
static_assert(offsetof(UTGFChatChangeToChannelEvent, ChannelType) == 0x000028, "Member 'UTGFChatChangeToChannelEvent::ChannelType' has a wrong offset!");

// Class TGFGame.TGFChatShowHideDetailEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFChatShowHideDetailEvent final : public UTGFEventArgs
{
public:
	bool                                          bIsShow;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatShowHideDetailEvent">();
	}
	static class UTGFChatShowHideDetailEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatShowHideDetailEvent>();
	}
};
static_assert(alignof(UTGFChatShowHideDetailEvent) == 0x000008, "Wrong alignment on UTGFChatShowHideDetailEvent");
static_assert(sizeof(UTGFChatShowHideDetailEvent) == 0x000030, "Wrong size on UTGFChatShowHideDetailEvent");
static_assert(offsetof(UTGFChatShowHideDetailEvent, bIsShow) == 0x000028, "Member 'UTGFChatShowHideDetailEvent::bIsShow' has a wrong offset!");

// Class TGFGame.TGFChatReceiveMessageEvent
// 0x00E0 (0x0108 - 0x0028)
class UTGFChatReceiveMessageEvent final : public UTGFEventArgs
{
public:
	struct FChatMessage                           ChatMessage;                                       // 0x0028(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatReceiveMessageEvent">();
	}
	static class UTGFChatReceiveMessageEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatReceiveMessageEvent>();
	}
};
static_assert(alignof(UTGFChatReceiveMessageEvent) == 0x000008, "Wrong alignment on UTGFChatReceiveMessageEvent");
static_assert(sizeof(UTGFChatReceiveMessageEvent) == 0x000108, "Wrong size on UTGFChatReceiveMessageEvent");
static_assert(offsetof(UTGFChatReceiveMessageEvent, ChatMessage) == 0x000028, "Member 'UTGFChatReceiveMessageEvent::ChatMessage' has a wrong offset!");

// Class TGFGame.TGFChatRefreshDisplayEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFChatRefreshDisplayEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatRefreshDisplayEvent">();
	}
	static class UTGFChatRefreshDisplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatRefreshDisplayEvent>();
	}
};
static_assert(alignof(UTGFChatRefreshDisplayEvent) == 0x000008, "Wrong alignment on UTGFChatRefreshDisplayEvent");
static_assert(sizeof(UTGFChatRefreshDisplayEvent) == 0x000028, "Wrong size on UTGFChatRefreshDisplayEvent");

// Class TGFGame.TGFChatAdultDirtyEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFChatAdultDirtyEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFChatAdultDirtyEvent">();
	}
	static class UTGFChatAdultDirtyEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFChatAdultDirtyEvent>();
	}
};
static_assert(alignof(UTGFChatAdultDirtyEvent) == 0x000008, "Wrong alignment on UTGFChatAdultDirtyEvent");
static_assert(sizeof(UTGFChatAdultDirtyEvent) == 0x000028, "Wrong size on UTGFChatAdultDirtyEvent");

// Class TGFGame.ChatFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UChatFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddTemporaryMessage(const class FString& StrContent, const ETGFProtoTgfEnChatChannelType ChannelType);
	static bool GetCanMinorChat();
	static bool GetCanMinorVoiceChat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatFunctionLibrary">();
	}
	static class UChatFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatFunctionLibrary>();
	}
};
static_assert(alignof(UChatFunctionLibrary) == 0x000008, "Wrong alignment on UChatFunctionLibrary");
static_assert(sizeof(UChatFunctionLibrary) == 0x000028, "Wrong size on UChatFunctionLibrary");

// Class TGFGame.ChatMainWindow
// 0x0000 (0x02B8 - 0x02B8)
class UChatMainWindow final : public UTGFWindow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatMainWindow">();
	}
	static class UChatMainWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatMainWindow>();
	}
};
static_assert(alignof(UChatMainWindow) == 0x000008, "Wrong alignment on UChatMainWindow");
static_assert(sizeof(UChatMainWindow) == 0x0002B8, "Wrong size on UChatMainWindow");

// Class TGFGame.ChatService
// 0x00A0 (0x00D0 - 0x0030)
class UChatService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           UpdatePanelTimerHandle;                            // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETGFProtoTgfEnChatChannelType, class UChatChannelInfo*> MyChannelInfoMap;                                  // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ETGFProtoTgfEnChatChannelType                 MyDisplayChannelType;                              // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETGFProtoTgfEnChatChannelType                 MySendChannelType;                                 // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMyHasSendKey;                                     // 0x0092(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               MySendUserKey;                                     // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRoleKey                               MySendRoleKey;                                     // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         MySilenceSequence;                                 // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMyUpdatePanelState;                               // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MyUpdatePanelCount;                                // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMyCanMinorChat;                                   // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMyCanMinorVoiceChat;                              // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTemporaryMessage(const class FString& StrContent, const ETGFProtoTgfEnChatChannelType ChannelType);
	void ChangeToNextSendChannelType();
	void EditCommitTextContent(const class FString& TextContent);
	bool GetCanMinorChat();
	bool GetCanMinorVoiceChat();
	class UChatChannelInfo* GetChannelInfoByChannelType(const ETGFProtoTgfEnChatChannelType ChannelType);
	class FName GetChannelKeyByChannelType(const ETGFProtoTgfEnChatChannelType ChannelType);
	TArray<struct FChatMessage> GetDisplayMessageList();
	void SetDisplayChannelType(const ETGFProtoTgfEnChatChannelType ChannelType);
	void SetSendChannelType(const ETGFProtoTgfEnChatChannelType ChannelType);
	void SetSendRoleKey(const struct FRoleKey& RoleKey);
	void SetUpdatePanelState(bool bIsUpdatePanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatService">();
	}
	static class UChatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatService>();
	}
};
static_assert(alignof(UChatService) == 0x000008, "Wrong alignment on UChatService");
static_assert(sizeof(UChatService) == 0x0000D0, "Wrong size on UChatService");
static_assert(offsetof(UChatService, UpdatePanelTimerHandle) == 0x000038, "Member 'UChatService::UpdatePanelTimerHandle' has a wrong offset!");
static_assert(offsetof(UChatService, MyChannelInfoMap) == 0x000040, "Member 'UChatService::MyChannelInfoMap' has a wrong offset!");
static_assert(offsetof(UChatService, MyDisplayChannelType) == 0x000090, "Member 'UChatService::MyDisplayChannelType' has a wrong offset!");
static_assert(offsetof(UChatService, MySendChannelType) == 0x000091, "Member 'UChatService::MySendChannelType' has a wrong offset!");
static_assert(offsetof(UChatService, bMyHasSendKey) == 0x000092, "Member 'UChatService::bMyHasSendKey' has a wrong offset!");
static_assert(offsetof(UChatService, MySendUserKey) == 0x000098, "Member 'UChatService::MySendUserKey' has a wrong offset!");
static_assert(offsetof(UChatService, MySendRoleKey) == 0x0000A8, "Member 'UChatService::MySendRoleKey' has a wrong offset!");
static_assert(offsetof(UChatService, MySilenceSequence) == 0x0000B8, "Member 'UChatService::MySilenceSequence' has a wrong offset!");
static_assert(offsetof(UChatService, bMyUpdatePanelState) == 0x0000C0, "Member 'UChatService::bMyUpdatePanelState' has a wrong offset!");
static_assert(offsetof(UChatService, MyUpdatePanelCount) == 0x0000C4, "Member 'UChatService::MyUpdatePanelCount' has a wrong offset!");
static_assert(offsetof(UChatService, bMyCanMinorChat) == 0x0000C8, "Member 'UChatService::bMyCanMinorChat' has a wrong offset!");
static_assert(offsetof(UChatService, bMyCanMinorVoiceChat) == 0x0000C9, "Member 'UChatService::bMyCanMinorVoiceChat' has a wrong offset!");

// Class TGFGame.ChatChannelInfo
// 0x0108 (0x0130 - 0x0028)
class UChatChannelInfo final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETGFProtoTgfEnChatChannelType                 ChannelType;                                       // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChatChannelConfigRow                  ChannelConfig;                                     // 0x0030(0x0088)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         LastSendTimeSeconds;                               // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int64, struct FChatMessage>              ChatMessageMap;                                    // 0x00C0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCanSendMessage(bool bSetSendTimestamp);
	bool CheckCanShowMessage(ETGFProtoTgfEnChatChannelType InChannelType);
	void ResetLastSendTimeSeconds();

	ETGFProtoTgfEnChatChannelType GetChannelType() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatChannelInfo">();
	}
	static class UChatChannelInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatChannelInfo>();
	}
};
static_assert(alignof(UChatChannelInfo) == 0x000008, "Wrong alignment on UChatChannelInfo");
static_assert(sizeof(UChatChannelInfo) == 0x000130, "Wrong size on UChatChannelInfo");
static_assert(offsetof(UChatChannelInfo, bIsValid) == 0x000028, "Member 'UChatChannelInfo::bIsValid' has a wrong offset!");
static_assert(offsetof(UChatChannelInfo, ChannelType) == 0x000029, "Member 'UChatChannelInfo::ChannelType' has a wrong offset!");
static_assert(offsetof(UChatChannelInfo, ChannelConfig) == 0x000030, "Member 'UChatChannelInfo::ChannelConfig' has a wrong offset!");
static_assert(offsetof(UChatChannelInfo, LastSendTimeSeconds) == 0x0000B8, "Member 'UChatChannelInfo::LastSendTimeSeconds' has a wrong offset!");
static_assert(offsetof(UChatChannelInfo, ChatMessageMap) == 0x0000C0, "Member 'UChatChannelInfo::ChatMessageMap' has a wrong offset!");

// Class TGFGame.CommonFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommonFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CopyStringToClipboard(const class FString& Text);
	static bool DateTimeValidate(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second, int32 Millisecond);
	static TMap<class FName, float> GetCurveTableRowMap(class UCurveTable* CurveTable);
	static bool GetEmitterRendererPropertiesByNiagaraComponent(class UNiagaraComponent* NiagaraComponent, TArray<class UNiagaraRendererProperties*>* RendererProperties);
	static TArray<struct FVersionedNiagaraEmitterData> GetEmittersByNiagaraComponent(class UNiagaraComponent* NiagaraComponent);
	static bool GetIsShowWeaponOperationTips();
	static class UUserWidget* GetListViewEntryWidgetFromItem(const class UListView* ListView, const class UObject* Item);
	static class FString GetNameFromPlayerNameData(const struct FPlayerNameData& InPlayerNameData, bool bIsForceUseHiddenName);
	static TArray<class UMaterialInterface*> GetNiagaraEmittersMaterialByName(class UNiagaraComponent* NiagaraComponent, const class FString& MaterialName);
	static class FString GetRoleHeadPortraitIconPath(int32 TypeId, int32 Gender, int32 FaceId, int32 SkinColor, int32 RowId);
	static struct FGameplayAttribute ParseGameplayAttributeFromName(const class FString& AttrStr);
	static class FString PasteStringToClipboard();
	static bool ReplaceNiagaraEmittersMaterialByDynamic(class UNiagaraComponent* NiagaraComponent, const class FString& MaterialName, class UMaterialInstanceDynamic* DynamicMaterial);
	static bool SetIsShowWeaponOperationTips();

	const class UTgfFirstLevelAttrDataAsset* GetFirstLevelAttrData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonFunctionLibrary">();
	}
	static class UCommonFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonFunctionLibrary>();
	}
};
static_assert(alignof(UCommonFunctionLibrary) == 0x000008, "Wrong alignment on UCommonFunctionLibrary");
static_assert(sizeof(UCommonFunctionLibrary) == 0x000028, "Wrong size on UCommonFunctionLibrary");

// Class TGFGame.ConfigService
// 0x0020 (0x0050 - 0x0030)
class UConfigService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigService">();
	}
	static class UConfigService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigService>();
	}
};
static_assert(alignof(UConfigService) == 0x000008, "Wrong alignment on UConfigService");
static_assert(sizeof(UConfigService) == 0x000050, "Wrong size on UConfigService");

// Class TGFGame.ConfirmWindow
// 0x0008 (0x02C0 - 0x02B8)
class UConfirmWindow final : public UTGFWindow
{
public:
	class UConfirmWindowArgs*                     ConfirmWindowArgs;                                 // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelButtonClicked();
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfirmWindow">();
	}
	static class UConfirmWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfirmWindow>();
	}
};
static_assert(alignof(UConfirmWindow) == 0x000008, "Wrong alignment on UConfirmWindow");
static_assert(sizeof(UConfirmWindow) == 0x0002C0, "Wrong size on UConfirmWindow");
static_assert(offsetof(UConfirmWindow, ConfirmWindowArgs) == 0x0002B8, "Member 'UConfirmWindow::ConfirmWindowArgs' has a wrong offset!");

// Class TGFGame.ConfirmWindowArgs
// 0x0070 (0x00A0 - 0x0030)
class UConfirmWindowArgs final : public UTGFWindowArgs
{
public:
	class FText                                   Message;                                           // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ConfirmText;                                       // 0x0048(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CancelText;                                        // 0x0060(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0078(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfirmWindowArgs">();
	}
	static class UConfirmWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfirmWindowArgs>();
	}
};
static_assert(alignof(UConfirmWindowArgs) == 0x000008, "Wrong alignment on UConfirmWindowArgs");
static_assert(sizeof(UConfirmWindowArgs) == 0x0000A0, "Wrong size on UConfirmWindowArgs");
static_assert(offsetof(UConfirmWindowArgs, Message) == 0x000030, "Member 'UConfirmWindowArgs::Message' has a wrong offset!");
static_assert(offsetof(UConfirmWindowArgs, ConfirmText) == 0x000048, "Member 'UConfirmWindowArgs::ConfirmText' has a wrong offset!");
static_assert(offsetof(UConfirmWindowArgs, CancelText) == 0x000060, "Member 'UConfirmWindowArgs::CancelText' has a wrong offset!");
static_assert(offsetof(UConfirmWindowArgs, Context) == 0x000078, "Member 'UConfirmWindowArgs::Context' has a wrong offset!");

// Class TGFGame.CreateWindowArgs
// 0x0000 (0x0030 - 0x0030)
class UCreateWindowArgs final : public UTGFWindowArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateWindowArgs">();
	}
	static class UCreateWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateWindowArgs>();
	}
};
static_assert(alignof(UCreateWindowArgs) == 0x000008, "Wrong alignment on UCreateWindowArgs");
static_assert(sizeof(UCreateWindowArgs) == 0x000030, "Wrong size on UCreateWindowArgs");

// Class TGFGame.CultureBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UCultureBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetCultureNameByType(const ETGFProtoTgfEnMutlLanguageType CultureType);
	static class FString GetCultureText(const struct FCultureTextMap& CultureTextMap);
	static ETGFProtoTgfEnMutlLanguageType GetCultureTypeByName(const class FString& CultureName);
	static class FString GetCurrentCultureName();
	static ETGFProtoTgfEnMutlLanguageType GetCurrentCultureType();
	static class FString GetDefaultCultureName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CultureBlueprintLibrary">();
	}
	static class UCultureBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCultureBlueprintLibrary>();
	}
};
static_assert(alignof(UCultureBlueprintLibrary) == 0x000008, "Wrong alignment on UCultureBlueprintLibrary");
static_assert(sizeof(UCultureBlueprintLibrary) == 0x000028, "Wrong size on UCultureBlueprintLibrary");

// Class TGFGame.DLCPacketService
// 0x0070 (0x00A0 - 0x0030)
class UDLCPacketService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntReceiveDlcAppId;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTGFProtoTgfDItemOffset*>        TArrayTGFItemOffsets;                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleRainbowConfig(class UTGFEventArgs* Args);
	void RefreshDLCInfo();
	void SendReceiveDLCPacketReq();
	void StartTimer(class UTGFEventArgs* Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCPacketService">();
	}
	static class UDLCPacketService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCPacketService>();
	}
};
static_assert(alignof(UDLCPacketService) == 0x000008, "Wrong alignment on UDLCPacketService");
static_assert(sizeof(UDLCPacketService) == 0x0000A0, "Wrong size on UDLCPacketService");
static_assert(offsetof(UDLCPacketService, IntReceiveDlcAppId) == 0x000038, "Member 'UDLCPacketService::IntReceiveDlcAppId' has a wrong offset!");
static_assert(offsetof(UDLCPacketService, TArrayTGFItemOffsets) == 0x000040, "Member 'UDLCPacketService::TArrayTGFItemOffsets' has a wrong offset!");

// Class TGFGame.FlawlessTrialsOpenEvent
// 0x0008 (0x0030 - 0x0028)
class UFlawlessTrialsOpenEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlawlessTrialsOpenEvent">();
	}
	static class UFlawlessTrialsOpenEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlawlessTrialsOpenEvent>();
	}
};
static_assert(alignof(UFlawlessTrialsOpenEvent) == 0x000008, "Wrong alignment on UFlawlessTrialsOpenEvent");
static_assert(sizeof(UFlawlessTrialsOpenEvent) == 0x000030, "Wrong size on UFlawlessTrialsOpenEvent");
static_assert(offsetof(UFlawlessTrialsOpenEvent, ErrorCode) == 0x000028, "Member 'UFlawlessTrialsOpenEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.FlawlessTrialsSelfQuitEvent
// 0x0008 (0x0030 - 0x0028)
class UFlawlessTrialsSelfQuitEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlawlessTrialsSelfQuitEvent">();
	}
	static class UFlawlessTrialsSelfQuitEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlawlessTrialsSelfQuitEvent>();
	}
};
static_assert(alignof(UFlawlessTrialsSelfQuitEvent) == 0x000008, "Wrong alignment on UFlawlessTrialsSelfQuitEvent");
static_assert(sizeof(UFlawlessTrialsSelfQuitEvent) == 0x000030, "Wrong size on UFlawlessTrialsSelfQuitEvent");
static_assert(offsetof(UFlawlessTrialsSelfQuitEvent, ErrorCode) == 0x000028, "Member 'UFlawlessTrialsSelfQuitEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.FlawlessTrialsReceiveRewardEvent
// 0x0010 (0x0038 - 0x0028)
class UFlawlessTrialsReceiveRewardEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfSCActivityCenterTrialReceiveRewardRsp* TGFRsp;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlawlessTrialsReceiveRewardEvent">();
	}
	static class UFlawlessTrialsReceiveRewardEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlawlessTrialsReceiveRewardEvent>();
	}
};
static_assert(alignof(UFlawlessTrialsReceiveRewardEvent) == 0x000008, "Wrong alignment on UFlawlessTrialsReceiveRewardEvent");
static_assert(sizeof(UFlawlessTrialsReceiveRewardEvent) == 0x000038, "Wrong size on UFlawlessTrialsReceiveRewardEvent");
static_assert(offsetof(UFlawlessTrialsReceiveRewardEvent, ErrorCode) == 0x000028, "Member 'UFlawlessTrialsReceiveRewardEvent::ErrorCode' has a wrong offset!");
static_assert(offsetof(UFlawlessTrialsReceiveRewardEvent, TGFRsp) == 0x000030, "Member 'UFlawlessTrialsReceiveRewardEvent::TGFRsp' has a wrong offset!");

// Class TGFGame.FlawlessTrialsHistoryEvent
// 0x0008 (0x0030 - 0x0028)
class UFlawlessTrialsHistoryEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlawlessTrialsHistoryEvent">();
	}
	static class UFlawlessTrialsHistoryEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlawlessTrialsHistoryEvent>();
	}
};
static_assert(alignof(UFlawlessTrialsHistoryEvent) == 0x000008, "Wrong alignment on UFlawlessTrialsHistoryEvent");
static_assert(sizeof(UFlawlessTrialsHistoryEvent) == 0x000030, "Wrong size on UFlawlessTrialsHistoryEvent");
static_assert(offsetof(UFlawlessTrialsHistoryEvent, ErrorCode) == 0x000028, "Member 'UFlawlessTrialsHistoryEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.FlawlessTrialsService
// 0x0020 (0x0050 - 0x0030)
class UFlawlessTrialsService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTrialBattleRecordsData*>        Records;                                           // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UTrialBattleRecordsData*> GetRecords();
	void InSceneSendFlawlessRewardReq();
	void SendTrialHistoryReq(const int32 ActivityId);
	void SendTrialOpenReq(const int32 ActivityId);
	void SendTrialReceiveRewardReq(const int32 ActivityId);
	void SendTrialSelfQuitReq(const int32 ActivityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlawlessTrialsService">();
	}
	static class UFlawlessTrialsService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlawlessTrialsService>();
	}
};
static_assert(alignof(UFlawlessTrialsService) == 0x000008, "Wrong alignment on UFlawlessTrialsService");
static_assert(sizeof(UFlawlessTrialsService) == 0x000050, "Wrong size on UFlawlessTrialsService");
static_assert(offsetof(UFlawlessTrialsService, Records) == 0x000038, "Member 'UFlawlessTrialsService::Records' has a wrong offset!");

// Class TGFGame.FusionItemData
// 0x0010 (0x0038 - 0x0028)
class UFusionItemData final : public UObject
{
public:
	TArray<int32>                                 CraftIds;                                          // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FusionItemData">();
	}
	static class UFusionItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFusionItemData>();
	}
};
static_assert(alignof(UFusionItemData) == 0x000008, "Wrong alignment on UFusionItemData");
static_assert(sizeof(UFusionItemData) == 0x000038, "Wrong size on UFusionItemData");
static_assert(offsetof(UFusionItemData, CraftIds) == 0x000028, "Member 'UFusionItemData::CraftIds' has a wrong offset!");

// Class TGFGame.TGFCraftingSuccess
// 0x0008 (0x0030 - 0x0028)
class UTGFCraftingSuccess final : public UTGFEventArgs
{
public:
	int32                                         Craft;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCraftingSuccess">();
	}
	static class UTGFCraftingSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCraftingSuccess>();
	}
};
static_assert(alignof(UTGFCraftingSuccess) == 0x000008, "Wrong alignment on UTGFCraftingSuccess");
static_assert(sizeof(UTGFCraftingSuccess) == 0x000030, "Wrong size on UTGFCraftingSuccess");
static_assert(offsetof(UTGFCraftingSuccess, Craft) == 0x000028, "Member 'UTGFCraftingSuccess::Craft' has a wrong offset!");

// Class TGFGame.TGFCraftingCancel
// 0x0010 (0x0038 - 0x0028)
class UTGFCraftingCancel final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItem>                       Items;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCraftingCancel">();
	}
	static class UTGFCraftingCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCraftingCancel>();
	}
};
static_assert(alignof(UTGFCraftingCancel) == 0x000008, "Wrong alignment on UTGFCraftingCancel");
static_assert(sizeof(UTGFCraftingCancel) == 0x000038, "Wrong size on UTGFCraftingCancel");
static_assert(offsetof(UTGFCraftingCancel, Items) == 0x000028, "Member 'UTGFCraftingCancel::Items' has a wrong offset!");

// Class TGFGame.TGFCraftingDrawSuccess
// 0x0010 (0x0038 - 0x0028)
class UTGFCraftingDrawSuccess final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItem>                       Items;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCraftingDrawSuccess">();
	}
	static class UTGFCraftingDrawSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCraftingDrawSuccess>();
	}
};
static_assert(alignof(UTGFCraftingDrawSuccess) == 0x000008, "Wrong alignment on UTGFCraftingDrawSuccess");
static_assert(sizeof(UTGFCraftingDrawSuccess) == 0x000038, "Wrong size on UTGFCraftingDrawSuccess");
static_assert(offsetof(UTGFCraftingDrawSuccess, Items) == 0x000028, "Member 'UTGFCraftingDrawSuccess::Items' has a wrong offset!");

// Class TGFGame.TGFCraftingUpdateRecipes
// 0x0010 (0x0038 - 0x0028)
class UTGFCraftingUpdateRecipes final : public UTGFEventArgs
{
public:
	TArray<int32>                                 Recipes;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCraftingUpdateRecipes">();
	}
	static class UTGFCraftingUpdateRecipes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCraftingUpdateRecipes>();
	}
};
static_assert(alignof(UTGFCraftingUpdateRecipes) == 0x000008, "Wrong alignment on UTGFCraftingUpdateRecipes");
static_assert(sizeof(UTGFCraftingUpdateRecipes) == 0x000038, "Wrong size on UTGFCraftingUpdateRecipes");
static_assert(offsetof(UTGFCraftingUpdateRecipes, Recipes) == 0x000028, "Member 'UTGFCraftingUpdateRecipes::Recipes' has a wrong offset!");

// Class TGFGame.TGFCraftingUpdateSlots
// 0x0010 (0x0038 - 0x0028)
class UTGFCraftingUpdateSlots final : public UTGFEventArgs
{
public:
	TArray<int32>                                 Slots;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCraftingUpdateSlots">();
	}
	static class UTGFCraftingUpdateSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCraftingUpdateSlots>();
	}
};
static_assert(alignof(UTGFCraftingUpdateSlots) == 0x000008, "Wrong alignment on UTGFCraftingUpdateSlots");
static_assert(sizeof(UTGFCraftingUpdateSlots) == 0x000038, "Wrong size on UTGFCraftingUpdateSlots");
static_assert(offsetof(UTGFCraftingUpdateSlots, Slots) == 0x000028, "Member 'UTGFCraftingUpdateSlots::Slots' has a wrong offset!");

// Class TGFGame.TGFPlayerGetCraftingEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFPlayerGetCraftingEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFPlayerGetCraftingEvent">();
	}
	static class UTGFPlayerGetCraftingEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFPlayerGetCraftingEvent>();
	}
};
static_assert(alignof(UTGFPlayerGetCraftingEvent) == 0x000008, "Wrong alignment on UTGFPlayerGetCraftingEvent");
static_assert(sizeof(UTGFPlayerGetCraftingEvent) == 0x000028, "Wrong size on UTGFPlayerGetCraftingEvent");

// Class TGFGame.TGFSelectCraftEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFSelectCraftEvent final : public UTGFEventArgs
{
public:
	int32                                         CraftId;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSelectCraftEvent">();
	}
	static class UTGFSelectCraftEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSelectCraftEvent>();
	}
};
static_assert(alignof(UTGFSelectCraftEvent) == 0x000008, "Wrong alignment on UTGFSelectCraftEvent");
static_assert(sizeof(UTGFSelectCraftEvent) == 0x000030, "Wrong size on UTGFSelectCraftEvent");
static_assert(offsetof(UTGFSelectCraftEvent, CraftId) == 0x000028, "Member 'UTGFSelectCraftEvent::CraftId' has a wrong offset!");

// Class TGFGame.FusionService
// 0x0098 (0x00C8 - 0x0030)
class UFusionService final : public UTGFService
{
public:
	struct FTGFUserCraftingData                   Craft_data;                                        // 0x0030(0x0020)(NativeAccessSpecifierPrivate)
	TArray<int32>                                 UnlockCrafts;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 UnlockSlots;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FCraftTab>                 CraftTabItems;                                     // 0x0070(0x0050)(NativeAccessSpecifierPrivate)
	int32                                         FilterState;                                       // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         InventoryTabSelect;                                // 0x00C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         StragePageId;                                      // 0x00C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCraftUnlock(int32 CraftId);
	bool CheckIsAllCraftFinish();
	bool CheckIsAnyCraftFinish();
	bool CheckIsTabCraftAllFinish(int32 Tag);
	bool CheckSlotUnlock(int32 SlotId);
	int32 GetCraftComboCount(int32 CraftId);
	int32 GetCraftCountById(int32 CraftId);
	const struct FTGFUserCraftingData GetCraftingData();
	TMap<int32, class UFusionItemData*> GetCraftTabFinishItems(int32 Tag);
	struct FCraftTab GetCraftTabItems(int32 Tag);
	TArray<int32> GetCraftTabItemTypes(int32 Tag);
	TMap<int32, class UFusionItemData*> GetCraftTabRunningItems(int32 Tag);
	int32 GetFilterState();
	ETgfFusionStateType GetFusionStateType(int32 CraftId);
	void OnSelectCraft(int32 Craft);
	void SendCancelCraftReq(int32 Craft, uint8 StorageType);
	void SendDrawCraftReq(int32 Craft, uint8 StorageType);
	void SendPlayerGetCraftingReq();
	void SendStartCraftReq(int32 Crafting_recipe, int32 Count);
	void SetCraftInventoryTabSelect(uint8 TabId);
	void SetCraftStragePageTab(uint8 PageId);
	int32 SetFilterState(int32 State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FusionService">();
	}
	static class UFusionService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFusionService>();
	}
};
static_assert(alignof(UFusionService) == 0x000008, "Wrong alignment on UFusionService");
static_assert(sizeof(UFusionService) == 0x0000C8, "Wrong size on UFusionService");
static_assert(offsetof(UFusionService, Craft_data) == 0x000030, "Member 'UFusionService::Craft_data' has a wrong offset!");
static_assert(offsetof(UFusionService, UnlockCrafts) == 0x000050, "Member 'UFusionService::UnlockCrafts' has a wrong offset!");
static_assert(offsetof(UFusionService, UnlockSlots) == 0x000060, "Member 'UFusionService::UnlockSlots' has a wrong offset!");
static_assert(offsetof(UFusionService, CraftTabItems) == 0x000070, "Member 'UFusionService::CraftTabItems' has a wrong offset!");
static_assert(offsetof(UFusionService, FilterState) == 0x0000C0, "Member 'UFusionService::FilterState' has a wrong offset!");
static_assert(offsetof(UFusionService, InventoryTabSelect) == 0x0000C4, "Member 'UFusionService::InventoryTabSelect' has a wrong offset!");
static_assert(offsetof(UFusionService, StragePageId) == 0x0000C5, "Member 'UFusionService::StragePageId' has a wrong offset!");

// Class TGFGame.TrialChallengesSingleLevelData
// 0x0020 (0x0048 - 0x0028)
class UTrialChallengesSingleLevelData final : public UObject
{
public:
	int32                                         ChallengeId;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BattleId;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleResult;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrialChallengesSingleLevelData">();
	}
	static class UTrialChallengesSingleLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrialChallengesSingleLevelData>();
	}
};
static_assert(alignof(UTrialChallengesSingleLevelData) == 0x000008, "Wrong alignment on UTrialChallengesSingleLevelData");
static_assert(sizeof(UTrialChallengesSingleLevelData) == 0x000048, "Wrong size on UTrialChallengesSingleLevelData");
static_assert(offsetof(UTrialChallengesSingleLevelData, ChallengeId) == 0x000028, "Member 'UTrialChallengesSingleLevelData::ChallengeId' has a wrong offset!");
static_assert(offsetof(UTrialChallengesSingleLevelData, BattleId) == 0x000030, "Member 'UTrialChallengesSingleLevelData::BattleId' has a wrong offset!");
static_assert(offsetof(UTrialChallengesSingleLevelData, BattleResult) == 0x000040, "Member 'UTrialChallengesSingleLevelData::BattleResult' has a wrong offset!");

// Class TGFGame.RpcGameClientServiceHelper
// 0x0000 (0x0028 - 0x0028)
class URpcGameClientServiceHelper final : public UObject
{
public:
	static const struct FRpcGameClientServiceMethods GetMethods();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RpcGameClientServiceHelper">();
	}
	static class URpcGameClientServiceHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URpcGameClientServiceHelper>();
	}
};
static_assert(alignof(URpcGameClientServiceHelper) == 0x000008, "Wrong alignment on URpcGameClientServiceHelper");
static_assert(sizeof(URpcGameClientServiceHelper) == 0x000028, "Wrong size on URpcGameClientServiceHelper");

// Class TGFGame.GameLoginService
// 0x0020 (0x0050 - 0x0030)
class UGameLoginService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UserUpdateHandler;                                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnGameLogout(class UTGFEventArgs* Args);

	class FString BP_GetOpenId() const;
	int64 BP_GetUserId() const;
	int32 BP_GetZoneId() const;
	bool IsLogin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLoginService">();
	}
	static class UGameLoginService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLoginService>();
	}
};
static_assert(alignof(UGameLoginService) == 0x000008, "Wrong alignment on UGameLoginService");
static_assert(sizeof(UGameLoginService) == 0x000050, "Wrong size on UGameLoginService");
static_assert(offsetof(UGameLoginService, UserUpdateHandler) == 0x000048, "Member 'UGameLoginService::UserUpdateHandler' has a wrong offset!");

// Class TGFGame.TradeSaleOrder
// 0x00E8 (0x0110 - 0x0028)
class UTradeSaleOrder final : public UObject
{
public:
	class UTgfInventoryItemWrapper_Trade*         ItemWrapper;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTgfInventoryItemWrapper_Lobby*         AuctionWrapper;                                    // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0xD8];                                      // 0x0038(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FTGFItem GetItem(int32 MarketId);
	bool HaveGearSetAttribute(int32 MarketId);
	bool IsCorruptionItem(int32 MarketId);

	int32 GetCurrentBidPrice() const;
	int32 GetFixedPrice() const;
	int32 GetItemTypeId(int32 MarketId) const;
	int32 GetLeftItemount() const;
	int32 GetOriginItemCount() const;
	int64 GetRemainTime() const;
	int32 GetStartingPrice() const;
	ETradeSaleOrderState GetState() const;
	int32 GetTradeItemProductId() const;
	ETradeSaleOrderType GetType() const;
	int32 GetUnitCount() const;
	int32 GetUnitPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeSaleOrder">();
	}
	static class UTradeSaleOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeSaleOrder>();
	}
};
static_assert(alignof(UTradeSaleOrder) == 0x000008, "Wrong alignment on UTradeSaleOrder");
static_assert(sizeof(UTradeSaleOrder) == 0x000110, "Wrong size on UTradeSaleOrder");
static_assert(offsetof(UTradeSaleOrder, ItemWrapper) == 0x000028, "Member 'UTradeSaleOrder::ItemWrapper' has a wrong offset!");
static_assert(offsetof(UTradeSaleOrder, AuctionWrapper) == 0x000030, "Member 'UTradeSaleOrder::AuctionWrapper' has a wrong offset!");

// Class TGFGame.GamePreLoginService
// 0x0028 (0x0058 - 0x0030)
class UGamePreLoginService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfPlayerPreLoginInfo*         PreLoginInfo;                                      // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lua_OnEnterLoginQueue();
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);
	void OnNetworkManagerExitState(class UTGFEventArgs* Args);

	class UTGFProtoTgfPlayerPreLoginInfo* GetPreLoginInfo() const;
	bool IsInQueue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePreLoginService">();
	}
	static class UGamePreLoginService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePreLoginService>();
	}
};
static_assert(alignof(UGamePreLoginService) == 0x000008, "Wrong alignment on UGamePreLoginService");
static_assert(sizeof(UGamePreLoginService) == 0x000058, "Wrong size on UGamePreLoginService");
static_assert(offsetof(UGamePreLoginService, PreLoginInfo) == 0x000040, "Member 'UGamePreLoginService::PreLoginInfo' has a wrong offset!");

// Class TGFGame.GameVersionManager
// 0x0000 (0x0028 - 0x0028)
class UGameVersionManager final : public UObject
{
public:
	static class FString GetAppVersion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameVersionManager">();
	}
	static class UGameVersionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameVersionManager>();
	}
};
static_assert(alignof(UGameVersionManager) == 0x000008, "Wrong alignment on UGameVersionManager");
static_assert(sizeof(UGameVersionManager) == 0x000028, "Wrong size on UGameVersionManager");

// Class TGFGame.GlobalUserInfo
// 0x0028 (0x0050 - 0x0028)
class UGlobalUserInfo final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UpdateTimestamp;                                   // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGlobalUserKey                         GlobalUserKey;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserKey                               CurrentUserKey;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetIsExpired() const;
	bool GetIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalUserInfo">();
	}
	static class UGlobalUserInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalUserInfo>();
	}
};
static_assert(alignof(UGlobalUserInfo) == 0x000008, "Wrong alignment on UGlobalUserInfo");
static_assert(sizeof(UGlobalUserInfo) == 0x000050, "Wrong size on UGlobalUserInfo");
static_assert(offsetof(UGlobalUserInfo, bIsValid) == 0x000028, "Member 'UGlobalUserInfo::bIsValid' has a wrong offset!");
static_assert(offsetof(UGlobalUserInfo, UpdateTimestamp) == 0x000030, "Member 'UGlobalUserInfo::UpdateTimestamp' has a wrong offset!");
static_assert(offsetof(UGlobalUserInfo, GlobalUserKey) == 0x000038, "Member 'UGlobalUserInfo::GlobalUserKey' has a wrong offset!");
static_assert(offsetof(UGlobalUserInfo, CurrentUserKey) == 0x000040, "Member 'UGlobalUserInfo::CurrentUserKey' has a wrong offset!");

// Class TGFGame.GMService
// 0x0040 (0x0070 - 0x0030)
class UGMService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowAliveTime;                                     // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowItemGuid;                                      // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCreateRoleToggleHelmet;                     // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowRecommendSource;                               // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebugDraw;                                     // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x33];                                      // 0x003D(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GMService">();
	}
	static class UGMService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGMService>();
	}
};
static_assert(alignof(UGMService) == 0x000008, "Wrong alignment on UGMService");
static_assert(sizeof(UGMService) == 0x000070, "Wrong size on UGMService");
static_assert(offsetof(UGMService, ShowAliveTime) == 0x000038, "Member 'UGMService::ShowAliveTime' has a wrong offset!");
static_assert(offsetof(UGMService, ShowItemGuid) == 0x000039, "Member 'UGMService::ShowItemGuid' has a wrong offset!");
static_assert(offsetof(UGMService, DisableCreateRoleToggleHelmet) == 0x00003A, "Member 'UGMService::DisableCreateRoleToggleHelmet' has a wrong offset!");
static_assert(offsetof(UGMService, ShowRecommendSource) == 0x00003B, "Member 'UGMService::ShowRecommendSource' has a wrong offset!");
static_assert(offsetof(UGMService, ShowDebugDraw) == 0x00003C, "Member 'UGMService::ShowDebugDraw' has a wrong offset!");

// Class TGFGame.TradeSearchService
// 0x0210 (0x0240 - 0x0030)
class UTradeSearchService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTradeSearchResultOrder*>        SearchResultOrders;                                // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        RecommendOrders;                                   // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int64, class UTradeSearchResultOrder*>   RecommendMap;                                      // 0x0070(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, struct FTGFTradeSearchResultData> PageDataCache;                                     // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, bool>                             RepeatOrderTicketId;                               // 0x0110(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        SpQualityOrders;                                   // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        SpScoreOrders;                                     // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        NewPublishOrders;                                  // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        HotSaleAmountOrders;                               // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        HotSalePriceOrders;                                // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeSearchResultOrder*>        INeedOrders;                                       // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x80];                                     // 0x01C0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearPageDataCache();
	TArray<int32> GeLegendaryAffixList();
	TArray<int32> GetAffixList(const class FString& AffixType);
	TArray<int32> GetAffixListByType(int32 AttributeClassify);
	bool GetHasNextPage();
	struct FTGFTradeSearchResultData GetPageDataCache(int32 PageIndex);
	TArray<class UTradeSearchResultOrder*> GetRecommendResults(bool Refresh);
	TArray<class UTradeSearchResultOrder*> GetRecommendResultsEaBase(bool Refresh);
	TArray<class UTradeSearchResultOrder*> GetSearchResultOrders();
	void GetTradeAuctionRecommendOrder();
	void OnAffixSelect(int32 AffixId, bool IsSureSelect, bool IsHomogenTrade);
	void OnGameLogout(class UTGFEventArgs* Args);
	void RefreshSearchList();
	void ReqTradeAuctionRecommendOrder1();
	void ReqTradeAuctionRecommendOrder2();
	void ReSearchRequest();
	void SendTradeAuctionRecommendOrderTicketRequest(bool Refresh);
	void SendTradeAuctionSearchRequest(int32 Career, int32 MinorType, const TArray<int32>& SubTypes, int32 Rarity, int32 Corruption, int32 MinPrice, int32 MaxPrice, int32 BoundPrice, int64 BoundTicketId, int64 BoundSpScore, int32 BoundRarity, int32 Affix1, int32 Affix2, int32 Affix3);
	void SendTradeSearchRequest(const int32 MarketId, int32 Career, int32 MajorType, int32 MinorType, const TArray<int32>& SubTypes, int32 Rarity, int32 Corruption, int32 MinPrice, int32 MaxPrice, int32 BoundPrice, int64 BoundTicketId, int64 BoundSpScore, int32 BoundRarity, int32 Affix1, int32 Affix2, int32 Affix3);
	void SetPageDataCache(int32 PageIndex, const TArray<class UTradeSearchResultOrder*>& Datas, bool NextPage);
	void TradeAuctionPageRequest(int32 BoundPrice, int64 BoundTicketId, int64 BoundSpScore, int32 BoundRarity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeSearchService">();
	}
	static class UTradeSearchService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeSearchService>();
	}
};
static_assert(alignof(UTradeSearchService) == 0x000008, "Wrong alignment on UTradeSearchService");
static_assert(sizeof(UTradeSearchService) == 0x000240, "Wrong size on UTradeSearchService");
static_assert(offsetof(UTradeSearchService, SearchResultOrders) == 0x000050, "Member 'UTradeSearchService::SearchResultOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, RecommendOrders) == 0x000060, "Member 'UTradeSearchService::RecommendOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, RecommendMap) == 0x000070, "Member 'UTradeSearchService::RecommendMap' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, PageDataCache) == 0x0000C0, "Member 'UTradeSearchService::PageDataCache' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, RepeatOrderTicketId) == 0x000110, "Member 'UTradeSearchService::RepeatOrderTicketId' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, SpQualityOrders) == 0x000160, "Member 'UTradeSearchService::SpQualityOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, SpScoreOrders) == 0x000170, "Member 'UTradeSearchService::SpScoreOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, NewPublishOrders) == 0x000180, "Member 'UTradeSearchService::NewPublishOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, HotSaleAmountOrders) == 0x000190, "Member 'UTradeSearchService::HotSaleAmountOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, HotSalePriceOrders) == 0x0001A0, "Member 'UTradeSearchService::HotSalePriceOrders' has a wrong offset!");
static_assert(offsetof(UTradeSearchService, INeedOrders) == 0x0001B0, "Member 'UTradeSearchService::INeedOrders' has a wrong offset!");

// Class TGFGame.GRomeLinkService
// 0x0140 (0x0170 - 0x0030)
class UGRomeLinkService final : public UTGFService
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UResolveDomain*                         ResolveGRomelinkMgrDomain;                         // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UResolveDomain*>                 ArrayResolveDomain;                                // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, class UResolveDomain*>    MapResolveDomains;                                 // 0x0100(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetPingMs();
	void HandleRainbowConfig(class UTGFEventArgs* Args);
	void SetBOpenGRomeLinkLog(bool bOpen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRomeLinkService">();
	}
	static class UGRomeLinkService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRomeLinkService>();
	}
};
static_assert(alignof(UGRomeLinkService) == 0x000008, "Wrong alignment on UGRomeLinkService");
static_assert(sizeof(UGRomeLinkService) == 0x000170, "Wrong size on UGRomeLinkService");
static_assert(offsetof(UGRomeLinkService, ResolveGRomelinkMgrDomain) == 0x0000E8, "Member 'UGRomeLinkService::ResolveGRomelinkMgrDomain' has a wrong offset!");
static_assert(offsetof(UGRomeLinkService, ArrayResolveDomain) == 0x0000F0, "Member 'UGRomeLinkService::ArrayResolveDomain' has a wrong offset!");
static_assert(offsetof(UGRomeLinkService, MapResolveDomains) == 0x000100, "Member 'UGRomeLinkService::MapResolveDomains' has a wrong offset!");

// Class TGFGame.GuideService
// 0x0018 (0x0048 - 0x0030)
class UGuideService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsShowReward();
	bool GetIsSkipGuide();
	void Lua_ShowGuideChoose();
	void SetIsSkipGuide(bool IsShow);
	void SetShowReward(bool IsShow);
	void ShowGuideChoose();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuideService">();
	}
	static class UGuideService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuideService>();
	}
};
static_assert(alignof(UGuideService) == 0x000008, "Wrong alignment on UGuideService");
static_assert(sizeof(UGuideService) == 0x000048, "Wrong size on UGuideService");

// Class TGFGame.GuideWindow
// 0x0000 (0x02B8 - 0x02B8)
class UGuideWindow : public UTGFWindow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuideWindow">();
	}
	static class UGuideWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuideWindow>();
	}
};
static_assert(alignof(UGuideWindow) == 0x000008, "Wrong alignment on UGuideWindow");
static_assert(sizeof(UGuideWindow) == 0x0002B8, "Wrong size on UGuideWindow");

// Class TGFGame.TGFCurrentServerChangedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFCurrentServerChangedEvent final : public UTGFEventArgs
{
public:
	class UServerItem*                            CurrentServerItem;                                 // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCurrentServerChangedEvent">();
	}
	static class UTGFCurrentServerChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCurrentServerChangedEvent>();
	}
};
static_assert(alignof(UTGFCurrentServerChangedEvent) == 0x000008, "Wrong alignment on UTGFCurrentServerChangedEvent");
static_assert(sizeof(UTGFCurrentServerChangedEvent) == 0x000030, "Wrong size on UTGFCurrentServerChangedEvent");
static_assert(offsetof(UTGFCurrentServerChangedEvent, CurrentServerItem) == 0x000028, "Member 'UTGFCurrentServerChangedEvent::CurrentServerItem' has a wrong offset!");

// Class TGFGame.HeadFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UHeadFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FTgfHeadResConfig GetDefaultHeadResConfigData(int32 Race, int32 Gender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadFunctionLibrary">();
	}
	static class UHeadFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadFunctionLibrary>();
	}
};
static_assert(alignof(UHeadFunctionLibrary) == 0x000008, "Wrong alignment on UHeadFunctionLibrary");
static_assert(sizeof(UHeadFunctionLibrary) == 0x000028, "Wrong size on UHeadFunctionLibrary");

// Class TGFGame.HeartbeatService
// 0x0018 (0x0048 - 0x0030)
class UHeartbeatService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameLoginSuccess(class UTGFEventArgs* Args);
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);
	void OnNetworkManagerExitState(class UTGFEventArgs* Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeartbeatService">();
	}
	static class UHeartbeatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeartbeatService>();
	}
};
static_assert(alignof(UHeartbeatService) == 0x000008, "Wrong alignment on UHeartbeatService");
static_assert(sizeof(UHeartbeatService) == 0x000048, "Wrong size on UHeartbeatService");

// Class TGFGame.TGFRoomSyncTeamEnterRoomEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomSyncTeamEnterRoomEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSyncTeamEnterRoomEvent">();
	}
	static class UTGFRoomSyncTeamEnterRoomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSyncTeamEnterRoomEvent>();
	}
};
static_assert(alignof(UTGFRoomSyncTeamEnterRoomEvent) == 0x000008, "Wrong alignment on UTGFRoomSyncTeamEnterRoomEvent");
static_assert(sizeof(UTGFRoomSyncTeamEnterRoomEvent) == 0x000028, "Wrong size on UTGFRoomSyncTeamEnterRoomEvent");

// Class TGFGame.TGFHeirloomUnlockEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFHeirloomUnlockEvent final : public UTGFEventArgs
{
public:
	int32                                         HeirloomId;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeirloomGroupId;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFHeirloomUnlockEvent">();
	}
	static class UTGFHeirloomUnlockEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFHeirloomUnlockEvent>();
	}
};
static_assert(alignof(UTGFHeirloomUnlockEvent) == 0x000008, "Wrong alignment on UTGFHeirloomUnlockEvent");
static_assert(sizeof(UTGFHeirloomUnlockEvent) == 0x000030, "Wrong size on UTGFHeirloomUnlockEvent");
static_assert(offsetof(UTGFHeirloomUnlockEvent, HeirloomId) == 0x000028, "Member 'UTGFHeirloomUnlockEvent::HeirloomId' has a wrong offset!");
static_assert(offsetof(UTGFHeirloomUnlockEvent, HeirloomGroupId) == 0x00002C, "Member 'UTGFHeirloomUnlockEvent::HeirloomGroupId' has a wrong offset!");

// Class TGFGame.TGFHeirloomArouseEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFHeirloomArouseEvent final : public UTGFEventArgs
{
public:
	int32                                         HeirloomGroupId;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFHeirloomArouseEvent">();
	}
	static class UTGFHeirloomArouseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFHeirloomArouseEvent>();
	}
};
static_assert(alignof(UTGFHeirloomArouseEvent) == 0x000008, "Wrong alignment on UTGFHeirloomArouseEvent");
static_assert(sizeof(UTGFHeirloomArouseEvent) == 0x000030, "Wrong size on UTGFHeirloomArouseEvent");
static_assert(offsetof(UTGFHeirloomArouseEvent, HeirloomGroupId) == 0x000028, "Member 'UTGFHeirloomArouseEvent::HeirloomGroupId' has a wrong offset!");

// Class TGFGame.TGFSettingScreenDestructEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSettingScreenDestructEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingScreenDestructEvent">();
	}
	static class UTGFSettingScreenDestructEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingScreenDestructEvent>();
	}
};
static_assert(alignof(UTGFSettingScreenDestructEvent) == 0x000008, "Wrong alignment on UTGFSettingScreenDestructEvent");
static_assert(sizeof(UTGFSettingScreenDestructEvent) == 0x000028, "Wrong size on UTGFSettingScreenDestructEvent");

// Class TGFGame.TGFHeirloomInstantiationEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFHeirloomInstantiationEvent final : public UTGFEventArgs
{
public:
	int32                                         TypeId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfDItemPosition*              Position;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFHeirloomInstantiationEvent">();
	}
	static class UTGFHeirloomInstantiationEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFHeirloomInstantiationEvent>();
	}
};
static_assert(alignof(UTGFHeirloomInstantiationEvent) == 0x000008, "Wrong alignment on UTGFHeirloomInstantiationEvent");
static_assert(sizeof(UTGFHeirloomInstantiationEvent) == 0x000038, "Wrong size on UTGFHeirloomInstantiationEvent");
static_assert(offsetof(UTGFHeirloomInstantiationEvent, TypeId) == 0x000028, "Member 'UTGFHeirloomInstantiationEvent::TypeId' has a wrong offset!");
static_assert(offsetof(UTGFHeirloomInstantiationEvent, Position) == 0x000030, "Member 'UTGFHeirloomInstantiationEvent::Position' has a wrong offset!");

// Class TGFGame.TGFGearGemSlotUnlockEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFGearGemSlotUnlockEvent final : public UTGFEventArgs
{
public:
	int32                                         GroupID;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearGemSlotUnlockEvent">();
	}
	static class UTGFGearGemSlotUnlockEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearGemSlotUnlockEvent>();
	}
};
static_assert(alignof(UTGFGearGemSlotUnlockEvent) == 0x000008, "Wrong alignment on UTGFGearGemSlotUnlockEvent");
static_assert(sizeof(UTGFGearGemSlotUnlockEvent) == 0x000030, "Wrong size on UTGFGearGemSlotUnlockEvent");
static_assert(offsetof(UTGFGearGemSlotUnlockEvent, GroupID) == 0x000028, "Member 'UTGFGearGemSlotUnlockEvent::GroupID' has a wrong offset!");
static_assert(offsetof(UTGFGearGemSlotUnlockEvent, SlotId) == 0x00002C, "Member 'UTGFGearGemSlotUnlockEvent::SlotId' has a wrong offset!");

// Class TGFGame.ServerItem
// 0x0058 (0x0080 - 0x0028)
class UServerItem final : public UObject
{
public:
	int32                                         ServerId;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CategoryId;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsServerUnavailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerItem">();
	}
	static class UServerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerItem>();
	}
};
static_assert(alignof(UServerItem) == 0x000008, "Wrong alignment on UServerItem");
static_assert(sizeof(UServerItem) == 0x000080, "Wrong size on UServerItem");
static_assert(offsetof(UServerItem, ServerId) == 0x000028, "Member 'UServerItem::ServerId' has a wrong offset!");
static_assert(offsetof(UServerItem, CategoryId) == 0x00002C, "Member 'UServerItem::CategoryId' has a wrong offset!");
static_assert(offsetof(UServerItem, ServerName) == 0x000030, "Member 'UServerItem::ServerName' has a wrong offset!");

// Class TGFGame.TGFGearGemInlaidEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGearGemInlaidEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearGemInlaidEvent">();
	}
	static class UTGFGearGemInlaidEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearGemInlaidEvent>();
	}
};
static_assert(alignof(UTGFGearGemInlaidEvent) == 0x000008, "Wrong alignment on UTGFGearGemInlaidEvent");
static_assert(sizeof(UTGFGearGemInlaidEvent) == 0x000028, "Wrong size on UTGFGearGemInlaidEvent");

// Class TGFGame.TGFGearGemUnlockEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFGearGemUnlockEvent final : public UTGFEventArgs
{
public:
	int32                                         GearGemId;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGearGemUnlockEvent">();
	}
	static class UTGFGearGemUnlockEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGearGemUnlockEvent>();
	}
};
static_assert(alignof(UTGFGearGemUnlockEvent) == 0x000008, "Wrong alignment on UTGFGearGemUnlockEvent");
static_assert(sizeof(UTGFGearGemUnlockEvent) == 0x000030, "Wrong size on UTGFGearGemUnlockEvent");
static_assert(offsetof(UTGFGearGemUnlockEvent, GearGemId) == 0x000028, "Member 'UTGFGearGemUnlockEvent::GearGemId' has a wrong offset!");

// Class TGFGame.TGFRoomSyncSnapshotEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomSyncSnapshotEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSyncSnapshotEvent">();
	}
	static class UTGFRoomSyncSnapshotEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSyncSnapshotEvent>();
	}
};
static_assert(alignof(UTGFRoomSyncSnapshotEvent) == 0x000008, "Wrong alignment on UTGFRoomSyncSnapshotEvent");
static_assert(sizeof(UTGFRoomSyncSnapshotEvent) == 0x000028, "Wrong size on UTGFRoomSyncSnapshotEvent");

// Class TGFGame.HeirloomService
// 0x00B0 (0x00E0 - 0x0030)
class UHeirloomService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UHeirloomGroup*>            MyHeirloomGroupMap;                                // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UHeirloomGearGem*>          MyHeirloomGearGemMap;                              // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void ArouseGearGem(int32 GearGemId, int32 CostIndex);
	void ArouseHeirloom(int32 HeirloomId, int32 CostIndex);
	bool CheckHeirloomCanInstantiate(int32 HeirloomId, EnItemStorageType StorageType, int32 PageId);
	bool CheckHeirloomGemItemCanInlaidByAffix(int32 HeirloomId, int32 GemItemId, int32 SlotId);
	TArray<class UHeirloomGearGem*> GetHeirloomGearGemArrayByMinorType(ETGFProtoTgfEnItemMinorType ItemMinorType);
	class UHeirloomGearGem* GetHeirloomGearGemById(int32 GearGemId);
	class UHeirloomGearGem* GetHeirloomGearGemByItemId(int32 GemItemId);
	TMap<int32, struct FHeirloomGearGemSlot> GetHeirloomGearGemSlotMap(int32 HeirloomId);
	TArray<class UHeirloomGroup*> GetHeirloomGroupArray(int32 TypeId);
	class UHeirloomGroup* GetHeirloomGroupById(int32 HeirloomGroupId);
	int32 GetHeirloomTypeByItemTypeId(int32 TypeId);
	void InlaidGearGem(int32 HeirloomId, int32 GearGemId, int32 SlotId);
	void InstantiateHeirloom(int32 HeirloomId, int32 CostIndex, EnItemStorageType StorageType, int32 PageId);
	void Lua_Deinitialize();
	void Lua_Initialized();

	TMap<int32, class UHeirloomGroup*> GetAllHeirloomGroupData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeirloomService">();
	}
	static class UHeirloomService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeirloomService>();
	}
};
static_assert(alignof(UHeirloomService) == 0x000008, "Wrong alignment on UHeirloomService");
static_assert(sizeof(UHeirloomService) == 0x0000E0, "Wrong size on UHeirloomService");
static_assert(offsetof(UHeirloomService, MyHeirloomGroupMap) == 0x000040, "Member 'UHeirloomService::MyHeirloomGroupMap' has a wrong offset!");
static_assert(offsetof(UHeirloomService, MyHeirloomGearGemMap) == 0x000090, "Member 'UHeirloomService::MyHeirloomGearGemMap' has a wrong offset!");

// Class TGFGame.HeirloomGroup
// 0x0110 (0x0138 - 0x0028)
class UHeirloomGroup final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupID;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TypeId;                                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseHeirloomId;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   HeirloomIdSet;                                     // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<int32>                                   UnlockHeirloomIdSet;                               // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         MaxGemSlotCount;                                   // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            EquippedGemItemMap;                                // 0x00E8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	int32 GetCurHeirloomId() const;
	int32 GetDisplayHeirloomId() const;
	int32 GetEquippedGemItemId(int32 SlotId) const;
	bool GetGemItemIsEquipped(int32 GemItemId) const;
	bool GetHeirloomCanUpgrade(int32 HeirloomId) const;
	bool GetIsUnlock() const;
	bool GetIsValid() const;
	int32 GetLastHeirloomId() const;
	int32 GetNextHeirloomId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeirloomGroup">();
	}
	static class UHeirloomGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeirloomGroup>();
	}
};
static_assert(alignof(UHeirloomGroup) == 0x000008, "Wrong alignment on UHeirloomGroup");
static_assert(sizeof(UHeirloomGroup) == 0x000138, "Wrong size on UHeirloomGroup");
static_assert(offsetof(UHeirloomGroup, bIsValid) == 0x000028, "Member 'UHeirloomGroup::bIsValid' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, GroupID) == 0x00002C, "Member 'UHeirloomGroup::GroupID' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, TypeId) == 0x000030, "Member 'UHeirloomGroup::TypeId' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, SortPriority) == 0x000034, "Member 'UHeirloomGroup::SortPriority' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, BaseHeirloomId) == 0x000038, "Member 'UHeirloomGroup::BaseHeirloomId' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, HeirloomIdSet) == 0x000040, "Member 'UHeirloomGroup::HeirloomIdSet' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, UnlockHeirloomIdSet) == 0x000090, "Member 'UHeirloomGroup::UnlockHeirloomIdSet' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, MaxGemSlotCount) == 0x0000E0, "Member 'UHeirloomGroup::MaxGemSlotCount' has a wrong offset!");
static_assert(offsetof(UHeirloomGroup, EquippedGemItemMap) == 0x0000E8, "Member 'UHeirloomGroup::EquippedGemItemMap' has a wrong offset!");

// Class TGFGame.PVPPlayerListItemObject
// 0x0010 (0x0038 - 0x0028)
class UPVPPlayerListItemObject final : public UObject
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPPlayerListItemObject">();
	}
	static class UPVPPlayerListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPPlayerListItemObject>();
	}
};
static_assert(alignof(UPVPPlayerListItemObject) == 0x000008, "Wrong alignment on UPVPPlayerListItemObject");
static_assert(sizeof(UPVPPlayerListItemObject) == 0x000038, "Wrong size on UPVPPlayerListItemObject");
static_assert(offsetof(UPVPPlayerListItemObject, UserKey) == 0x000028, "Member 'UPVPPlayerListItemObject::UserKey' has a wrong offset!");

// Class TGFGame.HeirloomGearGem
// 0x0018 (0x0040 - 0x0028)
class UHeirloomGearGem final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GearGemId;                                         // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GemItemId;                                         // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnItemMinorType                   ItemMinorType;                                     // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnlock;                                         // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsUnlock() const;
	bool GetIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeirloomGearGem">();
	}
	static class UHeirloomGearGem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeirloomGearGem>();
	}
};
static_assert(alignof(UHeirloomGearGem) == 0x000008, "Wrong alignment on UHeirloomGearGem");
static_assert(sizeof(UHeirloomGearGem) == 0x000040, "Wrong size on UHeirloomGearGem");
static_assert(offsetof(UHeirloomGearGem, bIsValid) == 0x000028, "Member 'UHeirloomGearGem::bIsValid' has a wrong offset!");
static_assert(offsetof(UHeirloomGearGem, GearGemId) == 0x00002C, "Member 'UHeirloomGearGem::GearGemId' has a wrong offset!");
static_assert(offsetof(UHeirloomGearGem, GemItemId) == 0x000030, "Member 'UHeirloomGearGem::GemItemId' has a wrong offset!");
static_assert(offsetof(UHeirloomGearGem, SortPriority) == 0x000034, "Member 'UHeirloomGearGem::SortPriority' has a wrong offset!");
static_assert(offsetof(UHeirloomGearGem, ItemMinorType) == 0x000038, "Member 'UHeirloomGearGem::ItemMinorType' has a wrong offset!");
static_assert(offsetof(UHeirloomGearGem, bIsUnlock) == 0x000039, "Member 'UHeirloomGearGem::bIsUnlock' has a wrong offset!");

// Class TGFGame.HttpReportService
// 0x0030 (0x0060 - 0x0030)
class UHttpReportService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReportError(const struct FTGFReportRecord& Record, const class FString& OpenID);
	void ReportEvent(const struct FTGFReportRecord& Record, const class FString& OpenID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HttpReportService">();
	}
	static class UHttpReportService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHttpReportService>();
	}
};
static_assert(alignof(UHttpReportService) == 0x000008, "Wrong alignment on UHttpReportService");
static_assert(sizeof(UHttpReportService) == 0x000060, "Wrong size on UHttpReportService");

// Class TGFGame.TGFRoomSyncMemberBattleVersionNotMatchEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFRoomSyncMemberBattleVersionNotMatchEvent final : public UTGFEventArgs
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSyncMemberBattleVersionNotMatchEvent">();
	}
	static class UTGFRoomSyncMemberBattleVersionNotMatchEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSyncMemberBattleVersionNotMatchEvent>();
	}
};
static_assert(alignof(UTGFRoomSyncMemberBattleVersionNotMatchEvent) == 0x000008, "Wrong alignment on UTGFRoomSyncMemberBattleVersionNotMatchEvent");
static_assert(sizeof(UTGFRoomSyncMemberBattleVersionNotMatchEvent) == 0x000038, "Wrong size on UTGFRoomSyncMemberBattleVersionNotMatchEvent");
static_assert(offsetof(UTGFRoomSyncMemberBattleVersionNotMatchEvent, UserKey) == 0x000028, "Member 'UTGFRoomSyncMemberBattleVersionNotMatchEvent::UserKey' has a wrong offset!");

// Class TGFGame.TGFMoveItemResponse
// 0x0010 (0x0038 - 0x0028)
class UTGFMoveItemResponse final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItemMoveAction>             Actions;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMoveItemResponse">();
	}
	static class UTGFMoveItemResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMoveItemResponse>();
	}
};
static_assert(alignof(UTGFMoveItemResponse) == 0x000008, "Wrong alignment on UTGFMoveItemResponse");
static_assert(sizeof(UTGFMoveItemResponse) == 0x000038, "Wrong size on UTGFMoveItemResponse");
static_assert(offsetof(UTGFMoveItemResponse, Actions) == 0x000028, "Member 'UTGFMoveItemResponse::Actions' has a wrong offset!");

// Class TGFGame.TGFSwapItemResponse
// 0x0030 (0x0058 - 0x0028)
class UTGFSwapItemResponse final : public UTGFEventArgs
{
public:
	struct FTGFItemPosition                       SrcCell;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTGFItemPosition                       DestCell;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSwapItemResponse">();
	}
	static class UTGFSwapItemResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSwapItemResponse>();
	}
};
static_assert(alignof(UTGFSwapItemResponse) == 0x000008, "Wrong alignment on UTGFSwapItemResponse");
static_assert(sizeof(UTGFSwapItemResponse) == 0x000058, "Wrong size on UTGFSwapItemResponse");
static_assert(offsetof(UTGFSwapItemResponse, SrcCell) == 0x000028, "Member 'UTGFSwapItemResponse::SrcCell' has a wrong offset!");
static_assert(offsetof(UTGFSwapItemResponse, DestCell) == 0x000040, "Member 'UTGFSwapItemResponse::DestCell' has a wrong offset!");

// Class TGFGame.TGFRoomSuggestEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFRoomSuggestEvent final : public UTGFEventArgs
{
public:
	TArray<class UPVPRoomKey*>                    RoomKeys;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSuggestEvent">();
	}
	static class UTGFRoomSuggestEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSuggestEvent>();
	}
};
static_assert(alignof(UTGFRoomSuggestEvent) == 0x000008, "Wrong alignment on UTGFRoomSuggestEvent");
static_assert(sizeof(UTGFRoomSuggestEvent) == 0x000038, "Wrong size on UTGFRoomSuggestEvent");
static_assert(offsetof(UTGFRoomSuggestEvent, RoomKeys) == 0x000028, "Member 'UTGFRoomSuggestEvent::RoomKeys' has a wrong offset!");

// Class TGFGame.TGFRoleWearResponse
// 0x0038 (0x0060 - 0x0028)
class UTGFRoleWearResponse final : public UTGFEventArgs
{
public:
	struct FTGFItemPosition                       SrcCell;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Partid;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTGFItemPosition                       Second_Cell;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoleWearResponse">();
	}
	static class UTGFRoleWearResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoleWearResponse>();
	}
};
static_assert(alignof(UTGFRoleWearResponse) == 0x000008, "Wrong alignment on UTGFRoleWearResponse");
static_assert(sizeof(UTGFRoleWearResponse) == 0x000060, "Wrong size on UTGFRoleWearResponse");
static_assert(offsetof(UTGFRoleWearResponse, SrcCell) == 0x000028, "Member 'UTGFRoleWearResponse::SrcCell' has a wrong offset!");
static_assert(offsetof(UTGFRoleWearResponse, Partid) == 0x000040, "Member 'UTGFRoleWearResponse::Partid' has a wrong offset!");
static_assert(offsetof(UTGFRoleWearResponse, Second_Cell) == 0x000048, "Member 'UTGFRoleWearResponse::Second_Cell' has a wrong offset!");

// Class TGFGame.TGFRoleTakeOffResponse
// 0x0038 (0x0060 - 0x0028)
class UTGFRoleTakeOffResponse final : public UTGFEventArgs
{
public:
	int32                                         Partid;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTGFItemPosition                       DestCell;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTGFItemPosition                       Second_Cell;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoleTakeOffResponse">();
	}
	static class UTGFRoleTakeOffResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoleTakeOffResponse>();
	}
};
static_assert(alignof(UTGFRoleTakeOffResponse) == 0x000008, "Wrong alignment on UTGFRoleTakeOffResponse");
static_assert(sizeof(UTGFRoleTakeOffResponse) == 0x000060, "Wrong size on UTGFRoleTakeOffResponse");
static_assert(offsetof(UTGFRoleTakeOffResponse, Partid) == 0x000028, "Member 'UTGFRoleTakeOffResponse::Partid' has a wrong offset!");
static_assert(offsetof(UTGFRoleTakeOffResponse, DestCell) == 0x000030, "Member 'UTGFRoleTakeOffResponse::DestCell' has a wrong offset!");
static_assert(offsetof(UTGFRoleTakeOffResponse, Second_Cell) == 0x000048, "Member 'UTGFRoleTakeOffResponse::Second_Cell' has a wrong offset!");

// Class TGFGame.PVPRoomMember
// 0x0018 (0x0040 - 0x0028)
class UPVPRoomMember final : public UObject
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasReady;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPRoomMember">();
	}
	static class UPVPRoomMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPRoomMember>();
	}
};
static_assert(alignof(UPVPRoomMember) == 0x000008, "Wrong alignment on UPVPRoomMember");
static_assert(sizeof(UPVPRoomMember) == 0x000040, "Wrong size on UPVPRoomMember");
static_assert(offsetof(UPVPRoomMember, UserKey) == 0x000028, "Member 'UPVPRoomMember::UserKey' has a wrong offset!");
static_assert(offsetof(UPVPRoomMember, HasReady) == 0x000038, "Member 'UPVPRoomMember::HasReady' has a wrong offset!");

// Class TGFGame.UpdateItemsNoti
// 0x0020 (0x0048 - 0x0028)
class UUpdateItemsNoti final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItem>                       Update_items;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTGFItemPosition>               Remove_items;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateItemsNoti">();
	}
	static class UUpdateItemsNoti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateItemsNoti>();
	}
};
static_assert(alignof(UUpdateItemsNoti) == 0x000008, "Wrong alignment on UUpdateItemsNoti");
static_assert(sizeof(UUpdateItemsNoti) == 0x000048, "Wrong size on UUpdateItemsNoti");
static_assert(offsetof(UUpdateItemsNoti, Update_items) == 0x000028, "Member 'UUpdateItemsNoti::Update_items' has a wrong offset!");
static_assert(offsetof(UUpdateItemsNoti, Remove_items) == 0x000038, "Member 'UUpdateItemsNoti::Remove_items' has a wrong offset!");

// Class TGFGame.UpdateCoinNoti
// 0x0018 (0x0040 - 0x0028)
class UUpdateCoinNoti final : public UTGFEventArgs
{
public:
	int32                                         CoinTypeId;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Count;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncreased;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateCoinNoti">();
	}
	static class UUpdateCoinNoti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateCoinNoti>();
	}
};
static_assert(alignof(UUpdateCoinNoti) == 0x000008, "Wrong alignment on UUpdateCoinNoti");
static_assert(sizeof(UUpdateCoinNoti) == 0x000040, "Wrong size on UUpdateCoinNoti");
static_assert(offsetof(UUpdateCoinNoti, CoinTypeId) == 0x000028, "Member 'UUpdateCoinNoti::CoinTypeId' has a wrong offset!");
static_assert(offsetof(UUpdateCoinNoti, Count) == 0x000030, "Member 'UUpdateCoinNoti::Count' has a wrong offset!");
static_assert(offsetof(UUpdateCoinNoti, bIncreased) == 0x000038, "Member 'UUpdateCoinNoti::bIncreased' has a wrong offset!");

// Class TGFGame.TGFRankGetSelfResponseEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFRankGetSelfResponseEvent final : public UTGFEventArgs
{
public:
	int32                                         RankType;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankInstanceId;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoleGuid;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRankGetSelfResponseEvent">();
	}
	static class UTGFRankGetSelfResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRankGetSelfResponseEvent>();
	}
};
static_assert(alignof(UTGFRankGetSelfResponseEvent) == 0x000008, "Wrong alignment on UTGFRankGetSelfResponseEvent");
static_assert(sizeof(UTGFRankGetSelfResponseEvent) == 0x000038, "Wrong size on UTGFRankGetSelfResponseEvent");
static_assert(offsetof(UTGFRankGetSelfResponseEvent, RankType) == 0x000028, "Member 'UTGFRankGetSelfResponseEvent::RankType' has a wrong offset!");
static_assert(offsetof(UTGFRankGetSelfResponseEvent, RankInstanceId) == 0x00002C, "Member 'UTGFRankGetSelfResponseEvent::RankInstanceId' has a wrong offset!");
static_assert(offsetof(UTGFRankGetSelfResponseEvent, RoleGuid) == 0x000030, "Member 'UTGFRankGetSelfResponseEvent::RoleGuid' has a wrong offset!");

// Class TGFGame.UpdateVirtualItemsNoti
// 0x0020 (0x0048 - 0x0028)
class UUpdateVirtualItemsNoti final : public UTGFEventArgs
{
public:
	TArray<struct FTGFItem>                       UpdateItems;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTGFItem>                       IncreasedItems;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateVirtualItemsNoti">();
	}
	static class UUpdateVirtualItemsNoti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateVirtualItemsNoti>();
	}
};
static_assert(alignof(UUpdateVirtualItemsNoti) == 0x000008, "Wrong alignment on UUpdateVirtualItemsNoti");
static_assert(sizeof(UUpdateVirtualItemsNoti) == 0x000048, "Wrong size on UUpdateVirtualItemsNoti");
static_assert(offsetof(UUpdateVirtualItemsNoti, UpdateItems) == 0x000028, "Member 'UUpdateVirtualItemsNoti::UpdateItems' has a wrong offset!");
static_assert(offsetof(UUpdateVirtualItemsNoti, IncreasedItems) == 0x000038, "Member 'UUpdateVirtualItemsNoti::IncreasedItems' has a wrong offset!");

// Class TGFGame.TooltipCompareChanged
// 0x0008 (0x0030 - 0x0028)
class UTooltipCompareChanged final : public UTGFEventArgs
{
public:
	bool                                          Compare;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipCompareChanged">();
	}
	static class UTooltipCompareChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipCompareChanged>();
	}
};
static_assert(alignof(UTooltipCompareChanged) == 0x000008, "Wrong alignment on UTooltipCompareChanged");
static_assert(sizeof(UTooltipCompareChanged) == 0x000030, "Wrong size on UTooltipCompareChanged");
static_assert(offsetof(UTooltipCompareChanged, Compare) == 0x000028, "Member 'UTooltipCompareChanged::Compare' has a wrong offset!");

// Class TGFGame.PVPModeListItemObject
// 0x0028 (0x0050 - 0x0028)
class UPVPModeListItemObject final : public UObject
{
public:
	int32                                         ModeId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ModeName;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPModeListItemObject">();
	}
	static class UPVPModeListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPModeListItemObject>();
	}
};
static_assert(alignof(UPVPModeListItemObject) == 0x000008, "Wrong alignment on UPVPModeListItemObject");
static_assert(sizeof(UPVPModeListItemObject) == 0x000050, "Wrong size on UPVPModeListItemObject");
static_assert(offsetof(UPVPModeListItemObject, ModeId) == 0x000028, "Member 'UPVPModeListItemObject::ModeId' has a wrong offset!");
static_assert(offsetof(UPVPModeListItemObject, ModeName) == 0x000030, "Member 'UPVPModeListItemObject::ModeName' has a wrong offset!");
static_assert(offsetof(UPVPModeListItemObject, IsLocked) == 0x000048, "Member 'UPVPModeListItemObject::IsLocked' has a wrong offset!");

// Class TGFGame.HostPlayerEquipChange
// 0x0000 (0x0028 - 0x0028)
class UHostPlayerEquipChange final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HostPlayerEquipChange">();
	}
	static class UHostPlayerEquipChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHostPlayerEquipChange>();
	}
};
static_assert(alignof(UHostPlayerEquipChange) == 0x000008, "Wrong alignment on UHostPlayerEquipChange");
static_assert(sizeof(UHostPlayerEquipChange) == 0x000028, "Wrong size on UHostPlayerEquipChange");

// Class TGFGame.StoragePageAdded
// 0x0000 (0x0028 - 0x0028)
class UStoragePageAdded final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoragePageAdded">();
	}
	static class UStoragePageAdded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoragePageAdded>();
	}
};
static_assert(alignof(UStoragePageAdded) == 0x000008, "Wrong alignment on UStoragePageAdded");
static_assert(sizeof(UStoragePageAdded) == 0x000028, "Wrong size on UStoragePageAdded");

// Class TGFGame.PVPRoomMemberPos
// 0x0008 (0x0030 - 0x0028)
class UPVPRoomMemberPos final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPRoomMemberPos">();
	}
	static class UPVPRoomMemberPos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPRoomMemberPos>();
	}
};
static_assert(alignof(UPVPRoomMemberPos) == 0x000008, "Wrong alignment on UPVPRoomMemberPos");
static_assert(sizeof(UPVPRoomMemberPos) == 0x000030, "Wrong size on UPVPRoomMemberPos");

// Class TGFGame.SoulBoundUpdate
// 0x0000 (0x0028 - 0x0028)
class USoulBoundUpdate final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoulBoundUpdate">();
	}
	static class USoulBoundUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoulBoundUpdate>();
	}
};
static_assert(alignof(USoulBoundUpdate) == 0x000008, "Wrong alignment on USoulBoundUpdate");
static_assert(sizeof(USoulBoundUpdate) == 0x000028, "Wrong size on USoulBoundUpdate");

// Class TGFGame.LobbyInventoryOpen
// 0x0000 (0x0028 - 0x0028)
class ULobbyInventoryOpen final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyInventoryOpen">();
	}
	static class ULobbyInventoryOpen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyInventoryOpen>();
	}
};
static_assert(alignof(ULobbyInventoryOpen) == 0x000008, "Wrong alignment on ULobbyInventoryOpen");
static_assert(sizeof(ULobbyInventoryOpen) == 0x000028, "Wrong size on ULobbyInventoryOpen");

// Class TGFGame.RainbowConfigService
// 0x0050 (0x0080 - 0x0030)
class URainbowConfigService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetConfig(const class FString& Key) const;
	int32 GetIntConfig(const class FString& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RainbowConfigService">();
	}
	static class URainbowConfigService* GetDefaultObj()
	{
		return GetDefaultObjImpl<URainbowConfigService>();
	}
};
static_assert(alignof(URainbowConfigService) == 0x000008, "Wrong alignment on URainbowConfigService");
static_assert(sizeof(URainbowConfigService) == 0x000080, "Wrong size on URainbowConfigService");

// Class TGFGame.OnUseItemResponse
// 0x0018 (0x0040 - 0x0028)
class UOnUseItemResponse final : public UTGFEventArgs
{
public:
	int32                                         UseItemTypeId;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTGFItem>                       GotItems;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnUseItemResponse">();
	}
	static class UOnUseItemResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnUseItemResponse>();
	}
};
static_assert(alignof(UOnUseItemResponse) == 0x000008, "Wrong alignment on UOnUseItemResponse");
static_assert(sizeof(UOnUseItemResponse) == 0x000040, "Wrong size on UOnUseItemResponse");
static_assert(offsetof(UOnUseItemResponse, UseItemTypeId) == 0x000028, "Member 'UOnUseItemResponse::UseItemTypeId' has a wrong offset!");
static_assert(offsetof(UOnUseItemResponse, GotItems) == 0x000030, "Member 'UOnUseItemResponse::GotItems' has a wrong offset!");

// Class TGFGame.FacadeDataUpdate
// 0x0000 (0x0028 - 0x0028)
class UFacadeDataUpdate final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FacadeDataUpdate">();
	}
	static class UFacadeDataUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFacadeDataUpdate>();
	}
};
static_assert(alignof(UFacadeDataUpdate) == 0x000008, "Wrong alignment on UFacadeDataUpdate");
static_assert(sizeof(UFacadeDataUpdate) == 0x000028, "Wrong size on UFacadeDataUpdate");

// Class TGFGame.RoleAttributeOffensiveInfo
// 0x0098 (0x00C0 - 0x0028)
class URoleAttributeOffensiveInfo final : public UObject
{
public:
	float                                         DPH;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSpeedRate;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLevel;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackBonus;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalStrikeChance;                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalStrikeDamage;                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDamageRate;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalDamage;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDamage;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningDamage;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColdDamage;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivineDamage;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDamage;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalPenetration;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirePenetration;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColdPenetration;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningPenetration;                              // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivinePenetration;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowPenetration;                                 // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagetoElites;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagetoControlledEnemies;                         // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreDefense;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllElementDamage;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackBoostRate;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteBoostRate;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UncontrolledBoostRate;                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResCostReduceRate;                                 // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResGenerateRate;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicOverTime;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicOnHit;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicOnKill;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicOnHurt;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magic;                                             // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMagic;                                          // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicGenerateRate;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSoulEnergy;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleAttributeOffensiveInfo">();
	}
	static class URoleAttributeOffensiveInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleAttributeOffensiveInfo>();
	}
};
static_assert(alignof(URoleAttributeOffensiveInfo) == 0x000008, "Wrong alignment on URoleAttributeOffensiveInfo");
static_assert(sizeof(URoleAttributeOffensiveInfo) == 0x0000C0, "Wrong size on URoleAttributeOffensiveInfo");
static_assert(offsetof(URoleAttributeOffensiveInfo, DPH) == 0x000028, "Member 'URoleAttributeOffensiveInfo::DPH' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, AttackSpeedRate) == 0x00002C, "Member 'URoleAttributeOffensiveInfo::AttackSpeedRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, AttackLevel) == 0x000030, "Member 'URoleAttributeOffensiveInfo::AttackLevel' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, AttackBonus) == 0x000034, "Member 'URoleAttributeOffensiveInfo::AttackBonus' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, CriticalStrikeChance) == 0x000038, "Member 'URoleAttributeOffensiveInfo::CriticalStrikeChance' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, CriticalStrikeDamage) == 0x00003C, "Member 'URoleAttributeOffensiveInfo::CriticalStrikeDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MovementSpeed) == 0x000040, "Member 'URoleAttributeOffensiveInfo::MovementSpeed' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, SkillDamageRate) == 0x000044, "Member 'URoleAttributeOffensiveInfo::SkillDamageRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, PhysicalDamage) == 0x000048, "Member 'URoleAttributeOffensiveInfo::PhysicalDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, FireDamage) == 0x00004C, "Member 'URoleAttributeOffensiveInfo::FireDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, LightningDamage) == 0x000050, "Member 'URoleAttributeOffensiveInfo::LightningDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, ColdDamage) == 0x000054, "Member 'URoleAttributeOffensiveInfo::ColdDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, DivineDamage) == 0x000058, "Member 'URoleAttributeOffensiveInfo::DivineDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, ShadowDamage) == 0x00005C, "Member 'URoleAttributeOffensiveInfo::ShadowDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, PhysicalPenetration) == 0x000060, "Member 'URoleAttributeOffensiveInfo::PhysicalPenetration' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, FirePenetration) == 0x000064, "Member 'URoleAttributeOffensiveInfo::FirePenetration' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, ColdPenetration) == 0x000068, "Member 'URoleAttributeOffensiveInfo::ColdPenetration' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, LightningPenetration) == 0x00006C, "Member 'URoleAttributeOffensiveInfo::LightningPenetration' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, DivinePenetration) == 0x000070, "Member 'URoleAttributeOffensiveInfo::DivinePenetration' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, ShadowPenetration) == 0x000074, "Member 'URoleAttributeOffensiveInfo::ShadowPenetration' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, DamagetoElites) == 0x000078, "Member 'URoleAttributeOffensiveInfo::DamagetoElites' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, DamagetoControlledEnemies) == 0x00007C, "Member 'URoleAttributeOffensiveInfo::DamagetoControlledEnemies' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, IgnoreDefense) == 0x000080, "Member 'URoleAttributeOffensiveInfo::IgnoreDefense' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, AllElementDamage) == 0x000084, "Member 'URoleAttributeOffensiveInfo::AllElementDamage' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, AttackBoostRate) == 0x000088, "Member 'URoleAttributeOffensiveInfo::AttackBoostRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, EliteBoostRate) == 0x00008C, "Member 'URoleAttributeOffensiveInfo::EliteBoostRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, UncontrolledBoostRate) == 0x000090, "Member 'URoleAttributeOffensiveInfo::UncontrolledBoostRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, ResCostReduceRate) == 0x000094, "Member 'URoleAttributeOffensiveInfo::ResCostReduceRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, ResGenerateRate) == 0x000098, "Member 'URoleAttributeOffensiveInfo::ResGenerateRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MagicOverTime) == 0x00009C, "Member 'URoleAttributeOffensiveInfo::MagicOverTime' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MagicOnHit) == 0x0000A0, "Member 'URoleAttributeOffensiveInfo::MagicOnHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MagicOnKill) == 0x0000A4, "Member 'URoleAttributeOffensiveInfo::MagicOnKill' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MagicOnHurt) == 0x0000A8, "Member 'URoleAttributeOffensiveInfo::MagicOnHurt' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, Magic) == 0x0000AC, "Member 'URoleAttributeOffensiveInfo::Magic' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MaxMagic) == 0x0000B0, "Member 'URoleAttributeOffensiveInfo::MaxMagic' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MagicGenerateRate) == 0x0000B4, "Member 'URoleAttributeOffensiveInfo::MagicGenerateRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeOffensiveInfo, MaxSoulEnergy) == 0x0000B8, "Member 'URoleAttributeOffensiveInfo::MaxSoulEnergy' has a wrong offset!");

// Class TGFGame.OnSaveRoleSkin
// 0x0010 (0x0038 - 0x0028)
class UOnSaveRoleSkin final : public UTGFEventArgs
{
public:
	int64                                         RoleGuid;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnSaveRoleSkin">();
	}
	static class UOnSaveRoleSkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnSaveRoleSkin>();
	}
};
static_assert(alignof(UOnSaveRoleSkin) == 0x000008, "Wrong alignment on UOnSaveRoleSkin");
static_assert(sizeof(UOnSaveRoleSkin) == 0x000038, "Wrong size on UOnSaveRoleSkin");
static_assert(offsetof(UOnSaveRoleSkin, RoleGuid) == 0x000028, "Member 'UOnSaveRoleSkin::RoleGuid' has a wrong offset!");
static_assert(offsetof(UOnSaveRoleSkin, bSuccess) == 0x000030, "Member 'UOnSaveRoleSkin::bSuccess' has a wrong offset!");

// Class TGFGame.OnSaveSkinTemplate
// 0x0010 (0x0038 - 0x0028)
class UOnSaveSkinTemplate final : public UTGFEventArgs
{
public:
	class UTGFProtoTgfDUserFacadeSkinGroup*       Template;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnSaveSkinTemplate">();
	}
	static class UOnSaveSkinTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnSaveSkinTemplate>();
	}
};
static_assert(alignof(UOnSaveSkinTemplate) == 0x000008, "Wrong alignment on UOnSaveSkinTemplate");
static_assert(sizeof(UOnSaveSkinTemplate) == 0x000038, "Wrong size on UOnSaveSkinTemplate");
static_assert(offsetof(UOnSaveSkinTemplate, Template) == 0x000028, "Member 'UOnSaveSkinTemplate::Template' has a wrong offset!");
static_assert(offsetof(UOnSaveSkinTemplate, bSuccess) == 0x000030, "Member 'UOnSaveSkinTemplate::bSuccess' has a wrong offset!");

// Class TGFGame.RankUserData
// 0x00C0 (0x00E8 - 0x0028)
class URankUserData final : public UObject
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RoleGuid;                                          // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankType;                                          // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankInstanceId;                                    // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubRankType;                                       // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubRankInstanceId;                                 // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankScore;                                         // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timepoint;                                         // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExcelLoaderTgfConfigExcelRankPeriodRewardPool* Reward;                                            // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x80];                                      // 0x0068(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URankUserData* Create(int32 RankIndex);

	bool IsContainsRank(class URankUserData* RankData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankUserData">();
	}
	static class URankUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankUserData>();
	}
};
static_assert(alignof(URankUserData) == 0x000008, "Wrong alignment on URankUserData");
static_assert(sizeof(URankUserData) == 0x0000E8, "Wrong size on URankUserData");
static_assert(offsetof(URankUserData, UserKey) == 0x000028, "Member 'URankUserData::UserKey' has a wrong offset!");
static_assert(offsetof(URankUserData, RoleGuid) == 0x000038, "Member 'URankUserData::RoleGuid' has a wrong offset!");
static_assert(offsetof(URankUserData, RankType) == 0x000040, "Member 'URankUserData::RankType' has a wrong offset!");
static_assert(offsetof(URankUserData, RankInstanceId) == 0x000044, "Member 'URankUserData::RankInstanceId' has a wrong offset!");
static_assert(offsetof(URankUserData, SubRankType) == 0x000048, "Member 'URankUserData::SubRankType' has a wrong offset!");
static_assert(offsetof(URankUserData, SubRankInstanceId) == 0x00004C, "Member 'URankUserData::SubRankInstanceId' has a wrong offset!");
static_assert(offsetof(URankUserData, Rank) == 0x000050, "Member 'URankUserData::Rank' has a wrong offset!");
static_assert(offsetof(URankUserData, RankScore) == 0x000054, "Member 'URankUserData::RankScore' has a wrong offset!");
static_assert(offsetof(URankUserData, Timepoint) == 0x000058, "Member 'URankUserData::Timepoint' has a wrong offset!");
static_assert(offsetof(URankUserData, Reward) == 0x000060, "Member 'URankUserData::Reward' has a wrong offset!");

// Class TGFGame.OnDeleteSkinTemplate
// 0x0010 (0x0038 - 0x0028)
class UOnDeleteSkinTemplate final : public UTGFEventArgs
{
public:
	class FString                                 ID;                                                // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnDeleteSkinTemplate">();
	}
	static class UOnDeleteSkinTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnDeleteSkinTemplate>();
	}
};
static_assert(alignof(UOnDeleteSkinTemplate) == 0x000008, "Wrong alignment on UOnDeleteSkinTemplate");
static_assert(sizeof(UOnDeleteSkinTemplate) == 0x000038, "Wrong size on UOnDeleteSkinTemplate");
static_assert(offsetof(UOnDeleteSkinTemplate, ID) == 0x000028, "Member 'UOnDeleteSkinTemplate::ID' has a wrong offset!");

// Class TGFGame.OnRoleSelectSkillSuccess
// 0x0008 (0x0030 - 0x0028)
class UOnRoleSelectSkillSuccess final : public UTGFEventArgs
{
public:
	int32                                         Positon;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillId;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnRoleSelectSkillSuccess">();
	}
	static class UOnRoleSelectSkillSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnRoleSelectSkillSuccess>();
	}
};
static_assert(alignof(UOnRoleSelectSkillSuccess) == 0x000008, "Wrong alignment on UOnRoleSelectSkillSuccess");
static_assert(sizeof(UOnRoleSelectSkillSuccess) == 0x000030, "Wrong size on UOnRoleSelectSkillSuccess");
static_assert(offsetof(UOnRoleSelectSkillSuccess, Positon) == 0x000028, "Member 'UOnRoleSelectSkillSuccess::Positon' has a wrong offset!");
static_assert(offsetof(UOnRoleSelectSkillSuccess, SkillId) == 0x00002C, "Member 'UOnRoleSelectSkillSuccess::SkillId' has a wrong offset!");

// Class TGFGame.PVPService
// 0x0140 (0x0170 - 0x0030)
class UPVPService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoomNameMaxLength;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RoomPasswordMaxLength;                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RoomMemberMaxNum;                                  // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               TeamOwner;                                         // 0x0048(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPVPRoomKey*>                    ForceRefreshRoomKeys;                              // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UPVPRoomKey*                            InviteRoomKey;                                     // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPVPRoomListItemObject*>         RoomInfos;                                         // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UPVPRoomListItemObject*>         LastRoomInfos;                                     // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UPVPRoomListItemObject*                 CurrentRoomInfo;                                   // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPVPRoomMember*                         PendingMember;                                     // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<int64>                                   PendingRoomIds;                                    // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UPVPRoomKey*>                    PendingRoomKeys;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UPVPRoomInvitation*>             PendingRoomInvitations;                            // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<int32>                                   IgnoreInvitationRoomIds;                           // 0x0110(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          IsInvitationWindowOpened;                          // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsecutiveInvitationCount;                        // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSearch;                                          // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoEnterRoom;                                     // 0x0169(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasEnterRoomConfirmed;                             // 0x016A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16B[0x5];                                      // 0x016B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPVPRoomInvitation* GetRoomInvitation();
	void RestoreLastRoomInfos();
	void SendRoomBatchGetReq(const TArray<class UPVPRoomKey*>& InRoomKeys, const TArray<class FString>& InRoomNames, bool bInSearch);
	void SendRoomCancelReadyReq();
	void SendRoomChangeMemberPosReq(const struct FUserKey& InMemberUserKey, int32 InTargetPos, bool InIsTeamMember);
	void SendRoomChangeMySelfPosReq(int32 InTargetPos, bool InIsTeamMember);
	void SendRoomCreateReq(const class FString& InRoomName, const class FString& InRoomKeyword);
	void SendRoomDisbandReq();
	void SendRoomEnterReq(class UPVPRoomKey* InRoomKey, const class FString& InRoomKeyword, bool bInInvited);
	void SendRoomGetReadyReq();
	void SendRoomIgnoreAllUserInviteReq();
	void SendRoomIgnoreRoomAllInviteReq(class UPVPRoomKey* InRoomKey);
	void SendRoomInviteAcceptReq(const struct FUserKey& InSendUser, class UPVPRoomKey* InRoomKey);
	void SendRoomInviteRejectReq(const struct FUserKey& InSendUser, class UPVPRoomKey* InRoomKey);
	void SendRoomInviteSendReq(const struct FUserKey& InTargetUser);
	void SendRoomKeywordChangeReq(const class FString& InRoomKeyword);
	void SendRoomKickOffMemberReq(const struct FUserKey& InMemberKey);
	void SendRoomLeaveReq();
	void SendRoomNameChangeReq(const class FString& InName);
	void SendRoomRefreshReq(class UPVPRoomKey* InRoomKey);
	void SendRoomSelectBattleMapReq(int32 InMapId);
	void SendRoomSelectBattleTypeReq(int32 InBattleType);
	void SendRoomStartBattleReq(const class FString& InRegion);
	void SendRoomSuggestReq();
	void SendRoomTransferOwnerReq(const struct FUserKey& InNewOwnerUserKey);
	void SetAutoEnterRoom(bool InAutoEnterRoom);
	void SetHasEnterRoomConfirmed(bool InHasEnterRoomConfirmed);

	bool GetAutoEnterRoom() const;
	int32 GetConsecutiveInvitationCount() const;
	class UPVPRoomListItemObject* GetCurrentRoomInfo() const;
	bool GetHasEnterRoomConfirmed() const;
	int32 GetIndexInWatchMembers(const struct FUserKey& InUserKey) const;
	class UPVPRoomKey* GetInviteRoomKey() const;
	EPVPRoomMemberCamp GetMemberCamp(const struct FUserKey& InUserKey) const;
	int32 GetRoomAudienceMaxNum() const;
	class UPVPRoomListItemObject* GetRoomInfo(class UPVPRoomKey* InRoomKey) const;
	const TArray<class UPVPRoomListItemObject*> GetRoomInfos() const;
	int32 GetRoomMemberMaxNum() const;
	int32 GetRoomNameMaxLength() const;
	int32 GetRoomPasswordMaxLength() const;
	struct FUserKey GetTeamOwnerUserKey() const;
	bool IsAudienceFull() const;
	bool IsLeader(int32 InSlotId, bool InIsTeamMember) const;
	bool IsMySelfOwner() const;
	bool IsMySelfTeamMember() const;
	bool IsOwner(const struct FUserKey& InUserKey) const;
	bool IsPlayerReady(const struct FUserKey& InUserKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPService">();
	}
	static class UPVPService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPService>();
	}
};
static_assert(alignof(UPVPService) == 0x000008, "Wrong alignment on UPVPService");
static_assert(sizeof(UPVPService) == 0x000170, "Wrong size on UPVPService");
static_assert(offsetof(UPVPService, RoomNameMaxLength) == 0x000038, "Member 'UPVPService::RoomNameMaxLength' has a wrong offset!");
static_assert(offsetof(UPVPService, RoomPasswordMaxLength) == 0x00003C, "Member 'UPVPService::RoomPasswordMaxLength' has a wrong offset!");
static_assert(offsetof(UPVPService, RoomMemberMaxNum) == 0x000040, "Member 'UPVPService::RoomMemberMaxNum' has a wrong offset!");
static_assert(offsetof(UPVPService, TeamOwner) == 0x000048, "Member 'UPVPService::TeamOwner' has a wrong offset!");
static_assert(offsetof(UPVPService, ForceRefreshRoomKeys) == 0x000058, "Member 'UPVPService::ForceRefreshRoomKeys' has a wrong offset!");
static_assert(offsetof(UPVPService, InviteRoomKey) == 0x000068, "Member 'UPVPService::InviteRoomKey' has a wrong offset!");
static_assert(offsetof(UPVPService, RoomInfos) == 0x000070, "Member 'UPVPService::RoomInfos' has a wrong offset!");
static_assert(offsetof(UPVPService, LastRoomInfos) == 0x000080, "Member 'UPVPService::LastRoomInfos' has a wrong offset!");
static_assert(offsetof(UPVPService, CurrentRoomInfo) == 0x000090, "Member 'UPVPService::CurrentRoomInfo' has a wrong offset!");
static_assert(offsetof(UPVPService, PendingMember) == 0x000098, "Member 'UPVPService::PendingMember' has a wrong offset!");
static_assert(offsetof(UPVPService, PendingRoomIds) == 0x0000A0, "Member 'UPVPService::PendingRoomIds' has a wrong offset!");
static_assert(offsetof(UPVPService, PendingRoomKeys) == 0x0000F0, "Member 'UPVPService::PendingRoomKeys' has a wrong offset!");
static_assert(offsetof(UPVPService, PendingRoomInvitations) == 0x000100, "Member 'UPVPService::PendingRoomInvitations' has a wrong offset!");
static_assert(offsetof(UPVPService, IgnoreInvitationRoomIds) == 0x000110, "Member 'UPVPService::IgnoreInvitationRoomIds' has a wrong offset!");
static_assert(offsetof(UPVPService, IsInvitationWindowOpened) == 0x000160, "Member 'UPVPService::IsInvitationWindowOpened' has a wrong offset!");
static_assert(offsetof(UPVPService, ConsecutiveInvitationCount) == 0x000164, "Member 'UPVPService::ConsecutiveInvitationCount' has a wrong offset!");
static_assert(offsetof(UPVPService, IsSearch) == 0x000168, "Member 'UPVPService::IsSearch' has a wrong offset!");
static_assert(offsetof(UPVPService, AutoEnterRoom) == 0x000169, "Member 'UPVPService::AutoEnterRoom' has a wrong offset!");
static_assert(offsetof(UPVPService, HasEnterRoomConfirmed) == 0x00016A, "Member 'UPVPService::HasEnterRoomConfirmed' has a wrong offset!");

// Class TGFGame.TabIdObject
// 0x0010 (0x0038 - 0x0028)
class UTabIdObject final : public UObject
{
public:
	int32                                         TabId;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalId;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_TabIdObject;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabIdObject">();
	}
	static class UTabIdObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabIdObject>();
	}
};
static_assert(alignof(UTabIdObject) == 0x000008, "Wrong alignment on UTabIdObject");
static_assert(sizeof(UTabIdObject) == 0x000038, "Wrong size on UTabIdObject");
static_assert(offsetof(UTabIdObject, TabId) == 0x000028, "Member 'UTabIdObject::TabId' has a wrong offset!");
static_assert(offsetof(UTabIdObject, AdditionalId) == 0x00002C, "Member 'UTabIdObject::AdditionalId' has a wrong offset!");
static_assert(offsetof(UTabIdObject, Index_TabIdObject) == 0x000030, "Member 'UTabIdObject::Index_TabIdObject' has a wrong offset!");

// Class TGFGame.TabNameObject
// 0x0018 (0x0040 - 0x0028)
class UTabNameObject final : public UObject
{
public:
	class FString                                 TabName;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_TabNameObject;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabNameObject">();
	}
	static class UTabNameObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabNameObject>();
	}
};
static_assert(alignof(UTabNameObject) == 0x000008, "Wrong alignment on UTabNameObject");
static_assert(sizeof(UTabNameObject) == 0x000040, "Wrong size on UTabNameObject");
static_assert(offsetof(UTabNameObject, TabName) == 0x000028, "Member 'UTabNameObject::TabName' has a wrong offset!");
static_assert(offsetof(UTabNameObject, Index_TabNameObject) == 0x000038, "Member 'UTabNameObject::Index_TabNameObject' has a wrong offset!");

// Class TGFGame.TypeIdObject
// 0x0008 (0x0030 - 0x0028)
class UTypeIdObject final : public UObject
{
public:
	int32                                         TypeId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypeIdObject">();
	}
	static class UTypeIdObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypeIdObject>();
	}
};
static_assert(alignof(UTypeIdObject) == 0x000008, "Wrong alignment on UTypeIdObject");
static_assert(sizeof(UTypeIdObject) == 0x000030, "Wrong size on UTypeIdObject");
static_assert(offsetof(UTypeIdObject, TypeId) == 0x000028, "Member 'UTypeIdObject::TypeId' has a wrong offset!");
static_assert(offsetof(UTypeIdObject, Count) == 0x00002C, "Member 'UTypeIdObject::Count' has a wrong offset!");

// Class TGFGame.InventoryService
// 0x05F8 (0x0628 - 0x0030)
class UInventoryService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTGFUserInvetoryData>           Storages;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTGFUserInvetoryData                   Storage_default;                                   // 0x0048(0x0030)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x2D0];                                     // 0x0078(0x02D0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FIntPoint>                 Item_size_map;                                     // 0x0348(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, int32>                            Item_stack_map;                                    // 0x0398(0x0050)(NativeAccessSpecifierPrivate)
	struct FTGFItem                               Item_temp;                                         // 0x03E8(0x0058)(NativeAccessSpecifierPrivate)
	TArray<struct FTGFItemMoveAction>             Pending_move_actions;                              // 0x0440(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTGFItemPosition                       Pending_swap_src;                                  // 0x0450(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FTGFItemPosition                       Pending_swap_dest;                                 // 0x0468(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FTGFItemPosition                       Pending_wear_item;                                 // 0x0480(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         Pending_takeoff;                                   // 0x0498(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Current_guid;                                      // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                ClickDragingWidget;                                // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, ETgfEquipQuality>                 Itemid_quality;                                    // 0x04B0(0x0050)(NativeAccessSpecifierPrivate)
	class UTGFWindow*                             Inventory_window;                                  // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Tooltips_compare;                                  // 0x0508(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Waitting_operation_response;                       // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UUserWidget*>                      Disable_hotkey_widgets;                            // 0x0510(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UUserWidget*                            Item_tooltip;                                      // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PageAddItemId;                                     // 0x0568(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PageAddItemCount;                                  // 0x056C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LastUseItemTypeId;                                 // 0x0570(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfDUserSoulBound*             UserSoulBound;                                     // 0x0578(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFProtoTgfDUserFacadeData*            UserFacadeData;                                    // 0x0580(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UTGFProtoTgfDUserFacadeMeta*> OwnSkins;                                          // 0x0588(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, int32>                            VirtualItemRowIndexMap;                            // 0x05D8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static int32 GetAllFirstLevelAttributeId();
	static int32 GetDPHAttributeId();
	static float GetRoleAttributeValue(class URoleAttributeInfo* AttributeInfo, EnRoleDisplayAttribueID Type_id);
	static void SortConsumeItems(TArray<struct FTGFItem>* Items);
	static class UTGFProtoTgfDItem* TGFItemToTGFProtoTgfDItem(const struct FTGFItem& Item);

	bool CanInventoryHotkey();
	void DisableInventoryHotkey(class UUserWidget* Widget);
	class UWidget* DuplicateWidget(class UWidget* Src, const class FName Param_Name);
	void EnableInventoryHotkey(class UUserWidget* Widget);
	const class UTgfEquipmentDefinition* FindEquipmentDefinition(int32 Type_id);
	void FireHostEquipChnaged();
	void FireLobbyInventoryOpen();
	bool GetAffixDisplayConfig(const struct FTGFItem& TGFItem, TArray<struct FAffixDisplayConfig>* Base, TArray<struct FAffixDisplayConfig>* MainBasic, TArray<struct FAffixDisplayConfig>* TopAffix, TArray<struct FAffixDisplayConfig>* GemAffix, TArray<struct FAffixDisplayConfig>* GearSetAffix);
	bool GetAffixDisplayConfigByPos(const struct FTGFItemPosition& Pos, TArray<struct FAffixDisplayConfig>* Base, TArray<struct FAffixDisplayConfig>* MainBasic, TArray<struct FAffixDisplayConfig>* TopAffix, TArray<struct FAffixDisplayConfig>* GemAffix, TArray<struct FAffixDisplayConfig>* GearSetAffix);
	void GetAllAffix(int64 Guid, TMap<int32, float>* Attributes, TMap<int32, float>* base_attributes);
	int32 GetAllEquipLevel();
	const class UTgfArmorDefinition* GetArmorDefinition(int32 Type_id);
	float GetAverageDefence(int64 Guid);
	float GetAverageDPH(int64 Guid);
	bool GetBagData(int64 Guid, struct FTGFUserInvetoryData* Inventory, TArray<struct FTGFItem>* Items);
	bool GetCellItem(EnItemStorageType Type, int32 X, int32 Y, int32 PageId, struct FTGFItem* Item);
	class UWidget* GetClickDragingWidget();
	int64 GetCoin();
	int64 GetCoinItem(int32 Type_id);
	int32 GetCostItemCount(int32 TypeId);
	int64 GetCurrentRole();
	bool GetEquipmentData(int64 Guid, TArray<struct FTGFItem>* Items);
	ETgfEquipSubType GetEquipSubtype(int32 Type_id);
	ETgfWeaponEquipType GetEquipType(int32 Type_id);
	class UTGFProtoTgfDUserFacadeData* GetFacadeDta();
	const class UAnimSequenceBase* GetIdleAnimation(int32 Main_type_id, int32 Second_type_id, const struct FGameplayTagContainer& WithTags, bool* bIsRightIdle);
	const class UInventoryFragment_InventoryIcon* GetInventoryIcon(int32 Type_id);
	class UTGFWindow* GetInventoryWindow();
	TSet<int32> GetItemAffixAttributeIds(int32 ItemId);
	void GetItemAffixDisplayConfig(int32 ItemId, TArray<struct FAffixDisplayConfig>* Affix, TArray<struct FAffixDisplayConfig>* Base, TArray<struct FAffixDisplayConfig>* Main, TArray<struct FAffixDisplayConfig>* Top, TArray<struct FAffixDisplayConfig>* Gem, TArray<struct FAffixDisplayConfig>* GearSet);
	bool GetItemByGuid(int64 RoleGuid, int64 ItemGuid, struct FTGFItem* Item);
	const class UTgfInventoryItemDefinition* GetItemConfig(int32 Type_id);
	bool GetItemConfigClass(int32 Type_id, TSubclassOf<class UTgfInventoryItemDefinition>* ItemClass);
	int32 GetItemCountInPackage(int64 Guid, int32 Type_id);
	ETGFProtoTgfEnItemMinorType GetItemItemMinorType(int32 Type_id);
	ETGFProtoTgfEnItemMajorType GetItemMajorType(int32 Type_id);
	ETgfEquipQuality GetItemQuality(int32 Type_id);
	void GetItemsById(int64 Guid, int32 Type_id, TArray<struct FTGFItem>* Out_items);
	void GetItemsByIdAndType(int64 Guid, int32 Type_id, EnItemStorageType Type, TArray<struct FTGFItem>* Out_items);
	struct FIntPoint GetItemSize(int32 Type_id);
	int32 GetItemSkinId(ETgfSkinSlot Slot);
	class UUserWidget* GetItemTooltipWidget();
	bool GetMatchEquip(int32 Type_id, struct FTGFItem* Item);
	int32 GetPageAddItemId(int32* Count);
	int64 GetPayDiamond();
	class URoleAttributeInfo* GetRoleAttributeInfo(int64 Guid);
	bool GetRoleEquipment(int32 Guid, int32 X, struct FTGFItem* Item);
	bool GetRoleWeaponOnHand(int64 Guid, int32* Right, int32* Left);
	int64 GetSkinAcquireTime(int32 SkinId);
	int32 GetSkinByThirdSlot(int32 ThirdSlot);
	bool GetSmallPackData(int64 Guid, struct FTGFUserInvetoryData* Inventory, TArray<struct FTGFItem>* Items);
	class UTGFProtoTgfDUserSoulBound* GetSoulBound();
	bool GetStackCount(int32 Type_id, int32* Stack_count);
	struct FTGFUserInvetoryData GetStorageData(int32 PageId, TArray<struct FTGFItem>* Items);
	int32 GetStoragePageCount();
	int32 GetTalentsCount();
	bool GetTooltipCompare();
	int32 GetVirtualItem(int32 Type_id);
	bool GetVirtualItemInfo(int32 Type_id, struct FTGFItem* Item);
	int32 GetVirtualItemRowIndex(int32 TypeId);
	TArray<class UTypeIdObject*> GetVirtualItems();
	bool GetWeaponOnHand(int32* Right, int32* Left);
	bool IsBothHandWeapon(int32 Type_id);
	bool IsCellValid(EnItemStorageType Type, const struct FIntPoint& Cell, const struct FIntPoint& Size, int32 PageId);
	bool IsEquipment(int32 Type_id);
	bool IsFreezeOperation();
	bool IsHaveSkin(int32 SkinId);
	bool IsHiddenHelmet();
	bool IsItemMatchLeftWeapon(int32 Main_type_id, int32 Left_type_id);
	bool IsItemMatchSlot(int32 Type_id, ETgfEquipSlot SlotType, const struct FGameplayTagContainer& Container, bool IgnoreCondition);
	bool IsMatchSlotConfig(ETgfEquipSlot SlotType, ETgfEquipSubType WeaponType, const struct FGameplayTagContainer& Container, bool IgnoreCondition);
	float Lua_GetRoleAttributeValue(EnRoleDisplayAttribueID AttributeID);
	void Lua_Initialized();
	void Lua_OnPreLoadMap(const class FString& MapName);
	void OnGameLogout(class UTGFEventArgs* Args);
	void OpenInventoryWindow(bool byHotkey);
	void ResetCell(EnItemStorageType Type, const struct FIntVector& Cell, const struct FIntPoint& Size);
	int32 ResetFreezeOperationTime();
	void SendDeleteSkinTemplate(const class FString& ID);
	void SendInventoryItemMoveReq(const TArray<struct FTGFItemMoveAction>& Actions);
	void SendInventoryItemSwapReq(const struct FTGFItemPosition& SrcCell, const struct FTGFItemPosition& DestCell, const struct FTGFItemPosition& Pos1, const struct FTGFItemPosition& Pos2);
	void SendInventoryPageAddReq();
	void SendMithrilRoleWearReq(int32 TypeId, int32 Count, const struct FTGFItemPosition& Position);
	void SendRoleSelectSkillReq(int32 Position, int32 SkillId);
	void SendSaveRoleSkin(int64 RoleGuid, const TArray<int32>& ItemIds, bool bHideHelmet);
	void SendSaveSkinTemplate(const class FString& Param_Name, const TArray<int32>& ItemIds, bool bHideHelmet);
	void SendSoulBoundReq(int32 Param_Index, TArray<struct FTGFItem>* Items, int64 Guid);
	void SendTakeoffItem(const struct FTGFItemPosition& ItemCell, const struct FTGFItemPosition& DestCell, const struct FTGFItemPosition& SecondPos);
	void SendUseItem(const struct FTGFItem& Item, int32 Count, int32 Param_Index);
	void SendWeaponSetSwap(const struct FTGFItemPosition& SrcCell1, const struct FTGFItemPosition& SrcCell2, const struct FTGFItemPosition& DestCell1, const struct FTGFItemPosition& DestCell2);
	void SendWearItem(const struct FTGFItemPosition& ItemCell, int32 Partid, const struct FTGFItemPosition& SwapPos, const struct FTGFItemPosition& SecondPos, int32 ItemCount);
	void SetClickDragingWidget(class UWidget* Widget);
	void SetCurrentRole(int64 Guid);
	void SetInventoryWindow(class UTGFWindow* Win);
	void SetItemTooltipWidget(class UUserWidget* Widget);
	void SetTooltipCompare(bool Compare);
	void SpawnEquipmentActorsWithAttachTarget(int32 Type_id, class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors, bool bAttachToLeft);
	void SpawnEquipmentActorsWithAttachTargetByDefinition(const class UTgfEquipmentDefinition* Def, class USceneComponent* AttachTarget, TArray<class AActor*>* OutSpawnedActors, bool bAttachToLeft);

	const class ULyraInventoryItemFragment* FindFragmentByClass(TSubclassOf<class ULyraInventoryItemDefinition> Item_class, TSubclassOf<class ULyraInventoryItemFragment> Fragment_class) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryService">();
	}
	static class UInventoryService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryService>();
	}
};
static_assert(alignof(UInventoryService) == 0x000008, "Wrong alignment on UInventoryService");
static_assert(sizeof(UInventoryService) == 0x000628, "Wrong size on UInventoryService");
static_assert(offsetof(UInventoryService, Storages) == 0x000038, "Member 'UInventoryService::Storages' has a wrong offset!");
static_assert(offsetof(UInventoryService, Storage_default) == 0x000048, "Member 'UInventoryService::Storage_default' has a wrong offset!");
static_assert(offsetof(UInventoryService, Item_size_map) == 0x000348, "Member 'UInventoryService::Item_size_map' has a wrong offset!");
static_assert(offsetof(UInventoryService, Item_stack_map) == 0x000398, "Member 'UInventoryService::Item_stack_map' has a wrong offset!");
static_assert(offsetof(UInventoryService, Item_temp) == 0x0003E8, "Member 'UInventoryService::Item_temp' has a wrong offset!");
static_assert(offsetof(UInventoryService, Pending_move_actions) == 0x000440, "Member 'UInventoryService::Pending_move_actions' has a wrong offset!");
static_assert(offsetof(UInventoryService, Pending_swap_src) == 0x000450, "Member 'UInventoryService::Pending_swap_src' has a wrong offset!");
static_assert(offsetof(UInventoryService, Pending_swap_dest) == 0x000468, "Member 'UInventoryService::Pending_swap_dest' has a wrong offset!");
static_assert(offsetof(UInventoryService, Pending_wear_item) == 0x000480, "Member 'UInventoryService::Pending_wear_item' has a wrong offset!");
static_assert(offsetof(UInventoryService, Pending_takeoff) == 0x000498, "Member 'UInventoryService::Pending_takeoff' has a wrong offset!");
static_assert(offsetof(UInventoryService, Current_guid) == 0x0004A0, "Member 'UInventoryService::Current_guid' has a wrong offset!");
static_assert(offsetof(UInventoryService, ClickDragingWidget) == 0x0004A8, "Member 'UInventoryService::ClickDragingWidget' has a wrong offset!");
static_assert(offsetof(UInventoryService, Itemid_quality) == 0x0004B0, "Member 'UInventoryService::Itemid_quality' has a wrong offset!");
static_assert(offsetof(UInventoryService, Inventory_window) == 0x000500, "Member 'UInventoryService::Inventory_window' has a wrong offset!");
static_assert(offsetof(UInventoryService, Tooltips_compare) == 0x000508, "Member 'UInventoryService::Tooltips_compare' has a wrong offset!");
static_assert(offsetof(UInventoryService, Waitting_operation_response) == 0x00050C, "Member 'UInventoryService::Waitting_operation_response' has a wrong offset!");
static_assert(offsetof(UInventoryService, Disable_hotkey_widgets) == 0x000510, "Member 'UInventoryService::Disable_hotkey_widgets' has a wrong offset!");
static_assert(offsetof(UInventoryService, Item_tooltip) == 0x000560, "Member 'UInventoryService::Item_tooltip' has a wrong offset!");
static_assert(offsetof(UInventoryService, PageAddItemId) == 0x000568, "Member 'UInventoryService::PageAddItemId' has a wrong offset!");
static_assert(offsetof(UInventoryService, PageAddItemCount) == 0x00056C, "Member 'UInventoryService::PageAddItemCount' has a wrong offset!");
static_assert(offsetof(UInventoryService, LastUseItemTypeId) == 0x000570, "Member 'UInventoryService::LastUseItemTypeId' has a wrong offset!");
static_assert(offsetof(UInventoryService, UserSoulBound) == 0x000578, "Member 'UInventoryService::UserSoulBound' has a wrong offset!");
static_assert(offsetof(UInventoryService, UserFacadeData) == 0x000580, "Member 'UInventoryService::UserFacadeData' has a wrong offset!");
static_assert(offsetof(UInventoryService, OwnSkins) == 0x000588, "Member 'UInventoryService::OwnSkins' has a wrong offset!");
static_assert(offsetof(UInventoryService, VirtualItemRowIndexMap) == 0x0005D8, "Member 'UInventoryService::VirtualItemRowIndexMap' has a wrong offset!");

// Class TGFGame.SDKGmeLeaveRoomEvent
// 0x0000 (0x0028 - 0x0028)
class USDKGmeLeaveRoomEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGmeLeaveRoomEvent">();
	}
	static class USDKGmeLeaveRoomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGmeLeaveRoomEvent>();
	}
};
static_assert(alignof(USDKGmeLeaveRoomEvent) == 0x000008, "Wrong alignment on USDKGmeLeaveRoomEvent");
static_assert(sizeof(USDKGmeLeaveRoomEvent) == 0x000028, "Wrong size on USDKGmeLeaveRoomEvent");

// Class TGFGame.JumpManager
// 0x0008 (0x0038 - 0x0030)
class UJumpManager final : public UTGFSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpByHref(const class FString& Href);
	void Lua_HyperlinkJump(const class FString& Href);
	void Lua_Initialized();
	void OnHyperlinkJumpDelegate(const class FString& Href);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpManager">();
	}
	static class UJumpManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJumpManager>();
	}
};
static_assert(alignof(UJumpManager) == 0x000008, "Wrong alignment on UJumpManager");
static_assert(sizeof(UJumpManager) == 0x000038, "Wrong size on UJumpManager");

// Class TGFGame.LevelItem
// 0x0018 (0x0040 - 0x0028)
class ULevelItem final : public UObject
{
public:
	int32                                         LevelId;                                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelType;                                         // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelItem">();
	}
	static class ULevelItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelItem>();
	}
};
static_assert(alignof(ULevelItem) == 0x000008, "Wrong alignment on ULevelItem");
static_assert(sizeof(ULevelItem) == 0x000040, "Wrong size on ULevelItem");
static_assert(offsetof(ULevelItem, LevelId) == 0x000028, "Member 'ULevelItem::LevelId' has a wrong offset!");
static_assert(offsetof(ULevelItem, LevelType) == 0x00002C, "Member 'ULevelItem::LevelType' has a wrong offset!");
static_assert(offsetof(ULevelItem, LevelName) == 0x000030, "Member 'ULevelItem::LevelName' has a wrong offset!");

// Class TGFGame.LevelService
// 0x0010 (0x0040 - 0x0030)
class ULevelService final : public UTGFService
{
public:
	TArray<class ULevelItem*>                     Levels;                                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class ULevelItem* GetLevelItemByIdAndType(const int32 LevelId, const int32 LevelType) const;
	class ULevelItem* GetLevelItemByName(const class FString& Param_Name) const;
	const TArray<class ULevelItem*> GetLevels() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelService">();
	}
	static class ULevelService* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelService>();
	}
};
static_assert(alignof(ULevelService) == 0x000008, "Wrong alignment on ULevelService");
static_assert(sizeof(ULevelService) == 0x000040, "Wrong size on ULevelService");
static_assert(offsetof(ULevelService, Levels) == 0x000030, "Member 'ULevelService::Levels' has a wrong offset!");

// Class TGFGame.LobbyService
// 0x0048 (0x0078 - 0x0030)
class ULobbyService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BackToHallWindow();
	void ChangeHallForce(ETGFProtoTgfEnHallSwitchType SwitchType);
	bool CheckCanChangeHallForce(bool bIsToast);
	class FString GetCurrentLobbyName();
	struct FPlayerProfile GetPlayerProfile();
	void LoadLobbyLevel(class FName LevelName, TSubclassOf<class UUserWidget> LobbyUi);
	void OnLoadingEnd(class UWorld* LoadedWorld);
	void SendPlayerGetInfoReq();
	void SetCurrentLobbyName(const class FString& LobbyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyService">();
	}
	static class ULobbyService* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyService>();
	}
};
static_assert(alignof(ULobbyService) == 0x000008, "Wrong alignment on ULobbyService");
static_assert(sizeof(ULobbyService) == 0x000078, "Wrong size on ULobbyService");

// Class TGFGame.RoleRaceData
// 0x0018 (0x0040 - 0x0028)
class URoleRaceData final : public UObject
{
public:
	int32                                         RaceID;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UExcelLoaderTgfConfigExcelRoleType*> ConfigList;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleRaceData">();
	}
	static class URoleRaceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleRaceData>();
	}
};
static_assert(alignof(URoleRaceData) == 0x000008, "Wrong alignment on URoleRaceData");
static_assert(sizeof(URoleRaceData) == 0x000040, "Wrong size on URoleRaceData");
static_assert(offsetof(URoleRaceData, RaceID) == 0x000028, "Member 'URoleRaceData::RaceID' has a wrong offset!");
static_assert(offsetof(URoleRaceData, ConfigList) == 0x000030, "Member 'URoleRaceData::ConfigList' has a wrong offset!");

// Class TGFGame.DUserRole
// 0x0078 (0x00A0 - 0x0028)
class UDUserRole final : public UObject
{
public:
	int64                                         CurrentGuid;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTGFUserRole                           UserRole;                                          // 0x0030(0x0070)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DUserRole">();
	}
	static class UDUserRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDUserRole>();
	}
};
static_assert(alignof(UDUserRole) == 0x000008, "Wrong alignment on UDUserRole");
static_assert(sizeof(UDUserRole) == 0x0000A0, "Wrong size on UDUserRole");
static_assert(offsetof(UDUserRole, CurrentGuid) == 0x000028, "Member 'UDUserRole::CurrentGuid' has a wrong offset!");
static_assert(offsetof(UDUserRole, UserRole) == 0x000030, "Member 'UDUserRole::UserRole' has a wrong offset!");

// Class TGFGame.SDKFriendService
// 0x0010 (0x0040 - 0x0030)
class USDKFriendService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKFriendService">();
	}
	static class USDKFriendService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKFriendService>();
	}
};
static_assert(alignof(USDKFriendService) == 0x000008, "Wrong alignment on USDKFriendService");
static_assert(sizeof(USDKFriendService) == 0x000040, "Wrong size on USDKFriendService");

// Class TGFGame.LoginCreateRoleWindow
// 0x0018 (0x02D0 - 0x02B8)
class ULoginCreateRoleWindow final : public UTGFWindow
{
public:
	class UCreateWindowArgs*                      WindowArgs;                                        // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDUserRole*>                     UserRoles;                                         // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void CancelLazyDeleteRole(int64 Guid);
	void EnterHallWithGuid(int64 SelectGuid, int64 CurrentGuid);
	TArray<class URoleRaceData*> GetRaceList();
	TArray<class UExcelLoaderTgfConfigExcelRoleType*> GetRaceListBy(int32 Race);
	class UTexture2D* GetTexture2D(const class FString& Fs);
	TArray<class UDUserRole*> GetUserRoles();
	void LazyDeleteRole(int64 Guid);
	void LeaveCreate();
	void OnHallSetRoleRspSuccess(class UTGFEventArgs* Args);
	void OnLazyDeleteTimeReached(int64 Guid);
	void OnReshapeFaceRspSuccess(class UTGFEventArgs* Args);
	void OnRoleCreateSuccess(class UTGFEventArgs* Args);
	void OnRoleDeleteResponse(class UTGFEventArgs* Args);
	void SendHallSetRoleReq(int64 Guid);
	void SendRoleCreateReq(const struct FRoleCreateData& Data);
	void SendRoleCreateRequest(int32 TypeId, const class FString& RoleName, int32 Gender);
	void SendRoleDeleteReq(int64 Guid);
	void SendRoleReshapeFaceReq(int64 InRoleID, const struct FRoleCreateData& Data);
	void TryDeleteRole(int64 Guid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginCreateRoleWindow">();
	}
	static class ULoginCreateRoleWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginCreateRoleWindow>();
	}
};
static_assert(alignof(ULoginCreateRoleWindow) == 0x000008, "Wrong alignment on ULoginCreateRoleWindow");
static_assert(sizeof(ULoginCreateRoleWindow) == 0x0002D0, "Wrong size on ULoginCreateRoleWindow");
static_assert(offsetof(ULoginCreateRoleWindow, WindowArgs) == 0x0002B8, "Member 'ULoginCreateRoleWindow::WindowArgs' has a wrong offset!");
static_assert(offsetof(ULoginCreateRoleWindow, UserRoles) == 0x0002C0, "Member 'ULoginCreateRoleWindow::UserRoles' has a wrong offset!");

// Class TGFGame.TGFSDKLoginSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSDKLoginSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSDKLoginSuccessEvent">();
	}
	static class UTGFSDKLoginSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSDKLoginSuccessEvent>();
	}
};
static_assert(alignof(UTGFSDKLoginSuccessEvent) == 0x000008, "Wrong alignment on UTGFSDKLoginSuccessEvent");
static_assert(sizeof(UTGFSDKLoginSuccessEvent) == 0x000028, "Wrong size on UTGFSDKLoginSuccessEvent");

// Class TGFGame.SDKMapleQuerySuccessEvent
// 0x0010 (0x0038 - 0x0028)
class USDKMapleQuerySuccessEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKMapleQuerySuccessEvent">();
	}
	static class USDKMapleQuerySuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKMapleQuerySuccessEvent>();
	}
};
static_assert(alignof(USDKMapleQuerySuccessEvent) == 0x000008, "Wrong alignment on USDKMapleQuerySuccessEvent");
static_assert(sizeof(USDKMapleQuerySuccessEvent) == 0x000038, "Wrong size on USDKMapleQuerySuccessEvent");

// Class TGFGame.TGFSDKLoginFailedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSDKLoginFailedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSDKLoginFailedEvent">();
	}
	static class UTGFSDKLoginFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSDKLoginFailedEvent>();
	}
};
static_assert(alignof(UTGFSDKLoginFailedEvent) == 0x000008, "Wrong alignment on UTGFSDKLoginFailedEvent");
static_assert(sizeof(UTGFSDKLoginFailedEvent) == 0x000028, "Wrong size on UTGFSDKLoginFailedEvent");

// Class TGFGame.TGFGamePreLoginSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGamePreLoginSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGamePreLoginSuccessEvent">();
	}
	static class UTGFGamePreLoginSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGamePreLoginSuccessEvent>();
	}
};
static_assert(alignof(UTGFGamePreLoginSuccessEvent) == 0x000008, "Wrong alignment on UTGFGamePreLoginSuccessEvent");
static_assert(sizeof(UTGFGamePreLoginSuccessEvent) == 0x000028, "Wrong size on UTGFGamePreLoginSuccessEvent");

// Class TGFGame.SDKGMEService
// 0x0168 (0x0198 - 0x0030)
class USDKGMEService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayGmeSendEvent;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopGmeSendEvent;                                  // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          PlayGmeReceiveEvent;                               // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopGmeReceiveEvent;                               // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          PlayGmeReceive3dEvent;                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopGmeReceive3dEvent;                             // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x130];                                     // 0x0068(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGMEService">();
	}
	static class USDKGMEService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGMEService>();
	}
};
static_assert(alignof(USDKGMEService) == 0x000008, "Wrong alignment on USDKGMEService");
static_assert(sizeof(USDKGMEService) == 0x000198, "Wrong size on USDKGMEService");
static_assert(offsetof(USDKGMEService, PlayGmeSendEvent) == 0x000038, "Member 'USDKGMEService::PlayGmeSendEvent' has a wrong offset!");
static_assert(offsetof(USDKGMEService, StopGmeSendEvent) == 0x000040, "Member 'USDKGMEService::StopGmeSendEvent' has a wrong offset!");
static_assert(offsetof(USDKGMEService, PlayGmeReceiveEvent) == 0x000048, "Member 'USDKGMEService::PlayGmeReceiveEvent' has a wrong offset!");
static_assert(offsetof(USDKGMEService, StopGmeReceiveEvent) == 0x000050, "Member 'USDKGMEService::StopGmeReceiveEvent' has a wrong offset!");
static_assert(offsetof(USDKGMEService, PlayGmeReceive3dEvent) == 0x000058, "Member 'USDKGMEService::PlayGmeReceive3dEvent' has a wrong offset!");
static_assert(offsetof(USDKGMEService, StopGmeReceive3dEvent) == 0x000060, "Member 'USDKGMEService::StopGmeReceive3dEvent' has a wrong offset!");

// Class TGFGame.TGFGamePreLoginFailedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFGamePreLoginFailedEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGamePreLoginFailedEvent">();
	}
	static class UTGFGamePreLoginFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGamePreLoginFailedEvent>();
	}
};
static_assert(alignof(UTGFGamePreLoginFailedEvent) == 0x000008, "Wrong alignment on UTGFGamePreLoginFailedEvent");
static_assert(sizeof(UTGFGamePreLoginFailedEvent) == 0x000030, "Wrong size on UTGFGamePreLoginFailedEvent");

// Class TGFGame.TGFGamePreLoginUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGamePreLoginUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGamePreLoginUpdateEvent">();
	}
	static class UTGFGamePreLoginUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGamePreLoginUpdateEvent>();
	}
};
static_assert(alignof(UTGFGamePreLoginUpdateEvent) == 0x000008, "Wrong alignment on UTGFGamePreLoginUpdateEvent");
static_assert(sizeof(UTGFGamePreLoginUpdateEvent) == 0x000028, "Wrong size on UTGFGamePreLoginUpdateEvent");

// Class TGFGame.SceneAppearanceActor
// 0x0010 (0x02A8 - 0x0298)
class ASceneAppearanceActor final : public AActor
{
public:
	class UTextureRenderTarget2D*                 AppearanceRenderTarget;                            // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* GetCurrentCaptureContent();
	class UTextureRenderTarget2D* GetCurrentCaptureRenderTarget();
	void ReregisterMesh();
	void SetCaptureComponent();
	void UpdateAvatorCapture(const struct FTgfAvatarBuildConfig& InAppearanceConfig, const struct FIntPoint& NewRTSize);
	void UpdateCapture();
	void UpdateCaptureTarget(class UTextureRenderTarget2D* NewTarget);
	void UpdateMesh(const struct FTgfAvatarBuildConfig& InAppearanceConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneAppearanceActor">();
	}
	static class ASceneAppearanceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneAppearanceActor>();
	}
};
static_assert(alignof(ASceneAppearanceActor) == 0x000008, "Wrong alignment on ASceneAppearanceActor");
static_assert(sizeof(ASceneAppearanceActor) == 0x0002A8, "Wrong size on ASceneAppearanceActor");
static_assert(offsetof(ASceneAppearanceActor, AppearanceRenderTarget) == 0x000298, "Member 'ASceneAppearanceActor::AppearanceRenderTarget' has a wrong offset!");

// Class TGFGame.TGFGameLoginSuccessEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFGameLoginSuccessEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameLoginSuccessEvent">();
	}
	static class UTGFGameLoginSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameLoginSuccessEvent>();
	}
};
static_assert(alignof(UTGFGameLoginSuccessEvent) == 0x000008, "Wrong alignment on UTGFGameLoginSuccessEvent");
static_assert(sizeof(UTGFGameLoginSuccessEvent) == 0x000038, "Wrong size on UTGFGameLoginSuccessEvent");

// Class TGFGame.TGFGameLoginFailedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFGameLoginFailedEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameLoginFailedEvent">();
	}
	static class UTGFGameLoginFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameLoginFailedEvent>();
	}
};
static_assert(alignof(UTGFGameLoginFailedEvent) == 0x000008, "Wrong alignment on UTGFGameLoginFailedEvent");
static_assert(sizeof(UTGFGameLoginFailedEvent) == 0x000030, "Wrong size on UTGFGameLoginFailedEvent");

// Class TGFGame.SDKLBSIPInfoResultEvent
// 0x0020 (0x0048 - 0x0028)
class USDKLBSIPInfoResultEvent final : public UTGFEventArgs
{
public:
	class FString                                 Region;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Alpha2;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKLBSIPInfoResultEvent">();
	}
	static class USDKLBSIPInfoResultEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKLBSIPInfoResultEvent>();
	}
};
static_assert(alignof(USDKLBSIPInfoResultEvent) == 0x000008, "Wrong alignment on USDKLBSIPInfoResultEvent");
static_assert(sizeof(USDKLBSIPInfoResultEvent) == 0x000048, "Wrong size on USDKLBSIPInfoResultEvent");
static_assert(offsetof(USDKLBSIPInfoResultEvent, Region) == 0x000028, "Member 'USDKLBSIPInfoResultEvent::Region' has a wrong offset!");
static_assert(offsetof(USDKLBSIPInfoResultEvent, Alpha2) == 0x000038, "Member 'USDKLBSIPInfoResultEvent::Alpha2' has a wrong offset!");

// Class TGFGame.TGFSyncPlayerInfoSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSyncPlayerInfoSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSyncPlayerInfoSuccessEvent">();
	}
	static class UTGFSyncPlayerInfoSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSyncPlayerInfoSuccessEvent>();
	}
};
static_assert(alignof(UTGFSyncPlayerInfoSuccessEvent) == 0x000008, "Wrong alignment on UTGFSyncPlayerInfoSuccessEvent");
static_assert(sizeof(UTGFSyncPlayerInfoSuccessEvent) == 0x000028, "Wrong size on UTGFSyncPlayerInfoSuccessEvent");

// Class TGFGame.TGFSyncPlayerInfoFailedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSyncPlayerInfoFailedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSyncPlayerInfoFailedEvent">();
	}
	static class UTGFSyncPlayerInfoFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSyncPlayerInfoFailedEvent>();
	}
};
static_assert(alignof(UTGFSyncPlayerInfoFailedEvent) == 0x000008, "Wrong alignment on UTGFSyncPlayerInfoFailedEvent");
static_assert(sizeof(UTGFSyncPlayerInfoFailedEvent) == 0x000028, "Wrong size on UTGFSyncPlayerInfoFailedEvent");

// Class TGFGame.TGFSteamWebviewClosedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSteamWebviewClosedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSteamWebviewClosedEvent">();
	}
	static class UTGFSteamWebviewClosedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSteamWebviewClosedEvent>();
	}
};
static_assert(alignof(UTGFSteamWebviewClosedEvent) == 0x000008, "Wrong alignment on UTGFSteamWebviewClosedEvent");
static_assert(sizeof(UTGFSteamWebviewClosedEvent) == 0x000028, "Wrong size on UTGFSteamWebviewClosedEvent");

// Class TGFGame.TGFGameLogoutEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGameLogoutEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameLogoutEvent">();
	}
	static class UTGFGameLogoutEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameLogoutEvent>();
	}
};
static_assert(alignof(UTGFGameLogoutEvent) == 0x000008, "Wrong alignment on UTGFGameLogoutEvent");
static_assert(sizeof(UTGFGameLogoutEvent) == 0x000028, "Wrong size on UTGFGameLogoutEvent");

// Class TGFGame.TGFGamePlayerGetInfoFailedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFGamePlayerGetInfoFailedEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGamePlayerGetInfoFailedEvent">();
	}
	static class UTGFGamePlayerGetInfoFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGamePlayerGetInfoFailedEvent>();
	}
};
static_assert(alignof(UTGFGamePlayerGetInfoFailedEvent) == 0x000008, "Wrong alignment on UTGFGamePlayerGetInfoFailedEvent");
static_assert(sizeof(UTGFGamePlayerGetInfoFailedEvent) == 0x000030, "Wrong size on UTGFGamePlayerGetInfoFailedEvent");

// Class TGFGame.SDKMapleService
// 0x0010 (0x0040 - 0x0030)
class USDKMapleService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKMapleService">();
	}
	static class USDKMapleService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKMapleService>();
	}
};
static_assert(alignof(USDKMapleService) == 0x000008, "Wrong alignment on USDKMapleService");
static_assert(sizeof(USDKMapleService) == 0x000040, "Wrong size on USDKMapleService");

// Class TGFGame.TGFGamePlayerGetInfoEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFGamePlayerGetInfoEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGamePlayerGetInfoEvent">();
	}
	static class UTGFGamePlayerGetInfoEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGamePlayerGetInfoEvent>();
	}
};
static_assert(alignof(UTGFGamePlayerGetInfoEvent) == 0x000008, "Wrong alignment on UTGFGamePlayerGetInfoEvent");
static_assert(sizeof(UTGFGamePlayerGetInfoEvent) == 0x000028, "Wrong size on UTGFGamePlayerGetInfoEvent");

// Class TGFGame.LoginWindow
// 0x0030 (0x02E8 - 0x02B8)
class ULoginWindow : public UTGFWindow
{
public:
	class UButton*                                SDKLogoutButton;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           LIActivity;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x20];                                     // 0x02C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckNoticePopup();
	void FAlertResultDelegate();
	void FRetryLoginDelegate();
	void FRetryQueryDirDelegate();
	class FString GetServerUnavailableMessage(const class FString& UserData);
	void OnConnectServerFailed(class UTGFEventArgs* Args);
	void OnConnectServerSuccess(class UTGFEventArgs* Args);
	void OnEnterStateConnectServer();
	void OnEnterStateGameLogin();
	void OnEnterStateLoadHall();
	void OnEnterStateNone();
	void OnEnterStateQueryDir();
	void OnEnterStateQueryRegion();
	void OnEnterStateSDKLogin();
	void OnEnterStateSyncPlayerInfo();
	void OnEnterStateWaitingSDKLogin();
	void OnEnterStateWaitingStartGame();
	void OnExitStateConnectServer();
	void OnExitStateGameLogin();
	void OnExitStateNone();
	void OnExitStateQueryDir();
	void OnExitStateQueryRegion();
	void OnExitStateSDKLogin();
	void OnExitStateSyncPlayerInfo();
	void OnExitStateWaitingSDKLogin();
	void OnExitStateWaitingStartGame();
	void OnGameLoginFailed(class UTGFEventArgs* Args);
	void OnGameLoginSuccess(class UTGFEventArgs* Args);
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnGetNoticeResult(class UTGFEventArgs* Args);
	void OnQueryDirFailed(class UTGFEventArgs* Args);
	void OnQueryDirSuccess(class UTGFEventArgs* Args);
	void OnQueryRegionResult(class UTGFEventArgs* Args);
	void OnSDKLoginFailed(class UTGFEventArgs* Args);
	void OnSDKLoginSuccess(class UTGFEventArgs* Args);
	void OnSyncPlayerInfoFailed(class UTGFEventArgs* Args);
	void OnSyncPlayerInfoSuccess(class UTGFEventArgs* Args);
	void OnUpdateStateWaitingStartGame();
	void QQLogin();
	void SDKLogout();
	void SetSensitive();
	void StartGame();
	void StartNoAuthLogin(const class FString& SimulateOpenId);
	void WeChatLogin();

	class FString GetOpenId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginWindow">();
	}
	static class ULoginWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginWindow>();
	}
};
static_assert(alignof(ULoginWindow) == 0x000008, "Wrong alignment on ULoginWindow");
static_assert(sizeof(ULoginWindow) == 0x0002E8, "Wrong size on ULoginWindow");
static_assert(offsetof(ULoginWindow, SDKLogoutButton) == 0x0002B8, "Member 'ULoginWindow::SDKLogoutButton' has a wrong offset!");
static_assert(offsetof(ULoginWindow, LIActivity) == 0x0002C0, "Member 'ULoginWindow::LIActivity' has a wrong offset!");

// Class TGFGame.SDKGvoiceQuitRoomEvent
// 0x0000 (0x0028 - 0x0028)
class USDKGvoiceQuitRoomEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGvoiceQuitRoomEvent">();
	}
	static class USDKGvoiceQuitRoomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGvoiceQuitRoomEvent>();
	}
};
static_assert(alignof(USDKGvoiceQuitRoomEvent) == 0x000008, "Wrong alignment on USDKGvoiceQuitRoomEvent");
static_assert(sizeof(USDKGvoiceQuitRoomEvent) == 0x000028, "Wrong size on USDKGvoiceQuitRoomEvent");

// Class TGFGame.LuaService
// 0x0008 (0x0038 - 0x0030)
class ULuaService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaService">();
	}
	static class ULuaService* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaService>();
	}
};
static_assert(alignof(ULuaService) == 0x000008, "Wrong alignment on ULuaService");
static_assert(sizeof(ULuaService) == 0x000038, "Wrong size on ULuaService");

// Class TGFGame.TGFMailStatusSyncEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMailStatusSyncEvent final : public UTGFEventArgs
{
public:
	int64                                         MailId;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMailStatusSyncEvent">();
	}
	static class UTGFMailStatusSyncEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMailStatusSyncEvent>();
	}
};
static_assert(alignof(UTGFMailStatusSyncEvent) == 0x000008, "Wrong alignment on UTGFMailStatusSyncEvent");
static_assert(sizeof(UTGFMailStatusSyncEvent) == 0x000030, "Wrong size on UTGFMailStatusSyncEvent");
static_assert(offsetof(UTGFMailStatusSyncEvent, MailId) == 0x000028, "Member 'UTGFMailStatusSyncEvent::MailId' has a wrong offset!");

// Class TGFGame.SDKNoticeService
// 0x0158 (0x0188 - 0x0030)
class USDKNoticeService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x158];                                     // 0x0030(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetNoticeStableId(const struct FSDKNoticeInfo& Notice);
	static const struct FSDKNoticeTextInfo GetNoticeTextInfo(const struct FSDKNoticeInfo& Notice);
	static bool IsPopupNoticePopupOnce(const struct FSDKNoticeInfo& NoticeInfo);

	void SetNoticeRead(const class FString& NoticeStableId);
	void SetPopupNoticeBlockForever(const class FString& NoticeStableId);
	void SetPopupNoticeBlockToday(const class FString& NoticeStableId);
	void SetPopupNoticeShowed(const class FString& NoticeStableId);

	bool GetNoticeList(int32 NoticeType, TArray<struct FSDKNoticeInfo>* NoticeList) const;
	bool GetNoticeRead(const class FString& NoticeStableId) const;
	bool GetNoticeUnreadByType(int32 NoticeType) const;
	bool GetPopupNoticeBlockToday(const class FString& NoticeStableId) const;
	bool GetPopupNoticeShowed(const class FString& NoticeStableId) const;
	bool PopupNoticeNeedShow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKNoticeService">();
	}
	static class USDKNoticeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKNoticeService>();
	}
};
static_assert(alignof(USDKNoticeService) == 0x000008, "Wrong alignment on USDKNoticeService");
static_assert(sizeof(USDKNoticeService) == 0x000188, "Wrong size on USDKNoticeService");

// Class TGFGame.TGFMailAttachmentSyncEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMailAttachmentSyncEvent final : public UTGFEventArgs
{
public:
	int64                                         MailId;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMailAttachmentSyncEvent">();
	}
	static class UTGFMailAttachmentSyncEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMailAttachmentSyncEvent>();
	}
};
static_assert(alignof(UTGFMailAttachmentSyncEvent) == 0x000008, "Wrong alignment on UTGFMailAttachmentSyncEvent");
static_assert(sizeof(UTGFMailAttachmentSyncEvent) == 0x000030, "Wrong size on UTGFMailAttachmentSyncEvent");
static_assert(offsetof(UTGFMailAttachmentSyncEvent, MailId) == 0x000028, "Member 'UTGFMailAttachmentSyncEvent::MailId' has a wrong offset!");

// Class TGFGame.TGFMailAddSyncEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMailAddSyncEvent final : public UTGFEventArgs
{
public:
	bool                                          ShouldRefreshList;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMailAddSyncEvent">();
	}
	static class UTGFMailAddSyncEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMailAddSyncEvent>();
	}
};
static_assert(alignof(UTGFMailAddSyncEvent) == 0x000008, "Wrong alignment on UTGFMailAddSyncEvent");
static_assert(sizeof(UTGFMailAddSyncEvent) == 0x000030, "Wrong size on UTGFMailAddSyncEvent");
static_assert(offsetof(UTGFMailAddSyncEvent, ShouldRefreshList) == 0x000028, "Member 'UTGFMailAddSyncEvent::ShouldRefreshList' has a wrong offset!");

// Class TGFGame.TGFSettingKeyBindingActivateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSettingKeyBindingActivateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingKeyBindingActivateEvent">();
	}
	static class UTGFSettingKeyBindingActivateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingKeyBindingActivateEvent>();
	}
};
static_assert(alignof(UTGFSettingKeyBindingActivateEvent) == 0x000008, "Wrong alignment on UTGFSettingKeyBindingActivateEvent");
static_assert(sizeof(UTGFSettingKeyBindingActivateEvent) == 0x000028, "Wrong size on UTGFSettingKeyBindingActivateEvent");

// Class TGFGame.TGFMailRedDotUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMailRedDotUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMailRedDotUpdateEvent">();
	}
	static class UTGFMailRedDotUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMailRedDotUpdateEvent>();
	}
};
static_assert(alignof(UTGFMailRedDotUpdateEvent) == 0x000008, "Wrong alignment on UTGFMailRedDotUpdateEvent");
static_assert(sizeof(UTGFMailRedDotUpdateEvent) == 0x000028, "Wrong size on UTGFMailRedDotUpdateEvent");

// Class TGFGame.TGFFutureMailActiveEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFFutureMailActiveEvent final : public UTGFEventArgs
{
public:
	bool                                          ShouldRefreshList;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFFutureMailActiveEvent">();
	}
	static class UTGFFutureMailActiveEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFFutureMailActiveEvent>();
	}
};
static_assert(alignof(UTGFFutureMailActiveEvent) == 0x000008, "Wrong alignment on UTGFFutureMailActiveEvent");
static_assert(sizeof(UTGFFutureMailActiveEvent) == 0x000030, "Wrong size on UTGFFutureMailActiveEvent");
static_assert(offsetof(UTGFFutureMailActiveEvent, ShouldRefreshList) == 0x000028, "Member 'UTGFFutureMailActiveEvent::ShouldRefreshList' has a wrong offset!");

// Class TGFGame.ModelFeatureObject
// 0x0020 (0x0048 - 0x0028)
class UModelFeatureObject final : public UObject
{
public:
	int32                                         ID;                                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OpenTime;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotShowTips;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelFeatureObject">();
	}
	static class UModelFeatureObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelFeatureObject>();
	}
};
static_assert(alignof(UModelFeatureObject) == 0x000008, "Wrong alignment on UModelFeatureObject");
static_assert(sizeof(UModelFeatureObject) == 0x000048, "Wrong size on UModelFeatureObject");
static_assert(offsetof(UModelFeatureObject, ID) == 0x000028, "Member 'UModelFeatureObject::ID' has a wrong offset!");
static_assert(offsetof(UModelFeatureObject, OpenTime) == 0x000030, "Member 'UModelFeatureObject::OpenTime' has a wrong offset!");
static_assert(offsetof(UModelFeatureObject, bNotShowTips) == 0x000040, "Member 'UModelFeatureObject::bNotShowTips' has a wrong offset!");

// Class TGFGame.TGFCurrentMailIdChangeEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFCurrentMailIdChangeEvent final : public UTGFEventArgs
{
public:
	int64                                         MailId;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCurrentMailIdChangeEvent">();
	}
	static class UTGFCurrentMailIdChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCurrentMailIdChangeEvent>();
	}
};
static_assert(alignof(UTGFCurrentMailIdChangeEvent) == 0x000008, "Wrong alignment on UTGFCurrentMailIdChangeEvent");
static_assert(sizeof(UTGFCurrentMailIdChangeEvent) == 0x000030, "Wrong size on UTGFCurrentMailIdChangeEvent");
static_assert(offsetof(UTGFCurrentMailIdChangeEvent, MailId) == 0x000028, "Member 'UTGFCurrentMailIdChangeEvent::MailId' has a wrong offset!");

// Class TGFGame.TGFMailReceiveAttachmentsPartlyEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMailReceiveAttachmentsPartlyEvent final : public UTGFEventArgs
{
public:
	class UTGFProtoTgfDMailRecord*                Record;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMailReceiveAttachmentsPartlyEvent">();
	}
	static class UTGFMailReceiveAttachmentsPartlyEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMailReceiveAttachmentsPartlyEvent>();
	}
};
static_assert(alignof(UTGFMailReceiveAttachmentsPartlyEvent) == 0x000008, "Wrong alignment on UTGFMailReceiveAttachmentsPartlyEvent");
static_assert(sizeof(UTGFMailReceiveAttachmentsPartlyEvent) == 0x000030, "Wrong size on UTGFMailReceiveAttachmentsPartlyEvent");
static_assert(offsetof(UTGFMailReceiveAttachmentsPartlyEvent, Record) == 0x000028, "Member 'UTGFMailReceiveAttachmentsPartlyEvent::Record' has a wrong offset!");

// Class TGFGame.PopupNoticeSaveGame
// 0x0050 (0x0078 - 0x0028)
class UPopupNoticeSaveGame final : public USaveGame
{
public:
	TMap<class FString, struct FDateTime>         PopupNoticeBlockTime;                              // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupNoticeSaveGame">();
	}
	static class UPopupNoticeSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupNoticeSaveGame>();
	}
};
static_assert(alignof(UPopupNoticeSaveGame) == 0x000008, "Wrong alignment on UPopupNoticeSaveGame");
static_assert(sizeof(UPopupNoticeSaveGame) == 0x000078, "Wrong size on UPopupNoticeSaveGame");
static_assert(offsetof(UPopupNoticeSaveGame, PopupNoticeBlockTime) == 0x000028, "Member 'UPopupNoticeSaveGame::PopupNoticeBlockTime' has a wrong offset!");

// Class TGFGame.MailService
// 0x0088 (0x00B8 - 0x0030)
class UMailService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x88];                                      // 0x0030(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeleteMails(const TArray<int64>& MailIds);
	TArray<class UTGFMailHeaderInfo*> GetAllMails();
	class UTGFMailHeaderInfo* GetMail(int64 MailId);
	void MarkAsRead(const TArray<int64>& MailIds);
	void OnGameLogout(class UTGFEventArgs* Args);
	void ReceiveAttachments(class UTgfInventoryWrapper_Virtual* VirtualInventory, class UTgfInventoryWrapper* InventoryContext);
	void ReceiveOneAttachment(int64 MailId, const struct FTGFItem& Item, int32 Param_Index);
	void ReceiveVirtualAttachments(const TArray<int64>& MailIds, bool NeedRemove);
	void SetCurrentMailId(int64 InCurrentMailId);
	void SetCurrentMailType(ETGFProtoTgfEnMailMajorType MajorType);

	int64 GetCurrentMailId() const;
	TArray<struct FTGFMailReceiveKey> GetCurrentMailReceiveKey(int64 MailId) const;
	ETGFProtoTgfEnMailMajorType GetCurrentMailType() const;
	struct FTGFMailContent GetMailContent(int64 MailId) const;
	int32 GetMailCount() const;
	TArray<struct FTGFMailReceiveKey> GetMailReceiveKeys() const;
	int32 GetMaxMailContent() const;
	class FString GetMultiLanguageContent(const struct FTGFMailContent& MailContent) const;
	class FString GetMultiLanguageTitle(const struct FTGFMailContent& MailContent) const;
	bool IsGivenTypeMailRedDot(ETGFProtoTgfEnMailMajorType MailType) const;
	bool IsMailAttachmentNotReceived(int64 MailId) const;
	bool IsMailAttachmentReceived(ETGFProtoTgfEnMailStatusType Status) const;
	bool IsMailRedDot() const;
	bool IsMailRemoved(int64 MailId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailService">();
	}
	static class UMailService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailService>();
	}
};
static_assert(alignof(UMailService) == 0x000008, "Wrong alignment on UMailService");
static_assert(sizeof(UMailService) == 0x0000B8, "Wrong size on UMailService");

// Class TGFGame.MarketMenuConfig
// 0x00E0 (0x0110 - 0x0030)
class UMarketMenuConfig final : public UDataAsset
{
public:
	TMap<int32, struct FSoftObjectPath>           TabIconMap;                                        // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FSoftObjectPath>           TabIconHighlightMap;                               // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BuybackTabIcon;                                    // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BuybackTabIconHighlight;                           // 0x00F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketMenuConfig">();
	}
	static class UMarketMenuConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketMenuConfig>();
	}
};
static_assert(alignof(UMarketMenuConfig) == 0x000008, "Wrong alignment on UMarketMenuConfig");
static_assert(sizeof(UMarketMenuConfig) == 0x000110, "Wrong size on UMarketMenuConfig");
static_assert(offsetof(UMarketMenuConfig, TabIconMap) == 0x000030, "Member 'UMarketMenuConfig::TabIconMap' has a wrong offset!");
static_assert(offsetof(UMarketMenuConfig, TabIconHighlightMap) == 0x000080, "Member 'UMarketMenuConfig::TabIconHighlightMap' has a wrong offset!");
static_assert(offsetof(UMarketMenuConfig, BuybackTabIcon) == 0x0000D0, "Member 'UMarketMenuConfig::BuybackTabIcon' has a wrong offset!");
static_assert(offsetof(UMarketMenuConfig, BuybackTabIconHighlight) == 0x0000F0, "Member 'UMarketMenuConfig::BuybackTabIconHighlight' has a wrong offset!");

// Class TGFGame.TgfInventoryWrapper_Virtual
// 0x0018 (0x01B0 - 0x0198)
class UTgfInventoryWrapper_Virtual final : public UTgfInventoryWrapper
{
public:
	struct FIntPoint                              InventorySize;                                     // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              DefaultSize;                                       // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              MaxSize;                                           // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnMailReceiveAttachmentsPartly(class UTGFEventArgs* Args);
	void SetMailItems(const TArray<struct FTGFMailReceiveKey>& MailItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapper_Virtual">();
	}
	static class UTgfInventoryWrapper_Virtual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapper_Virtual>();
	}
};
static_assert(alignof(UTgfInventoryWrapper_Virtual) == 0x000008, "Wrong alignment on UTgfInventoryWrapper_Virtual");
static_assert(sizeof(UTgfInventoryWrapper_Virtual) == 0x0001B0, "Wrong size on UTgfInventoryWrapper_Virtual");
static_assert(offsetof(UTgfInventoryWrapper_Virtual, InventorySize) == 0x000198, "Member 'UTgfInventoryWrapper_Virtual::InventorySize' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_Virtual, DefaultSize) == 0x0001A0, "Member 'UTgfInventoryWrapper_Virtual::DefaultSize' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_Virtual, MaxSize) == 0x0001A8, "Member 'UTgfInventoryWrapper_Virtual::MaxSize' has a wrong offset!");

// Class TGFGame.TgfInventoryItemWrapper_Market
// 0x0070 (0x00B8 - 0x0048)
class UTgfInventoryItemWrapper_Market final : public UTgfInventoryItemWrapper
{
public:
	uint8                                         Pad_48[0x70];                                      // 0x0048(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTGFItem GetItemData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_Market">();
	}
	static class UTgfInventoryItemWrapper_Market* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_Market>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_Market) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_Market");
static_assert(sizeof(UTgfInventoryItemWrapper_Market) == 0x0000B8, "Wrong size on UTgfInventoryItemWrapper_Market");

// Class TGFGame.MarketProduct
// 0x0068 (0x0090 - 0x0028)
class UMarketProduct final : public UObject
{
public:
	class UTgfInventoryItemWrapper*               ItemWrapper;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailableAmount;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalAvailableAmount;                              // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LastSoldTimepoint;                                 // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NextRefreshTime;                                   // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LastRefreshTime;                                   // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SoldVersion;                                       // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdentified;                                       // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x37];                                      // 0x0059(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetCost(TArray<struct FMarketCost>* OutCost) const;
	struct FMarketCost GetCostFromServerData() const;
	bool GetIsBuyBackItem() const;
	int32 GetProductDisplayOrder() const;
	class FString GetProductIcon() const;
	int32 GetProductId() const;
	class FText GetProductName() const;
	class FString GetProductSkuId() const;
	bool IsIdentified() const;
	bool IsShowDisplayTemplate() const;
	bool IsSpecialProduct() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketProduct">();
	}
	static class UMarketProduct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketProduct>();
	}
};
static_assert(alignof(UMarketProduct) == 0x000008, "Wrong alignment on UMarketProduct");
static_assert(sizeof(UMarketProduct) == 0x000090, "Wrong size on UMarketProduct");
static_assert(offsetof(UMarketProduct, ItemWrapper) == 0x000028, "Member 'UMarketProduct::ItemWrapper' has a wrong offset!");
static_assert(offsetof(UMarketProduct, AvailableAmount) == 0x000030, "Member 'UMarketProduct::AvailableAmount' has a wrong offset!");
static_assert(offsetof(UMarketProduct, TotalAvailableAmount) == 0x000034, "Member 'UMarketProduct::TotalAvailableAmount' has a wrong offset!");
static_assert(offsetof(UMarketProduct, LastSoldTimepoint) == 0x000038, "Member 'UMarketProduct::LastSoldTimepoint' has a wrong offset!");
static_assert(offsetof(UMarketProduct, NextRefreshTime) == 0x000040, "Member 'UMarketProduct::NextRefreshTime' has a wrong offset!");
static_assert(offsetof(UMarketProduct, LastRefreshTime) == 0x000048, "Member 'UMarketProduct::LastRefreshTime' has a wrong offset!");
static_assert(offsetof(UMarketProduct, SoldVersion) == 0x000050, "Member 'UMarketProduct::SoldVersion' has a wrong offset!");
static_assert(offsetof(UMarketProduct, bIdentified) == 0x000058, "Member 'UMarketProduct::bIdentified' has a wrong offset!");

// Class TGFGame.TGFSocialGameFriendUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSocialGameFriendUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialGameFriendUpdateEvent">();
	}
	static class UTGFSocialGameFriendUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialGameFriendUpdateEvent>();
	}
};
static_assert(alignof(UTGFSocialGameFriendUpdateEvent) == 0x000008, "Wrong alignment on UTGFSocialGameFriendUpdateEvent");
static_assert(sizeof(UTGFSocialGameFriendUpdateEvent) == 0x000028, "Wrong size on UTGFSocialGameFriendUpdateEvent");

// Class TGFGame.TGFMarketSellStartEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMarketSellStartEvent final : public UTGFEventArgs
{
public:
	class UTgfInventoryItemWrapper*               Item;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMarketSellStartEvent">();
	}
	static class UTGFMarketSellStartEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMarketSellStartEvent>();
	}
};
static_assert(alignof(UTGFMarketSellStartEvent) == 0x000008, "Wrong alignment on UTGFMarketSellStartEvent");
static_assert(sizeof(UTGFMarketSellStartEvent) == 0x000030, "Wrong size on UTGFMarketSellStartEvent");
static_assert(offsetof(UTGFMarketSellStartEvent, Item) == 0x000028, "Member 'UTGFMarketSellStartEvent::Item' has a wrong offset!");

// Class TGFGame.TGFMarketSellFinishEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMarketSellFinishEvent final : public UTGFEventArgs
{
public:
	class UTgfInventoryItemWrapper*               Item;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMarketSellFinishEvent">();
	}
	static class UTGFMarketSellFinishEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMarketSellFinishEvent>();
	}
};
static_assert(alignof(UTGFMarketSellFinishEvent) == 0x000008, "Wrong alignment on UTGFMarketSellFinishEvent");
static_assert(sizeof(UTGFMarketSellFinishEvent) == 0x000030, "Wrong size on UTGFMarketSellFinishEvent");
static_assert(offsetof(UTGFMarketSellFinishEvent, Item) == 0x000028, "Member 'UTGFMarketSellFinishEvent::Item' has a wrong offset!");

// Class TGFGame.TGFKeyConflictPopup
// 0x0018 (0x02D0 - 0x02B8)
class UTGFKeyConflictPopup final : public UTGFWindow
{
public:
	class UCommonTextBlock*                       ConflictKeyName;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                ButtonCancel;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                ButtonConfirm;                                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateConflictKeyWidget(const struct FKey& InKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFKeyConflictPopup">();
	}
	static class UTGFKeyConflictPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFKeyConflictPopup>();
	}
};
static_assert(alignof(UTGFKeyConflictPopup) == 0x000008, "Wrong alignment on UTGFKeyConflictPopup");
static_assert(sizeof(UTGFKeyConflictPopup) == 0x0002D0, "Wrong size on UTGFKeyConflictPopup");
static_assert(offsetof(UTGFKeyConflictPopup, ConflictKeyName) == 0x0002B8, "Member 'UTGFKeyConflictPopup::ConflictKeyName' has a wrong offset!");
static_assert(offsetof(UTGFKeyConflictPopup, ButtonCancel) == 0x0002C0, "Member 'UTGFKeyConflictPopup::ButtonCancel' has a wrong offset!");
static_assert(offsetof(UTGFKeyConflictPopup, ButtonConfirm) == 0x0002C8, "Member 'UTGFKeyConflictPopup::ButtonConfirm' has a wrong offset!");

// Class TGFGame.TGFMarketRefreshRedDotEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMarketRefreshRedDotEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMarketRefreshRedDotEvent">();
	}
	static class UTGFMarketRefreshRedDotEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMarketRefreshRedDotEvent>();
	}
};
static_assert(alignof(UTGFMarketRefreshRedDotEvent) == 0x000008, "Wrong alignment on UTGFMarketRefreshRedDotEvent");
static_assert(sizeof(UTGFMarketRefreshRedDotEvent) == 0x000028, "Wrong size on UTGFMarketRefreshRedDotEvent");

// Class TGFGame.TGFMarketTableRefreshEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMarketTableRefreshEvent final : public UTGFEventArgs
{
public:
	int32                                         TableId;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMarketTableRefreshEvent">();
	}
	static class UTGFMarketTableRefreshEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMarketTableRefreshEvent>();
	}
};
static_assert(alignof(UTGFMarketTableRefreshEvent) == 0x000008, "Wrong alignment on UTGFMarketTableRefreshEvent");
static_assert(sizeof(UTGFMarketTableRefreshEvent) == 0x000030, "Wrong size on UTGFMarketTableRefreshEvent");
static_assert(offsetof(UTGFMarketTableRefreshEvent, TableId) == 0x000028, "Member 'UTGFMarketTableRefreshEvent::TableId' has a wrong offset!");

// Class TGFGame.TgfInventoryWrapper_MithrilResult
// 0x0010 (0x01A8 - 0x0198)
class UTgfInventoryWrapper_MithrilResult final : public UTgfInventoryWrapper
{
public:
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapper_MithrilResult">();
	}
	static class UTgfInventoryWrapper_MithrilResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapper_MithrilResult>();
	}
};
static_assert(alignof(UTgfInventoryWrapper_MithrilResult) == 0x000008, "Wrong alignment on UTgfInventoryWrapper_MithrilResult");
static_assert(sizeof(UTgfInventoryWrapper_MithrilResult) == 0x0001A8, "Wrong size on UTgfInventoryWrapper_MithrilResult");

// Class TGFGame.TGFMarketPurchaseSuccessEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMarketPurchaseSuccessEvent final : public UTGFEventArgs
{
public:
	int32                                         ProductId;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMarketPurchaseSuccessEvent">();
	}
	static class UTGFMarketPurchaseSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMarketPurchaseSuccessEvent>();
	}
};
static_assert(alignof(UTGFMarketPurchaseSuccessEvent) == 0x000008, "Wrong alignment on UTGFMarketPurchaseSuccessEvent");
static_assert(sizeof(UTGFMarketPurchaseSuccessEvent) == 0x000030, "Wrong size on UTGFMarketPurchaseSuccessEvent");
static_assert(offsetof(UTGFMarketPurchaseSuccessEvent, ProductId) == 0x000028, "Member 'UTGFMarketPurchaseSuccessEvent::ProductId' has a wrong offset!");

// Class TGFGame.MarketService
// 0x0078 (0x00A8 - 0x0030)
class UMarketService final : public UTGFService
{
public:
	FMulticastInlineDelegateProperty_             OnTabUpdate;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FMarketProductTab>         ProductTabs;                                       // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         InventoryTabSelect;                                // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         StragePageId;                                      // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_92[0x16];                                      // 0x0092(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ContainPopupVideo(int32 PopupVideoId);
	uint8 GetMarketInventoryTableSelect();
	TArray<class UExcelLoaderTgfConfigExcelMarketTabInfo*> GetMarketTabInfoCfgByMarketId(int32 MarketId);
	int64 GetMarketTabRefreshTime(int32 TabId);
	bool GetPlayRefreshEffect();
	class UMarketProduct* GetProduct(int32 ProductId);
	TArray<class UMarketProduct*> GetProductListByTabId(int32 TabId);
	void OnCheckTab(int32 TabId);
	void OnMarketSellFinish(class UTgfInventoryItemWrapper* Item);
	void OnMarketSellStart(class UTgfInventoryItemWrapper* Item);
	void ReInitProduct();
	void SendMarketBuyProductReq(int32 ProductId, int32 Count);
	void SendMarketBuyProductWithCostReq(int32 ProductId, int32 Count, int32 CostType, int32 CostPrice);
	void SendMarketBuySoldItemReq(class UMarketProduct* Product, int32 Count);
	void SendMarketSellItemsReq(class UTgfInventoryItemWrapper* Item);
	void SendPlayRefreshEffect();
	void SendPopupVideo(int32 PopupVideoId);
	void SetMarketInventoryTabSelect(uint8 TabId);
	void SetMarketStragePageTab(uint8 PageId);

	bool ShouldShowMarketRedDot() const;
	bool ShouldShowMarketTabRedDot(int32 TabId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketService">();
	}
	static class UMarketService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketService>();
	}
};
static_assert(alignof(UMarketService) == 0x000008, "Wrong alignment on UMarketService");
static_assert(sizeof(UMarketService) == 0x0000A8, "Wrong size on UMarketService");
static_assert(offsetof(UMarketService, OnTabUpdate) == 0x000030, "Member 'UMarketService::OnTabUpdate' has a wrong offset!");
static_assert(offsetof(UMarketService, ProductTabs) == 0x000040, "Member 'UMarketService::ProductTabs' has a wrong offset!");
static_assert(offsetof(UMarketService, InventoryTabSelect) == 0x000090, "Member 'UMarketService::InventoryTabSelect' has a wrong offset!");
static_assert(offsetof(UMarketService, StragePageId) == 0x000091, "Member 'UMarketService::StragePageId' has a wrong offset!");

// Class TGFGame.TGFSocialUpdateFriendInviteEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSocialUpdateFriendInviteEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialUpdateFriendInviteEvent">();
	}
	static class UTGFSocialUpdateFriendInviteEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialUpdateFriendInviteEvent>();
	}
};
static_assert(alignof(UTGFSocialUpdateFriendInviteEvent) == 0x000008, "Wrong alignment on UTGFSocialUpdateFriendInviteEvent");
static_assert(sizeof(UTGFSocialUpdateFriendInviteEvent) == 0x000028, "Wrong size on UTGFSocialUpdateFriendInviteEvent");

// Class TGFGame.MarqueeSubsystem
// 0x0128 (0x0158 - 0x0030)
class UMarqueeSubsystem final : public UTGFSubsystem
{
public:
	bool                                          bMyInitLoginMarquee;                               // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           MyUpdateConfigTimerHandle;                         // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FMarqueeConfig>            MyMarqueeConfigMap;                                // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   MyActiveMarqueeSet;                                // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int64>                            MyMarqueeNextPlayTimestampMap;                     // 0x00E0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           MyUpdateMessageTimerHandle;                        // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMarqueeMessage>                MyMarqueeMessageArray;                             // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MyMarqueeMoveSpeed;                                // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MyUpdateConfigInterval;                            // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MyUpdateMessageInterval;                           // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOneMarqueeById(int32 MarqueeId);
	void AddOneMarqueeByStr(const class FString& StrContent, EMarqueeType MarqueeType, int32 SortOrder);
	bool GetLastMarqueeMessage(struct FMarqueeMessage* OutMarqueeMessage);
	float GetMarqueeMoveSpeed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarqueeSubsystem">();
	}
	static class UMarqueeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarqueeSubsystem>();
	}
};
static_assert(alignof(UMarqueeSubsystem) == 0x000008, "Wrong alignment on UMarqueeSubsystem");
static_assert(sizeof(UMarqueeSubsystem) == 0x000158, "Wrong size on UMarqueeSubsystem");
static_assert(offsetof(UMarqueeSubsystem, bMyInitLoginMarquee) == 0x000030, "Member 'UMarqueeSubsystem::bMyInitLoginMarquee' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyUpdateConfigTimerHandle) == 0x000038, "Member 'UMarqueeSubsystem::MyUpdateConfigTimerHandle' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyMarqueeConfigMap) == 0x000040, "Member 'UMarqueeSubsystem::MyMarqueeConfigMap' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyActiveMarqueeSet) == 0x000090, "Member 'UMarqueeSubsystem::MyActiveMarqueeSet' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyMarqueeNextPlayTimestampMap) == 0x0000E0, "Member 'UMarqueeSubsystem::MyMarqueeNextPlayTimestampMap' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyUpdateMessageTimerHandle) == 0x000130, "Member 'UMarqueeSubsystem::MyUpdateMessageTimerHandle' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyMarqueeMessageArray) == 0x000138, "Member 'UMarqueeSubsystem::MyMarqueeMessageArray' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyMarqueeMoveSpeed) == 0x000148, "Member 'UMarqueeSubsystem::MyMarqueeMoveSpeed' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyUpdateConfigInterval) == 0x00014C, "Member 'UMarqueeSubsystem::MyUpdateConfigInterval' has a wrong offset!");
static_assert(offsetof(UMarqueeSubsystem, MyUpdateMessageInterval) == 0x000150, "Member 'UMarqueeSubsystem::MyUpdateMessageInterval' has a wrong offset!");

// Class TGFGame.TGFMatchStartEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMatchStartEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchStartEvent">();
	}
	static class UTGFMatchStartEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchStartEvent>();
	}
};
static_assert(alignof(UTGFMatchStartEvent) == 0x000008, "Wrong alignment on UTGFMatchStartEvent");
static_assert(sizeof(UTGFMatchStartEvent) == 0x000028, "Wrong size on UTGFMatchStartEvent");

// Class TGFGame.SocialService
// 0x0240 (0x0270 - 0x0030)
class USocialService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUserKey, class UFriendSuggest*>  MyFriendSuggestMap;                                // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUserKey, class UFriendInvite*>   MyFriendInviteMap;                                 // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUserKey, class UGameFriend*>     MyGameFriendMap;                                   // 0x00E0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGlobalUserKey, class USteamFriend*> MySteamFriendMap;                                  // 0x0130(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUserKey, class UFriendSuggest*>  MyTogetherPlayerMap;                               // 0x0180(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUserKey, class UFriendSuggest*>  MyFriendSearchMap;                                 // 0x01D0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<struct FUserKey>                         MyInvitedUserSet;                                  // 0x0220(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void AcceptAllFriendInvite();
	void AcceptFriendInvite(const struct FUserKey& UserKey);
	void AddInvitedUser(const struct FUserKey& UserKey);
	void ApplyFriend(const struct FUserKey& UserKey);
	bool CheckIsFriend(const int64 UserId);
	bool CheckIsGameFriend(const struct FUserKey& UserKey);
	bool CheckIsInvitedUser(const struct FUserKey& UserKey);
	bool CheckIsSteamFriend(const struct FGlobalUserKey& GlobalUserKey);
	void ClearInvitedUser();
	TArray<class UFriendInvite*> GetFriendInviteArray();
	TArray<class UFriendSuggest*> GetFriendSearchArray();
	TArray<class UFriendSuggest*> GetFriendSuggestArray();
	TArray<class UGameFriend*> GetGameFriendArray();
	int32 GetGameFriendCount();
	int32 GetOnlineGameFriendCount();
	int32 GetOnlineSteamFriendCount();
	TArray<class USteamFriend*> GetSteamFriendArray();
	int32 GetSteamFriendCount();
	TArray<class UFriendSuggest*> GetTogetherPlayerArray();
	void Lua_Initialized();
	void Lua_SetToggleRedDot(ESocialToggleType ToggleType, bool bRedTips);
	void RejectAllFriendInvite();
	void RejectFriendInvite(const struct FUserKey& UserKey);
	void RemoveFriend(const struct FUserKey& UserKey);
	void RemoveTogetherPlayer(const struct FUserKey& UserKey);
	void RequestFriendAll();
	void RequestFriendSuggest(ETGFProtoTgfEnForceType ForceType);
	void SearchPlayer(const class FString& StrContent, ESearchPlayerTag SearchTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialService">();
	}
	static class USocialService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialService>();
	}
};
static_assert(alignof(USocialService) == 0x000008, "Wrong alignment on USocialService");
static_assert(sizeof(USocialService) == 0x000270, "Wrong size on USocialService");
static_assert(offsetof(USocialService, MyFriendSuggestMap) == 0x000040, "Member 'USocialService::MyFriendSuggestMap' has a wrong offset!");
static_assert(offsetof(USocialService, MyFriendInviteMap) == 0x000090, "Member 'USocialService::MyFriendInviteMap' has a wrong offset!");
static_assert(offsetof(USocialService, MyGameFriendMap) == 0x0000E0, "Member 'USocialService::MyGameFriendMap' has a wrong offset!");
static_assert(offsetof(USocialService, MySteamFriendMap) == 0x000130, "Member 'USocialService::MySteamFriendMap' has a wrong offset!");
static_assert(offsetof(USocialService, MyTogetherPlayerMap) == 0x000180, "Member 'USocialService::MyTogetherPlayerMap' has a wrong offset!");
static_assert(offsetof(USocialService, MyFriendSearchMap) == 0x0001D0, "Member 'USocialService::MyFriendSearchMap' has a wrong offset!");
static_assert(offsetof(USocialService, MyInvitedUserSet) == 0x000220, "Member 'USocialService::MyInvitedUserSet' has a wrong offset!");

// Class TGFGame.TGFMatchStopEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMatchStopEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchStopEvent">();
	}
	static class UTGFMatchStopEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchStopEvent>();
	}
};
static_assert(alignof(UTGFMatchStopEvent) == 0x000008, "Wrong alignment on UTGFMatchStopEvent");
static_assert(sizeof(UTGFMatchStopEvent) == 0x000028, "Wrong size on UTGFMatchStopEvent");

// Class TGFGame.TGFPreMatchingCancelEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFPreMatchingCancelEvent final : public UTGFEventArgs
{
public:
	int32                                         Reason;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFPreMatchingCancelEvent">();
	}
	static class UTGFPreMatchingCancelEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFPreMatchingCancelEvent>();
	}
};
static_assert(alignof(UTGFPreMatchingCancelEvent) == 0x000008, "Wrong alignment on UTGFPreMatchingCancelEvent");
static_assert(sizeof(UTGFPreMatchingCancelEvent) == 0x000030, "Wrong size on UTGFPreMatchingCancelEvent");
static_assert(offsetof(UTGFPreMatchingCancelEvent, Reason) == 0x000028, "Member 'UTGFPreMatchingCancelEvent::Reason' has a wrong offset!");

// Class TGFGame.TGFSocialFriendSearchFinishEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFSocialFriendSearchFinishEvent final : public UTGFEventArgs
{
public:
	ESearchPlayerTag                              SearchTag;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialFriendSearchFinishEvent">();
	}
	static class UTGFSocialFriendSearchFinishEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialFriendSearchFinishEvent>();
	}
};
static_assert(alignof(UTGFSocialFriendSearchFinishEvent) == 0x000008, "Wrong alignment on UTGFSocialFriendSearchFinishEvent");
static_assert(sizeof(UTGFSocialFriendSearchFinishEvent) == 0x000030, "Wrong size on UTGFSocialFriendSearchFinishEvent");
static_assert(offsetof(UTGFSocialFriendSearchFinishEvent, SearchTag) == 0x000028, "Member 'UTGFSocialFriendSearchFinishEvent::SearchTag' has a wrong offset!");

// Class TGFGame.TGFMatchingTimeoutEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMatchingTimeoutEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchingTimeoutEvent">();
	}
	static class UTGFMatchingTimeoutEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchingTimeoutEvent>();
	}
};
static_assert(alignof(UTGFMatchingTimeoutEvent) == 0x000008, "Wrong alignment on UTGFMatchingTimeoutEvent");
static_assert(sizeof(UTGFMatchingTimeoutEvent) == 0x000028, "Wrong size on UTGFMatchingTimeoutEvent");

// Class TGFGame.TGFMatchingCancelEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMatchingCancelEvent final : public UTGFEventArgs
{
public:
	int32                                         Reason;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchingCancelEvent">();
	}
	static class UTGFMatchingCancelEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchingCancelEvent>();
	}
};
static_assert(alignof(UTGFMatchingCancelEvent) == 0x000008, "Wrong alignment on UTGFMatchingCancelEvent");
static_assert(sizeof(UTGFMatchingCancelEvent) == 0x000030, "Wrong size on UTGFMatchingCancelEvent");
static_assert(offsetof(UTGFMatchingCancelEvent, Reason) == 0x000028, "Member 'UTGFMatchingCancelEvent::Reason' has a wrong offset!");

// Class TGFGame.SettingService
// 0x0020 (0x0050 - 0x0030)
class USettingService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 RoleGuids;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddCheckedActivitiy(int32 ActivitiyID);
	struct FKey GetInputKeyByInputAction(class UInputAction* InputAction);
	class ULyraSettingsLocal* GetLyraSettingsLocal();
	class ULyraSettingsShared* GetLyraSettingsShared();
	bool LoadAllowMakeTeam();
	bool LoadCameraShakesByMoving();
	bool LoadChargeSkillMethod();
	TArray<int32> LoadCheckedActivities();
	int32 LoadDailyLoginCheck();
	TArray<ETgfEquipQuality> LoadInventoryAutoQuality();
	const TArray<int64> LoadInventoryOpened();
	bool LoadInventorySee();
	const TArray<int64> LoadInventoryTalentTips(int32 Key);
	bool LoadIsLiveMode();
	bool LoadKilledScreenshotAutoDelete();
	class FString LoadKilledScreenshotPath();
	EStorageLimit LoadKilledScreenshotStorageLimit();
	const TArray<int64> LoadMithrilInventoryOpened();
	int32 LoadMoonInterationTime();
	bool LoadMouseTargetingMethod();
	bool LoadOpenOperationTips();
	bool LoadPrivateChat();
	ESocialPermission LoadPrivateRoomInvitePermission();
	TArray<int32> LoadProcessingTaskIds(const class FString& LocalUserKey);
	TArray<int32> LoadSavedTalents();
	bool LoadSaveKilledScreenshot();
	bool LoadShowWeaponOperatinsTipsFlag();
	bool LoadSquatDownMethodMethod();
	bool LoadTermAttribute();
	void Lua_Initialized();
	void Lua_OpenAccountDeletion();
	void Lua_OpenCustomerService();
	void Lua_OpenPrivacyProtocol();
	void Lua_OpenProtocolDescription();
	void Lua_OpenUserProtocol();
	void ResetKeyBindings();
	void SaveCheckedActivities(const TArray<int32>& Activities);
	void SaveDailyLoginCheck(int32 Timme);
	void SaveInventoryAutoQuality(const TArray<ETgfEquipQuality>& Rarity);
	void SaveInventoryOpened(const TArray<int64>& Guids);
	void SaveInventoryTalentTips(int32 Key, const TArray<int64>& Guids);
	void SaveKeyBinding(class FName ActionName, const struct FKey& Key);
	void SaveMithrilInventoryOpened(const TArray<int64>& Guids);
	void SaveMoonInterationTime(int32 Timme);
	void SavePrivateRoomInvitePermission(ESocialPermission Permission);
	void SaveProcessingTaskIds(const class FString& LocalUserKey, const TArray<int32>& ProcessingTaskIds);
	void SaveShowWeaponOperatinsTipsFlag(bool bIsShow);
	void SaveTalents(const TArray<int32>& Talents);
	void SetIsLiveMode(bool NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingService">();
	}
	static class USettingService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingService>();
	}
};
static_assert(alignof(USettingService) == 0x000008, "Wrong alignment on USettingService");
static_assert(sizeof(USettingService) == 0x000050, "Wrong size on USettingService");
static_assert(offsetof(USettingService, RoleGuids) == 0x000040, "Member 'USettingService::RoleGuids' has a wrong offset!");

// Class TGFGame.TGFMatchedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMatchedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchedEvent">();
	}
	static class UTGFMatchedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchedEvent>();
	}
};
static_assert(alignof(UTGFMatchedEvent) == 0x000008, "Wrong alignment on UTGFMatchedEvent");
static_assert(sizeof(UTGFMatchedEvent) == 0x000028, "Wrong size on UTGFMatchedEvent");

// Class TGFGame.TGFMatchingExitSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMatchingExitSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchingExitSuccessEvent">();
	}
	static class UTGFMatchingExitSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchingExitSuccessEvent>();
	}
};
static_assert(alignof(UTGFMatchingExitSuccessEvent) == 0x000008, "Wrong alignment on UTGFMatchingExitSuccessEvent");
static_assert(sizeof(UTGFMatchingExitSuccessEvent) == 0x000028, "Wrong size on UTGFMatchingExitSuccessEvent");

// Class TGFGame.GameFriend
// 0x0040 (0x0068 - 0x0028)
class UGameFriend final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               UserKey;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UserUpdateHandler;                                 // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RoleUpdateHandler;                                 // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserInfo*                              MyUserInfo;                                        // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URoleInfo*                              MyRoleInfo;                                        // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInitialized;                                    // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastIsOnLine;                                     // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFriend">();
	}
	static class UGameFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFriend>();
	}
};
static_assert(alignof(UGameFriend) == 0x000008, "Wrong alignment on UGameFriend");
static_assert(sizeof(UGameFriend) == 0x000068, "Wrong size on UGameFriend");
static_assert(offsetof(UGameFriend, bIsValid) == 0x000028, "Member 'UGameFriend::bIsValid' has a wrong offset!");
static_assert(offsetof(UGameFriend, UserKey) == 0x000030, "Member 'UGameFriend::UserKey' has a wrong offset!");
static_assert(offsetof(UGameFriend, UserUpdateHandler) == 0x000040, "Member 'UGameFriend::UserUpdateHandler' has a wrong offset!");
static_assert(offsetof(UGameFriend, RoleUpdateHandler) == 0x000048, "Member 'UGameFriend::RoleUpdateHandler' has a wrong offset!");
static_assert(offsetof(UGameFriend, MyUserInfo) == 0x000050, "Member 'UGameFriend::MyUserInfo' has a wrong offset!");
static_assert(offsetof(UGameFriend, MyRoleInfo) == 0x000058, "Member 'UGameFriend::MyRoleInfo' has a wrong offset!");
static_assert(offsetof(UGameFriend, bIsInitialized) == 0x000060, "Member 'UGameFriend::bIsInitialized' has a wrong offset!");
static_assert(offsetof(UGameFriend, bLastIsOnLine) == 0x000061, "Member 'UGameFriend::bLastIsOnLine' has a wrong offset!");

// Class TGFGame.TGFMatchingExitFailedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMatchingExitFailedEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchingExitFailedEvent">();
	}
	static class UTGFMatchingExitFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchingExitFailedEvent>();
	}
};
static_assert(alignof(UTGFMatchingExitFailedEvent) == 0x000008, "Wrong alignment on UTGFMatchingExitFailedEvent");
static_assert(sizeof(UTGFMatchingExitFailedEvent) == 0x000030, "Wrong size on UTGFMatchingExitFailedEvent");
static_assert(offsetof(UTGFMatchingExitFailedEvent, ErrorCode) == 0x000028, "Member 'UTGFMatchingExitFailedEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.TGFRoomCancelEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFRoomCancelEvent final : public UTGFEventArgs
{
public:
	int32                                         Reason;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomCancelEvent">();
	}
	static class UTGFRoomCancelEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomCancelEvent>();
	}
};
static_assert(alignof(UTGFRoomCancelEvent) == 0x000008, "Wrong alignment on UTGFRoomCancelEvent");
static_assert(sizeof(UTGFRoomCancelEvent) == 0x000030, "Wrong size on UTGFRoomCancelEvent");
static_assert(offsetof(UTGFRoomCancelEvent, Reason) == 0x000028, "Member 'UTGFRoomCancelEvent::Reason' has a wrong offset!");

// Class TGFGame.TGFGameTaskNetDataSync
// 0x0020 (0x0048 - 0x0028)
class UTGFGameTaskNetDataSync final : public UTGFEventArgs
{
public:
	class FString                                 EventName;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskId;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldStatus;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStatus;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameTaskNetDataSync">();
	}
	static class UTGFGameTaskNetDataSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameTaskNetDataSync>();
	}
};
static_assert(alignof(UTGFGameTaskNetDataSync) == 0x000008, "Wrong alignment on UTGFGameTaskNetDataSync");
static_assert(sizeof(UTGFGameTaskNetDataSync) == 0x000048, "Wrong size on UTGFGameTaskNetDataSync");
static_assert(offsetof(UTGFGameTaskNetDataSync, EventName) == 0x000028, "Member 'UTGFGameTaskNetDataSync::EventName' has a wrong offset!");
static_assert(offsetof(UTGFGameTaskNetDataSync, TaskId) == 0x000038, "Member 'UTGFGameTaskNetDataSync::TaskId' has a wrong offset!");
static_assert(offsetof(UTGFGameTaskNetDataSync, OldStatus) == 0x00003C, "Member 'UTGFGameTaskNetDataSync::OldStatus' has a wrong offset!");
static_assert(offsetof(UTGFGameTaskNetDataSync, NewStatus) == 0x000040, "Member 'UTGFGameTaskNetDataSync::NewStatus' has a wrong offset!");

// Class TGFGame.TGFMatchCaptainLevelSelectEvent
// 0x0020 (0x0048 - 0x0028)
class UTGFMatchCaptainLevelSelectEvent final : public UTGFEventArgs
{
public:
	struct FMatchLevelInfo                        LevelInfo;                                         // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchCaptainLevelSelectEvent">();
	}
	static class UTGFMatchCaptainLevelSelectEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchCaptainLevelSelectEvent>();
	}
};
static_assert(alignof(UTGFMatchCaptainLevelSelectEvent) == 0x000008, "Wrong alignment on UTGFMatchCaptainLevelSelectEvent");
static_assert(sizeof(UTGFMatchCaptainLevelSelectEvent) == 0x000048, "Wrong size on UTGFMatchCaptainLevelSelectEvent");
static_assert(offsetof(UTGFMatchCaptainLevelSelectEvent, LevelInfo) == 0x000028, "Member 'UTGFMatchCaptainLevelSelectEvent::LevelInfo' has a wrong offset!");

// Class TGFGame.TGFMatchChallengerSelectEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFMatchChallengerSelectEvent final : public UTGFEventArgs
{
public:
	ETGFProtoTgfEnChallengerModelType             ChallengerType;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMatchChallengerSelectEvent">();
	}
	static class UTGFMatchChallengerSelectEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMatchChallengerSelectEvent>();
	}
};
static_assert(alignof(UTGFMatchChallengerSelectEvent) == 0x000008, "Wrong alignment on UTGFMatchChallengerSelectEvent");
static_assert(sizeof(UTGFMatchChallengerSelectEvent) == 0x000030, "Wrong size on UTGFMatchChallengerSelectEvent");
static_assert(offsetof(UTGFMatchChallengerSelectEvent, ChallengerType) == 0x000028, "Member 'UTGFMatchChallengerSelectEvent::ChallengerType' has a wrong offset!");

// Class TGFGame.StringFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UStringFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FStringResult ConvertDateTimeToLocal(const class FString& InString);
	static struct FStringResult FilterChineseCharacter(const class FString& InString);
	static struct FStringResult LeftLimitStringLength(const class FString& InString, const int32 Length);
	static bool MatchDefaultRoleName(const class FString& InString, class FString* OutName, int64* OutIndex);
	static struct FStringResult ReserveEnglishAndNumberCharacter(const class FString& InString);
	static struct FStringResult ReserveEnglishCharacter(const class FString& InString);
	static struct FStringResult ReserveEnglishSymbolAndNumberCharacter(const class FString& InString);
	static struct FStringResult ReserveNumberCharacter(const class FString& InString);
	static struct FStringResult ReserveRoomNameAndPasswordCharacter(const class FString& InString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StringFunctionLibrary">();
	}
	static class UStringFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStringFunctionLibrary>();
	}
};
static_assert(alignof(UStringFunctionLibrary) == 0x000008, "Wrong alignment on UStringFunctionLibrary");
static_assert(sizeof(UStringFunctionLibrary) == 0x000028, "Wrong size on UStringFunctionLibrary");

// Class TGFGame.MatchService
// 0x0198 (0x01C8 - 0x0030)
class UMatchService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchLevelInfo                        SelectedLevelInfo;                                 // 0x0040(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ETGFProtoTgfEnChallengerModelType             SelectedChallengerType;                            // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWaitMatchingPreSearchRsp;                         // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWaitMatchingSearchRsp;                            // 0x0062(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63[0x145];                                     // 0x0063(0x0145)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfSCBattleSettleSync*         BattleResultData;                                  // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowBattleResult;                                  // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowBattleReturn;                                  // 0x01B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B2[0x16];                                     // 0x01B2(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMatchToast();
	void CreatTestResultData();
	void ExitMatching();
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);
	void OnNetworkManagerExitState(class UTGFEventArgs* Args);
	void OpenMatchToast(EMatchState MatchState);
	void ResumeMatching();
	void SelectChallengerType(ETGFProtoTgfEnChallengerModelType ChallengerType);
	void SelectMapLevel(const int32 LevelId, const int32 LevelType, const class FString& Region);
	void SetShowBattleResult(bool IsShow);
	void SetShowBattleReturn(bool IsShow);
	void StartMatch(const int32 LevelType, const int32 LevelId, const class FString& Region);
	void StopMatch();

	class UTGFProtoTgfSCBattleSettleSync* GetResultData() const;
	ETGFProtoTgfEnChallengerModelType GetSelectedChallengerType() const;
	struct FMatchLevelInfo GetSelectedLevelInfo() const;
	bool IsMatching() const;
	bool IsTicketsEnough() const;
	bool ShouldShowBattleResult() const;
	bool ShouldShowBattleReturn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchService">();
	}
	static class UMatchService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchService>();
	}
};
static_assert(alignof(UMatchService) == 0x000008, "Wrong alignment on UMatchService");
static_assert(sizeof(UMatchService) == 0x0001C8, "Wrong size on UMatchService");
static_assert(offsetof(UMatchService, SelectedLevelInfo) == 0x000040, "Member 'UMatchService::SelectedLevelInfo' has a wrong offset!");
static_assert(offsetof(UMatchService, SelectedChallengerType) == 0x000060, "Member 'UMatchService::SelectedChallengerType' has a wrong offset!");
static_assert(offsetof(UMatchService, bWaitMatchingPreSearchRsp) == 0x000061, "Member 'UMatchService::bWaitMatchingPreSearchRsp' has a wrong offset!");
static_assert(offsetof(UMatchService, bWaitMatchingSearchRsp) == 0x000062, "Member 'UMatchService::bWaitMatchingSearchRsp' has a wrong offset!");
static_assert(offsetof(UMatchService, BattleResultData) == 0x0001A8, "Member 'UMatchService::BattleResultData' has a wrong offset!");
static_assert(offsetof(UMatchService, ShowBattleResult) == 0x0001B0, "Member 'UMatchService::ShowBattleResult' has a wrong offset!");
static_assert(offsetof(UMatchService, ShowBattleReturn) == 0x0001B1, "Member 'UMatchService::ShowBattleReturn' has a wrong offset!");

// Class TGFGame.MatchToastArgs
// 0x0008 (0x0038 - 0x0030)
class UMatchToastArgs final : public UTGFWindowArgs
{
public:
	EMatchState                                   MatchState;                                        // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMatchToastArgs* Create(EMatchState InMatchState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchToastArgs">();
	}
	static class UMatchToastArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchToastArgs>();
	}
};
static_assert(alignof(UMatchToastArgs) == 0x000008, "Wrong alignment on UMatchToastArgs");
static_assert(sizeof(UMatchToastArgs) == 0x000038, "Wrong size on UMatchToastArgs");
static_assert(offsetof(UMatchToastArgs, MatchState) == 0x000030, "Member 'UMatchToastArgs::MatchState' has a wrong offset!");

// Class TGFGame.FriendSuggest
// 0x0030 (0x0058 - 0x0028)
class UFriendSuggest final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               UserKey;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleKey                               RoleKey;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnTeamMethodType                  TeamMethod;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSuggest">();
	}
	static class UFriendSuggest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSuggest>();
	}
};
static_assert(alignof(UFriendSuggest) == 0x000008, "Wrong alignment on UFriendSuggest");
static_assert(sizeof(UFriendSuggest) == 0x000058, "Wrong size on UFriendSuggest");
static_assert(offsetof(UFriendSuggest, bIsValid) == 0x000028, "Member 'UFriendSuggest::bIsValid' has a wrong offset!");
static_assert(offsetof(UFriendSuggest, UserKey) == 0x000030, "Member 'UFriendSuggest::UserKey' has a wrong offset!");
static_assert(offsetof(UFriendSuggest, RoleKey) == 0x000040, "Member 'UFriendSuggest::RoleKey' has a wrong offset!");
static_assert(offsetof(UFriendSuggest, TeamMethod) == 0x000050, "Member 'UFriendSuggest::TeamMethod' has a wrong offset!");

// Class TGFGame.MatchWindow
// 0x0000 (0x02B8 - 0x02B8)
class UMatchWindow final : public UTGFWindow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchWindow">();
	}
	static class UMatchWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchWindow>();
	}
};
static_assert(alignof(UMatchWindow) == 0x000008, "Wrong alignment on UMatchWindow");
static_assert(sizeof(UMatchWindow) == 0x0002B8, "Wrong size on UMatchWindow");

// Class TGFGame.MatchWindowArgs
// 0x0020 (0x0050 - 0x0030)
class UMatchWindowArgs final : public UTGFWindowArgs
{
public:
	bool                                          SendSearchRequest;                                 // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENMatchWindowStatus                           Status;                                            // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelId;                                           // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelType;                                         // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Region;                                            // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UMatchWindowArgs* Create(const int32 Param_LevelId, const int32 Param_LevelType, const class FString& Param_Region, bool Param_SendSearchRequest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchWindowArgs">();
	}
	static class UMatchWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchWindowArgs>();
	}
};
static_assert(alignof(UMatchWindowArgs) == 0x000008, "Wrong alignment on UMatchWindowArgs");
static_assert(sizeof(UMatchWindowArgs) == 0x000050, "Wrong size on UMatchWindowArgs");
static_assert(offsetof(UMatchWindowArgs, SendSearchRequest) == 0x000030, "Member 'UMatchWindowArgs::SendSearchRequest' has a wrong offset!");
static_assert(offsetof(UMatchWindowArgs, Status) == 0x000031, "Member 'UMatchWindowArgs::Status' has a wrong offset!");
static_assert(offsetof(UMatchWindowArgs, LevelId) == 0x000034, "Member 'UMatchWindowArgs::LevelId' has a wrong offset!");
static_assert(offsetof(UMatchWindowArgs, LevelType) == 0x000038, "Member 'UMatchWindowArgs::LevelType' has a wrong offset!");
static_assert(offsetof(UMatchWindowArgs, Region) == 0x000040, "Member 'UMatchWindowArgs::Region' has a wrong offset!");

// Class TGFGame.TGFGameHallObjectTouchEvent
// 0x0028 (0x0050 - 0x0028)
class UTGFGameHallObjectTouchEvent final : public UTGFEventArgs
{
public:
	class FString                                 EventName;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TouchActor;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TouchName;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameHallObjectTouchEvent">();
	}
	static class UTGFGameHallObjectTouchEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameHallObjectTouchEvent>();
	}
};
static_assert(alignof(UTGFGameHallObjectTouchEvent) == 0x000008, "Wrong alignment on UTGFGameHallObjectTouchEvent");
static_assert(sizeof(UTGFGameHallObjectTouchEvent) == 0x000050, "Wrong size on UTGFGameHallObjectTouchEvent");
static_assert(offsetof(UTGFGameHallObjectTouchEvent, EventName) == 0x000028, "Member 'UTGFGameHallObjectTouchEvent::EventName' has a wrong offset!");
static_assert(offsetof(UTGFGameHallObjectTouchEvent, TouchActor) == 0x000038, "Member 'UTGFGameHallObjectTouchEvent::TouchActor' has a wrong offset!");
static_assert(offsetof(UTGFGameHallObjectTouchEvent, TouchName) == 0x000040, "Member 'UTGFGameHallObjectTouchEvent::TouchName' has a wrong offset!");

// Class TGFGame.MidasPaySuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UMidasPaySuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MidasPaySuccessEvent">();
	}
	static class UMidasPaySuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMidasPaySuccessEvent>();
	}
};
static_assert(alignof(UMidasPaySuccessEvent) == 0x000008, "Wrong alignment on UMidasPaySuccessEvent");
static_assert(sizeof(UMidasPaySuccessEvent) == 0x000028, "Wrong size on UMidasPaySuccessEvent");

// Class TGFGame.MidasPayFailedEvent
// 0x0028 (0x0050 - 0x0028)
class UMidasPayFailedEvent final : public UTGFEventArgs
{
public:
	int32                                         RetCode;                                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InnerCode;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RetMessage;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MidasPayFailedEvent">();
	}
	static class UMidasPayFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMidasPayFailedEvent>();
	}
};
static_assert(alignof(UMidasPayFailedEvent) == 0x000008, "Wrong alignment on UMidasPayFailedEvent");
static_assert(sizeof(UMidasPayFailedEvent) == 0x000050, "Wrong size on UMidasPayFailedEvent");
static_assert(offsetof(UMidasPayFailedEvent, RetCode) == 0x000028, "Member 'UMidasPayFailedEvent::RetCode' has a wrong offset!");
static_assert(offsetof(UMidasPayFailedEvent, InnerCode) == 0x000030, "Member 'UMidasPayFailedEvent::InnerCode' has a wrong offset!");
static_assert(offsetof(UMidasPayFailedEvent, RetMessage) == 0x000040, "Member 'UMidasPayFailedEvent::RetMessage' has a wrong offset!");

// Class TGFGame.TGFTeamFinderStatusChangedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTeamFinderStatusChangedEvent final : public UTGFEventArgs
{
public:
	bool                                          bFinderStatus;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamFinderStatusChangedEvent">();
	}
	static class UTGFTeamFinderStatusChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamFinderStatusChangedEvent>();
	}
};
static_assert(alignof(UTGFTeamFinderStatusChangedEvent) == 0x000008, "Wrong alignment on UTGFTeamFinderStatusChangedEvent");
static_assert(sizeof(UTGFTeamFinderStatusChangedEvent) == 0x000030, "Wrong size on UTGFTeamFinderStatusChangedEvent");
static_assert(offsetof(UTGFTeamFinderStatusChangedEvent, bFinderStatus) == 0x000028, "Member 'UTGFTeamFinderStatusChangedEvent::bFinderStatus' has a wrong offset!");

// Class TGFGame.MidasPayProductInfoEvent
// 0x0000 (0x0028 - 0x0028)
class UMidasPayProductInfoEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MidasPayProductInfoEvent">();
	}
	static class UMidasPayProductInfoEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMidasPayProductInfoEvent>();
	}
};
static_assert(alignof(UMidasPayProductInfoEvent) == 0x000008, "Wrong alignment on UMidasPayProductInfoEvent");
static_assert(sizeof(UMidasPayProductInfoEvent) == 0x000028, "Wrong size on UMidasPayProductInfoEvent");

// Class TGFGame.MidasService
// 0x02C8 (0x02F8 - 0x0030)
class UMidasService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x2C8];                                     // 0x0030(0x02C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsLimitInterval();
	bool GetIsPaying();
	void GetProductInfo(const TArray<class FString>& SkuIdList);
	bool GetProductInfoBySkuId(const class FString& SkuId, struct FCtiProductInfo* OutProductInfo);
	class FString GetProductInnerCode();
	int32 GetProductRetCode();
	void Init(const class FString& OpenID, const class FString& ServerId);
	void Pay(const class FString& PayInfo);
	void ReapplyReceipt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MidasService">();
	}
	static class UMidasService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMidasService>();
	}
};
static_assert(alignof(UMidasService) == 0x000008, "Wrong alignment on UMidasService");
static_assert(sizeof(UMidasService) == 0x0002F8, "Wrong size on UMidasService");

// Class TGFGame.CheckDailyLogin
// 0x0000 (0x0028 - 0x0028)
class UCheckDailyLogin final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckDailyLogin">();
	}
	static class UCheckDailyLogin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckDailyLogin>();
	}
};
static_assert(alignof(UCheckDailyLogin) == 0x000008, "Wrong alignment on UCheckDailyLogin");
static_assert(sizeof(UCheckDailyLogin) == 0x000028, "Wrong size on UCheckDailyLogin");

// Class TGFGame.TGFMithrilForceReceiveRewardEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFMithrilForceReceiveRewardEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMithrilForceReceiveRewardEvent">();
	}
	static class UTGFMithrilForceReceiveRewardEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMithrilForceReceiveRewardEvent>();
	}
};
static_assert(alignof(UTGFMithrilForceReceiveRewardEvent) == 0x000008, "Wrong alignment on UTGFMithrilForceReceiveRewardEvent");
static_assert(sizeof(UTGFMithrilForceReceiveRewardEvent) == 0x000028, "Wrong size on UTGFMithrilForceReceiveRewardEvent");

// Class TGFGame.MithrilService
// 0x0018 (0x0048 - 0x0030)
class UMithrilService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MithrilPrestige;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnterMithrilHall();
	void LeaveMithrilHall();
	void Lua_Initialized();
	void SelectMithrilRole(ETGFProtoTgfEnRoleCareerType CareerType, ETGFProtoTgfEnRoleGenderType GenderType);
	void SendMithrilForceReceiveRewardReq(const TArray<class UTGFProtoTgfDItemOffset*>& InRewardItems);
	void SetMithrilPrestige(int64 Prestige);

	bool CheckHasMithrilRole() const;
	bool CheckInMithrilHall() const;
	int32 GetMithrilLevel(int64* OutNextExp, int64* OutRemainExp) const;
	int32 GetMithrilPrestigeLevel(int64 Prestige, int64* OutNextExp, int64* OutRemainExp) const;
	int64 GetMithrilRoleGuid(ETGFProtoTgfEnRoleCareerType CareerType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MithrilService">();
	}
	static class UMithrilService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMithrilService>();
	}
};
static_assert(alignof(UMithrilService) == 0x000008, "Wrong alignment on UMithrilService");
static_assert(sizeof(UMithrilService) == 0x000048, "Wrong size on UMithrilService");
static_assert(offsetof(UMithrilService, MithrilPrestige) == 0x000040, "Member 'UMithrilService::MithrilPrestige' has a wrong offset!");

// Class TGFGame.TaskService
// 0x0020 (0x0050 - 0x0030)
class UTaskService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfDUserQuestsData*            TaskFullData;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRookieTaskWhileLogin;                          // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDataReady;                                      // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lua_BroadcastCheckDailyLogin();
	void Lua_Initialized();
	void Lua_NotifyTaskDataReady(bool bIsReady);
	bool Lua_ReportTaskReward(int32 TaskId);
	bool Lua_ReportTaskSubmitItem(int32 TaskId, int64 SubmitCnt);
	void Lua_UpdateTaskInfo(class UTGFProtoTgfDUserQuestData* UpdataTaskInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskService">();
	}
	static class UTaskService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskService>();
	}
};
static_assert(alignof(UTaskService) == 0x000008, "Wrong alignment on UTaskService");
static_assert(sizeof(UTaskService) == 0x000050, "Wrong size on UTaskService");
static_assert(offsetof(UTaskService, TaskFullData) == 0x000040, "Member 'UTaskService::TaskFullData' has a wrong offset!");
static_assert(offsetof(UTaskService, bHasRookieTaskWhileLogin) == 0x000048, "Member 'UTaskService::bHasRookieTaskWhileLogin' has a wrong offset!");
static_assert(offsetof(UTaskService, bIsDataReady) == 0x000049, "Member 'UTaskService::bIsDataReady' has a wrong offset!");

// Class TGFGame.TGFGenderListItemObject
// 0x0018 (0x0040 - 0x0028)
class UTGFGenderListItemObject final : public UObject
{
public:
	int32                                         GenderId;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BaseTexture;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SelectTexture;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGenderListItemObject">();
	}
	static class UTGFGenderListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGenderListItemObject>();
	}
};
static_assert(alignof(UTGFGenderListItemObject) == 0x000008, "Wrong alignment on UTGFGenderListItemObject");
static_assert(sizeof(UTGFGenderListItemObject) == 0x000040, "Wrong size on UTGFGenderListItemObject");
static_assert(offsetof(UTGFGenderListItemObject, GenderId) == 0x000028, "Member 'UTGFGenderListItemObject::GenderId' has a wrong offset!");
static_assert(offsetof(UTGFGenderListItemObject, BaseTexture) == 0x000030, "Member 'UTGFGenderListItemObject::BaseTexture' has a wrong offset!");
static_assert(offsetof(UTGFGenderListItemObject, SelectTexture) == 0x000038, "Member 'UTGFGenderListItemObject::SelectTexture' has a wrong offset!");

// Class TGFGame.TGFWeaponListItemObject
// 0x0018 (0x0040 - 0x0028)
class UTGFWeaponListItemObject final : public UObject
{
public:
	class FText                                   WeaponName;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFWeaponListItemObject">();
	}
	static class UTGFWeaponListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFWeaponListItemObject>();
	}
};
static_assert(alignof(UTGFWeaponListItemObject) == 0x000008, "Wrong alignment on UTGFWeaponListItemObject");
static_assert(sizeof(UTGFWeaponListItemObject) == 0x000040, "Wrong size on UTGFWeaponListItemObject");
static_assert(offsetof(UTGFWeaponListItemObject, WeaponName) == 0x000028, "Member 'UTGFWeaponListItemObject::WeaponName' has a wrong offset!");

// Class TGFGame.RoleAttributeInfo
// 0x0020 (0x0048 - 0x0028)
class URoleAttributeInfo final : public UObject
{
public:
	class URoleAttributeCoreInfo*                 CoreInfo;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URoleAttributeOffensiveInfo*            OffensiveInfo;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UURoleAttributeDefensiveInfo*           DefensiveInfo;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URoleAttributeInteractiveInfo*          InteractiveInfo;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleAttributeInfo">();
	}
	static class URoleAttributeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleAttributeInfo>();
	}
};
static_assert(alignof(URoleAttributeInfo) == 0x000008, "Wrong alignment on URoleAttributeInfo");
static_assert(sizeof(URoleAttributeInfo) == 0x000048, "Wrong size on URoleAttributeInfo");
static_assert(offsetof(URoleAttributeInfo, CoreInfo) == 0x000028, "Member 'URoleAttributeInfo::CoreInfo' has a wrong offset!");
static_assert(offsetof(URoleAttributeInfo, OffensiveInfo) == 0x000030, "Member 'URoleAttributeInfo::OffensiveInfo' has a wrong offset!");
static_assert(offsetof(URoleAttributeInfo, DefensiveInfo) == 0x000038, "Member 'URoleAttributeInfo::DefensiveInfo' has a wrong offset!");
static_assert(offsetof(URoleAttributeInfo, InteractiveInfo) == 0x000040, "Member 'URoleAttributeInfo::InteractiveInfo' has a wrong offset!");

// Class TGFGame.TGFSkillListItemObject
// 0x0008 (0x0030 - 0x0028)
class UTGFSkillListItemObject final : public UObject
{
public:
	int32                                         SkillId;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSkillListItemObject">();
	}
	static class UTGFSkillListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSkillListItemObject>();
	}
};
static_assert(alignof(UTGFSkillListItemObject) == 0x000008, "Wrong alignment on UTGFSkillListItemObject");
static_assert(sizeof(UTGFSkillListItemObject) == 0x000030, "Wrong size on UTGFSkillListItemObject");
static_assert(offsetof(UTGFSkillListItemObject, SkillId) == 0x000028, "Member 'UTGFSkillListItemObject::SkillId' has a wrong offset!");

// Class TGFGame.TGFTalentListItemObject
// 0x0080 (0x00A8 - 0x0028)
class UTGFTalentListItemObject final : public UObject
{
public:
	struct FTgfCareerTalentCfgItem                Talent;                                            // 0x0028(0x0080)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTalentListItemObject">();
	}
	static class UTGFTalentListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTalentListItemObject>();
	}
};
static_assert(alignof(UTGFTalentListItemObject) == 0x000008, "Wrong alignment on UTGFTalentListItemObject");
static_assert(sizeof(UTGFTalentListItemObject) == 0x0000A8, "Wrong size on UTGFTalentListItemObject");
static_assert(offsetof(UTGFTalentListItemObject, Talent) == 0x000028, "Member 'UTGFTalentListItemObject::Talent' has a wrong offset!");

// Class TGFGame.TgfAppearanceService
// 0x0118 (0x0148 - 0x0030)
class UTgfAppearanceService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ASceneAppearanceActor>   SceneInstance;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTgfAppearanceCaptureReqWorker*         CurrCaptureWorker;                                 // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 QueueWorkerID;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<int64, class UTgfAppearanceCaptureReqWorker*> MapRoleIDAppearanceWorker;                         // 0x0060(0x0050)(NativeAccessSpecifierPublic)
	TMap<int64, class UTgfAppearanceCacheTextureData*> MapCacheCaptureData;                               // 0x00B0(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventAppearanceTextureCaptureFinishDelegate;       // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         NOperateFrameInterval;                             // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x1C];                                     // 0x0114(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ScenceCls;                                         // 0x0130(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastCaptureData(int64 RoleID, class UObject* SlateBrush);
	class UTexture2D* GetAppearanceTextureDirectly(const struct FTgfAvatarBuildConfig& InAppearanceConfig);
	class ASceneAppearanceActor* GetSceneInstance();
	void InitAppearanceScene();
	void RequestRoleAppearanceTexture(int64 RoleID, const struct FTgfAvatarBuildConfig& InAppearanceConfig, bool NeedQueueFirst, const struct FVector2D& ImgSize);
	void SetOperateFrameInterval(int32 FrameInterval);
	void SetWorkerFrameInterval(int32 FrameInterval);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAppearanceService">();
	}
	static class UTgfAppearanceService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAppearanceService>();
	}
};
static_assert(alignof(UTgfAppearanceService) == 0x000008, "Wrong alignment on UTgfAppearanceService");
static_assert(sizeof(UTgfAppearanceService) == 0x000148, "Wrong size on UTgfAppearanceService");
static_assert(offsetof(UTgfAppearanceService, SceneInstance) == 0x000040, "Member 'UTgfAppearanceService::SceneInstance' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, CurrCaptureWorker) == 0x000048, "Member 'UTgfAppearanceService::CurrCaptureWorker' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, QueueWorkerID) == 0x000050, "Member 'UTgfAppearanceService::QueueWorkerID' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, MapRoleIDAppearanceWorker) == 0x000060, "Member 'UTgfAppearanceService::MapRoleIDAppearanceWorker' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, MapCacheCaptureData) == 0x0000B0, "Member 'UTgfAppearanceService::MapCacheCaptureData' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, EventAppearanceTextureCaptureFinishDelegate) == 0x000100, "Member 'UTgfAppearanceService::EventAppearanceTextureCaptureFinishDelegate' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, NOperateFrameInterval) == 0x000110, "Member 'UTgfAppearanceService::NOperateFrameInterval' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceService, ScenceCls) == 0x000130, "Member 'UTgfAppearanceService::ScenceCls' has a wrong offset!");

// Class TGFGame.TGFCareerListItemObject
// 0x0008 (0x0030 - 0x0028)
class UTGFCareerListItemObject final : public UObject
{
public:
	int32                                         TypeId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCareerListItemObject">();
	}
	static class UTGFCareerListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCareerListItemObject>();
	}
};
static_assert(alignof(UTGFCareerListItemObject) == 0x000008, "Wrong alignment on UTGFCareerListItemObject");
static_assert(sizeof(UTGFCareerListItemObject) == 0x000030, "Wrong size on UTGFCareerListItemObject");
static_assert(offsetof(UTGFCareerListItemObject, TypeId) == 0x000028, "Member 'UTGFCareerListItemObject::TypeId' has a wrong offset!");
static_assert(offsetof(UTGFCareerListItemObject, Gender) == 0x00002C, "Member 'UTGFCareerListItemObject::Gender' has a wrong offset!");

// Class TGFGame.TGFMithrilItemObject
// 0x0008 (0x0030 - 0x0028)
class UTGFMithrilItemObject final : public UObject
{
public:
	int32                                         TypeId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMithrilItemObject">();
	}
	static class UTGFMithrilItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMithrilItemObject>();
	}
};
static_assert(alignof(UTGFMithrilItemObject) == 0x000008, "Wrong alignment on UTGFMithrilItemObject");
static_assert(sizeof(UTGFMithrilItemObject) == 0x000030, "Wrong size on UTGFMithrilItemObject");
static_assert(offsetof(UTGFMithrilItemObject, TypeId) == 0x000028, "Member 'UTGFMithrilItemObject::TypeId' has a wrong offset!");

// Class TGFGame.RoleInfo
// 0x00B8 (0x00E0 - 0x0028)
class URoleInfo final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UpdateTimestamp;                                   // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserKey                               UserKey;                                           // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleKey                               RoleKey;                                           // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RoleCreateIndex;                                   // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RoleName;                                          // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceShowDefaultName;                             // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoleTypeId;                                        // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoleLevel;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTGFProtoTgfDRoleMetaIndex*             RoleMeta;                                          // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTGFProtoTgfDRoleDressUp*               RoleDressUp;                                       // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETgfEquipSlot, int32>                    RoleWearingMap;                                    // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	struct FTgfAvatarBuildConfig GetAvatarBuildConfig() const;
	class FString GetDefaultRoleName() const;
	TArray<int32> GetEquipmentList(bool bFilterDressUp) const;
	TArray<int32> GetEquipmentListWithoutSlotType(ETgfEquipSlot ExceptType) const;
	class FString GetHeadIconPath() const;
	bool GetIsExpired() const;
	bool GetIsValid() const;
	class FString GetRoleName() const;
	TArray<int32> GetUESkinsList() const;
	TArray<int32> GetWeaponList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleInfo">();
	}
	static class URoleInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleInfo>();
	}
};
static_assert(alignof(URoleInfo) == 0x000008, "Wrong alignment on URoleInfo");
static_assert(sizeof(URoleInfo) == 0x0000E0, "Wrong size on URoleInfo");
static_assert(offsetof(URoleInfo, bIsValid) == 0x000028, "Member 'URoleInfo::bIsValid' has a wrong offset!");
static_assert(offsetof(URoleInfo, UpdateTimestamp) == 0x000030, "Member 'URoleInfo::UpdateTimestamp' has a wrong offset!");
static_assert(offsetof(URoleInfo, UserKey) == 0x000038, "Member 'URoleInfo::UserKey' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleKey) == 0x000048, "Member 'URoleInfo::RoleKey' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleCreateIndex) == 0x000058, "Member 'URoleInfo::RoleCreateIndex' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleName) == 0x000060, "Member 'URoleInfo::RoleName' has a wrong offset!");
static_assert(offsetof(URoleInfo, bForceShowDefaultName) == 0x000070, "Member 'URoleInfo::bForceShowDefaultName' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleTypeId) == 0x000074, "Member 'URoleInfo::RoleTypeId' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleLevel) == 0x000078, "Member 'URoleInfo::RoleLevel' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleMeta) == 0x000080, "Member 'URoleInfo::RoleMeta' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleDressUp) == 0x000088, "Member 'URoleInfo::RoleDressUp' has a wrong offset!");
static_assert(offsetof(URoleInfo, RoleWearingMap) == 0x000090, "Member 'URoleInfo::RoleWearingMap' has a wrong offset!");

// Class TGFGame.PayService
// 0x0020 (0x0050 - 0x0030)
class UPayService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckPayGetAllReceived();
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnPaySuccess(class UTGFEventArgs* Args);
	void SendPayGetAll();
	void SendPayUpdateDiamondReq();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PayService">();
	}
	static class UPayService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPayService>();
	}
};
static_assert(alignof(UPayService) == 0x000008, "Wrong alignment on UPayService");
static_assert(sizeof(UPayService) == 0x000050, "Wrong size on UPayService");

// Class TGFGame.TGFHallSettingDirtyEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFHallSettingDirtyEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFHallSettingDirtyEvent">();
	}
	static class UTGFHallSettingDirtyEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFHallSettingDirtyEvent>();
	}
};
static_assert(alignof(UTGFHallSettingDirtyEvent) == 0x000008, "Wrong alignment on UTGFHallSettingDirtyEvent");
static_assert(sizeof(UTGFHallSettingDirtyEvent) == 0x000028, "Wrong size on UTGFHallSettingDirtyEvent");

// Class TGFGame.ResolveDomain
// 0x0060 (0x0088 - 0x0028)
class UResolveDomain final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResolveDomain">();
	}
	static class UResolveDomain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResolveDomain>();
	}
};
static_assert(alignof(UResolveDomain) == 0x000008, "Wrong alignment on UResolveDomain");
static_assert(sizeof(UResolveDomain) == 0x000088, "Wrong size on UResolveDomain");

// Class TGFGame.TGFCreateRoleWindowArgs
// 0x0020 (0x0050 - 0x0030)
class UTGFCreateRoleWindowArgs final : public UTGFWindowArgs
{
public:
	int32                                         CareerID;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PreUIName;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreateType;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCreateRoleWindowArgs">();
	}
	static class UTGFCreateRoleWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCreateRoleWindowArgs>();
	}
};
static_assert(alignof(UTGFCreateRoleWindowArgs) == 0x000008, "Wrong alignment on UTGFCreateRoleWindowArgs");
static_assert(sizeof(UTGFCreateRoleWindowArgs) == 0x000050, "Wrong size on UTGFCreateRoleWindowArgs");
static_assert(offsetof(UTGFCreateRoleWindowArgs, CareerID) == 0x000030, "Member 'UTGFCreateRoleWindowArgs::CareerID' has a wrong offset!");
static_assert(offsetof(UTGFCreateRoleWindowArgs, PreUIName) == 0x000038, "Member 'UTGFCreateRoleWindowArgs::PreUIName' has a wrong offset!");
static_assert(offsetof(UTGFCreateRoleWindowArgs, CreateType) == 0x000048, "Member 'UTGFCreateRoleWindowArgs::CreateType' has a wrong offset!");

// Class TGFGame.RoleInfoNoti
// 0x0008 (0x0030 - 0x0028)
class URoleInfoNoti final : public UTGFEventArgs
{
public:
	int64                                         Role_guid;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleInfoNoti">();
	}
	static class URoleInfoNoti* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleInfoNoti>();
	}
};
static_assert(alignof(URoleInfoNoti) == 0x000008, "Wrong alignment on URoleInfoNoti");
static_assert(sizeof(URoleInfoNoti) == 0x000030, "Wrong size on URoleInfoNoti");
static_assert(offsetof(URoleInfoNoti, Role_guid) == 0x000028, "Member 'URoleInfoNoti::Role_guid' has a wrong offset!");

// Class TGFGame.TgfAppearanceCaptureReqWorker
// 0x0090 (0x00B8 - 0x0028)
class UTgfAppearanceCaptureReqWorker final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RoleID;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTgfAvatarBuildConfig                  AppearanceConfig;                                  // 0x0038(0x0068)(NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAppearanceCaptureReqWorker">();
	}
	static class UTgfAppearanceCaptureReqWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAppearanceCaptureReqWorker>();
	}
};
static_assert(alignof(UTgfAppearanceCaptureReqWorker) == 0x000008, "Wrong alignment on UTgfAppearanceCaptureReqWorker");
static_assert(sizeof(UTgfAppearanceCaptureReqWorker) == 0x0000B8, "Wrong size on UTgfAppearanceCaptureReqWorker");
static_assert(offsetof(UTgfAppearanceCaptureReqWorker, RoleID) == 0x000030, "Member 'UTgfAppearanceCaptureReqWorker::RoleID' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceCaptureReqWorker, AppearanceConfig) == 0x000038, "Member 'UTgfAppearanceCaptureReqWorker::AppearanceConfig' has a wrong offset!");

// Class TGFGame.PlayerInfoService
// 0x0050 (0x0080 - 0x0030)
class UPlayerInfoService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	ECreateRoleFrom                               CreateRoleFrom;                                    // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HistoryRoleMaxLevel;                               // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	ECreateRoleFrom GetCreateOpenFrom();
	ETGFProtoTgfEnRoleCareerType GetHallRoleCareerType();
	ETGFProtoTgfEnForceType GetHallRoleForceType();
	int32 GetHallRoleGender();
	int64 GetHallRoleGuid();
	class UTGFProtoTgfDUserRole* GetHallRoleInfo();
	class UTGFProtoTgfDUserRoleBasic* GetHallRoleInfoBasic();
	ETGFProtoTgfEnRoleRaceType GetHallRoleRace();
	bool GetRole(int64 Guid, struct FTGFUserRole* Role);
	class UTGFProtoTgfDUserRole* GetRoleInfo(int64 Guid);
	TArray<struct FTGFUserRole> GetRoleList();
	void OnGameLogout(class UTGFEventArgs* Args);
	void OpenCreateRole(ECreateRoleFrom InFrom, class UTGFCreateRoleWindowArgs* Args);
	void SendBusinessPingReq(ETGFProtoTgfEnBusinessPingType PingType);
	void SendPlayerUpdateBirthDayReq(const class FString& Birth);

	int32 GetAreaId() const;
	class FString GetBirth() const;
	int32 GetConsecutiveLoginDays() const;
	int32 GetCumulativeLoginDays() const;
	int32 GetHistoryRoleMaxLevel() const;
	class FString GetRegisterCountry() const;
	int32 GetRoleCount() const;
	ETGFProtoTgfEnUserTableDataVersion GetUserDataVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInfoService">();
	}
	static class UPlayerInfoService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInfoService>();
	}
};
static_assert(alignof(UPlayerInfoService) == 0x000008, "Wrong alignment on UPlayerInfoService");
static_assert(sizeof(UPlayerInfoService) == 0x000080, "Wrong size on UPlayerInfoService");
static_assert(offsetof(UPlayerInfoService, CreateRoleFrom) == 0x000078, "Member 'UPlayerInfoService::CreateRoleFrom' has a wrong offset!");
static_assert(offsetof(UPlayerInfoService, HistoryRoleMaxLevel) == 0x00007C, "Member 'UPlayerInfoService::HistoryRoleMaxLevel' has a wrong offset!");

// Class TGFGame.PlayerUpgradeWindowArgs
// 0x0008 (0x0038 - 0x0030)
class UPlayerUpgradeWindowArgs final : public UTGFWindowArgs
{
public:
	int32                                         OldLevel;                                          // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerUpgradeWindowArgs">();
	}
	static class UPlayerUpgradeWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerUpgradeWindowArgs>();
	}
};
static_assert(alignof(UPlayerUpgradeWindowArgs) == 0x000008, "Wrong alignment on UPlayerUpgradeWindowArgs");
static_assert(sizeof(UPlayerUpgradeWindowArgs) == 0x000038, "Wrong size on UPlayerUpgradeWindowArgs");
static_assert(offsetof(UPlayerUpgradeWindowArgs, OldLevel) == 0x000030, "Member 'UPlayerUpgradeWindowArgs::OldLevel' has a wrong offset!");
static_assert(offsetof(UPlayerUpgradeWindowArgs, NewLevel) == 0x000034, "Member 'UPlayerUpgradeWindowArgs::NewLevel' has a wrong offset!");

// Class TGFGame.TGFGameSettingFileDialog
// 0x0048 (0x01B0 - 0x0168)
class UTGFGameSettingFileDialog final : public UGameSettingValue
{
public:
	uint8                                         Pad_168[0x48];                                     // 0x0168(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameSettingFileDialog">();
	}
	static class UTGFGameSettingFileDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameSettingFileDialog>();
	}
};
static_assert(alignof(UTGFGameSettingFileDialog) == 0x000008, "Wrong alignment on UTGFGameSettingFileDialog");
static_assert(sizeof(UTGFGameSettingFileDialog) == 0x0001B0, "Wrong size on UTGFGameSettingFileDialog");

// Class TGFGame.PlayerUpgradeWindow
// 0x0000 (0x02B8 - 0x02B8)
class UPlayerUpgradeWindow final : public UTGFWindow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerUpgradeWindow">();
	}
	static class UPlayerUpgradeWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerUpgradeWindow>();
	}
};
static_assert(alignof(UPlayerUpgradeWindow) == 0x000008, "Wrong alignment on UPlayerUpgradeWindow");
static_assert(sizeof(UPlayerUpgradeWindow) == 0x0002B8, "Wrong size on UPlayerUpgradeWindow");

// Class TGFGame.TGFRoomCreateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomCreateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomCreateEvent">();
	}
	static class UTGFRoomCreateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomCreateEvent>();
	}
};
static_assert(alignof(UTGFRoomCreateEvent) == 0x000008, "Wrong alignment on UTGFRoomCreateEvent");
static_assert(sizeof(UTGFRoomCreateEvent) == 0x000028, "Wrong size on UTGFRoomCreateEvent");

// Class TGFGame.TgfAudioSystemSave
// 0x0010 (0x0038 - 0x0028)
class UTgfAudioSystemSave final : public UObject
{
public:
	struct FTgfAudioSystemSettings                Settings;                                          // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAudioSystemSave">();
	}
	static class UTgfAudioSystemSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAudioSystemSave>();
	}
};
static_assert(alignof(UTgfAudioSystemSave) == 0x000008, "Wrong alignment on UTgfAudioSystemSave");
static_assert(sizeof(UTgfAudioSystemSave) == 0x000038, "Wrong size on UTgfAudioSystemSave");
static_assert(offsetof(UTgfAudioSystemSave, Settings) == 0x000028, "Member 'UTgfAudioSystemSave::Settings' has a wrong offset!");

// Class TGFGame.TGFRoomEnterEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomEnterEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomEnterEvent">();
	}
	static class UTGFRoomEnterEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomEnterEvent>();
	}
};
static_assert(alignof(UTGFRoomEnterEvent) == 0x000008, "Wrong alignment on UTGFRoomEnterEvent");
static_assert(sizeof(UTGFRoomEnterEvent) == 0x000028, "Wrong size on UTGFRoomEnterEvent");

// Class TGFGame.TGFRoomLeaveEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomLeaveEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomLeaveEvent">();
	}
	static class UTGFRoomLeaveEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomLeaveEvent>();
	}
};
static_assert(alignof(UTGFRoomLeaveEvent) == 0x000008, "Wrong alignment on UTGFRoomLeaveEvent");
static_assert(sizeof(UTGFRoomLeaveEvent) == 0x000028, "Wrong size on UTGFRoomLeaveEvent");

// Class TGFGame.TeamMember
// 0x0040 (0x0068 - 0x0028)
class UTeamMember final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               UserKey;                                           // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReady;                                          // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UserUpdateHandler;                                 // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RoleUpdateHandler;                                 // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserInfo*                              MyUserInfo;                                        // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URoleInfo*                              MyRoleInfo;                                        // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetIsReady(bool bInReady);

	bool GetIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamMember">();
	}
	static class UTeamMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamMember>();
	}
};
static_assert(alignof(UTeamMember) == 0x000008, "Wrong alignment on UTeamMember");
static_assert(sizeof(UTeamMember) == 0x000068, "Wrong size on UTeamMember");
static_assert(offsetof(UTeamMember, bIsValid) == 0x000028, "Member 'UTeamMember::bIsValid' has a wrong offset!");
static_assert(offsetof(UTeamMember, UserKey) == 0x000030, "Member 'UTeamMember::UserKey' has a wrong offset!");
static_assert(offsetof(UTeamMember, bIsReady) == 0x000040, "Member 'UTeamMember::bIsReady' has a wrong offset!");
static_assert(offsetof(UTeamMember, UserUpdateHandler) == 0x000048, "Member 'UTeamMember::UserUpdateHandler' has a wrong offset!");
static_assert(offsetof(UTeamMember, RoleUpdateHandler) == 0x000050, "Member 'UTeamMember::RoleUpdateHandler' has a wrong offset!");
static_assert(offsetof(UTeamMember, MyUserInfo) == 0x000058, "Member 'UTeamMember::MyUserInfo' has a wrong offset!");
static_assert(offsetof(UTeamMember, MyRoleInfo) == 0x000060, "Member 'UTeamMember::MyRoleInfo' has a wrong offset!");

// Class TGFGame.TGFRoomDisbandEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomDisbandEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomDisbandEvent">();
	}
	static class UTGFRoomDisbandEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomDisbandEvent>();
	}
};
static_assert(alignof(UTGFRoomDisbandEvent) == 0x000008, "Wrong alignment on UTGFRoomDisbandEvent");
static_assert(sizeof(UTGFRoomDisbandEvent) == 0x000028, "Wrong size on UTGFRoomDisbandEvent");

// Class TGFGame.TGFRoomChangeMySelfPosEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomChangeMySelfPosEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomChangeMySelfPosEvent">();
	}
	static class UTGFRoomChangeMySelfPosEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomChangeMySelfPosEvent>();
	}
};
static_assert(alignof(UTGFRoomChangeMySelfPosEvent) == 0x000008, "Wrong alignment on UTGFRoomChangeMySelfPosEvent");
static_assert(sizeof(UTGFRoomChangeMySelfPosEvent) == 0x000028, "Wrong size on UTGFRoomChangeMySelfPosEvent");

// Class TGFGame.TGFGameRuntimeSetting
// 0x0000 (0x0028 - 0x0028)
class UTGFGameRuntimeSetting final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameRuntimeSetting">();
	}
	static class UTGFGameRuntimeSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameRuntimeSetting>();
	}
};
static_assert(alignof(UTGFGameRuntimeSetting) == 0x000008, "Wrong alignment on UTGFGameRuntimeSetting");
static_assert(sizeof(UTGFGameRuntimeSetting) == 0x000028, "Wrong size on UTGFGameRuntimeSetting");

// Class TGFGame.TGFRoomChangeMemberPosEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomChangeMemberPosEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomChangeMemberPosEvent">();
	}
	static class UTGFRoomChangeMemberPosEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomChangeMemberPosEvent>();
	}
};
static_assert(alignof(UTGFRoomChangeMemberPosEvent) == 0x000008, "Wrong alignment on UTGFRoomChangeMemberPosEvent");
static_assert(sizeof(UTGFRoomChangeMemberPosEvent) == 0x000028, "Wrong size on UTGFRoomChangeMemberPosEvent");

// Class TGFGame.TGFRoomSelectBattleMapEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomSelectBattleMapEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSelectBattleMapEvent">();
	}
	static class UTGFRoomSelectBattleMapEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSelectBattleMapEvent>();
	}
};
static_assert(alignof(UTGFRoomSelectBattleMapEvent) == 0x000008, "Wrong alignment on UTGFRoomSelectBattleMapEvent");
static_assert(sizeof(UTGFRoomSelectBattleMapEvent) == 0x000028, "Wrong size on UTGFRoomSelectBattleMapEvent");

// Class TGFGame.TgfInventoryWrapper_Lobby
// 0x0060 (0x01F8 - 0x0198)
class UTgfInventoryWrapper_Lobby : public UTgfInventoryWrapper
{
public:
	int64                                         CurrentRoleId;                                     // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            GearSetLevelMap;                                   // 0x01A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UTgfInventoryRoleWrapper*               InventoryRoleWrapper;                              // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnItemUpdate(class UTGFEventArgs* Args);
	void SetInventoryRoleWrapper(class UTgfInventoryRoleWrapper* RoleWrapper);

	void GetActiveTalents(TArray<struct FTgfCareerTalentCfgItem>* ActiveTalents) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapper_Lobby">();
	}
	static class UTgfInventoryWrapper_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapper_Lobby>();
	}
};
static_assert(alignof(UTgfInventoryWrapper_Lobby) == 0x000008, "Wrong alignment on UTgfInventoryWrapper_Lobby");
static_assert(sizeof(UTgfInventoryWrapper_Lobby) == 0x0001F8, "Wrong size on UTgfInventoryWrapper_Lobby");
static_assert(offsetof(UTgfInventoryWrapper_Lobby, CurrentRoleId) == 0x000198, "Member 'UTgfInventoryWrapper_Lobby::CurrentRoleId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_Lobby, GearSetLevelMap) == 0x0001A0, "Member 'UTgfInventoryWrapper_Lobby::GearSetLevelMap' has a wrong offset!");
static_assert(offsetof(UTgfInventoryWrapper_Lobby, InventoryRoleWrapper) == 0x0001F0, "Member 'UTgfInventoryWrapper_Lobby::InventoryRoleWrapper' has a wrong offset!");

// Class TGFGame.TGFRoomSelectBattleTypeEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomSelectBattleTypeEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSelectBattleTypeEvent">();
	}
	static class UTGFRoomSelectBattleTypeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSelectBattleTypeEvent>();
	}
};
static_assert(alignof(UTGFRoomSelectBattleTypeEvent) == 0x000008, "Wrong alignment on UTGFRoomSelectBattleTypeEvent");
static_assert(sizeof(UTGFRoomSelectBattleTypeEvent) == 0x000028, "Wrong size on UTGFRoomSelectBattleTypeEvent");

// Class TGFGame.TGFRoomGetReadyEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomGetReadyEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomGetReadyEvent">();
	}
	static class UTGFRoomGetReadyEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomGetReadyEvent>();
	}
};
static_assert(alignof(UTGFRoomGetReadyEvent) == 0x000008, "Wrong alignment on UTGFRoomGetReadyEvent");
static_assert(sizeof(UTGFRoomGetReadyEvent) == 0x000028, "Wrong size on UTGFRoomGetReadyEvent");

// Class TGFGame.TgfInventoryItemWrapper_Activity
// 0x0078 (0x00C0 - 0x0048)
class UTgfInventoryItemWrapper_Activity final : public UTgfInventoryItemWrapper
{
public:
	int32                                         ItemId;                                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemCount;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxDurability;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTGFItem                               ItemData;                                          // 0x0058(0x0058)(Protected, NativeAccessSpecifierProtected)
	int64                                         MailId;                                            // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_TgfInventoryItemWrapper_Activity;            // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Guid;                                              // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UTgfInventoryItemWrapper_Activity* Create(int32 Type_id, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_Activity">();
	}
	static class UTgfInventoryItemWrapper_Activity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_Activity>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_Activity) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_Activity");
static_assert(sizeof(UTgfInventoryItemWrapper_Activity) == 0x0000C0, "Wrong size on UTgfInventoryItemWrapper_Activity");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, ItemId) == 0x000048, "Member 'UTgfInventoryItemWrapper_Activity::ItemId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, ItemCount) == 0x00004C, "Member 'UTgfInventoryItemWrapper_Activity::ItemCount' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, MaxDurability) == 0x000050, "Member 'UTgfInventoryItemWrapper_Activity::MaxDurability' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, ItemData) == 0x000058, "Member 'UTgfInventoryItemWrapper_Activity::ItemData' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, MailId) == 0x0000B0, "Member 'UTgfInventoryItemWrapper_Activity::MailId' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, Index_TgfInventoryItemWrapper_Activity) == 0x0000B8, "Member 'UTgfInventoryItemWrapper_Activity::Index_TgfInventoryItemWrapper_Activity' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Activity, Guid) == 0x0000BC, "Member 'UTgfInventoryItemWrapper_Activity::Guid' has a wrong offset!");

// Class TGFGame.TGFRoomCancelReadyEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomCancelReadyEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomCancelReadyEvent">();
	}
	static class UTGFRoomCancelReadyEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomCancelReadyEvent>();
	}
};
static_assert(alignof(UTGFRoomCancelReadyEvent) == 0x000008, "Wrong alignment on UTGFRoomCancelReadyEvent");
static_assert(sizeof(UTGFRoomCancelReadyEvent) == 0x000028, "Wrong size on UTGFRoomCancelReadyEvent");

// Class TGFGame.TGFRoomStartBattleEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomStartBattleEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomStartBattleEvent">();
	}
	static class UTGFRoomStartBattleEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomStartBattleEvent>();
	}
};
static_assert(alignof(UTGFRoomStartBattleEvent) == 0x000008, "Wrong alignment on UTGFRoomStartBattleEvent");
static_assert(sizeof(UTGFRoomStartBattleEvent) == 0x000028, "Wrong size on UTGFRoomStartBattleEvent");

// Class TGFGame.TgfCommonWindowArgs
// 0x0018 (0x0048 - 0x0030)
class UTgfCommonWindowArgs final : public UTGFWindowArgs
{
public:
	int32                                         Param1;                                            // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param2;                                            // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParamString;                                       // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UTgfCommonWindowArgs* Create(int32 Param_Param1, int32 Param_Param2, const class FString& ParamStr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfCommonWindowArgs">();
	}
	static class UTgfCommonWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfCommonWindowArgs>();
	}
};
static_assert(alignof(UTgfCommonWindowArgs) == 0x000008, "Wrong alignment on UTgfCommonWindowArgs");
static_assert(sizeof(UTgfCommonWindowArgs) == 0x000048, "Wrong size on UTgfCommonWindowArgs");
static_assert(offsetof(UTgfCommonWindowArgs, Param1) == 0x000030, "Member 'UTgfCommonWindowArgs::Param1' has a wrong offset!");
static_assert(offsetof(UTgfCommonWindowArgs, Param2) == 0x000034, "Member 'UTgfCommonWindowArgs::Param2' has a wrong offset!");
static_assert(offsetof(UTgfCommonWindowArgs, ParamString) == 0x000038, "Member 'UTgfCommonWindowArgs::ParamString' has a wrong offset!");

// Class TGFGame.TGFRoomNameChangeEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomNameChangeEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomNameChangeEvent">();
	}
	static class UTGFRoomNameChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomNameChangeEvent>();
	}
};
static_assert(alignof(UTGFRoomNameChangeEvent) == 0x000008, "Wrong alignment on UTGFRoomNameChangeEvent");
static_assert(sizeof(UTGFRoomNameChangeEvent) == 0x000028, "Wrong size on UTGFRoomNameChangeEvent");

// Class TGFGame.TGFRoomKeywordChangeEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomKeywordChangeEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomKeywordChangeEvent">();
	}
	static class UTGFRoomKeywordChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomKeywordChangeEvent>();
	}
};
static_assert(alignof(UTGFRoomKeywordChangeEvent) == 0x000008, "Wrong alignment on UTGFRoomKeywordChangeEvent");
static_assert(sizeof(UTGFRoomKeywordChangeEvent) == 0x000028, "Wrong size on UTGFRoomKeywordChangeEvent");

// Class TGFGame.TgfInventoryItemWrapper_Lobby
// 0x0060 (0x00A8 - 0x0048)
class UTgfInventoryItemWrapper_Lobby final : public UTgfInventoryItemWrapper
{
public:
	struct FTGFItem                               ItemData;                                          // 0x0048(0x0058)(Protected, NativeAccessSpecifierProtected)
	int32                                         MaxDurability;                                     // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTgfInventoryItemWrapper_Lobby* Create(const struct FTGFItem& Item);
	static class UTgfInventoryItemWrapper_Lobby* CreateByDItem(class UTGFProtoTgfDItem* ProtoDItem);

	struct FTGFItem GetItemData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_Lobby">();
	}
	static class UTgfInventoryItemWrapper_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_Lobby>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_Lobby) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_Lobby");
static_assert(sizeof(UTgfInventoryItemWrapper_Lobby) == 0x0000A8, "Wrong size on UTgfInventoryItemWrapper_Lobby");
static_assert(offsetof(UTgfInventoryItemWrapper_Lobby, ItemData) == 0x000048, "Member 'UTgfInventoryItemWrapper_Lobby::ItemData' has a wrong offset!");
static_assert(offsetof(UTgfInventoryItemWrapper_Lobby, MaxDurability) == 0x0000A0, "Member 'UTgfInventoryItemWrapper_Lobby::MaxDurability' has a wrong offset!");

// Class TGFGame.TGFRoomTransferOwnerEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomTransferOwnerEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomTransferOwnerEvent">();
	}
	static class UTGFRoomTransferOwnerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomTransferOwnerEvent>();
	}
};
static_assert(alignof(UTGFRoomTransferOwnerEvent) == 0x000008, "Wrong alignment on UTGFRoomTransferOwnerEvent");
static_assert(sizeof(UTGFRoomTransferOwnerEvent) == 0x000028, "Wrong size on UTGFRoomTransferOwnerEvent");

// Class TGFGame.TGFRoomKickOffMemberEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomKickOffMemberEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomKickOffMemberEvent">();
	}
	static class UTGFRoomKickOffMemberEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomKickOffMemberEvent>();
	}
};
static_assert(alignof(UTGFRoomKickOffMemberEvent) == 0x000008, "Wrong alignment on UTGFRoomKickOffMemberEvent");
static_assert(sizeof(UTGFRoomKickOffMemberEvent) == 0x000028, "Wrong size on UTGFRoomKickOffMemberEvent");

// Class TGFGame.TGFItemBarData
// 0x0010 (0x0038 - 0x0028)
class UTGFItemBarData final : public UObject
{
public:
	int32                                         TypeId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEmphasize;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFItemBarData">();
	}
	static class UTGFItemBarData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFItemBarData>();
	}
};
static_assert(alignof(UTGFItemBarData) == 0x000008, "Wrong alignment on UTGFItemBarData");
static_assert(sizeof(UTGFItemBarData) == 0x000038, "Wrong size on UTGFItemBarData");
static_assert(offsetof(UTGFItemBarData, TypeId) == 0x000028, "Member 'UTGFItemBarData::TypeId' has a wrong offset!");
static_assert(offsetof(UTGFItemBarData, Count) == 0x00002C, "Member 'UTGFItemBarData::Count' has a wrong offset!");
static_assert(offsetof(UTGFItemBarData, IsEmphasize) == 0x000030, "Member 'UTGFItemBarData::IsEmphasize' has a wrong offset!");

// Class TGFGame.TGFRoomInviteSendEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomInviteSendEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomInviteSendEvent">();
	}
	static class UTGFRoomInviteSendEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomInviteSendEvent>();
	}
};
static_assert(alignof(UTGFRoomInviteSendEvent) == 0x000008, "Wrong alignment on UTGFRoomInviteSendEvent");
static_assert(sizeof(UTGFRoomInviteSendEvent) == 0x000028, "Wrong size on UTGFRoomInviteSendEvent");

// Class TGFGame.TGFRoomInviteAcceptEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomInviteAcceptEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomInviteAcceptEvent">();
	}
	static class UTGFRoomInviteAcceptEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomInviteAcceptEvent>();
	}
};
static_assert(alignof(UTGFRoomInviteAcceptEvent) == 0x000008, "Wrong alignment on UTGFRoomInviteAcceptEvent");
static_assert(sizeof(UTGFRoomInviteAcceptEvent) == 0x000028, "Wrong size on UTGFRoomInviteAcceptEvent");

// Class TGFGame.TgfInventoryWrapper_Mithril
// 0x0000 (0x01F8 - 0x01F8)
class UTgfInventoryWrapper_Mithril final : public UTgfInventoryWrapper_Lobby
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryWrapper_Mithril">();
	}
	static class UTgfInventoryWrapper_Mithril* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryWrapper_Mithril>();
	}
};
static_assert(alignof(UTgfInventoryWrapper_Mithril) == 0x000008, "Wrong alignment on UTgfInventoryWrapper_Mithril");
static_assert(sizeof(UTgfInventoryWrapper_Mithril) == 0x0001F8, "Wrong size on UTgfInventoryWrapper_Mithril");

// Class TGFGame.TGFRoomInviteRejectEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomInviteRejectEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomInviteRejectEvent">();
	}
	static class UTGFRoomInviteRejectEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomInviteRejectEvent>();
	}
};
static_assert(alignof(UTGFRoomInviteRejectEvent) == 0x000008, "Wrong alignment on UTGFRoomInviteRejectEvent");
static_assert(sizeof(UTGFRoomInviteRejectEvent) == 0x000028, "Wrong size on UTGFRoomInviteRejectEvent");

// Class TGFGame.TGFRoomIgnoreRoomAllInviteEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomIgnoreRoomAllInviteEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomIgnoreRoomAllInviteEvent">();
	}
	static class UTGFRoomIgnoreRoomAllInviteEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomIgnoreRoomAllInviteEvent>();
	}
};
static_assert(alignof(UTGFRoomIgnoreRoomAllInviteEvent) == 0x000008, "Wrong alignment on UTGFRoomIgnoreRoomAllInviteEvent");
static_assert(sizeof(UTGFRoomIgnoreRoomAllInviteEvent) == 0x000028, "Wrong size on UTGFRoomIgnoreRoomAllInviteEvent");

// Class TGFGame.TgfInventoryItemWrapper_Trade
// 0x0060 (0x00A8 - 0x0048)
class UTgfInventoryItemWrapper_Trade final : public UTgfInventoryItemWrapper
{
public:
	uint8                                         Pad_48[0x60];                                      // 0x0048(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTGFItem GetItemData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_Trade">();
	}
	static class UTgfInventoryItemWrapper_Trade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_Trade>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_Trade) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_Trade");
static_assert(sizeof(UTgfInventoryItemWrapper_Trade) == 0x0000A8, "Wrong size on UTgfInventoryItemWrapper_Trade");

// Class TGFGame.TGFRoomIgnoreAllUserInviteEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomIgnoreAllUserInviteEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomIgnoreAllUserInviteEvent">();
	}
	static class UTGFRoomIgnoreAllUserInviteEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomIgnoreAllUserInviteEvent>();
	}
};
static_assert(alignof(UTGFRoomIgnoreAllUserInviteEvent) == 0x000008, "Wrong alignment on UTGFRoomIgnoreAllUserInviteEvent");
static_assert(sizeof(UTGFRoomIgnoreAllUserInviteEvent) == 0x000028, "Wrong size on UTGFRoomIgnoreAllUserInviteEvent");

// Class TGFGame.TGFRoomBatchGetEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomBatchGetEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomBatchGetEvent">();
	}
	static class UTGFRoomBatchGetEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomBatchGetEvent>();
	}
};
static_assert(alignof(UTGFRoomBatchGetEvent) == 0x000008, "Wrong alignment on UTGFRoomBatchGetEvent");
static_assert(sizeof(UTGFRoomBatchGetEvent) == 0x000028, "Wrong size on UTGFRoomBatchGetEvent");

// Class TGFGame.TGFRoomSyncRoomActionEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomSyncRoomActionEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSyncRoomActionEvent">();
	}
	static class UTGFRoomSyncRoomActionEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSyncRoomActionEvent>();
	}
};
static_assert(alignof(UTGFRoomSyncRoomActionEvent) == 0x000008, "Wrong alignment on UTGFRoomSyncRoomActionEvent");
static_assert(sizeof(UTGFRoomSyncRoomActionEvent) == 0x000028, "Wrong size on UTGFRoomSyncRoomActionEvent");

// Class TGFGame.TGFRoomSyncRoomEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFRoomSyncRoomEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomSyncRoomEvent">();
	}
	static class UTGFRoomSyncRoomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomSyncRoomEvent>();
	}
};
static_assert(alignof(UTGFRoomSyncRoomEvent) == 0x000008, "Wrong alignment on UTGFRoomSyncRoomEvent");
static_assert(sizeof(UTGFRoomSyncRoomEvent) == 0x000028, "Wrong size on UTGFRoomSyncRoomEvent");

// Class TGFGame.TGFRoomForceRefreshEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFRoomForceRefreshEvent final : public UTGFEventArgs
{
public:
	class UPVPRoomListItemObject*                 RoomInfo;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRoomForceRefreshEvent">();
	}
	static class UTGFRoomForceRefreshEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRoomForceRefreshEvent>();
	}
};
static_assert(alignof(UTGFRoomForceRefreshEvent) == 0x000008, "Wrong alignment on UTGFRoomForceRefreshEvent");
static_assert(sizeof(UTGFRoomForceRefreshEvent) == 0x000030, "Wrong size on UTGFRoomForceRefreshEvent");
static_assert(offsetof(UTGFRoomForceRefreshEvent, RoomInfo) == 0x000028, "Member 'UTGFRoomForceRefreshEvent::RoomInfo' has a wrong offset!");

// Class TGFGame.PVPRoomKey
// 0x0010 (0x0038 - 0x0028)
class UPVPRoomKey final : public UObject
{
public:
	int64                                         RoomId;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RoomSvrId;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPRoomKey">();
	}
	static class UPVPRoomKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPRoomKey>();
	}
};
static_assert(alignof(UPVPRoomKey) == 0x000008, "Wrong alignment on UPVPRoomKey");
static_assert(sizeof(UPVPRoomKey) == 0x000038, "Wrong size on UPVPRoomKey");
static_assert(offsetof(UPVPRoomKey, RoomId) == 0x000028, "Member 'UPVPRoomKey::RoomId' has a wrong offset!");
static_assert(offsetof(UPVPRoomKey, RoomSvrId) == 0x000030, "Member 'UPVPRoomKey::RoomSvrId' has a wrong offset!");

// Class TGFGame.PVPRoomListItemObject
// 0x0090 (0x00B8 - 0x0028)
class UPVPRoomListItemObject final : public UObject
{
public:
	class UPVPRoomKey*                            RoomKey;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserKey                               RoomCreatorUserKey;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RoomName;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FText                                   RoomPassword;                                      // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<class UPVPRoomMember*>                 TeamMembers;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UPVPRoomMember*>                 WatchMembers;                                      // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         BattleMap;                                         // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleType;                                        // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnRoomStatus                      Status;                                            // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               RoomOwnerUserKey;                                  // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreateTime;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumTotalMember() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPRoomListItemObject">();
	}
	static class UPVPRoomListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPRoomListItemObject>();
	}
};
static_assert(alignof(UPVPRoomListItemObject) == 0x000008, "Wrong alignment on UPVPRoomListItemObject");
static_assert(sizeof(UPVPRoomListItemObject) == 0x0000B8, "Wrong size on UPVPRoomListItemObject");
static_assert(offsetof(UPVPRoomListItemObject, RoomKey) == 0x000028, "Member 'UPVPRoomListItemObject::RoomKey' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, RoomCreatorUserKey) == 0x000030, "Member 'UPVPRoomListItemObject::RoomCreatorUserKey' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, RoomName) == 0x000040, "Member 'UPVPRoomListItemObject::RoomName' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, RoomPassword) == 0x000058, "Member 'UPVPRoomListItemObject::RoomPassword' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, TeamMembers) == 0x000070, "Member 'UPVPRoomListItemObject::TeamMembers' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, WatchMembers) == 0x000080, "Member 'UPVPRoomListItemObject::WatchMembers' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, BattleMap) == 0x000090, "Member 'UPVPRoomListItemObject::BattleMap' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, BattleType) == 0x000094, "Member 'UPVPRoomListItemObject::BattleType' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, Status) == 0x000098, "Member 'UPVPRoomListItemObject::Status' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, RoomOwnerUserKey) == 0x0000A0, "Member 'UPVPRoomListItemObject::RoomOwnerUserKey' has a wrong offset!");
static_assert(offsetof(UPVPRoomListItemObject, CreateTime) == 0x0000B0, "Member 'UPVPRoomListItemObject::CreateTime' has a wrong offset!");

// Class TGFGame.PVPMapListItemObject
// 0x0030 (0x0058 - 0x0028)
class UPVPMapListItemObject final : public UObject
{
public:
	int32                                         MapId;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MapName;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             MapRes;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPMapListItemObject">();
	}
	static class UPVPMapListItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPMapListItemObject>();
	}
};
static_assert(alignof(UPVPMapListItemObject) == 0x000008, "Wrong alignment on UPVPMapListItemObject");
static_assert(sizeof(UPVPMapListItemObject) == 0x000058, "Wrong size on UPVPMapListItemObject");
static_assert(offsetof(UPVPMapListItemObject, MapId) == 0x000028, "Member 'UPVPMapListItemObject::MapId' has a wrong offset!");
static_assert(offsetof(UPVPMapListItemObject, MapName) == 0x000030, "Member 'UPVPMapListItemObject::MapName' has a wrong offset!");
static_assert(offsetof(UPVPMapListItemObject, MapRes) == 0x000048, "Member 'UPVPMapListItemObject::MapRes' has a wrong offset!");
static_assert(offsetof(UPVPMapListItemObject, IsLocked) == 0x000050, "Member 'UPVPMapListItemObject::IsLocked' has a wrong offset!");

// Class TGFGame.PVPRoomInvitation
// 0x0030 (0x0058 - 0x0028)
class UPVPRoomInvitation final : public UObject
{
public:
	struct FUserKey                               SendUser;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPVPRoomKey*                            RoomKey;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RoomName;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPRoomInvitation">();
	}
	static class UPVPRoomInvitation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPVPRoomInvitation>();
	}
};
static_assert(alignof(UPVPRoomInvitation) == 0x000008, "Wrong alignment on UPVPRoomInvitation");
static_assert(sizeof(UPVPRoomInvitation) == 0x000058, "Wrong size on UPVPRoomInvitation");
static_assert(offsetof(UPVPRoomInvitation, SendUser) == 0x000028, "Member 'UPVPRoomInvitation::SendUser' has a wrong offset!");
static_assert(offsetof(UPVPRoomInvitation, RoomKey) == 0x000038, "Member 'UPVPRoomInvitation::RoomKey' has a wrong offset!");
static_assert(offsetof(UPVPRoomInvitation, RoomName) == 0x000040, "Member 'UPVPRoomInvitation::RoomName' has a wrong offset!");

// Class TGFGame.TGFRainbowConfigEvent
// 0x0020 (0x0048 - 0x0028)
class UTGFRainbowConfigEvent final : public UTGFEventArgs
{
public:
	class FString                                 StrKey;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrValue;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRainbowConfigEvent">();
	}
	static class UTGFRainbowConfigEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRainbowConfigEvent>();
	}
};
static_assert(alignof(UTGFRainbowConfigEvent) == 0x000008, "Wrong alignment on UTGFRainbowConfigEvent");
static_assert(sizeof(UTGFRainbowConfigEvent) == 0x000048, "Wrong size on UTGFRainbowConfigEvent");
static_assert(offsetof(UTGFRainbowConfigEvent, StrKey) == 0x000028, "Member 'UTGFRainbowConfigEvent::StrKey' has a wrong offset!");
static_assert(offsetof(UTGFRainbowConfigEvent, StrValue) == 0x000038, "Member 'UTGFRainbowConfigEvent::StrValue' has a wrong offset!");

// Class TGFGame.TGFRankGetSpecifyResponseEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFRankGetSpecifyResponseEvent final : public UTGFEventArgs
{
public:
	int32                                         RankType;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankInstanceId;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFRankGetSpecifyResponseEvent">();
	}
	static class UTGFRankGetSpecifyResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFRankGetSpecifyResponseEvent>();
	}
};
static_assert(alignof(UTGFRankGetSpecifyResponseEvent) == 0x000008, "Wrong alignment on UTGFRankGetSpecifyResponseEvent");
static_assert(sizeof(UTGFRankGetSpecifyResponseEvent) == 0x000030, "Wrong size on UTGFRankGetSpecifyResponseEvent");
static_assert(offsetof(UTGFRankGetSpecifyResponseEvent, RankType) == 0x000028, "Member 'UTGFRankGetSpecifyResponseEvent::RankType' has a wrong offset!");
static_assert(offsetof(UTGFRankGetSpecifyResponseEvent, RankInstanceId) == 0x00002C, "Member 'UTGFRankGetSpecifyResponseEvent::RankInstanceId' has a wrong offset!");

// Class TGFGame.RankService
// 0x00D0 (0x0100 - 0x0030)
class URankService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URankUserData*>                  RankDatas;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URankUserData*>                  MyRankDatas;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0xA8];                                      // 0x0058(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DelRankData(class URankUserData* TargetData);
	TArray<class URankUserData*> GetMyRankDataByRankTypeInstanceId(int32 RankType, int32 RankInstanceId, int64 RoleGuid);
	TArray<class URankUserData*> GetMyRankDatas();
	int32 GetMyRankScore(int32 RankType, int32 RankInstanceId);
	TArray<class URankUserData*> GetRankDataByRankTypeInstanceId(int32 RankType, int32 RankInstanceId);
	TArray<class URankUserData*> GetRankDatas();
	void SendRankGetSelfRankRequest(int32 RankType, int32 RankInstance, int32 SubRankType, int32 SubRankInstance, int64 RoleGuid, int32 UpCount, int32 DownCount);
	void SendRankGetSpecifyRequest(int32 RankType, int32 RankInstance, int32 SubRankType, int32 SubRankInstance, int32 StartNo, int32 Count);
	void UpdateOrAddRankData(TArray<class URankUserData*>* SourceData, class URankUserData* TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankService">();
	}
	static class URankService* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankService>();
	}
};
static_assert(alignof(URankService) == 0x000008, "Wrong alignment on URankService");
static_assert(sizeof(URankService) == 0x000100, "Wrong size on URankService");
static_assert(offsetof(URankService, RankDatas) == 0x000038, "Member 'URankService::RankDatas' has a wrong offset!");
static_assert(offsetof(URankService, MyRankDatas) == 0x000048, "Member 'URankService::MyRankDatas' has a wrong offset!");

// Class TGFGame.ReportService
// 0x0028 (0x0058 - 0x0030)
class UReportService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGameReport(const struct FTGFReportRecord& Record);
	void OnSendReport(const struct FTGFReportRecord& Record);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportService">();
	}
	static class UReportService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportService>();
	}
};
static_assert(alignof(UReportService) == 0x000008, "Wrong alignment on UReportService");
static_assert(sizeof(UReportService) == 0x000058, "Wrong size on UReportService");

// Class TGFGame.ResultWindow
// 0x0008 (0x02C0 - 0x02B8)
class UResultWindow final : public UTGFWindow
{
public:
	class UCreateWindowArgs*                      WindowArgs;                                        // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultWindow">();
	}
	static class UResultWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResultWindow>();
	}
};
static_assert(alignof(UResultWindow) == 0x000008, "Wrong alignment on UResultWindow");
static_assert(sizeof(UResultWindow) == 0x0002C0, "Wrong size on UResultWindow");
static_assert(offsetof(UResultWindow, WindowArgs) == 0x0002B8, "Member 'UResultWindow::WindowArgs' has a wrong offset!");

// Class TGFGame.RoleAttributeInteractiveInfo
// 0x00C0 (0x00E8 - 0x0028)
class URoleAttributeInteractiveInfo final : public UObject
{
public:
	float                                         ScenarioInteractionSpeed;                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponChangeSpeed;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowableItemConsumeSpeed;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverableItemConsumeSpeed;                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorePackageSpeed;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortalInteractSpeedRate;                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractSpeedAdditional;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoulEnergyOverTime;                                // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoulEnergyOnHit;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoulEnergyOnKill;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoulEnergyOnHurt;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoulEnergyGenerateRate;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNaturalEnergy;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaturalEnergyOverTime;                             // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaturalEnergyOnHit;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaturalEnergyOnKill;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaturalEnergyOnHurt;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaturalEnergyGenerateRate;                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillCooldownScaleRate;                            // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GainGoldOutOfPortal;                               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpBoostRateOutOfPortal;                           // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillingMaxLayerMaxHealthPercent;                   // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillingMaxLayerAttackBoostRate;                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillingMaxLayerCriticalRate;                       // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedWithHitRunning;                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealOverTimeWithHitRunning;                        // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalRateWithHitRunning;                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeLeachRateWithHitRunning;                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackBoostRateWithFullHealth;                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalRateWithFullHealth;                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealOnOpenChest;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicOnOpenChest;                                  // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GainGoldOnOpenChest;                               // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GainGoldOnKill;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealOnDefendSuccess;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOnDefendSuccess;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalFixedDamageOnCausingHit;                 // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddShieldOnCastSkill;                              // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementNoneDamageOnCausingHit;           // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementFireDamageOnCausingHit;           // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementIceDamageOnCausingHit;            // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementThunderDamageOnCausingHit;        // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementLightDamageOnCausingHit;          // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementDarkDamageOnCausingHit;           // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementMaxHealthExtra;                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementExtraDefGearLevel;                // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalElementExtraAttGearLevel;                // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleAttributeInteractiveInfo">();
	}
	static class URoleAttributeInteractiveInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleAttributeInteractiveInfo>();
	}
};
static_assert(alignof(URoleAttributeInteractiveInfo) == 0x000008, "Wrong alignment on URoleAttributeInteractiveInfo");
static_assert(sizeof(URoleAttributeInteractiveInfo) == 0x0000E8, "Wrong size on URoleAttributeInteractiveInfo");
static_assert(offsetof(URoleAttributeInteractiveInfo, ScenarioInteractionSpeed) == 0x000028, "Member 'URoleAttributeInteractiveInfo::ScenarioInteractionSpeed' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, WeaponChangeSpeed) == 0x00002C, "Member 'URoleAttributeInteractiveInfo::WeaponChangeSpeed' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, ThrowableItemConsumeSpeed) == 0x000030, "Member 'URoleAttributeInteractiveInfo::ThrowableItemConsumeSpeed' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, RecoverableItemConsumeSpeed) == 0x000034, "Member 'URoleAttributeInteractiveInfo::RecoverableItemConsumeSpeed' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, ExplorePackageSpeed) == 0x000038, "Member 'URoleAttributeInteractiveInfo::ExplorePackageSpeed' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, PortalInteractSpeedRate) == 0x00003C, "Member 'URoleAttributeInteractiveInfo::PortalInteractSpeedRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, InteractSpeedAdditional) == 0x000040, "Member 'URoleAttributeInteractiveInfo::InteractSpeedAdditional' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, SoulEnergyOverTime) == 0x000044, "Member 'URoleAttributeInteractiveInfo::SoulEnergyOverTime' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, SoulEnergyOnHit) == 0x000048, "Member 'URoleAttributeInteractiveInfo::SoulEnergyOnHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, SoulEnergyOnKill) == 0x00004C, "Member 'URoleAttributeInteractiveInfo::SoulEnergyOnKill' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, SoulEnergyOnHurt) == 0x000050, "Member 'URoleAttributeInteractiveInfo::SoulEnergyOnHurt' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, SoulEnergyGenerateRate) == 0x000054, "Member 'URoleAttributeInteractiveInfo::SoulEnergyGenerateRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, MaxNaturalEnergy) == 0x000058, "Member 'URoleAttributeInteractiveInfo::MaxNaturalEnergy' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, NaturalEnergyOverTime) == 0x00005C, "Member 'URoleAttributeInteractiveInfo::NaturalEnergyOverTime' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, NaturalEnergyOnHit) == 0x000060, "Member 'URoleAttributeInteractiveInfo::NaturalEnergyOnHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, NaturalEnergyOnKill) == 0x000064, "Member 'URoleAttributeInteractiveInfo::NaturalEnergyOnKill' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, NaturalEnergyOnHurt) == 0x000068, "Member 'URoleAttributeInteractiveInfo::NaturalEnergyOnHurt' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, NaturalEnergyGenerateRate) == 0x00006C, "Member 'URoleAttributeInteractiveInfo::NaturalEnergyGenerateRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, SkillCooldownScaleRate) == 0x000070, "Member 'URoleAttributeInteractiveInfo::SkillCooldownScaleRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, GainGoldOutOfPortal) == 0x000074, "Member 'URoleAttributeInteractiveInfo::GainGoldOutOfPortal' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, ExpBoostRateOutOfPortal) == 0x000078, "Member 'URoleAttributeInteractiveInfo::ExpBoostRateOutOfPortal' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, KillingMaxLayerMaxHealthPercent) == 0x00007C, "Member 'URoleAttributeInteractiveInfo::KillingMaxLayerMaxHealthPercent' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, KillingMaxLayerAttackBoostRate) == 0x000080, "Member 'URoleAttributeInteractiveInfo::KillingMaxLayerAttackBoostRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, KillingMaxLayerCriticalRate) == 0x000084, "Member 'URoleAttributeInteractiveInfo::KillingMaxLayerCriticalRate' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, MoveSpeedWithHitRunning) == 0x000088, "Member 'URoleAttributeInteractiveInfo::MoveSpeedWithHitRunning' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, HealOverTimeWithHitRunning) == 0x00008C, "Member 'URoleAttributeInteractiveInfo::HealOverTimeWithHitRunning' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, CriticalRateWithHitRunning) == 0x000090, "Member 'URoleAttributeInteractiveInfo::CriticalRateWithHitRunning' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, LifeLeachRateWithHitRunning) == 0x000094, "Member 'URoleAttributeInteractiveInfo::LifeLeachRateWithHitRunning' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AttackBoostRateWithFullHealth) == 0x000098, "Member 'URoleAttributeInteractiveInfo::AttackBoostRateWithFullHealth' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, CriticalRateWithFullHealth) == 0x00009C, "Member 'URoleAttributeInteractiveInfo::CriticalRateWithFullHealth' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, HealOnOpenChest) == 0x0000A0, "Member 'URoleAttributeInteractiveInfo::HealOnOpenChest' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, MagicOnOpenChest) == 0x0000A4, "Member 'URoleAttributeInteractiveInfo::MagicOnOpenChest' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, GainGoldOnOpenChest) == 0x0000A8, "Member 'URoleAttributeInteractiveInfo::GainGoldOnOpenChest' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, GainGoldOnKill) == 0x0000AC, "Member 'URoleAttributeInteractiveInfo::GainGoldOnKill' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, HealOnDefendSuccess) == 0x0000B0, "Member 'URoleAttributeInteractiveInfo::HealOnDefendSuccess' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, DamageOnDefendSuccess) == 0x0000B4, "Member 'URoleAttributeInteractiveInfo::DamageOnDefendSuccess' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalFixedDamageOnCausingHit) == 0x0000B8, "Member 'URoleAttributeInteractiveInfo::AdditionalFixedDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AddShieldOnCastSkill) == 0x0000BC, "Member 'URoleAttributeInteractiveInfo::AddShieldOnCastSkill' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementNoneDamageOnCausingHit) == 0x0000C0, "Member 'URoleAttributeInteractiveInfo::AdditionalElementNoneDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementFireDamageOnCausingHit) == 0x0000C4, "Member 'URoleAttributeInteractiveInfo::AdditionalElementFireDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementIceDamageOnCausingHit) == 0x0000C8, "Member 'URoleAttributeInteractiveInfo::AdditionalElementIceDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementThunderDamageOnCausingHit) == 0x0000CC, "Member 'URoleAttributeInteractiveInfo::AdditionalElementThunderDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementLightDamageOnCausingHit) == 0x0000D0, "Member 'URoleAttributeInteractiveInfo::AdditionalElementLightDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementDarkDamageOnCausingHit) == 0x0000D4, "Member 'URoleAttributeInteractiveInfo::AdditionalElementDarkDamageOnCausingHit' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementMaxHealthExtra) == 0x0000D8, "Member 'URoleAttributeInteractiveInfo::AdditionalElementMaxHealthExtra' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementExtraDefGearLevel) == 0x0000DC, "Member 'URoleAttributeInteractiveInfo::AdditionalElementExtraDefGearLevel' has a wrong offset!");
static_assert(offsetof(URoleAttributeInteractiveInfo, AdditionalElementExtraAttGearLevel) == 0x0000E0, "Member 'URoleAttributeInteractiveInfo::AdditionalElementExtraAttGearLevel' has a wrong offset!");

// Class TGFGame.RoleFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URoleFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UExcelLoaderTgfConfigExcelRoleType* GetExcelRoleTypeById(int32 RoleTypeId);
	static TArray<class UExcelLoaderTgfConfigExcelRoleType*> GetExcelRoleTypeList(ETGFProtoTgfEnForceType InForceType);
	static class FString GetRoleHeadPortraitSourceRelativePath(int32 RowId);
	static int32 GetRoleTypeIdByTypeName(const class FString& RoleTypeName);
	static TArray<int32> GetRoleUeSkinIds(const TArray<int32>& SkinIds);
	static TArray<class UExcelLoaderTgfConfigExcelRoleType*> SortCareerConfigList(TArray<class UExcelLoaderTgfConfigExcelRoleType*>& CareerConfigList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleFunctionLibrary">();
	}
	static class URoleFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleFunctionLibrary>();
	}
};
static_assert(alignof(URoleFunctionLibrary) == 0x000008, "Wrong alignment on URoleFunctionLibrary");
static_assert(sizeof(URoleFunctionLibrary) == 0x000028, "Wrong size on URoleFunctionLibrary");

// Class TGFGame.RoomService
// 0x01A0 (0x01D0 - 0x0030)
class URoomService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x1A0];                                     // 0x0030(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameLogout(class UTGFEventArgs* Args);
	void OnNetworkManagerEnterState(class UTGFEventArgs* Args);
	void OnNetworkManagerExitState(class UTGFEventArgs* Args);
	void SetShouldPromptBattleVersionNotCompatible(bool ShouldPrompt);

	bool GetShouldPromptBattleVersionNotCompatible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomService">();
	}
	static class URoomService* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomService>();
	}
};
static_assert(alignof(URoomService) == 0x000008, "Wrong alignment on URoomService");
static_assert(sizeof(URoomService) == 0x0001D0, "Wrong size on URoomService");

// Class TGFGame.SDKAccountService
// 0x01C8 (0x01F8 - 0x0030)
class USDKAccountService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x1C8];                                     // 0x0030(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool UseLIPass();

	void LIOnBackPressed();
	void LIOpenAccountCenter();
	void LIResetUIRoot();
	void LISetUIRoot(class UCanvasPanel* UiRoot);

	int32 GetAdultAge() const;
	int32 GetAdultCheckStatus() const;
	int32 GetChannelId() const;
	class FString GetOpenId() const;
	class FString GetRegion() const;
	class FString GetSteamId() const;
	class FString GetSteamUserName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKAccountService">();
	}
	static class USDKAccountService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKAccountService>();
	}
};
static_assert(alignof(USDKAccountService) == 0x000008, "Wrong alignment on USDKAccountService");
static_assert(sizeof(USDKAccountService) == 0x0001F8, "Wrong size on USDKAccountService");

// Class TGFGame.SDKGmeEnterRoomEvent
// 0x0010 (0x0038 - 0x0028)
class USDKGmeEnterRoomEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGmeEnterRoomEvent">();
	}
	static class USDKGmeEnterRoomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGmeEnterRoomEvent>();
	}
};
static_assert(alignof(USDKGmeEnterRoomEvent) == 0x000008, "Wrong alignment on USDKGmeEnterRoomEvent");
static_assert(sizeof(USDKGmeEnterRoomEvent) == 0x000038, "Wrong size on USDKGmeEnterRoomEvent");

// Class TGFGame.SDKGmeConnectTimeoutEvent
// 0x0008 (0x0030 - 0x0028)
class USDKGmeConnectTimeoutEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGmeConnectTimeoutEvent">();
	}
	static class USDKGmeConnectTimeoutEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGmeConnectTimeoutEvent>();
	}
};
static_assert(alignof(USDKGmeConnectTimeoutEvent) == 0x000008, "Wrong alignment on USDKGmeConnectTimeoutEvent");
static_assert(sizeof(USDKGmeConnectTimeoutEvent) == 0x000030, "Wrong size on USDKGmeConnectTimeoutEvent");

// Class TGFGame.SDKGvoiceJoinRoomEvent
// 0x0000 (0x0028 - 0x0028)
class USDKGvoiceJoinRoomEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGvoiceJoinRoomEvent">();
	}
	static class USDKGvoiceJoinRoomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGvoiceJoinRoomEvent>();
	}
};
static_assert(alignof(USDKGvoiceJoinRoomEvent) == 0x000008, "Wrong alignment on USDKGvoiceJoinRoomEvent");
static_assert(sizeof(USDKGvoiceJoinRoomEvent) == 0x000028, "Wrong size on USDKGvoiceJoinRoomEvent");

// Class TGFGame.SDKGvoiceMemberInfoUpateEvent
// 0x0010 (0x0038 - 0x0028)
class USDKGvoiceMemberInfoUpateEvent final : public UTGFEventArgs
{
public:
	class FString                                 OpenID;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKGvoiceMemberInfoUpateEvent">();
	}
	static class USDKGvoiceMemberInfoUpateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKGvoiceMemberInfoUpateEvent>();
	}
};
static_assert(alignof(USDKGvoiceMemberInfoUpateEvent) == 0x000008, "Wrong alignment on USDKGvoiceMemberInfoUpateEvent");
static_assert(sizeof(USDKGvoiceMemberInfoUpateEvent) == 0x000038, "Wrong size on USDKGvoiceMemberInfoUpateEvent");
static_assert(offsetof(USDKGvoiceMemberInfoUpateEvent, OpenID) == 0x000028, "Member 'USDKGvoiceMemberInfoUpateEvent::OpenID' has a wrong offset!");

// Class TGFGame.SDKLBSService
// 0x0028 (0x0058 - 0x0030)
class USDKLBSService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKLBSService">();
	}
	static class USDKLBSService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKLBSService>();
	}
};
static_assert(alignof(USDKLBSService) == 0x000008, "Wrong alignment on USDKLBSService");
static_assert(sizeof(USDKLBSService) == 0x000058, "Wrong size on USDKLBSService");

// Class TGFGame.SDKMapleQueryFailedEvent
// 0x0008 (0x0030 - 0x0028)
class USDKMapleQueryFailedEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKMapleQueryFailedEvent">();
	}
	static class USDKMapleQueryFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKMapleQueryFailedEvent>();
	}
};
static_assert(alignof(USDKMapleQueryFailedEvent) == 0x000008, "Wrong alignment on USDKMapleQueryFailedEvent");
static_assert(sizeof(USDKMapleQueryFailedEvent) == 0x000030, "Wrong size on USDKMapleQueryFailedEvent");

// Class TGFGame.SDKNoticeResultEvent
// 0x0000 (0x0028 - 0x0028)
class USDKNoticeResultEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKNoticeResultEvent">();
	}
	static class USDKNoticeResultEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKNoticeResultEvent>();
	}
};
static_assert(alignof(USDKNoticeResultEvent) == 0x000008, "Wrong alignment on USDKNoticeResultEvent");
static_assert(sizeof(USDKNoticeResultEvent) == 0x000028, "Wrong size on USDKNoticeResultEvent");

// Class TGFGame.NoticeReadSaveGame
// 0x0050 (0x0078 - 0x0028)
class UNoticeReadSaveGame final : public USaveGame
{
public:
	TSet<class FString>                           NoticeReadIds;                                     // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoticeReadSaveGame">();
	}
	static class UNoticeReadSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoticeReadSaveGame>();
	}
};
static_assert(alignof(UNoticeReadSaveGame) == 0x000008, "Wrong alignment on UNoticeReadSaveGame");
static_assert(sizeof(UNoticeReadSaveGame) == 0x000078, "Wrong size on UNoticeReadSaveGame");
static_assert(offsetof(UNoticeReadSaveGame, NoticeReadIds) == 0x000028, "Member 'UNoticeReadSaveGame::NoticeReadIds' has a wrong offset!");

// Class TGFGame.SDKService
// 0x0078 (0x00A8 - 0x0030)
class USDKService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetConfig(const class FString& Key) const;
	class FString GetINTLGameId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKService">();
	}
	static class USDKService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKService>();
	}
};
static_assert(alignof(USDKService) == 0x000008, "Wrong alignment on USDKService");
static_assert(sizeof(USDKService) == 0x0000A8, "Wrong size on USDKService");

// Class TGFGame.SDKWebviewService
// 0x0050 (0x0080 - 0x0030)
class USDKWebviewService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lua_OnWebViewResult(int32 MsgType, const class FString& MsgJsonData);
	void OpenUrl(const class FString& URL, int32 ScreenOrientationValue, bool FullScreenValue, bool UseURLEncodeValue, bool IsBrowserValue, const class FString& ExtraJsonValue, bool UseEncryptUrl);
	void OpenUrlByExternalUI(const class FString& URL, bool Modal, bool UseURLEncodeValue, bool UseEncryptUrl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDKWebviewService">();
	}
	static class USDKWebviewService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDKWebviewService>();
	}
};
static_assert(alignof(USDKWebviewService) == 0x000008, "Wrong alignment on USDKWebviewService");
static_assert(sizeof(USDKWebviewService) == 0x000080, "Wrong size on USDKWebviewService");

// Class TGFGame.SelectMapService
// 0x0000 (0x0030 - 0x0030)
class USelectMapService final : public UTGFSubsystem
{
public:
	class FString GetMapNameIdByMapIdAndDiffSelect(int32 MapId, int32 DifficultySelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectMapService">();
	}
	static class USelectMapService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectMapService>();
	}
};
static_assert(alignof(USelectMapService) == 0x000008, "Wrong alignment on USelectMapService");
static_assert(sizeof(USelectMapService) == 0x000030, "Wrong size on USelectMapService");

// Class TGFGame.Category
// 0x0028 (0x0050 - 0x0028)
class UCategory final : public UObject
{
public:
	int32                                         CategoryId;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CategoryName;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UServerItem*>                    Servers;                                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Category">();
	}
	static class UCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCategory>();
	}
};
static_assert(alignof(UCategory) == 0x000008, "Wrong alignment on UCategory");
static_assert(sizeof(UCategory) == 0x000050, "Wrong size on UCategory");
static_assert(offsetof(UCategory, CategoryId) == 0x000028, "Member 'UCategory::CategoryId' has a wrong offset!");
static_assert(offsetof(UCategory, CategoryName) == 0x000030, "Member 'UCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(UCategory, Servers) == 0x000040, "Member 'UCategory::Servers' has a wrong offset!");

// Class TGFGame.SelectServerService
// 0x00A8 (0x00D8 - 0x0030)
class USelectServerService final : public UTGFService
{
public:
	TArray<class UCategory*>                      Categories;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, class UServerItem*>               Servers;                                           // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	class UServerItem*                            CurrentServerItem;                                 // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x40];                                      // 0x0098(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentServerItem(class UServerItem* ServerItem);

	const TArray<class UCategory*> GetCategories() const;
	class UServerItem* GetCurrentServerItem() const;
	class UServerItem* GetDefaultServerItem() const;
	int32 GetServerCount() const;
	class UServerItem* GetServerItem(int32 ServerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectServerService">();
	}
	static class USelectServerService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectServerService>();
	}
};
static_assert(alignof(USelectServerService) == 0x000008, "Wrong alignment on USelectServerService");
static_assert(sizeof(USelectServerService) == 0x0000D8, "Wrong size on USelectServerService");
static_assert(offsetof(USelectServerService, Categories) == 0x000030, "Member 'USelectServerService::Categories' has a wrong offset!");
static_assert(offsetof(USelectServerService, Servers) == 0x000040, "Member 'USelectServerService::Servers' has a wrong offset!");
static_assert(offsetof(USelectServerService, CurrentServerItem) == 0x000090, "Member 'USelectServerService::CurrentServerItem' has a wrong offset!");

// Class TGFGame.TGFSettingKeyBindingDeactivateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSettingKeyBindingDeactivateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingKeyBindingDeactivateEvent">();
	}
	static class UTGFSettingKeyBindingDeactivateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingKeyBindingDeactivateEvent>();
	}
};
static_assert(alignof(UTGFSettingKeyBindingDeactivateEvent) == 0x000008, "Wrong alignment on UTGFSettingKeyBindingDeactivateEvent");
static_assert(sizeof(UTGFSettingKeyBindingDeactivateEvent) == 0x000028, "Wrong size on UTGFSettingKeyBindingDeactivateEvent");

// Class TGFGame.TGFSettingLanguageChangedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSettingLanguageChangedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingLanguageChangedEvent">();
	}
	static class UTGFSettingLanguageChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingLanguageChangedEvent>();
	}
};
static_assert(alignof(UTGFSettingLanguageChangedEvent) == 0x000008, "Wrong alignment on UTGFSettingLanguageChangedEvent");
static_assert(sizeof(UTGFSettingLanguageChangedEvent) == 0x000028, "Wrong size on UTGFSettingLanguageChangedEvent");

// Class TGFGame.TGFSocialFriendGetSuggestEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFSocialFriendGetSuggestEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialFriendGetSuggestEvent">();
	}
	static class UTGFSocialFriendGetSuggestEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialFriendGetSuggestEvent>();
	}
};
static_assert(alignof(UTGFSocialFriendGetSuggestEvent) == 0x000008, "Wrong alignment on UTGFSocialFriendGetSuggestEvent");
static_assert(sizeof(UTGFSocialFriendGetSuggestEvent) == 0x000028, "Wrong size on UTGFSocialFriendGetSuggestEvent");

// Class TGFGame.TGFSocialAddGameFriendEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFSocialAddGameFriendEvent final : public UTGFEventArgs
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialAddGameFriendEvent">();
	}
	static class UTGFSocialAddGameFriendEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialAddGameFriendEvent>();
	}
};
static_assert(alignof(UTGFSocialAddGameFriendEvent) == 0x000008, "Wrong alignment on UTGFSocialAddGameFriendEvent");
static_assert(sizeof(UTGFSocialAddGameFriendEvent) == 0x000038, "Wrong size on UTGFSocialAddGameFriendEvent");
static_assert(offsetof(UTGFSocialAddGameFriendEvent, UserKey) == 0x000028, "Member 'UTGFSocialAddGameFriendEvent::UserKey' has a wrong offset!");

// Class TGFGame.TGFSocialGameFriendOnlineUpdateEvent
// 0x0018 (0x0040 - 0x0028)
class UTGFSocialGameFriendOnlineUpdateEvent final : public UTGFEventArgs
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnline;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialGameFriendOnlineUpdateEvent">();
	}
	static class UTGFSocialGameFriendOnlineUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialGameFriendOnlineUpdateEvent>();
	}
};
static_assert(alignof(UTGFSocialGameFriendOnlineUpdateEvent) == 0x000008, "Wrong alignment on UTGFSocialGameFriendOnlineUpdateEvent");
static_assert(sizeof(UTGFSocialGameFriendOnlineUpdateEvent) == 0x000040, "Wrong size on UTGFSocialGameFriendOnlineUpdateEvent");
static_assert(offsetof(UTGFSocialGameFriendOnlineUpdateEvent, UserKey) == 0x000028, "Member 'UTGFSocialGameFriendOnlineUpdateEvent::UserKey' has a wrong offset!");
static_assert(offsetof(UTGFSocialGameFriendOnlineUpdateEvent, bIsOnline) == 0x000038, "Member 'UTGFSocialGameFriendOnlineUpdateEvent::bIsOnline' has a wrong offset!");

// Class TGFGame.TGFSocialInviteSuccessEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFSocialInviteSuccessEvent final : public UTGFEventArgs
{
public:
	struct FUserKey                               UserKey;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSocialInviteSuccessEvent">();
	}
	static class UTGFSocialInviteSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSocialInviteSuccessEvent>();
	}
};
static_assert(alignof(UTGFSocialInviteSuccessEvent) == 0x000008, "Wrong alignment on UTGFSocialInviteSuccessEvent");
static_assert(sizeof(UTGFSocialInviteSuccessEvent) == 0x000038, "Wrong size on UTGFSocialInviteSuccessEvent");
static_assert(offsetof(UTGFSocialInviteSuccessEvent, UserKey) == 0x000028, "Member 'UTGFSocialInviteSuccessEvent::UserKey' has a wrong offset!");

// Class TGFGame.FriendInvite
// 0x0020 (0x0048 - 0x0028)
class UFriendInvite final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               UserKey;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CreateTimestamp;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendInvite">();
	}
	static class UFriendInvite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendInvite>();
	}
};
static_assert(alignof(UFriendInvite) == 0x000008, "Wrong alignment on UFriendInvite");
static_assert(sizeof(UFriendInvite) == 0x000048, "Wrong size on UFriendInvite");
static_assert(offsetof(UFriendInvite, bIsValid) == 0x000028, "Member 'UFriendInvite::bIsValid' has a wrong offset!");
static_assert(offsetof(UFriendInvite, UserKey) == 0x000030, "Member 'UFriendInvite::UserKey' has a wrong offset!");
static_assert(offsetof(UFriendInvite, CreateTimestamp) == 0x000040, "Member 'UFriendInvite::CreateTimestamp' has a wrong offset!");

// Class TGFGame.SteamFriend
// 0x0020 (0x0048 - 0x0028)
class USteamFriend final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGlobalUserKey                         GlobalUserKey;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GlobalUserUpdateHandler;                           // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameFriend*                            MyGameFriend;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamFriend">();
	}
	static class USteamFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamFriend>();
	}
};
static_assert(alignof(USteamFriend) == 0x000008, "Wrong alignment on USteamFriend");
static_assert(sizeof(USteamFriend) == 0x000048, "Wrong size on USteamFriend");
static_assert(offsetof(USteamFriend, bIsValid) == 0x000028, "Member 'USteamFriend::bIsValid' has a wrong offset!");
static_assert(offsetof(USteamFriend, GlobalUserKey) == 0x000030, "Member 'USteamFriend::GlobalUserKey' has a wrong offset!");
static_assert(offsetof(USteamFriend, GlobalUserUpdateHandler) == 0x000038, "Member 'USteamFriend::GlobalUserUpdateHandler' has a wrong offset!");
static_assert(offsetof(USteamFriend, MyGameFriend) == 0x000040, "Member 'USteamFriend::MyGameFriend' has a wrong offset!");

// Class TGFGame.TGFEventIntArgs
// 0x0010 (0x0038 - 0x0028)
class UTGFEventIntArgs final : public UTGFEventArgs
{
public:
	int32                                         Value;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ValueInt64;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFEventIntArgs">();
	}
	static class UTGFEventIntArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFEventIntArgs>();
	}
};
static_assert(alignof(UTGFEventIntArgs) == 0x000008, "Wrong alignment on UTGFEventIntArgs");
static_assert(sizeof(UTGFEventIntArgs) == 0x000038, "Wrong size on UTGFEventIntArgs");
static_assert(offsetof(UTGFEventIntArgs, Value) == 0x000028, "Member 'UTGFEventIntArgs::Value' has a wrong offset!");
static_assert(offsetof(UTGFEventIntArgs, ValueInt64) == 0x000030, "Member 'UTGFEventIntArgs::ValueInt64' has a wrong offset!");

// Class TGFGame.TaskFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTaskFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetAdventureDetailConfigRow(int32 AdventrureID, struct FTGFGameAdventureDetailConfigRow* AdventureConfigRow);
	static bool GetSteamAchievementConfigRow(ETGFInGameRookieTaskType TaskType, struct FTGFSteamAchievementTaskParamConfigRow* SteamAchievementConfigRow);
	static bool ReportClientTaskProgressValue(ETGFInGameRookieTaskType RookieTaskType, int64 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskFunctionLibrary">();
	}
	static class UTaskFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskFunctionLibrary>();
	}
};
static_assert(alignof(UTaskFunctionLibrary) == 0x000008, "Wrong alignment on UTaskFunctionLibrary");
static_assert(sizeof(UTaskFunctionLibrary) == 0x000028, "Wrong size on UTaskFunctionLibrary");

// Class TGFGame.TGFTaskItemData
// 0x0078 (0x00A0 - 0x0028)
class UTGFTaskItemData final : public UObject
{
public:
	int32                                         TaskId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETGFProtoTgfEnQuestProgressType, int64>  MapProgressTypeValue;                              // 0x0030(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnQuestStatus                     TaskStatus;                                        // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ProgressValue;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListOrder;                                         // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemIndex;                                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddProgressValue(int32 ProgressType, int64 Value);
	void ClearProgressValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTaskItemData">();
	}
	static class UTGFTaskItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTaskItemData>();
	}
};
static_assert(alignof(UTGFTaskItemData) == 0x000008, "Wrong alignment on UTGFTaskItemData");
static_assert(sizeof(UTGFTaskItemData) == 0x0000A0, "Wrong size on UTGFTaskItemData");
static_assert(offsetof(UTGFTaskItemData, TaskId) == 0x000028, "Member 'UTGFTaskItemData::TaskId' has a wrong offset!");
static_assert(offsetof(UTGFTaskItemData, MapProgressTypeValue) == 0x000030, "Member 'UTGFTaskItemData::MapProgressTypeValue' has a wrong offset!");
static_assert(offsetof(UTGFTaskItemData, Timestamp) == 0x000080, "Member 'UTGFTaskItemData::Timestamp' has a wrong offset!");
static_assert(offsetof(UTGFTaskItemData, TaskStatus) == 0x000088, "Member 'UTGFTaskItemData::TaskStatus' has a wrong offset!");
static_assert(offsetof(UTGFTaskItemData, ProgressValue) == 0x000090, "Member 'UTGFTaskItemData::ProgressValue' has a wrong offset!");
static_assert(offsetof(UTGFTaskItemData, ListOrder) == 0x000098, "Member 'UTGFTaskItemData::ListOrder' has a wrong offset!");
static_assert(offsetof(UTGFTaskItemData, ItemIndex) == 0x00009C, "Member 'UTGFTaskItemData::ItemIndex' has a wrong offset!");

// Class TGFGame.TGFGameTaskNetDataFullRsp
// 0x0000 (0x0028 - 0x0028)
class UTGFGameTaskNetDataFullRsp final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameTaskNetDataFullRsp">();
	}
	static class UTGFGameTaskNetDataFullRsp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameTaskNetDataFullRsp>();
	}
};
static_assert(alignof(UTGFGameTaskNetDataFullRsp) == 0x000008, "Wrong alignment on UTGFGameTaskNetDataFullRsp");
static_assert(sizeof(UTGFGameTaskNetDataFullRsp) == 0x000028, "Wrong size on UTGFGameTaskNetDataFullRsp");

// Class TGFGame.TGFGameTaskNetDataBriefSync
// 0x0000 (0x0028 - 0x0028)
class UTGFGameTaskNetDataBriefSync final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameTaskNetDataBriefSync">();
	}
	static class UTGFGameTaskNetDataBriefSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameTaskNetDataBriefSync>();
	}
};
static_assert(alignof(UTGFGameTaskNetDataBriefSync) == 0x000008, "Wrong alignment on UTGFGameTaskNetDataBriefSync");
static_assert(sizeof(UTGFGameTaskNetDataBriefSync) == 0x000028, "Wrong size on UTGFGameTaskNetDataBriefSync");

// Class TGFGame.TGFTeamReceiveInvitationEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTeamReceiveInvitationEvent final : public UTGFEventArgs
{
public:
	class UTeamInvite*                            TeamInvite;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamReceiveInvitationEvent">();
	}
	static class UTGFTeamReceiveInvitationEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamReceiveInvitationEvent>();
	}
};
static_assert(alignof(UTGFTeamReceiveInvitationEvent) == 0x000008, "Wrong alignment on UTGFTeamReceiveInvitationEvent");
static_assert(sizeof(UTGFTeamReceiveInvitationEvent) == 0x000030, "Wrong size on UTGFTeamReceiveInvitationEvent");
static_assert(offsetof(UTGFTeamReceiveInvitationEvent, TeamInvite) == 0x000028, "Member 'UTGFTeamReceiveInvitationEvent::TeamInvite' has a wrong offset!");

// Class TGFGame.TGFTeamUpdateInvitationEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTeamUpdateInvitationEvent final : public UTGFEventArgs
{
public:
	class UTeamInvite*                            TeamInvite;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamUpdateInvitationEvent">();
	}
	static class UTGFTeamUpdateInvitationEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamUpdateInvitationEvent>();
	}
};
static_assert(alignof(UTGFTeamUpdateInvitationEvent) == 0x000008, "Wrong alignment on UTGFTeamUpdateInvitationEvent");
static_assert(sizeof(UTGFTeamUpdateInvitationEvent) == 0x000030, "Wrong size on UTGFTeamUpdateInvitationEvent");
static_assert(offsetof(UTGFTeamUpdateInvitationEvent, TeamInvite) == 0x000028, "Member 'UTGFTeamUpdateInvitationEvent::TeamInvite' has a wrong offset!");

// Class TGFGame.TGFTeamMemberUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTeamMemberUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamMemberUpdateEvent">();
	}
	static class UTGFTeamMemberUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamMemberUpdateEvent>();
	}
};
static_assert(alignof(UTGFTeamMemberUpdateEvent) == 0x000008, "Wrong alignment on UTGFTeamMemberUpdateEvent");
static_assert(sizeof(UTGFTeamMemberUpdateEvent) == 0x000028, "Wrong size on UTGFTeamMemberUpdateEvent");

// Class TGFGame.TGFTeamStartPreMatchingEvent
// 0x0018 (0x0040 - 0x0028)
class UTGFTeamStartPreMatchingEvent final : public UTGFEventArgs
{
public:
	int32                                         LevelType;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelId;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamStartPreMatchingEvent">();
	}
	static class UTGFTeamStartPreMatchingEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamStartPreMatchingEvent>();
	}
};
static_assert(alignof(UTGFTeamStartPreMatchingEvent) == 0x000008, "Wrong alignment on UTGFTeamStartPreMatchingEvent");
static_assert(sizeof(UTGFTeamStartPreMatchingEvent) == 0x000040, "Wrong size on UTGFTeamStartPreMatchingEvent");
static_assert(offsetof(UTGFTeamStartPreMatchingEvent, LevelType) == 0x000028, "Member 'UTGFTeamStartPreMatchingEvent::LevelType' has a wrong offset!");
static_assert(offsetof(UTGFTeamStartPreMatchingEvent, LevelId) == 0x00002C, "Member 'UTGFTeamStartPreMatchingEvent::LevelId' has a wrong offset!");
static_assert(offsetof(UTGFTeamStartPreMatchingEvent, Region) == 0x000030, "Member 'UTGFTeamStartPreMatchingEvent::Region' has a wrong offset!");

// Class TGFGame.TGFTeamStartMatchingEvent
// 0x0018 (0x0040 - 0x0028)
class UTGFTeamStartMatchingEvent final : public UTGFEventArgs
{
public:
	int32                                         LevelType;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelId;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamStartMatchingEvent">();
	}
	static class UTGFTeamStartMatchingEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamStartMatchingEvent>();
	}
};
static_assert(alignof(UTGFTeamStartMatchingEvent) == 0x000008, "Wrong alignment on UTGFTeamStartMatchingEvent");
static_assert(sizeof(UTGFTeamStartMatchingEvent) == 0x000040, "Wrong size on UTGFTeamStartMatchingEvent");
static_assert(offsetof(UTGFTeamStartMatchingEvent, LevelType) == 0x000028, "Member 'UTGFTeamStartMatchingEvent::LevelType' has a wrong offset!");
static_assert(offsetof(UTGFTeamStartMatchingEvent, LevelId) == 0x00002C, "Member 'UTGFTeamStartMatchingEvent::LevelId' has a wrong offset!");
static_assert(offsetof(UTGFTeamStartMatchingEvent, Region) == 0x000030, "Member 'UTGFTeamStartMatchingEvent::Region' has a wrong offset!");

// Class TGFGame.TGFTeamSearchStatusChangedEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTeamSearchStatusChangedEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTeamSearchStatusChangedEvent">();
	}
	static class UTGFTeamSearchStatusChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTeamSearchStatusChangedEvent>();
	}
};
static_assert(alignof(UTGFTeamSearchStatusChangedEvent) == 0x000008, "Wrong alignment on UTGFTeamSearchStatusChangedEvent");
static_assert(sizeof(UTGFTeamSearchStatusChangedEvent) == 0x000028, "Wrong size on UTGFTeamSearchStatusChangedEvent");

// Class TGFGame.TeamService
// 0x0088 (0x00B8 - 0x0030)
class UTeamService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMyFinderStatus;                                   // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeamInfo*                              MyTeamInfo;                                        // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FUserKey, class UTeamInvite*>     MyTeamInviteMap;                                   // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           MyTeamSearchTimerHandle;                           // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         MyTeamSearchId;                                    // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         MyTeamSearchStartTimestamp;                        // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMyWaitTeamSearchRsp;                              // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMyWaitBattleConfirmRsp;                           // 0x00B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApproveInvite(const class UTeamInvite* TeamInvite);
	void CancelSearchTeam();
	bool CheckIsTeamMember(const struct FUserKey& UserKey);
	void ClearExpiredInvite();
	void ClearInvite();
	void CloseTeamInvitePage();
	void ExitTeam();
	struct FUserKey GetCaptainUserKey();
	bool GetFinderStatus();
	bool GetIsAllReady();
	bool GetIsCaptain();
	bool GetIsInTeam();
	bool GetIsNoOneInBattle();
	bool GetIsNoOneOffline();
	bool GetIsReady();
	int32 GetMemberCount();
	bool GetSearchTeamStatus();
	int64 GetTeamId();
	TArray<class UTeamInvite*> GetTeamInviteList();
	TArray<class UTeamMember*> GetTeamMemberList(const bool bExceptSelf);
	ETeamRole GetTeamRole();
	void GiveCaptain(const struct FUserKey& UserKey);
	void Invite(const struct FUserKey& UserKey, ETGFProtoTgfEnTeamMethodType TeamMethod);
	void OnTeamSearchTimer();
	void OpenTeamInvitePage();
	void Ready();
	void RejectInvite(const class UTeamInvite* TeamInvite);
	void RemoveMember(const struct FUserKey& UserKey);
	void SearchTeam(int32 MinRoleLevel, const TArray<int32>& RoleTypeList, const TArray<int32>& ModeTypeList, const TArray<int32>& ServiceTypeList);
	void SetFinderStatus(bool bFinderStatus);
	void ToggleTeamSearchTimer(bool bIsOpen);
	void Unready();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamService">();
	}
	static class UTeamService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamService>();
	}
};
static_assert(alignof(UTeamService) == 0x000008, "Wrong alignment on UTeamService");
static_assert(sizeof(UTeamService) == 0x0000B8, "Wrong size on UTeamService");
static_assert(offsetof(UTeamService, bMyFinderStatus) == 0x000038, "Member 'UTeamService::bMyFinderStatus' has a wrong offset!");
static_assert(offsetof(UTeamService, MyTeamInfo) == 0x000040, "Member 'UTeamService::MyTeamInfo' has a wrong offset!");
static_assert(offsetof(UTeamService, MyTeamInviteMap) == 0x000048, "Member 'UTeamService::MyTeamInviteMap' has a wrong offset!");
static_assert(offsetof(UTeamService, MyTeamSearchTimerHandle) == 0x000098, "Member 'UTeamService::MyTeamSearchTimerHandle' has a wrong offset!");
static_assert(offsetof(UTeamService, MyTeamSearchId) == 0x0000A0, "Member 'UTeamService::MyTeamSearchId' has a wrong offset!");
static_assert(offsetof(UTeamService, MyTeamSearchStartTimestamp) == 0x0000A8, "Member 'UTeamService::MyTeamSearchStartTimestamp' has a wrong offset!");
static_assert(offsetof(UTeamService, bMyWaitTeamSearchRsp) == 0x0000B0, "Member 'UTeamService::bMyWaitTeamSearchRsp' has a wrong offset!");
static_assert(offsetof(UTeamService, bMyWaitBattleConfirmRsp) == 0x0000B1, "Member 'UTeamService::bMyWaitBattleConfirmRsp' has a wrong offset!");

// Class TGFGame.TeamInvite
// 0x0030 (0x0058 - 0x0028)
class UTeamInvite final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsApplyJoin;                                      // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserKey                               UserKey;                                           // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TeamId;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ExpiredTimeStamp;                                  // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETGFProtoTgfEnTeamMethodType                  TeamMethod;                                        // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamInvite">();
	}
	static class UTeamInvite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamInvite>();
	}
};
static_assert(alignof(UTeamInvite) == 0x000008, "Wrong alignment on UTeamInvite");
static_assert(sizeof(UTeamInvite) == 0x000058, "Wrong size on UTeamInvite");
static_assert(offsetof(UTeamInvite, bIsValid) == 0x000028, "Member 'UTeamInvite::bIsValid' has a wrong offset!");
static_assert(offsetof(UTeamInvite, bIsApplyJoin) == 0x000029, "Member 'UTeamInvite::bIsApplyJoin' has a wrong offset!");
static_assert(offsetof(UTeamInvite, UserKey) == 0x000030, "Member 'UTeamInvite::UserKey' has a wrong offset!");
static_assert(offsetof(UTeamInvite, TeamId) == 0x000040, "Member 'UTeamInvite::TeamId' has a wrong offset!");
static_assert(offsetof(UTeamInvite, ExpiredTimeStamp) == 0x000048, "Member 'UTeamInvite::ExpiredTimeStamp' has a wrong offset!");
static_assert(offsetof(UTeamInvite, TeamMethod) == 0x000050, "Member 'UTeamInvite::TeamMethod' has a wrong offset!");

// Class TGFGame.TeamInfo
// 0x0070 (0x0098 - 0x0028)
class UTeamInfo final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         TeamId;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserKey                               CaptainUserKey;                                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FUserKey, class UTeamMember*>     TeamMemberMap;                                     // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	bool GetIsMember(const struct FUserKey& InUserKey);
	bool GetIsReady(const struct FUserKey& InUserKey);
	int32 GetMemberCount();

	bool GetIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamInfo">();
	}
	static class UTeamInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamInfo>();
	}
};
static_assert(alignof(UTeamInfo) == 0x000008, "Wrong alignment on UTeamInfo");
static_assert(sizeof(UTeamInfo) == 0x000098, "Wrong size on UTeamInfo");
static_assert(offsetof(UTeamInfo, bIsValid) == 0x000028, "Member 'UTeamInfo::bIsValid' has a wrong offset!");
static_assert(offsetof(UTeamInfo, TeamId) == 0x000030, "Member 'UTeamInfo::TeamId' has a wrong offset!");
static_assert(offsetof(UTeamInfo, CaptainUserKey) == 0x000038, "Member 'UTeamInfo::CaptainUserKey' has a wrong offset!");
static_assert(offsetof(UTeamInfo, TeamMemberMap) == 0x000048, "Member 'UTeamInfo::TeamMemberMap' has a wrong offset!");

// Class TGFGame.TgfAppearanceCacheTextureData
// 0x0070 (0x0098 - 0x0028)
class UTgfAppearanceCacheTextureData final : public UObject
{
public:
	struct FTgfAvatarBuildConfig                  AppearanceConfig;                                  // 0x0028(0x0068)(NativeAccessSpecifierPublic)
	class UObject*                                CacheTexture;                                      // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAppearanceCacheTextureData">();
	}
	static class UTgfAppearanceCacheTextureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAppearanceCacheTextureData>();
	}
};
static_assert(alignof(UTgfAppearanceCacheTextureData) == 0x000008, "Wrong alignment on UTgfAppearanceCacheTextureData");
static_assert(sizeof(UTgfAppearanceCacheTextureData) == 0x000098, "Wrong size on UTgfAppearanceCacheTextureData");
static_assert(offsetof(UTgfAppearanceCacheTextureData, AppearanceConfig) == 0x000028, "Member 'UTgfAppearanceCacheTextureData::AppearanceConfig' has a wrong offset!");
static_assert(offsetof(UTgfAppearanceCacheTextureData, CacheTexture) == 0x000090, "Member 'UTgfAppearanceCacheTextureData::CacheTexture' has a wrong offset!");

// Class TGFGame.TgfAudioStateVolume
// 0x0010 (0x02E0 - 0x02D0)
class ATgfAudioStateVolume final : public ATriggerVolume
{
public:
	class UAkStateValue*                          AkStateEnter;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkStateValue*                          AkStateLeave;                                      // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAudioStateVolume">();
	}
	static class ATgfAudioStateVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATgfAudioStateVolume>();
	}
};
static_assert(alignof(ATgfAudioStateVolume) == 0x000008, "Wrong alignment on ATgfAudioStateVolume");
static_assert(sizeof(ATgfAudioStateVolume) == 0x0002E0, "Wrong size on ATgfAudioStateVolume");
static_assert(offsetof(ATgfAudioStateVolume, AkStateEnter) == 0x0002D0, "Member 'ATgfAudioStateVolume::AkStateEnter' has a wrong offset!");
static_assert(offsetof(ATgfAudioStateVolume, AkStateLeave) == 0x0002D8, "Member 'ATgfAudioStateVolume::AkStateLeave' has a wrong offset!");

// Class TGFGame.TgfAudioSystem
// 0x0010 (0x0040 - 0x0030)
class UTgfAudioSystem final : public UTGFService
{
public:
	class UAkAudioEvent*                          HallMusicPlayEvent;                                // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          HallMusicStopEvent;                                // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UAkComponent* GetDefaultListener();
	void MuteSFX(bool Mute);
	void OnBattleEnter();
	void OnBattleLeave();
	void PlayHallMusic(class UAkAudioEvent* PlayEvent, class UAkAudioEvent* StopEvent);
	void StopHallMusic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfAudioSystem">();
	}
	static class UTgfAudioSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfAudioSystem>();
	}
};
static_assert(alignof(UTgfAudioSystem) == 0x000008, "Wrong alignment on UTgfAudioSystem");
static_assert(sizeof(UTgfAudioSystem) == 0x000040, "Wrong size on UTgfAudioSystem");
static_assert(offsetof(UTgfAudioSystem, HallMusicPlayEvent) == 0x000030, "Member 'UTgfAudioSystem::HallMusicPlayEvent' has a wrong offset!");
static_assert(offsetof(UTgfAudioSystem, HallMusicStopEvent) == 0x000038, "Member 'UTgfAudioSystem::HallMusicStopEvent' has a wrong offset!");

// Class TGFGame.TGFForgeRepairPanel
// 0x0120 (0x03E0 - 0x02C0)
class UTGFForgeRepairPanel final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2C0[0x70];                                     // 0x02C0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 EquipmentBgActive;                                 // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 EquipmentBgGrey;                                   // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 AnvilGrey;                                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 AnvilActive;                                       // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImgEquipment;                                      // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 EquipmentSketch;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                BtnRepair;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                BtnRepairWearing;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                BtnRepairBackpack;                                 // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           RepairMaterialPanel;                               // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           RepairWearingMaterialPanel;                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           RepairBackpackMaterialPanel;                       // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           RepairBlankHintPanel;                              // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           RepairWearingMaterialHintPanel;                    // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           RepairBackpackMaterialHintPanel;                   // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFItemBar*                            RepairCost;                                        // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFItemBar*                            RepairWearingCost;                                 // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFItemBar*                            RepairBackpackCost;                                // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonListView*                        RepairMaterialList;                                // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonListView*                        RepairWearingMaterialList;                         // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonListView*                        RepairBackpackMaterialList;                        // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonListView*                        OwnMaterialList;                                   // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleGearRepairFinish(class UTGFEventArgs* Args);
	void HandleGearRepairSuccess();
	void HandleOnBtnRepairBackpackClicked();
	void HandleOnBtnRepairClicked();
	void HandleOnBtnRepairWearingClicked();
	void HandleSwitchForgeTab(class UTGFEventArgs* Args);
	void Refresh();
	void RefreshSelectedEquipment(class UTgfInventoryItemWrapper* ItemWrapper);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFForgeRepairPanel">();
	}
	static class UTGFForgeRepairPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFForgeRepairPanel>();
	}
};
static_assert(alignof(UTGFForgeRepairPanel) == 0x000008, "Wrong alignment on UTGFForgeRepairPanel");
static_assert(sizeof(UTGFForgeRepairPanel) == 0x0003E0, "Wrong size on UTGFForgeRepairPanel");
static_assert(offsetof(UTGFForgeRepairPanel, EquipmentBgActive) == 0x000330, "Member 'UTGFForgeRepairPanel::EquipmentBgActive' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, EquipmentBgGrey) == 0x000338, "Member 'UTGFForgeRepairPanel::EquipmentBgGrey' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, AnvilGrey) == 0x000340, "Member 'UTGFForgeRepairPanel::AnvilGrey' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, AnvilActive) == 0x000348, "Member 'UTGFForgeRepairPanel::AnvilActive' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, ImgEquipment) == 0x000350, "Member 'UTGFForgeRepairPanel::ImgEquipment' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, EquipmentSketch) == 0x000358, "Member 'UTGFForgeRepairPanel::EquipmentSketch' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, BtnRepair) == 0x000360, "Member 'UTGFForgeRepairPanel::BtnRepair' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, BtnRepairWearing) == 0x000368, "Member 'UTGFForgeRepairPanel::BtnRepairWearing' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, BtnRepairBackpack) == 0x000370, "Member 'UTGFForgeRepairPanel::BtnRepairBackpack' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairMaterialPanel) == 0x000378, "Member 'UTGFForgeRepairPanel::RepairMaterialPanel' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairWearingMaterialPanel) == 0x000380, "Member 'UTGFForgeRepairPanel::RepairWearingMaterialPanel' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairBackpackMaterialPanel) == 0x000388, "Member 'UTGFForgeRepairPanel::RepairBackpackMaterialPanel' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairBlankHintPanel) == 0x000390, "Member 'UTGFForgeRepairPanel::RepairBlankHintPanel' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairWearingMaterialHintPanel) == 0x000398, "Member 'UTGFForgeRepairPanel::RepairWearingMaterialHintPanel' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairBackpackMaterialHintPanel) == 0x0003A0, "Member 'UTGFForgeRepairPanel::RepairBackpackMaterialHintPanel' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairCost) == 0x0003A8, "Member 'UTGFForgeRepairPanel::RepairCost' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairWearingCost) == 0x0003B0, "Member 'UTGFForgeRepairPanel::RepairWearingCost' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairBackpackCost) == 0x0003B8, "Member 'UTGFForgeRepairPanel::RepairBackpackCost' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairMaterialList) == 0x0003C0, "Member 'UTGFForgeRepairPanel::RepairMaterialList' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairWearingMaterialList) == 0x0003C8, "Member 'UTGFForgeRepairPanel::RepairWearingMaterialList' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, RepairBackpackMaterialList) == 0x0003D0, "Member 'UTGFForgeRepairPanel::RepairBackpackMaterialList' has a wrong offset!");
static_assert(offsetof(UTGFForgeRepairPanel, OwnMaterialList) == 0x0003D8, "Member 'UTGFForgeRepairPanel::OwnMaterialList' has a wrong offset!");

// Class TGFGame.TGFGameSettingButton
// 0x0018 (0x0180 - 0x0168)
class UTGFGameSettingButton final : public UGameSetting
{
public:
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameSettingButton">();
	}
	static class UTGFGameSettingButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameSettingButton>();
	}
};
static_assert(alignof(UTGFGameSettingButton) == 0x000008, "Wrong alignment on UTGFGameSettingButton");
static_assert(sizeof(UTGFGameSettingButton) == 0x000180, "Wrong size on UTGFGameSettingButton");

// Class TGFGame.TGFGameSettingSubtitle
// 0x0008 (0x0180 - 0x0178)
class UTGFGameSettingSubtitle final : public UGameSettingCollection
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameSettingSubtitle">();
	}
	static class UTGFGameSettingSubtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameSettingSubtitle>();
	}
};
static_assert(alignof(UTGFGameSettingSubtitle) == 0x000008, "Wrong alignment on UTGFGameSettingSubtitle");
static_assert(sizeof(UTGFGameSettingSubtitle) == 0x000180, "Wrong size on UTGFGameSettingSubtitle");

// Class TGFGame.TgfInventoryItemWrapper_Mithril
// 0x0000 (0x0048 - 0x0048)
class UTgfInventoryItemWrapper_Mithril final : public UTgfInventoryItemWrapper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryItemWrapper_Mithril">();
	}
	static class UTgfInventoryItemWrapper_Mithril* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryItemWrapper_Mithril>();
	}
};
static_assert(alignof(UTgfInventoryItemWrapper_Mithril) == 0x000008, "Wrong alignment on UTgfInventoryItemWrapper_Mithril");
static_assert(sizeof(UTgfInventoryItemWrapper_Mithril) == 0x000048, "Wrong size on UTgfInventoryItemWrapper_Mithril");

// Class TGFGame.TgfInventoryRoleWrapper_Lobby
// 0x0010 (0x0040 - 0x0030)
class UTgfInventoryRoleWrapper_Lobby final : public UTgfInventoryRoleWrapper
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URoleAttributeInfo*                     RoleAttrInfo;                                      // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UTgfInventoryRoleWrapper_Lobby* CreateInventoryRoleWrapperLobby();

	class URoleAttributeInfo* GetRoleAttributeInfo(int64 Guid);
	float Lua_GetRoleAttributeValue(EnRoleDisplayAttribueID AttributeID);
	bool ResetRoleAttributeInfo();
	bool SetFirstLevelAttrDataAsset(const class UTgfFirstLevelAttrDataAsset* DataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryRoleWrapper_Lobby">();
	}
	static class UTgfInventoryRoleWrapper_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryRoleWrapper_Lobby>();
	}
};
static_assert(alignof(UTgfInventoryRoleWrapper_Lobby) == 0x000008, "Wrong alignment on UTgfInventoryRoleWrapper_Lobby");
static_assert(sizeof(UTgfInventoryRoleWrapper_Lobby) == 0x000040, "Wrong size on UTgfInventoryRoleWrapper_Lobby");
static_assert(offsetof(UTgfInventoryRoleWrapper_Lobby, RoleAttrInfo) == 0x000038, "Member 'UTgfInventoryRoleWrapper_Lobby::RoleAttrInfo' has a wrong offset!");

// Class TGFGame.TgfEquipmentWrapper_Lobby
// 0x0000 (0x0030 - 0x0030)
class UTgfEquipmentWrapper_Lobby final : public UTgfEquipmentWrapper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfEquipmentWrapper_Lobby">();
	}
	static class UTgfEquipmentWrapper_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfEquipmentWrapper_Lobby>();
	}
};
static_assert(alignof(UTgfEquipmentWrapper_Lobby) == 0x000008, "Wrong alignment on UTgfEquipmentWrapper_Lobby");
static_assert(sizeof(UTgfEquipmentWrapper_Lobby) == 0x000030, "Wrong size on UTgfEquipmentWrapper_Lobby");

// Class TGFGame.TgfInventoryLibrary_Lobby
// 0x0000 (0x0028 - 0x0028)
class UTgfInventoryLibrary_Lobby final : public UBlueprintFunctionLibrary
{
public:
	static class UTgfInventoryWrapper* CreateLobbyInventoryContext(ETgfInventoryType Type, class UOverlay* InPopupOverlayPanel, TScriptInterface<class ITooltipWidget> InItemTooltipWidget, class UTgfInventoryWrapper* ParentInventory);
	static int32 GetMarketBuybackTabId();
	static EnItemStorageType InventoryTypeToServerEnum(ETgfInventoryType InventoryType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryLibrary_Lobby">();
	}
	static class UTgfInventoryLibrary_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryLibrary_Lobby>();
	}
};
static_assert(alignof(UTgfInventoryLibrary_Lobby) == 0x000008, "Wrong alignment on UTgfInventoryLibrary_Lobby");
static_assert(sizeof(UTgfInventoryLibrary_Lobby) == 0x000028, "Wrong size on UTgfInventoryLibrary_Lobby");

// Class TGFGame.TgfInventoryLibrary_Mithril
// 0x0000 (0x0028 - 0x0028)
class UTgfInventoryLibrary_Mithril final : public UBlueprintFunctionLibrary
{
public:
	static class UTgfInventoryWrapper* CreateMithrilInventoryContext(ETgfInventoryType Type, class UOverlay* InPopupOverlayPanel, TScriptInterface<class ITooltipWidget> InItemTooltipWidget, class UTgfInventoryWrapper* ParentInventory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryLibrary_Mithril">();
	}
	static class UTgfInventoryLibrary_Mithril* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryLibrary_Mithril>();
	}
};
static_assert(alignof(UTgfInventoryLibrary_Mithril) == 0x000008, "Wrong alignment on UTgfInventoryLibrary_Mithril");
static_assert(sizeof(UTgfInventoryLibrary_Mithril) == 0x000028, "Wrong size on UTgfInventoryLibrary_Mithril");

// Class TGFGame.TgfInventoryLibrary_MithrilResult
// 0x0000 (0x0028 - 0x0028)
class UTgfInventoryLibrary_MithrilResult final : public UBlueprintFunctionLibrary
{
public:
	static class UTgfInventoryWrapper* CreateMithrilInventoryContext(ETgfInventoryType Type, class UOverlay* InPopupOverlayPanel, TScriptInterface<class ITooltipWidget> InItemTooltipWidget, class UTgfInventoryWrapper* ParentInventory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryLibrary_MithrilResult">();
	}
	static class UTgfInventoryLibrary_MithrilResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryLibrary_MithrilResult>();
	}
};
static_assert(alignof(UTgfInventoryLibrary_MithrilResult) == 0x000008, "Wrong alignment on UTgfInventoryLibrary_MithrilResult");
static_assert(sizeof(UTgfInventoryLibrary_MithrilResult) == 0x000028, "Wrong size on UTgfInventoryLibrary_MithrilResult");

// Class TGFGame.TgfInventoryLibrary_Virtual
// 0x0000 (0x0028 - 0x0028)
class UTgfInventoryLibrary_Virtual final : public UBlueprintFunctionLibrary
{
public:
	static class UTgfInventoryWrapper* CreateActivityInventoryContext(class UOverlay* InPopupOverlayPanel, TScriptInterface<class ITooltipWidget> InItemTooltipWidget, class UTgfInventoryWrapper* ParentInventory, const struct FIntPoint& Size, const struct FIntPoint& MaxSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfInventoryLibrary_Virtual">();
	}
	static class UTgfInventoryLibrary_Virtual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfInventoryLibrary_Virtual>();
	}
};
static_assert(alignof(UTgfInventoryLibrary_Virtual) == 0x000008, "Wrong alignment on UTgfInventoryLibrary_Virtual");
static_assert(sizeof(UTgfInventoryLibrary_Virtual) == 0x000028, "Wrong size on UTgfInventoryLibrary_Virtual");

// Class TGFGame.TGFItemBar
// 0x0000 (0x02C0 - 0x02C0)
class UTGFItemBar final : public UCommonUserWidget
{
public:
	void SetUp(int32 InTypeId, int32 InCount, bool bEmphasize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFItemBar">();
	}
	static class UTGFItemBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFItemBar>();
	}
};
static_assert(alignof(UTGFItemBar) == 0x000008, "Wrong alignment on UTGFItemBar");
static_assert(sizeof(UTGFItemBar) == 0x0002C0, "Wrong size on UTGFItemBar");

// Class TGFGame.TGFMailHeaderInfo
// 0x0040 (0x0068 - 0x0028)
class UTGFMailHeaderInfo final : public UObject
{
public:
	int64                                         MailId;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Sender;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         LeftTimes;                                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasRead;                                           // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAttachments;                                    // 0x0065(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFMailHeaderInfo">();
	}
	static class UTGFMailHeaderInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFMailHeaderInfo>();
	}
};
static_assert(alignof(UTGFMailHeaderInfo) == 0x000008, "Wrong alignment on UTGFMailHeaderInfo");
static_assert(sizeof(UTGFMailHeaderInfo) == 0x000068, "Wrong size on UTGFMailHeaderInfo");
static_assert(offsetof(UTGFMailHeaderInfo, MailId) == 0x000028, "Member 'UTGFMailHeaderInfo::MailId' has a wrong offset!");
static_assert(offsetof(UTGFMailHeaderInfo, Title) == 0x000030, "Member 'UTGFMailHeaderInfo::Title' has a wrong offset!");
static_assert(offsetof(UTGFMailHeaderInfo, Sender) == 0x000048, "Member 'UTGFMailHeaderInfo::Sender' has a wrong offset!");
static_assert(offsetof(UTGFMailHeaderInfo, LeftTimes) == 0x000060, "Member 'UTGFMailHeaderInfo::LeftTimes' has a wrong offset!");
static_assert(offsetof(UTGFMailHeaderInfo, HasRead) == 0x000064, "Member 'UTGFMailHeaderInfo::HasRead' has a wrong offset!");
static_assert(offsetof(UTGFMailHeaderInfo, HasAttachments) == 0x000065, "Member 'UTGFMailHeaderInfo::HasAttachments' has a wrong offset!");

// Class TGFGame.TGFNetworkManagerEnterStateEvent
// 0x0020 (0x0048 - 0x0028)
class UTGFNetworkManagerEnterStateEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFNetworkManagerEnterStateEvent">();
	}
	static class UTGFNetworkManagerEnterStateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFNetworkManagerEnterStateEvent>();
	}
};
static_assert(alignof(UTGFNetworkManagerEnterStateEvent) == 0x000008, "Wrong alignment on UTGFNetworkManagerEnterStateEvent");
static_assert(sizeof(UTGFNetworkManagerEnterStateEvent) == 0x000048, "Wrong size on UTGFNetworkManagerEnterStateEvent");

// Class TGFGame.TGFConnectServerSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFConnectServerSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFConnectServerSuccessEvent">();
	}
	static class UTGFConnectServerSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFConnectServerSuccessEvent>();
	}
};
static_assert(alignof(UTGFConnectServerSuccessEvent) == 0x000008, "Wrong alignment on UTGFConnectServerSuccessEvent");
static_assert(sizeof(UTGFConnectServerSuccessEvent) == 0x000028, "Wrong size on UTGFConnectServerSuccessEvent");

// Class TGFGame.TGFConnectServerFailedEvent
// 0x0028 (0x0050 - 0x0028)
class UTGFConnectServerFailedEvent final : public UTGFEventArgs
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFConnectServerFailedEvent">();
	}
	static class UTGFConnectServerFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFConnectServerFailedEvent>();
	}
};
static_assert(alignof(UTGFConnectServerFailedEvent) == 0x000008, "Wrong alignment on UTGFConnectServerFailedEvent");
static_assert(sizeof(UTGFConnectServerFailedEvent) == 0x000050, "Wrong size on UTGFConnectServerFailedEvent");

// Class TGFGame.TGFNetworkFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTGFNetworkFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetProtocolErrorText(int32 ErrorCode, int64 SubErrorCode);
	static void PromptProtocolError(int32 ErrorCode, int64 SubErrorCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFNetworkFunctionLibrary">();
	}
	static class UTGFNetworkFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFNetworkFunctionLibrary>();
	}
};
static_assert(alignof(UTGFNetworkFunctionLibrary) == 0x000008, "Wrong alignment on UTGFNetworkFunctionLibrary");
static_assert(sizeof(UTGFNetworkFunctionLibrary) == 0x000028, "Wrong size on UTGFNetworkFunctionLibrary");

// Class TGFGame.RegionData
// 0x0078 (0x00A0 - 0x0028)
class URegionData final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTGFRegionData GetRegionData();
	bool GetRegionLatency();
	bool SendUdpMsg();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegionData">();
	}
	static class URegionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegionData>();
	}
};
static_assert(alignof(URegionData) == 0x000008, "Wrong alignment on URegionData");
static_assert(sizeof(URegionData) == 0x0000A0, "Wrong size on URegionData");

// Class TGFGame.TGFSettingsListEntrySetting_Button
// 0x0018 (0x0318 - 0x0300)
class UTGFSettingsListEntrySetting_Button final : public UGameSettingListEntry_Setting
{
public:
	class UTGFGameSettingButton*                  ButtonSetting;                                     // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonTextBlock*                       Text_ButtonName;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                SettingButton;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleSettingButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingsListEntrySetting_Button">();
	}
	static class UTGFSettingsListEntrySetting_Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingsListEntrySetting_Button>();
	}
};
static_assert(alignof(UTGFSettingsListEntrySetting_Button) == 0x000008, "Wrong alignment on UTGFSettingsListEntrySetting_Button");
static_assert(sizeof(UTGFSettingsListEntrySetting_Button) == 0x000318, "Wrong size on UTGFSettingsListEntrySetting_Button");
static_assert(offsetof(UTGFSettingsListEntrySetting_Button, ButtonSetting) == 0x000300, "Member 'UTGFSettingsListEntrySetting_Button::ButtonSetting' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_Button, Text_ButtonName) == 0x000308, "Member 'UTGFSettingsListEntrySetting_Button::Text_ButtonName' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_Button, SettingButton) == 0x000310, "Member 'UTGFSettingsListEntrySetting_Button::SettingButton' has a wrong offset!");

// Class TGFGame.TGFSettingsListEntrySetting_ComboBox
// 0x0018 (0x0318 - 0x0300)
class UTGFSettingsListEntrySetting_ComboBox final : public UGameSettingListEntry_Setting
{
public:
	class UGameSettingValueDiscrete*              DiscreteSetting;                                   // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           Panel_Value;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UComboBoxString*                        ComboBox;                                          // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleSelectOptionChanged(const class FString& SelectedItem, ESelectInfo SelectionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingsListEntrySetting_ComboBox">();
	}
	static class UTGFSettingsListEntrySetting_ComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingsListEntrySetting_ComboBox>();
	}
};
static_assert(alignof(UTGFSettingsListEntrySetting_ComboBox) == 0x000008, "Wrong alignment on UTGFSettingsListEntrySetting_ComboBox");
static_assert(sizeof(UTGFSettingsListEntrySetting_ComboBox) == 0x000318, "Wrong size on UTGFSettingsListEntrySetting_ComboBox");
static_assert(offsetof(UTGFSettingsListEntrySetting_ComboBox, DiscreteSetting) == 0x000300, "Member 'UTGFSettingsListEntrySetting_ComboBox::DiscreteSetting' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_ComboBox, Panel_Value) == 0x000308, "Member 'UTGFSettingsListEntrySetting_ComboBox::Panel_Value' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_ComboBox, ComboBox) == 0x000310, "Member 'UTGFSettingsListEntrySetting_ComboBox::ComboBox' has a wrong offset!");

// Class TGFGame.TGFSettingsListEntrySetting_FileDialog
// 0x0018 (0x0318 - 0x0300)
class UTGFSettingsListEntrySetting_FileDialog final : public UGameSettingListEntry_Setting
{
public:
	class UTGFGameSettingFileDialog*              FileDialogSetting;                                 // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonTextBlock*                       Text_FilePath;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                BtnFileDialog;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBtnFileDialogClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingsListEntrySetting_FileDialog">();
	}
	static class UTGFSettingsListEntrySetting_FileDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingsListEntrySetting_FileDialog>();
	}
};
static_assert(alignof(UTGFSettingsListEntrySetting_FileDialog) == 0x000008, "Wrong alignment on UTGFSettingsListEntrySetting_FileDialog");
static_assert(sizeof(UTGFSettingsListEntrySetting_FileDialog) == 0x000318, "Wrong size on UTGFSettingsListEntrySetting_FileDialog");
static_assert(offsetof(UTGFSettingsListEntrySetting_FileDialog, FileDialogSetting) == 0x000300, "Member 'UTGFSettingsListEntrySetting_FileDialog::FileDialogSetting' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_FileDialog, Text_FilePath) == 0x000308, "Member 'UTGFSettingsListEntrySetting_FileDialog::Text_FilePath' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_FileDialog, BtnFileDialog) == 0x000310, "Member 'UTGFSettingsListEntrySetting_FileDialog::BtnFileDialog' has a wrong offset!");

// Class TGFGame.TGFSettingsListEntrySetting_KeyboardInput
// 0x0040 (0x0340 - 0x0300)
class UTGFSettingsListEntrySetting_KeyboardInput final : public UGameSettingListEntry_Setting
{
public:
	class UTGFGameSettingKeyBinding*              KeyboardInputSetting;                              // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   OriginalKeyToBind;                                 // 0x0308(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFKeyConflictPopup*                   KeyConflictPopup;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSettingPressAnyKey*                KeyboardKeyMapGroup;                               // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 KeyboardHintAni;                                   // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                BtnKeyboard;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBtnKeyboardClicked();
	void HandleBtnKeyboardSelected(const struct FKey& InKey);
	void HandleConflictKeyCanceled();
	void HandleConflictKeyConfirmed();
	void HandleInvalidKeySelected(const struct FKey& InKey);
	void HandleKeySelectionCanceled();
	void UpdateKey(const struct FKey& InKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingsListEntrySetting_KeyboardInput">();
	}
	static class UTGFSettingsListEntrySetting_KeyboardInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingsListEntrySetting_KeyboardInput>();
	}
};
static_assert(alignof(UTGFSettingsListEntrySetting_KeyboardInput) == 0x000008, "Wrong alignment on UTGFSettingsListEntrySetting_KeyboardInput");
static_assert(sizeof(UTGFSettingsListEntrySetting_KeyboardInput) == 0x000340, "Wrong size on UTGFSettingsListEntrySetting_KeyboardInput");
static_assert(offsetof(UTGFSettingsListEntrySetting_KeyboardInput, KeyboardInputSetting) == 0x000300, "Member 'UTGFSettingsListEntrySetting_KeyboardInput::KeyboardInputSetting' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_KeyboardInput, OriginalKeyToBind) == 0x000308, "Member 'UTGFSettingsListEntrySetting_KeyboardInput::OriginalKeyToBind' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_KeyboardInput, KeyConflictPopup) == 0x000320, "Member 'UTGFSettingsListEntrySetting_KeyboardInput::KeyConflictPopup' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_KeyboardInput, KeyboardKeyMapGroup) == 0x000328, "Member 'UTGFSettingsListEntrySetting_KeyboardInput::KeyboardKeyMapGroup' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_KeyboardInput, KeyboardHintAni) == 0x000330, "Member 'UTGFSettingsListEntrySetting_KeyboardInput::KeyboardHintAni' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_KeyboardInput, BtnKeyboard) == 0x000338, "Member 'UTGFSettingsListEntrySetting_KeyboardInput::BtnKeyboard' has a wrong offset!");

// Class TGFGame.TGFSettingsListEntrySetting_Subtitle
// 0x0008 (0x0308 - 0x0300)
class UTGFSettingsListEntrySetting_Subtitle final : public UGameSettingListEntry_Setting
{
public:
	class UUserWidget*                            Spacer;                                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingsListEntrySetting_Subtitle">();
	}
	static class UTGFSettingsListEntrySetting_Subtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingsListEntrySetting_Subtitle>();
	}
};
static_assert(alignof(UTGFSettingsListEntrySetting_Subtitle) == 0x000008, "Wrong alignment on UTGFSettingsListEntrySetting_Subtitle");
static_assert(sizeof(UTGFSettingsListEntrySetting_Subtitle) == 0x000308, "Wrong size on UTGFSettingsListEntrySetting_Subtitle");
static_assert(offsetof(UTGFSettingsListEntrySetting_Subtitle, Spacer) == 0x000300, "Member 'UTGFSettingsListEntrySetting_Subtitle::Spacer' has a wrong offset!");

// Class TGFGame.TGFSettingsListEntrySetting_Switch
// 0x0020 (0x0320 - 0x0300)
class UTGFSettingsListEntrySetting_Switch final : public UGameSettingListEntry_Setting
{
public:
	class UGameSettingValueDiscreteDynamic_Bool*  DiscreteSetting;                                   // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           Panel_Value;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFSettingWidget_SwitchButton*         BtnClose;                                          // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTGFSettingWidget_SwitchButton*         BtnOpen;                                           // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBtnCloseClicked(bool InIsChecked);
	void HandleBtnOpenClicked(bool InIsChecked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingsListEntrySetting_Switch">();
	}
	static class UTGFSettingsListEntrySetting_Switch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingsListEntrySetting_Switch>();
	}
};
static_assert(alignof(UTGFSettingsListEntrySetting_Switch) == 0x000008, "Wrong alignment on UTGFSettingsListEntrySetting_Switch");
static_assert(sizeof(UTGFSettingsListEntrySetting_Switch) == 0x000320, "Wrong size on UTGFSettingsListEntrySetting_Switch");
static_assert(offsetof(UTGFSettingsListEntrySetting_Switch, DiscreteSetting) == 0x000300, "Member 'UTGFSettingsListEntrySetting_Switch::DiscreteSetting' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_Switch, Panel_Value) == 0x000308, "Member 'UTGFSettingsListEntrySetting_Switch::Panel_Value' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_Switch, BtnClose) == 0x000310, "Member 'UTGFSettingsListEntrySetting_Switch::BtnClose' has a wrong offset!");
static_assert(offsetof(UTGFSettingsListEntrySetting_Switch, BtnOpen) == 0x000318, "Member 'UTGFSettingsListEntrySetting_Switch::BtnOpen' has a wrong offset!");

// Class TGFGame.TGFSettingValueDiscreteDynamic_SSModeEnum
// 0x0000 (0x01D0 - 0x01D0)
class UTGFSettingValueDiscreteDynamic_SSModeEnum final : public UGameSettingValueDiscreteDynamic_Enum
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingValueDiscreteDynamic_SSModeEnum">();
	}
	static class UTGFSettingValueDiscreteDynamic_SSModeEnum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingValueDiscreteDynamic_SSModeEnum>();
	}
};
static_assert(alignof(UTGFSettingValueDiscreteDynamic_SSModeEnum) == 0x000008, "Wrong alignment on UTGFSettingValueDiscreteDynamic_SSModeEnum");
static_assert(sizeof(UTGFSettingValueDiscreteDynamic_SSModeEnum) == 0x0001D0, "Wrong size on UTGFSettingValueDiscreteDynamic_SSModeEnum");

// Class TGFGame.TGFSettingValueDiscreteDynamic_WindowModeEnum
// 0x0000 (0x01D0 - 0x01D0)
class UTGFSettingValueDiscreteDynamic_WindowModeEnum final : public UGameSettingValueDiscreteDynamic_Enum
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingValueDiscreteDynamic_WindowModeEnum">();
	}
	static class UTGFSettingValueDiscreteDynamic_WindowModeEnum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingValueDiscreteDynamic_WindowModeEnum>();
	}
};
static_assert(alignof(UTGFSettingValueDiscreteDynamic_WindowModeEnum) == 0x000008, "Wrong alignment on UTGFSettingValueDiscreteDynamic_WindowModeEnum");
static_assert(sizeof(UTGFSettingValueDiscreteDynamic_WindowModeEnum) == 0x0001D0, "Wrong size on UTGFSettingValueDiscreteDynamic_WindowModeEnum");

// Class TGFGame.TGFSettingValueDiscrete_DeskTopFPSType
// 0x0018 (0x0180 - 0x0168)
class UTGFSettingValueDiscrete_DeskTopFPSType final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingValueDiscrete_DeskTopFPSType">();
	}
	static class UTGFSettingValueDiscrete_DeskTopFPSType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingValueDiscrete_DeskTopFPSType>();
	}
};
static_assert(alignof(UTGFSettingValueDiscrete_DeskTopFPSType) == 0x000008, "Wrong alignment on UTGFSettingValueDiscrete_DeskTopFPSType");
static_assert(sizeof(UTGFSettingValueDiscrete_DeskTopFPSType) == 0x000180, "Wrong size on UTGFSettingValueDiscrete_DeskTopFPSType");

// Class TGFGame.TGFSettingValueDiscrete_Resolution
// 0x0020 (0x0188 - 0x0168)
class UTGFSettingValueDiscrete_Resolution final : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAppropraiteDiscreteOptionIndex();
	TArray<class FText> GetAppropriateDiscreteOptions();
	void Initialize();
	void SetAppropriateDiscreteOptionByIndex(int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingValueDiscrete_Resolution">();
	}
	static class UTGFSettingValueDiscrete_Resolution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingValueDiscrete_Resolution>();
	}
};
static_assert(alignof(UTGFSettingValueDiscrete_Resolution) == 0x000008, "Wrong alignment on UTGFSettingValueDiscrete_Resolution");
static_assert(sizeof(UTGFSettingValueDiscrete_Resolution) == 0x000188, "Wrong size on UTGFSettingValueDiscrete_Resolution");

// Class TGFGame.TGFSettingWidget_SwitchButton
// 0x0028 (0x02E8 - 0x02C0)
class UTGFSettingWidget_SwitchButton final : public UCommonUserWidget
{
public:
	class UCommonTextBlock*                       TextNormal;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonTextBlock*                       TextActive;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           Normal;                                            // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           Active;                                            // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCheckBox*                              CheckBox;                                          // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingWidget_SwitchButton">();
	}
	static class UTGFSettingWidget_SwitchButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingWidget_SwitchButton>();
	}
};
static_assert(alignof(UTGFSettingWidget_SwitchButton) == 0x000008, "Wrong alignment on UTGFSettingWidget_SwitchButton");
static_assert(sizeof(UTGFSettingWidget_SwitchButton) == 0x0002E8, "Wrong size on UTGFSettingWidget_SwitchButton");
static_assert(offsetof(UTGFSettingWidget_SwitchButton, TextNormal) == 0x0002C0, "Member 'UTGFSettingWidget_SwitchButton::TextNormal' has a wrong offset!");
static_assert(offsetof(UTGFSettingWidget_SwitchButton, TextActive) == 0x0002C8, "Member 'UTGFSettingWidget_SwitchButton::TextActive' has a wrong offset!");
static_assert(offsetof(UTGFSettingWidget_SwitchButton, Normal) == 0x0002D0, "Member 'UTGFSettingWidget_SwitchButton::Normal' has a wrong offset!");
static_assert(offsetof(UTGFSettingWidget_SwitchButton, Active) == 0x0002D8, "Member 'UTGFSettingWidget_SwitchButton::Active' has a wrong offset!");
static_assert(offsetof(UTGFSettingWidget_SwitchButton, CheckBox) == 0x0002E0, "Member 'UTGFSettingWidget_SwitchButton::CheckBox' has a wrong offset!");

// Class TGFGame.TgfSteamAchievement
// 0x0008 (0x0038 - 0x0030)
class UTgfSteamAchievement final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleWearEquipmentTask(int64 RoleGuid);
	void HandleWithTalentsTask();
	void OnBattleMatchEvent(class UTGFEventArgs* Arg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfSteamAchievement">();
	}
	static class UTgfSteamAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfSteamAchievement>();
	}
};
static_assert(alignof(UTgfSteamAchievement) == 0x000008, "Wrong alignment on UTgfSteamAchievement");
static_assert(sizeof(UTgfSteamAchievement) == 0x000038, "Wrong size on UTgfSteamAchievement");

// Class TGFGame.TGFTradeMarketProductMetricPoint
// 0x0020 (0x0048 - 0x0028)
class UTGFTradeMarketProductMetricPoint final : public UObject
{
public:
	int64                                         LowestPrice;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         StandardPrice;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         HighestPrice;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeMarketProductMetricPoint">();
	}
	static class UTGFTradeMarketProductMetricPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeMarketProductMetricPoint>();
	}
};
static_assert(alignof(UTGFTradeMarketProductMetricPoint) == 0x000008, "Wrong alignment on UTGFTradeMarketProductMetricPoint");
static_assert(sizeof(UTGFTradeMarketProductMetricPoint) == 0x000048, "Wrong size on UTGFTradeMarketProductMetricPoint");
static_assert(offsetof(UTGFTradeMarketProductMetricPoint, LowestPrice) == 0x000028, "Member 'UTGFTradeMarketProductMetricPoint::LowestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductMetricPoint, StandardPrice) == 0x000030, "Member 'UTGFTradeMarketProductMetricPoint::StandardPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductMetricPoint, HighestPrice) == 0x000038, "Member 'UTGFTradeMarketProductMetricPoint::HighestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductMetricPoint, Timestamp) == 0x000040, "Member 'UTGFTradeMarketProductMetricPoint::Timestamp' has a wrong offset!");

// Class TGFGame.TGFTradeMarketProductOnSaleDistribution
// 0x0018 (0x0040 - 0x0028)
class UTGFTradeMarketProductOnSaleDistribution final : public UObject
{
public:
	int64                                         LowestPrice;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         HighestPrice;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderTicketCount;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeMarketProductOnSaleDistribution">();
	}
	static class UTGFTradeMarketProductOnSaleDistribution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeMarketProductOnSaleDistribution>();
	}
};
static_assert(alignof(UTGFTradeMarketProductOnSaleDistribution) == 0x000008, "Wrong alignment on UTGFTradeMarketProductOnSaleDistribution");
static_assert(sizeof(UTGFTradeMarketProductOnSaleDistribution) == 0x000040, "Wrong size on UTGFTradeMarketProductOnSaleDistribution");
static_assert(offsetof(UTGFTradeMarketProductOnSaleDistribution, LowestPrice) == 0x000028, "Member 'UTGFTradeMarketProductOnSaleDistribution::LowestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductOnSaleDistribution, HighestPrice) == 0x000030, "Member 'UTGFTradeMarketProductOnSaleDistribution::HighestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductOnSaleDistribution, OrderTicketCount) == 0x000038, "Member 'UTGFTradeMarketProductOnSaleDistribution::OrderTicketCount' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductOnSaleDistribution, ItemCount) == 0x00003C, "Member 'UTGFTradeMarketProductOnSaleDistribution::ItemCount' has a wrong offset!");

// Class TGFGame.TGFTradeMarketProductPricePercentage
// 0x0010 (0x0038 - 0x0028)
class UTGFTradeMarketProductPricePercentage final : public UObject
{
public:
	int64                                         Percent;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MinPrice;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeMarketProductPricePercentage">();
	}
	static class UTGFTradeMarketProductPricePercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeMarketProductPricePercentage>();
	}
};
static_assert(alignof(UTGFTradeMarketProductPricePercentage) == 0x000008, "Wrong alignment on UTGFTradeMarketProductPricePercentage");
static_assert(sizeof(UTGFTradeMarketProductPricePercentage) == 0x000038, "Wrong size on UTGFTradeMarketProductPricePercentage");
static_assert(offsetof(UTGFTradeMarketProductPricePercentage, Percent) == 0x000028, "Member 'UTGFTradeMarketProductPricePercentage::Percent' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductPricePercentage, MinPrice) == 0x000030, "Member 'UTGFTradeMarketProductPricePercentage::MinPrice' has a wrong offset!");

// Class TGFGame.TGFTradeMarketProductData
// 0x0158 (0x0180 - 0x0028)
class UTGFTradeMarketProductData final : public UObject
{
public:
	int32                                         OrderType;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradeProductId;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaCode;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradeMarketId;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LowestPrice;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         StandardPrice;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NextUpdateStandardPriceTime;                       // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTGFTradeMarketProductMetricPoint*> MetricPoint;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTGFTradeMarketProductOnSaleDistribution*> OnSale;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTGFTradeMarketProductPricePercentage*> Percentages;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTgfInventoryItemWrapper_Trade*         ItemWrapper;                                       // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSale;                                          // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         WeekLowestPrice;                                   // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WeekHighestPrice;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SpLowest;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SpHighest;                                         // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CurrentLowestPrice;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   SourceType;                                        // 0x00B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int64                                         CurTimeStemp;                                      // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTGFProtoTgfDTradeIndexSearchBound*     Bound;                                             // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x68];                                     // 0x0118(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FTGFItem GetItem(int32 MarketId);
	TArray<int32> GetSourceTypes();
	bool HaveGearSetAttribute(int32 MarketId);
	bool IsCorruptionItem(int32 MarketId);

	int32 GetItemTypeId(int32 MarketId) const;
	int64 GetLowestPrice() const;
	int64 GetStartPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeMarketProductData">();
	}
	static class UTGFTradeMarketProductData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeMarketProductData>();
	}
};
static_assert(alignof(UTGFTradeMarketProductData) == 0x000008, "Wrong alignment on UTGFTradeMarketProductData");
static_assert(sizeof(UTGFTradeMarketProductData) == 0x000180, "Wrong size on UTGFTradeMarketProductData");
static_assert(offsetof(UTGFTradeMarketProductData, OrderType) == 0x000028, "Member 'UTGFTradeMarketProductData::OrderType' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, TradeProductId) == 0x00002C, "Member 'UTGFTradeMarketProductData::TradeProductId' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, AreaCode) == 0x000030, "Member 'UTGFTradeMarketProductData::AreaCode' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, TradeMarketId) == 0x000034, "Member 'UTGFTradeMarketProductData::TradeMarketId' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, LowestPrice) == 0x000038, "Member 'UTGFTradeMarketProductData::LowestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, StandardPrice) == 0x000040, "Member 'UTGFTradeMarketProductData::StandardPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, NextUpdateStandardPriceTime) == 0x000048, "Member 'UTGFTradeMarketProductData::NextUpdateStandardPriceTime' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, MetricPoint) == 0x000050, "Member 'UTGFTradeMarketProductData::MetricPoint' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, OnSale) == 0x000060, "Member 'UTGFTradeMarketProductData::OnSale' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, Percentages) == 0x000070, "Member 'UTGFTradeMarketProductData::Percentages' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, ItemWrapper) == 0x000080, "Member 'UTGFTradeMarketProductData::ItemWrapper' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, IsOnSale) == 0x000088, "Member 'UTGFTradeMarketProductData::IsOnSale' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, WeekLowestPrice) == 0x000090, "Member 'UTGFTradeMarketProductData::WeekLowestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, WeekHighestPrice) == 0x000098, "Member 'UTGFTradeMarketProductData::WeekHighestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, SpLowest) == 0x0000A0, "Member 'UTGFTradeMarketProductData::SpLowest' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, SpHighest) == 0x0000A8, "Member 'UTGFTradeMarketProductData::SpHighest' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, CurrentLowestPrice) == 0x0000B0, "Member 'UTGFTradeMarketProductData::CurrentLowestPrice' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, SourceType) == 0x0000B8, "Member 'UTGFTradeMarketProductData::SourceType' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, CurTimeStemp) == 0x000108, "Member 'UTGFTradeMarketProductData::CurTimeStemp' has a wrong offset!");
static_assert(offsetof(UTGFTradeMarketProductData, Bound) == 0x000110, "Member 'UTGFTradeMarketProductData::Bound' has a wrong offset!");

// Class TGFGame.TgfVoiceChatService
// 0x0038 (0x0068 - 0x0030)
class UTgfVoiceChatService final : public UTGFService
{
public:
	struct FKey                                   MyVoiceKey;                                        // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ExpectRoomName;                                    // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentRoomName;                                   // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GA_CloseMic();
	void GA_OpenMic();
	void JoinVoiceRoom(const class FString& RoomName);
	void OnGmeConnectTimeout(class UTGFEventArgs* Args);
	void OnSettingScreenDestruct(class UTGFEventArgs* Args);
	void OnUnlockModuleDirty(class UTGFEventArgs* Args);
	void OnUserKeyDownEvent(const struct FKeyEvent& InKeyEvent);
	void OnUserKeyUpEvent(const struct FKeyEvent& InKeyEvent);
	void QuitVoiceRoom(const class FString& RoomMark);
	void UpdateVoiceMode();

	void CloseVoicePage() const;
	bool GetSettingOpenState() const;
	int32 GetVoiceLevel(const int64 UserId) const;
	void OpenVoicePage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TgfVoiceChatService">();
	}
	static class UTgfVoiceChatService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTgfVoiceChatService>();
	}
};
static_assert(alignof(UTgfVoiceChatService) == 0x000008, "Wrong alignment on UTgfVoiceChatService");
static_assert(sizeof(UTgfVoiceChatService) == 0x000068, "Wrong size on UTgfVoiceChatService");
static_assert(offsetof(UTgfVoiceChatService, MyVoiceKey) == 0x000030, "Member 'UTgfVoiceChatService::MyVoiceKey' has a wrong offset!");
static_assert(offsetof(UTgfVoiceChatService, ExpectRoomName) == 0x000048, "Member 'UTgfVoiceChatService::ExpectRoomName' has a wrong offset!");
static_assert(offsetof(UTgfVoiceChatService, CurrentRoomName) == 0x000058, "Member 'UTgfVoiceChatService::CurrentRoomName' has a wrong offset!");

// Class TGFGame.TimeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTimeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString FormatToCultureLocalTime(int64 UnixTimestamp, const ETimeFormatType FormatType, const class FString& CultureName);
	static class FString FormatToLocalTime(int64 UnixTimestamp);
	static class FString FormatToLocalTimeWithFormat(int64 UnixTimestamp, const class FString& InFormat);
	static int64 GetLocalTimestamp();
	static class FString GetOrdinal(int32 Value);
	static struct FDateTime GetUtcDateTime();
	static struct FDateTime TransToLocalDateTime(int64 UnixTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeFunctionLibrary">();
	}
	static class UTimeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeFunctionLibrary>();
	}
};
static_assert(alignof(UTimeFunctionLibrary) == 0x000008, "Wrong alignment on UTimeFunctionLibrary");
static_assert(sizeof(UTimeFunctionLibrary) == 0x000028, "Wrong size on UTimeFunctionLibrary");

// Class TGFGame.TimerSubsystem
// 0x0018 (0x0048 - 0x0030)
class UTimerSubsystem final : public UTGFSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lua_Initialized();
	void Lua_Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerSubsystem">();
	}
	static class UTimerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimerSubsystem>();
	}
};
static_assert(alignof(UTimerSubsystem) == 0x000008, "Wrong alignment on UTimerSubsystem");
static_assert(sizeof(UTimerSubsystem) == 0x000048, "Wrong size on UTimerSubsystem");

// Class TGFGame.TimeService
// 0x0010 (0x0040 - 0x0030)
class UTimeService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameLogout(class UTGFEventArgs* Args);

	int64 GetCurrentTimeStamp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeService">();
	}
	static class UTimeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeService>();
	}
};
static_assert(alignof(UTimeService) == 0x000008, "Wrong alignment on UTimeService");
static_assert(sizeof(UTimeService) == 0x000040, "Wrong size on UTimeService");

// Class TGFGame.TimeTextBlock
// 0x0000 (0x0340 - 0x0340)
class UTimeTextBlock final : public UTextBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeTextBlock">();
	}
	static class UTimeTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeTextBlock>();
	}
};
static_assert(alignof(UTimeTextBlock) == 0x000010, "Wrong alignment on UTimeTextBlock");
static_assert(sizeof(UTimeTextBlock) == 0x000340, "Wrong size on UTimeTextBlock");

// Class TGFGame.ToastWindow
// 0x0000 (0x02B8 - 0x02B8)
class UToastWindow final : public UTGFWindow
{
public:
	static void ShowToast(const class FText& Message);
	static void ShowToastWithActor(const class FText& Message, class AActor* InputActor);
	static void ShowToastWithActorAndTime(const class FText& Message, class AActor* InputActor, float Time);
	static void ShowToastWithObject(const class FText& Message, class UObject* InputObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToastWindow">();
	}
	static class UToastWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToastWindow>();
	}
};
static_assert(alignof(UToastWindow) == 0x000008, "Wrong alignment on UToastWindow");
static_assert(sizeof(UToastWindow) == 0x0002B8, "Wrong size on UToastWindow");

// Class TGFGame.ToastWindowArgs
// 0x0020 (0x0050 - 0x0030)
class UToastWindowArgs final : public UTGFWindowArgs
{
public:
	class FText                                   Message;                                           // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToastWindowArgs">();
	}
	static class UToastWindowArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToastWindowArgs>();
	}
};
static_assert(alignof(UToastWindowArgs) == 0x000008, "Wrong alignment on UToastWindowArgs");
static_assert(sizeof(UToastWindowArgs) == 0x000050, "Wrong size on UToastWindowArgs");
static_assert(offsetof(UToastWindowArgs, Message) == 0x000030, "Member 'UToastWindowArgs::Message' has a wrong offset!");
static_assert(offsetof(UToastWindowArgs, FadeTime) == 0x000048, "Member 'UToastWindowArgs::FadeTime' has a wrong offset!");

// Class TGFGame.ToolLib
// 0x0000 (0x0028 - 0x0028)
class UToolLib final : public UObject
{
public:
	static TArray<class UExcelLoaderTgfConfigExcelRoleType*> GetCareerConfigList(int32 Race);
	static class UTexture2D* GetTexture2D(const class FString& Path);
	static int32 GetTotlePageCount(int32 DataCnt, int32 OnePageCnt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolLib">();
	}
	static class UToolLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToolLib>();
	}
};
static_assert(alignof(UToolLib) == 0x000008, "Wrong alignment on UToolLib");
static_assert(sizeof(UToolLib) == 0x000028, "Wrong size on UToolLib");

// Class TGFGame.TradeBidOrder
// 0x00D8 (0x0100 - 0x0028)
class UTradeBidOrder final : public UObject
{
public:
	class UTgfInventoryItemWrapper_Lobby*         ItemWrapper;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0xD0];                                      // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FTGFItem GetItem();

	int32 GetCurrentBidPrice() const;
	int32 GetItemTypeId() const;
	int32 GetMyBidPrice() const;
	class UTradeSearchResultOrder* GetOrderForBid() const;
	int64 GetRemainTime() const;
	ETradeBidOrderState GetState() const;
	int32 GetTradeItemProductId() const;
	int64 GetTradeOrderTicketId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeBidOrder">();
	}
	static class UTradeBidOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeBidOrder>();
	}
};
static_assert(alignof(UTradeBidOrder) == 0x000008, "Wrong alignment on UTradeBidOrder");
static_assert(sizeof(UTradeBidOrder) == 0x000100, "Wrong size on UTradeBidOrder");
static_assert(offsetof(UTradeBidOrder, ItemWrapper) == 0x000028, "Member 'UTradeBidOrder::ItemWrapper' has a wrong offset!");

// Class TGFGame.TGFTradeAuctionOrderPublishSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeAuctionOrderPublishSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeAuctionOrderPublishSuccessEvent">();
	}
	static class UTGFTradeAuctionOrderPublishSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeAuctionOrderPublishSuccessEvent>();
	}
};
static_assert(alignof(UTGFTradeAuctionOrderPublishSuccessEvent) == 0x000008, "Wrong alignment on UTGFTradeAuctionOrderPublishSuccessEvent");
static_assert(sizeof(UTGFTradeAuctionOrderPublishSuccessEvent) == 0x000028, "Wrong size on UTGFTradeAuctionOrderPublishSuccessEvent");

// Class TGFGame.TGFTradeAuctionOrderPublishFailedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradeAuctionOrderPublishFailedEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeAuctionOrderPublishFailedEvent">();
	}
	static class UTGFTradeAuctionOrderPublishFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeAuctionOrderPublishFailedEvent>();
	}
};
static_assert(alignof(UTGFTradeAuctionOrderPublishFailedEvent) == 0x000008, "Wrong alignment on UTGFTradeAuctionOrderPublishFailedEvent");
static_assert(sizeof(UTGFTradeAuctionOrderPublishFailedEvent) == 0x000030, "Wrong size on UTGFTradeAuctionOrderPublishFailedEvent");
static_assert(offsetof(UTGFTradeAuctionOrderPublishFailedEvent, ErrorCode) == 0x000028, "Member 'UTGFTradeAuctionOrderPublishFailedEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.TGFTradeBidOrderPublishSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeBidOrderPublishSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeBidOrderPublishSuccessEvent">();
	}
	static class UTGFTradeBidOrderPublishSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeBidOrderPublishSuccessEvent>();
	}
};
static_assert(alignof(UTGFTradeBidOrderPublishSuccessEvent) == 0x000008, "Wrong alignment on UTGFTradeBidOrderPublishSuccessEvent");
static_assert(sizeof(UTGFTradeBidOrderPublishSuccessEvent) == 0x000028, "Wrong size on UTGFTradeBidOrderPublishSuccessEvent");

// Class TGFGame.TGFTradeBidOrderPublishFailedEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradeBidOrderPublishFailedEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeBidOrderPublishFailedEvent">();
	}
	static class UTGFTradeBidOrderPublishFailedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeBidOrderPublishFailedEvent>();
	}
};
static_assert(alignof(UTGFTradeBidOrderPublishFailedEvent) == 0x000008, "Wrong alignment on UTGFTradeBidOrderPublishFailedEvent");
static_assert(sizeof(UTGFTradeBidOrderPublishFailedEvent) == 0x000030, "Wrong size on UTGFTradeBidOrderPublishFailedEvent");
static_assert(offsetof(UTGFTradeBidOrderPublishFailedEvent, ErrorCode) == 0x000028, "Member 'UTGFTradeBidOrderPublishFailedEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.TGFTradeMyOrderUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeMyOrderUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeMyOrderUpdateEvent">();
	}
	static class UTGFTradeMyOrderUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeMyOrderUpdateEvent>();
	}
};
static_assert(alignof(UTGFTradeMyOrderUpdateEvent) == 0x000008, "Wrong alignment on UTGFTradeMyOrderUpdateEvent");
static_assert(sizeof(UTGFTradeMyOrderUpdateEvent) == 0x000028, "Wrong size on UTGFTradeMyOrderUpdateEvent");

// Class TGFGame.TGFTradeSearchSuccessEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeSearchSuccessEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSearchSuccessEvent">();
	}
	static class UTGFTradeSearchSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSearchSuccessEvent>();
	}
};
static_assert(alignof(UTGFTradeSearchSuccessEvent) == 0x000008, "Wrong alignment on UTGFTradeSearchSuccessEvent");
static_assert(sizeof(UTGFTradeSearchSuccessEvent) == 0x000028, "Wrong size on UTGFTradeSearchSuccessEvent");

// Class TGFGame.TGFTradeSearchErrorEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeSearchErrorEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSearchErrorEvent">();
	}
	static class UTGFTradeSearchErrorEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSearchErrorEvent>();
	}
};
static_assert(alignof(UTGFTradeSearchErrorEvent) == 0x000008, "Wrong alignment on UTGFTradeSearchErrorEvent");
static_assert(sizeof(UTGFTradeSearchErrorEvent) == 0x000028, "Wrong size on UTGFTradeSearchErrorEvent");

// Class TGFGame.TGFTradeSearchAffixSelectEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradeSearchAffixSelectEvent final : public UTGFEventArgs
{
public:
	int32                                         SelectId;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SureSelect;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHomogenTrade;                                    // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSearchAffixSelectEvent">();
	}
	static class UTGFTradeSearchAffixSelectEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSearchAffixSelectEvent>();
	}
};
static_assert(alignof(UTGFTradeSearchAffixSelectEvent) == 0x000008, "Wrong alignment on UTGFTradeSearchAffixSelectEvent");
static_assert(sizeof(UTGFTradeSearchAffixSelectEvent) == 0x000030, "Wrong size on UTGFTradeSearchAffixSelectEvent");
static_assert(offsetof(UTGFTradeSearchAffixSelectEvent, SelectId) == 0x000028, "Member 'UTGFTradeSearchAffixSelectEvent::SelectId' has a wrong offset!");
static_assert(offsetof(UTGFTradeSearchAffixSelectEvent, SureSelect) == 0x00002C, "Member 'UTGFTradeSearchAffixSelectEvent::SureSelect' has a wrong offset!");
static_assert(offsetof(UTGFTradeSearchAffixSelectEvent, IsHomogenTrade) == 0x00002D, "Member 'UTGFTradeSearchAffixSelectEvent::IsHomogenTrade' has a wrong offset!");

// Class TGFGame.TGFTradeFetchOrderSuccessEvent
// 0x0010 (0x0038 - 0x0028)
class UTGFTradeFetchOrderSuccessEvent final : public UTGFEventArgs
{
public:
	TArray<int64>                                 TradeOrderTicketIdList;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeFetchOrderSuccessEvent">();
	}
	static class UTGFTradeFetchOrderSuccessEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeFetchOrderSuccessEvent>();
	}
};
static_assert(alignof(UTGFTradeFetchOrderSuccessEvent) == 0x000008, "Wrong alignment on UTGFTradeFetchOrderSuccessEvent");
static_assert(sizeof(UTGFTradeFetchOrderSuccessEvent) == 0x000038, "Wrong size on UTGFTradeFetchOrderSuccessEvent");
static_assert(offsetof(UTGFTradeFetchOrderSuccessEvent, TradeOrderTicketIdList) == 0x000028, "Member 'UTGFTradeFetchOrderSuccessEvent::TradeOrderTicketIdList' has a wrong offset!");

// Class TGFGame.TGFTradeSearchCacheClearEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeSearchCacheClearEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSearchCacheClearEvent">();
	}
	static class UTGFTradeSearchCacheClearEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSearchCacheClearEvent>();
	}
};
static_assert(alignof(UTGFTradeSearchCacheClearEvent) == 0x000008, "Wrong alignment on UTGFTradeSearchCacheClearEvent");
static_assert(sizeof(UTGFTradeSearchCacheClearEvent) == 0x000028, "Wrong size on UTGFTradeSearchCacheClearEvent");

// Class TGFGame.TGFTradeSaleMultiEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradeSaleMultiEvent final : public UTGFEventArgs
{
public:
	bool                                          IsMultiMode;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSaleMultiEvent">();
	}
	static class UTGFTradeSaleMultiEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSaleMultiEvent>();
	}
};
static_assert(alignof(UTGFTradeSaleMultiEvent) == 0x000008, "Wrong alignment on UTGFTradeSaleMultiEvent");
static_assert(sizeof(UTGFTradeSaleMultiEvent) == 0x000030, "Wrong size on UTGFTradeSaleMultiEvent");
static_assert(offsetof(UTGFTradeSaleMultiEvent, IsMultiMode) == 0x000028, "Member 'UTGFTradeSaleMultiEvent::IsMultiMode' has a wrong offset!");

// Class TGFGame.TGFTradeSaleItemSelectEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeSaleItemSelectEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSaleItemSelectEvent">();
	}
	static class UTGFTradeSaleItemSelectEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSaleItemSelectEvent>();
	}
};
static_assert(alignof(UTGFTradeSaleItemSelectEvent) == 0x000008, "Wrong alignment on UTGFTradeSaleItemSelectEvent");
static_assert(sizeof(UTGFTradeSaleItemSelectEvent) == 0x000028, "Wrong size on UTGFTradeSaleItemSelectEvent");

// Class TGFGame.TGFTradeProductSearchResponseEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductSearchResponseEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductSearchResponseEvent">();
	}
	static class UTGFTradeProductSearchResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductSearchResponseEvent>();
	}
};
static_assert(alignof(UTGFTradeProductSearchResponseEvent) == 0x000008, "Wrong alignment on UTGFTradeProductSearchResponseEvent");
static_assert(sizeof(UTGFTradeProductSearchResponseEvent) == 0x000028, "Wrong size on UTGFTradeProductSearchResponseEvent");

// Class TGFGame.TGFTradeProductSearchResponseErrorEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductSearchResponseErrorEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductSearchResponseErrorEvent">();
	}
	static class UTGFTradeProductSearchResponseErrorEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductSearchResponseErrorEvent>();
	}
};
static_assert(alignof(UTGFTradeProductSearchResponseErrorEvent) == 0x000008, "Wrong alignment on UTGFTradeProductSearchResponseErrorEvent");
static_assert(sizeof(UTGFTradeProductSearchResponseErrorEvent) == 0x000028, "Wrong size on UTGFTradeProductSearchResponseErrorEvent");

// Class TGFGame.TGFTradeProductInfoResponseEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductInfoResponseEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductInfoResponseEvent">();
	}
	static class UTGFTradeProductInfoResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductInfoResponseEvent>();
	}
};
static_assert(alignof(UTGFTradeProductInfoResponseEvent) == 0x000008, "Wrong alignment on UTGFTradeProductInfoResponseEvent");
static_assert(sizeof(UTGFTradeProductInfoResponseEvent) == 0x000028, "Wrong size on UTGFTradeProductInfoResponseEvent");

// Class TGFGame.TGFTradeProductHistoricalCurvesEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductHistoricalCurvesEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductHistoricalCurvesEvent">();
	}
	static class UTGFTradeProductHistoricalCurvesEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductHistoricalCurvesEvent>();
	}
};
static_assert(alignof(UTGFTradeProductHistoricalCurvesEvent) == 0x000008, "Wrong alignment on UTGFTradeProductHistoricalCurvesEvent");
static_assert(sizeof(UTGFTradeProductHistoricalCurvesEvent) == 0x000028, "Wrong size on UTGFTradeProductHistoricalCurvesEvent");

// Class TGFGame.TGFTradePurchaseOrderResponseEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradePurchaseOrderResponseEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradePurchaseOrderResponseEvent">();
	}
	static class UTGFTradePurchaseOrderResponseEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradePurchaseOrderResponseEvent>();
	}
};
static_assert(alignof(UTGFTradePurchaseOrderResponseEvent) == 0x000008, "Wrong alignment on UTGFTradePurchaseOrderResponseEvent");
static_assert(sizeof(UTGFTradePurchaseOrderResponseEvent) == 0x000028, "Wrong size on UTGFTradePurchaseOrderResponseEvent");

// Class TGFGame.TGFTradePurchaseOrderFailEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradePurchaseOrderFailEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradePurchaseOrderFailEvent">();
	}
	static class UTGFTradePurchaseOrderFailEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradePurchaseOrderFailEvent>();
	}
};
static_assert(alignof(UTGFTradePurchaseOrderFailEvent) == 0x000008, "Wrong alignment on UTGFTradePurchaseOrderFailEvent");
static_assert(sizeof(UTGFTradePurchaseOrderFailEvent) == 0x000030, "Wrong size on UTGFTradePurchaseOrderFailEvent");
static_assert(offsetof(UTGFTradePurchaseOrderFailEvent, ErrorCode) == 0x000028, "Member 'UTGFTradePurchaseOrderFailEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.TGFTradeSalesOrderFailEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradeSalesOrderFailEvent final : public UTGFEventArgs
{
public:
	int32                                         ErrorCode;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSalesOrderFailEvent">();
	}
	static class UTGFTradeSalesOrderFailEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSalesOrderFailEvent>();
	}
};
static_assert(alignof(UTGFTradeSalesOrderFailEvent) == 0x000008, "Wrong alignment on UTGFTradeSalesOrderFailEvent");
static_assert(sizeof(UTGFTradeSalesOrderFailEvent) == 0x000030, "Wrong size on UTGFTradeSalesOrderFailEvent");
static_assert(offsetof(UTGFTradeSalesOrderFailEvent, ErrorCode) == 0x000028, "Member 'UTGFTradeSalesOrderFailEvent::ErrorCode' has a wrong offset!");

// Class TGFGame.TGFTradeMyProductUpdateEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeMyProductUpdateEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeMyProductUpdateEvent">();
	}
	static class UTGFTradeMyProductUpdateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeMyProductUpdateEvent>();
	}
};
static_assert(alignof(UTGFTradeMyProductUpdateEvent) == 0x000008, "Wrong alignment on UTGFTradeMyProductUpdateEvent");
static_assert(sizeof(UTGFTradeMyProductUpdateEvent) == 0x000028, "Wrong size on UTGFTradeMyProductUpdateEvent");

// Class TGFGame.TGFTradeProductRecommoendEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductRecommoendEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductRecommoendEvent">();
	}
	static class UTGFTradeProductRecommoendEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductRecommoendEvent>();
	}
};
static_assert(alignof(UTGFTradeProductRecommoendEvent) == 0x000008, "Wrong alignment on UTGFTradeProductRecommoendEvent");
static_assert(sizeof(UTGFTradeProductRecommoendEvent) == 0x000028, "Wrong size on UTGFTradeProductRecommoendEvent");

// Class TGFGame.TGFTradeProductSearchClear
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductSearchClear final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductSearchClear">();
	}
	static class UTGFTradeProductSearchClear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductSearchClear>();
	}
};
static_assert(alignof(UTGFTradeProductSearchClear) == 0x000008, "Wrong alignment on UTGFTradeProductSearchClear");
static_assert(sizeof(UTGFTradeProductSearchClear) == 0x000028, "Wrong size on UTGFTradeProductSearchClear");

// Class TGFGame.TGFTradeSwitchToBlacksmithEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFTradeSwitchToBlacksmithEvent final : public UTGFEventArgs
{
public:
	int32                                         TabId;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTypeId;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeSwitchToBlacksmithEvent">();
	}
	static class UTGFTradeSwitchToBlacksmithEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeSwitchToBlacksmithEvent>();
	}
};
static_assert(alignof(UTGFTradeSwitchToBlacksmithEvent) == 0x000008, "Wrong alignment on UTGFTradeSwitchToBlacksmithEvent");
static_assert(sizeof(UTGFTradeSwitchToBlacksmithEvent) == 0x000030, "Wrong size on UTGFTradeSwitchToBlacksmithEvent");
static_assert(offsetof(UTGFTradeSwitchToBlacksmithEvent, TabId) == 0x000028, "Member 'UTGFTradeSwitchToBlacksmithEvent::TabId' has a wrong offset!");
static_assert(offsetof(UTGFTradeSwitchToBlacksmithEvent, ItemTypeId) == 0x00002C, "Member 'UTGFTradeSwitchToBlacksmithEvent::ItemTypeId' has a wrong offset!");

// Class TGFGame.TGFTradeRedSeenEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeRedSeenEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeRedSeenEvent">();
	}
	static class UTGFTradeRedSeenEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeRedSeenEvent>();
	}
};
static_assert(alignof(UTGFTradeRedSeenEvent) == 0x000008, "Wrong alignment on UTGFTradeRedSeenEvent");
static_assert(sizeof(UTGFTradeRedSeenEvent) == 0x000028, "Wrong size on UTGFTradeRedSeenEvent");

// Class TGFGame.TGFTradeActionRecommoendEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeActionRecommoendEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeActionRecommoendEvent">();
	}
	static class UTGFTradeActionRecommoendEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeActionRecommoendEvent>();
	}
};
static_assert(alignof(UTGFTradeActionRecommoendEvent) == 0x000008, "Wrong alignment on UTGFTradeActionRecommoendEvent");
static_assert(sizeof(UTGFTradeActionRecommoendEvent) == 0x000028, "Wrong size on UTGFTradeActionRecommoendEvent");

// Class TGFGame.TGFTradeProductRecommoendRefreshEvent
// 0x0000 (0x0028 - 0x0028)
class UTGFTradeProductRecommoendRefreshEvent final : public UTGFEventArgs
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFTradeProductRecommoendRefreshEvent">();
	}
	static class UTGFTradeProductRecommoendRefreshEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFTradeProductRecommoendRefreshEvent>();
	}
};
static_assert(alignof(UTGFTradeProductRecommoendRefreshEvent) == 0x000008, "Wrong alignment on UTGFTradeProductRecommoendRefreshEvent");
static_assert(sizeof(UTGFTradeProductRecommoendRefreshEvent) == 0x000028, "Wrong size on UTGFTradeProductRecommoendRefreshEvent");

// Class TGFGame.TradeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTradeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetTradeAuctionStartingPrice(int32 ProductId, int32 MarketId, bool* IsDefaultSp);
	static int32 GetTradeItemProductIdByItem(const struct FTGFItem& Item, int32 MarketId);
	static int32 GetTradeItemStartingPrice(const struct FTGFItem& Item, int32 MarketId);
	static int32 GetTradeItemTypeByProductId(int32 ProductId, int32 MarketId);
	static int32 GetTradeMarketCurrencyType(int32 TradeMarketId);
	static bool IsTradeAllowed(int32 ModuleId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeFunctionLibrary">();
	}
	static class UTradeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeFunctionLibrary>();
	}
};
static_assert(alignof(UTradeFunctionLibrary) == 0x000008, "Wrong alignment on UTradeFunctionLibrary");
static_assert(sizeof(UTradeFunctionLibrary) == 0x000028, "Wrong size on UTradeFunctionLibrary");

// Class TGFGame.TradeHomogenService
// 0x0378 (0x03A8 - 0x0030)
class UTradeHomogenService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTradeSaleOrder*>                SaleOrders;                                        // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FTGFItem>                       SelectItems;                                       // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTGFTradeMarketProductData*>     ProductDatas;                                      // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTradeProductBuyOrder*>          MyBuyOrders;                                       // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTGFTradeMarketProductData*>     SearchResults;                                     // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class UTGFTradeMarketProductData*>       RecommendResults;                                  // 0x00C8(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class UTGFTradeMarketProductData*>       INeedRecommendList;                                // 0x0118(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class UTGFTradeMarketProductData*>       HotSaleRecommendList;                              // 0x0168(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, class UTGFTradeMarketProductData*> RecommendMap;                                      // 0x01B8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<ETgfEquipQuality, struct FRecommendProductPool> INeedRecommendProductPools;                        // 0x0208(0x0050)(NativeAccessSpecifierPrivate)
	TMap<ETgfEquipQuality, struct FRecommendProductPool> HotSaleRecommendProductPools;                      // 0x0258(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UTGFTradeMarketProductData*>     AllProductDatas;                                   // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x78];                                     // 0x02B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTGFTradeProductSearchResultData> PageDataCache;                                     // 0x0330(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddSelectItem(const struct FTGFItem& Item);
	bool CheckCanReceiveRedPoint();
	bool CheckHasSoldOutRedPoint();
	void CheckSelectItems();
	void ClearSearchDataCache();
	bool ClearSelectItems();
	void ClientSearch(int32 Career, int32 MinorType, const TArray<int32>& SubTypes, int32 Rarity, int32 MinPrice, int32 MaxPrice, int32 ProductCount, int32 PageIndex, int32 Affix1, int32 Affix2, int32 Affix3);
	void ClientSearchByPage(int32 ProductCount, int32 PageIndex);
	bool ContainSelectItem(const struct FTGFItem& Item);
	int32 FindClosestIntervalValue(int32 Start, int32 End, int32 Interval, int32 Value);
	bool GetHasNextPage();
	int32 GetItemPrice(int32 ProductId);
	int32 GetLeftReceiveCount(int64 TradeOrderTicketId);
	TArray<class UTradeProductBuyOrder*> GetMyBuyOrders(int32 State);
	struct FTGFTradeProductSearchResultData GetPageDataCache(int32 PageIndex);
	class UTGFTradeMarketProductData* GetProductOrderById(int32 ProductId, int64 OrderType);
	int32 GetPublishCostType();
	TSet<class UTGFTradeMarketProductData*> GetRecommendList();
	TSet<class UTGFTradeMarketProductData*> GetRecommendResults(bool Refresh);
	TSet<class UTGFTradeMarketProductData*> GetRecommendResults_New(bool Refresh);
	TArray<class UTradeSaleOrder*> GetSaleOrders(int32 MaxCount);
	TArray<class UTGFTradeMarketProductData*> GetSearchResults();
	TArray<struct FTGFItem> GetSelectItems();
	class UTGFTradeMarketProductData* GetTradeMarketProductDataById(int32 ProductId, int64 OrderType);
	TArray<class UTGFTradeMarketProductData*> GetTradeMarketProductDatas();
	void HandleGearRepairFinish(class UTGFEventArgs* Args);
	void InitSearchProductData();
	void OnPublishProduct(const struct FTGFItem& Item, int32 Count, int32 Price);
	void ReceiveAll();
	void ReceiveProductOrder(class UTradeProductBuyOrder* BuyOrder);
	void ReceiveSaleList(const TArray<class UTradeSaleOrder*>& Orders);
	void ReceiveSaleOrder(class UTradeSaleOrder* SaleOrder);
	void RefreshSearchList(int32 PageIndex);
	bool RemoveSelectItem(const struct FTGFItem& Item);
	void ReSearchRequest();
	void SendTradeOrderHistoryRequest(const int32 MarketId);
	void SendTradeProductBasicInfoRequest(const TArray<class UTradeSaleItem*>& Items, int64 OrderType);
	void SendTradeProductOrderCancelRequest(const int64 TradeOrderTicketId);
	void SendTradeProductPriceInfoRequest(const int32 MarketId, int32 ProductId, int32 OrderType, bool bNotFireInfoRsp);
	void SendTradeProductRecommendOrderTicketRequest(bool Refresh);
	void SendTradeProductRecommendOrderTicketRequest_New();
	void SendTradePublishRequest();
	void SendTradePurchaseOrderPublishRequest(int32 ProductId, int32 Count, int32 Price, const class FString& BillNo, bool IsFixed);
	void SendTradeSaleOrderPublishRequest(int32 ProductId, int32 Count, int32 Price, const TArray<struct FTGFItem>& Items, int32 CostType, const class FString& BillNo, bool IsBatchSell);
	void SendTradeSearchRequest(int32 Career, int32 MinorType, const TArray<int32>& SubTypes, int32 Rarity, int32 MinPrice, int32 MaxPrice, int32 Affix1, int32 Affix2, int32 Affix3, class UTGFProtoTgfDTradeIndexSearchBound* Bound);
	void SetPageDataCache(int32 PageIndex, const TArray<class UTGFTradeMarketProductData*>& Datas, bool NextPage);
	void SetProductSoldOut(const int64 ProductId);
	void SetSaleMultiMode(bool MultiMode);
	void TradeProductBasicInfoReq(const TArray<class UTGFTradeMarketProductData*>& Products, int64 OrderType);
	void TradeProductBasicInfoReqByProductId(int32 ProductId, int64 OrderType);
	void TradeProductBasicInfoReqByProductIdArray(const TArray<int32>& ProductIds, int64 OrderType);
	void TradeSearchPageRequest(class UTGFProtoTgfDTradeIndexSearchBound* Bound);

	int32 GetCurrentIncome() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeHomogenService">();
	}
	static class UTradeHomogenService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeHomogenService>();
	}
};
static_assert(alignof(UTradeHomogenService) == 0x000008, "Wrong alignment on UTradeHomogenService");
static_assert(sizeof(UTradeHomogenService) == 0x0003A8, "Wrong size on UTradeHomogenService");
static_assert(offsetof(UTradeHomogenService, SaleOrders) == 0x000070, "Member 'UTradeHomogenService::SaleOrders' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, SelectItems) == 0x000080, "Member 'UTradeHomogenService::SelectItems' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, ProductDatas) == 0x000090, "Member 'UTradeHomogenService::ProductDatas' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, MyBuyOrders) == 0x0000A8, "Member 'UTradeHomogenService::MyBuyOrders' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, SearchResults) == 0x0000B8, "Member 'UTradeHomogenService::SearchResults' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, RecommendResults) == 0x0000C8, "Member 'UTradeHomogenService::RecommendResults' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, INeedRecommendList) == 0x000118, "Member 'UTradeHomogenService::INeedRecommendList' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, HotSaleRecommendList) == 0x000168, "Member 'UTradeHomogenService::HotSaleRecommendList' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, RecommendMap) == 0x0001B8, "Member 'UTradeHomogenService::RecommendMap' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, INeedRecommendProductPools) == 0x000208, "Member 'UTradeHomogenService::INeedRecommendProductPools' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, HotSaleRecommendProductPools) == 0x000258, "Member 'UTradeHomogenService::HotSaleRecommendProductPools' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, AllProductDatas) == 0x0002A8, "Member 'UTradeHomogenService::AllProductDatas' has a wrong offset!");
static_assert(offsetof(UTradeHomogenService, PageDataCache) == 0x000330, "Member 'UTradeHomogenService::PageDataCache' has a wrong offset!");

// Class TGFGame.TradeProductBuyOrder
// 0x00D8 (0x0100 - 0x0028)
class UTradeProductBuyOrder final : public UObject
{
public:
	class UTgfInventoryItemWrapper_Trade*         ItemWrapper;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0xD0];                                      // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FTGFItem GetItem();

	int64 GetBuyTime() const;
	bool GetIsFixedOrder() const;
	int32 GetItemTypeId() const;
	int32 GetOriginItemCount() const;
	int32 GetPurchaseLeftCount() const;
	int32 GetPurchaseLeftPrice() const;
	int32 GetPurchaseOriginItemCount() const;
	int32 GetPurchaseOriginPrice() const;
	int32 GetPurchaseUnitPrice() const;
	int64 GetRealDealTime() const;
	int32 GetTradeItemProductId() const;
	int64 GetTradeProductTicketId() const;
	int64 GetTradeTicketState() const;
	int32 GetUnitPrice() const;
	bool IsPartDeal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeProductBuyOrder">();
	}
	static class UTradeProductBuyOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeProductBuyOrder>();
	}
};
static_assert(alignof(UTradeProductBuyOrder) == 0x000008, "Wrong alignment on UTradeProductBuyOrder");
static_assert(sizeof(UTradeProductBuyOrder) == 0x000100, "Wrong size on UTradeProductBuyOrder");
static_assert(offsetof(UTradeProductBuyOrder, ItemWrapper) == 0x000028, "Member 'UTradeProductBuyOrder::ItemWrapper' has a wrong offset!");

// Class TGFGame.TradeSaleItem
// 0x0068 (0x0090 - 0x0028)
class UTradeSaleItem final : public UObject
{
public:
	int32                                         ItemTypeId;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTGFItem                               Item;                                              // 0x0030(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTgfInventoryItemWrapper_Lobby*         ItemWrapper;                                       // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsCorruptionItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeSaleItem">();
	}
	static class UTradeSaleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeSaleItem>();
	}
};
static_assert(alignof(UTradeSaleItem) == 0x000008, "Wrong alignment on UTradeSaleItem");
static_assert(sizeof(UTradeSaleItem) == 0x000090, "Wrong size on UTradeSaleItem");
static_assert(offsetof(UTradeSaleItem, ItemTypeId) == 0x000028, "Member 'UTradeSaleItem::ItemTypeId' has a wrong offset!");
static_assert(offsetof(UTradeSaleItem, Item) == 0x000030, "Member 'UTradeSaleItem::Item' has a wrong offset!");
static_assert(offsetof(UTradeSaleItem, ItemWrapper) == 0x000088, "Member 'UTradeSaleItem::ItemWrapper' has a wrong offset!");

// Class TGFGame.TradeSearchResultOrder
// 0x0128 (0x0150 - 0x0028)
class UTradeSearchResultOrder final : public UObject
{
public:
	class UTgfInventoryItemWrapper_Lobby*         ItemWrapper;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   SourceType;                                        // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0xD0];                                      // 0x0080(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FTGFItem GetItem();
	class UTgfInventoryItemWrapper_Lobby* GetItemWrapper();
	TArray<int32> GetSourceTypes();
	bool IsCorruptionItem();

	int32 GetCurrentBidPrice() const;
	int32 GetFixedPrice() const;
	int32 GetItemRarity() const;
	int32 GetItemTypeId() const;
	int64 GetRemainTime() const;
	int64 GetSpScore() const;
	int32 GetStartingPrice() const;
	ETradeSaleOrderState GetState() const;
	int32 GetTradeItemProductId() const;
	int64 GetTradeOrderTicketId() const;
	bool IsMyAuctionOrder() const;
	bool IsMyBidOrderAndCurrentWinning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeSearchResultOrder">();
	}
	static class UTradeSearchResultOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeSearchResultOrder>();
	}
};
static_assert(alignof(UTradeSearchResultOrder) == 0x000008, "Wrong alignment on UTradeSearchResultOrder");
static_assert(sizeof(UTradeSearchResultOrder) == 0x000150, "Wrong size on UTradeSearchResultOrder");
static_assert(offsetof(UTradeSearchResultOrder, ItemWrapper) == 0x000028, "Member 'UTradeSearchResultOrder::ItemWrapper' has a wrong offset!");
static_assert(offsetof(UTradeSearchResultOrder, SourceType) == 0x000030, "Member 'UTradeSearchResultOrder::SourceType' has a wrong offset!");

// Class TGFGame.TradeService
// 0x0110 (0x0140 - 0x0030)
class UTradeService final : public UTGFService
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTradeSaleOrder*>                SaleOrders;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTradeBidOrder*>                 MyBidOrders;                                       // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTGFTradeMarketProductData*>     ProductDatas;                                      // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BidOrder(class UTradeSearchResultOrder* Order, int32 BidPrice);
	void CancelSaleOrder(class UTradeSaleOrder* SaleOrder);
	bool CheckHaveBidOutAuction();
	bool CheckHaveBidSuccessAuction();
	bool CheckHaveOutBidRedPoint();
	bool CheckHaveSellRedPoint();
	void DeleteBidOrder(class UTradeBidOrder* BidOrder);
	int32 GetBagTabPageIndex();
	int32 GetInventoryPageIndex();
	TArray<class UTradeBidOrder*> GetMyBidOrders(ETradeBidOrderState State);
	int32 GetReceiveOrderPendingSize(int64 TradeOrderTicketId);
	TArray<class UTradeSaleOrder*> GetSaleOrders(int32 MaxCount);
	bool GetTradeIsUnlock();
	class UTGFTradeMarketProductData* GetTradeMarketProductDataById(int32 ProductId);
	bool GetTradeUnlockIsClicked();
	int64 GetTradeUnlockTimeStamp();
	void OnGameLogout(class UTGFEventArgs* Args);
	void ReceiveBidOrder(class UTradeBidOrder* BidOrder);
	void ReceiveSaleList(const TArray<class UTradeSaleOrder*>& Orders);
	void ReceiveSaleOrder(class UTradeSaleOrder* SaleOrder);
	void RefreshBidOrderDetail();
	void RefreshOrderInfoForBid(class UTradeSearchResultOrder* Order);
	void RefreshOrderInfoForOutBidOrders();
	void ReportBagTabState(int32 PageIndex);
	void SendTradeAuctionBasicInfoRequest(const TArray<class UTradeSaleItem*>& Items);
	void SetBidRedPointSeen(bool HasSeen);
	void SetCurControlType(int32 Type);
	void SetInventoryPageIndex(int32 PageIndex, int32 Type);
	void SetSellRedPointSeen(bool HasSeen);
	void SetTradeUnlockClickState(bool IsClickToClick);
	void SetTradeUnlockTimeStamp(int64 Timestamp);

	int32 GetCurrentIncome() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeService">();
	}
	static class UTradeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeService>();
	}
};
static_assert(alignof(UTradeService) == 0x000008, "Wrong alignment on UTradeService");
static_assert(sizeof(UTradeService) == 0x000140, "Wrong size on UTradeService");
static_assert(offsetof(UTradeService, SaleOrders) == 0x0000E8, "Member 'UTradeService::SaleOrders' has a wrong offset!");
static_assert(offsetof(UTradeService, MyBidOrders) == 0x0000F8, "Member 'UTradeService::MyBidOrders' has a wrong offset!");
static_assert(offsetof(UTradeService, ProductDatas) == 0x000110, "Member 'UTradeService::ProductDatas' has a wrong offset!");

// Class TGFGame.TrialBattleRecordsData
// 0x0030 (0x0058 - 0x0028)
class UTrialBattleRecordsData final : public UObject
{
public:
	int32                                         Status;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinCount;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailedCount;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTrialChallengesSingleLevelData*> ChallengesData;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SelfQuit;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GradeId;                                           // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundId;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeTimes;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrialBattleRecordsData">();
	}
	static class UTrialBattleRecordsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrialBattleRecordsData>();
	}
};
static_assert(alignof(UTrialBattleRecordsData) == 0x000008, "Wrong alignment on UTrialBattleRecordsData");
static_assert(sizeof(UTrialBattleRecordsData) == 0x000058, "Wrong size on UTrialBattleRecordsData");
static_assert(offsetof(UTrialBattleRecordsData, Status) == 0x000028, "Member 'UTrialBattleRecordsData::Status' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, WinCount) == 0x00002C, "Member 'UTrialBattleRecordsData::WinCount' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, FailedCount) == 0x000030, "Member 'UTrialBattleRecordsData::FailedCount' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, ChallengesData) == 0x000038, "Member 'UTrialBattleRecordsData::ChallengesData' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, SelfQuit) == 0x000048, "Member 'UTrialBattleRecordsData::SelfQuit' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, GradeId) == 0x00004C, "Member 'UTrialBattleRecordsData::GradeId' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, RoundId) == 0x000050, "Member 'UTrialBattleRecordsData::RoundId' has a wrong offset!");
static_assert(offsetof(UTrialBattleRecordsData, ChallengeTimes) == 0x000054, "Member 'UTrialBattleRecordsData::ChallengeTimes' has a wrong offset!");

// Class TGFGame.UnlockBanWindow
// 0x0008 (0x02C0 - 0x02B8)
class UUnlockBanWindow final : public UTGFWindow
{
public:
	class UUnlockBanWindowArgs*                   UnlockBanWindowArgs;                               // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ExecuteConfirm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockBanWindow">();
	}
	static class UUnlockBanWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockBanWindow>();
	}
};
static_assert(alignof(UUnlockBanWindow) == 0x000008, "Wrong alignment on UUnlockBanWindow");
static_assert(sizeof(UUnlockBanWindow) == 0x0002C0, "Wrong size on UUnlockBanWindow");
static_assert(offsetof(UUnlockBanWindow, UnlockBanWindowArgs) == 0x0002B8, "Member 'UUnlockBanWindow::UnlockBanWindowArgs' has a wrong offset!");

// Class TGFGame.TGFUnlockModuleDirtyEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFUnlockModuleDirtyEvent final : public UTGFEventArgs
{
public:
	int32                                         ModuleId;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFUnlockModuleDirtyEvent">();
	}
	static class UTGFUnlockModuleDirtyEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFUnlockModuleDirtyEvent>();
	}
};
static_assert(alignof(UTGFUnlockModuleDirtyEvent) == 0x000008, "Wrong alignment on UTGFUnlockModuleDirtyEvent");
static_assert(sizeof(UTGFUnlockModuleDirtyEvent) == 0x000030, "Wrong size on UTGFUnlockModuleDirtyEvent");
static_assert(offsetof(UTGFUnlockModuleDirtyEvent, ModuleId) == 0x000028, "Member 'UTGFUnlockModuleDirtyEvent::ModuleId' has a wrong offset!");

// Class TGFGame.UpdateConfigBytesService
// 0x0110 (0x0140 - 0x0030)
class UUpdateConfigBytesService final : public UTGFService
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StrHotUpdateKey;                                   // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BSetHotUpdatePath;                                 // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CdnHotUpdatePath;                                  // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0xE0];                                      // 0x0060(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckUseUpdateConfigBytes(class FString* StrServerVersion);
	void HandleRainbowConfig(class UTGFEventArgs* Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateConfigBytesService">();
	}
	static class UUpdateConfigBytesService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateConfigBytesService>();
	}
};
static_assert(alignof(UUpdateConfigBytesService) == 0x000008, "Wrong alignment on UUpdateConfigBytesService");
static_assert(sizeof(UUpdateConfigBytesService) == 0x000140, "Wrong size on UUpdateConfigBytesService");
static_assert(offsetof(UUpdateConfigBytesService, StrHotUpdateKey) == 0x000038, "Member 'UUpdateConfigBytesService::StrHotUpdateKey' has a wrong offset!");
static_assert(offsetof(UUpdateConfigBytesService, BSetHotUpdatePath) == 0x000048, "Member 'UUpdateConfigBytesService::BSetHotUpdatePath' has a wrong offset!");
static_assert(offsetof(UUpdateConfigBytesService, CdnHotUpdatePath) == 0x000050, "Member 'UUpdateConfigBytesService::CdnHotUpdatePath' has a wrong offset!");

// Class TGFGame.URoleAttributeDefensiveInfo
// 0x0068 (0x0090 - 0x0028)
class UURoleAttributeDefensiveInfo final : public UObject
{
public:
	float                                         DefenseLevel;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardedDamageNegation;                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalResistance;                                // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireResistance;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColdResistance;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningResistance;                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivineResistance;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowResistance;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionfromElites;                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionfromControlledEnemies;              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldBonus;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldReceiveRate;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenerationpersecond;                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenerationonKill;                          // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenerationonHit;                           // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeLeechonHit;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealBonus;                                         // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealBoostRate;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealReceiveRate;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldBoostRate;                                   // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllElementResistance;                              // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealthPercent;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReduceRate;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageVulnerRate;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealWoundRate;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"URoleAttributeDefensiveInfo">();
	}
	static class UURoleAttributeDefensiveInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UURoleAttributeDefensiveInfo>();
	}
};
static_assert(alignof(UURoleAttributeDefensiveInfo) == 0x000008, "Wrong alignment on UURoleAttributeDefensiveInfo");
static_assert(sizeof(UURoleAttributeDefensiveInfo) == 0x000090, "Wrong size on UURoleAttributeDefensiveInfo");
static_assert(offsetof(UURoleAttributeDefensiveInfo, DefenseLevel) == 0x000028, "Member 'UURoleAttributeDefensiveInfo::DefenseLevel' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, GuardedDamageNegation) == 0x00002C, "Member 'UURoleAttributeDefensiveInfo::GuardedDamageNegation' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, PhysicalResistance) == 0x000030, "Member 'UURoleAttributeDefensiveInfo::PhysicalResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, FireResistance) == 0x000034, "Member 'UURoleAttributeDefensiveInfo::FireResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, ColdResistance) == 0x000038, "Member 'UURoleAttributeDefensiveInfo::ColdResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, LightningResistance) == 0x00003C, "Member 'UURoleAttributeDefensiveInfo::LightningResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, DivineResistance) == 0x000040, "Member 'UURoleAttributeDefensiveInfo::DivineResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, ShadowResistance) == 0x000044, "Member 'UURoleAttributeDefensiveInfo::ShadowResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, DamageReductionfromElites) == 0x000048, "Member 'UURoleAttributeDefensiveInfo::DamageReductionfromElites' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, DamageReductionfromControlledEnemies) == 0x00004C, "Member 'UURoleAttributeDefensiveInfo::DamageReductionfromControlledEnemies' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, ShieldBonus) == 0x000050, "Member 'UURoleAttributeDefensiveInfo::ShieldBonus' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, ShieldReceiveRate) == 0x000054, "Member 'UURoleAttributeDefensiveInfo::ShieldReceiveRate' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealthRegenerationpersecond) == 0x000058, "Member 'UURoleAttributeDefensiveInfo::HealthRegenerationpersecond' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealthRegenerationonKill) == 0x00005C, "Member 'UURoleAttributeDefensiveInfo::HealthRegenerationonKill' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealthRegenerationonHit) == 0x000060, "Member 'UURoleAttributeDefensiveInfo::HealthRegenerationonHit' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, LifeLeechonHit) == 0x000064, "Member 'UURoleAttributeDefensiveInfo::LifeLeechonHit' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealBonus) == 0x000068, "Member 'UURoleAttributeDefensiveInfo::HealBonus' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealBoostRate) == 0x00006C, "Member 'UURoleAttributeDefensiveInfo::HealBoostRate' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealReceiveRate) == 0x000070, "Member 'UURoleAttributeDefensiveInfo::HealReceiveRate' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, ShieldBoostRate) == 0x000074, "Member 'UURoleAttributeDefensiveInfo::ShieldBoostRate' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, AllElementResistance) == 0x000078, "Member 'UURoleAttributeDefensiveInfo::AllElementResistance' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, MaxHealthPercent) == 0x00007C, "Member 'UURoleAttributeDefensiveInfo::MaxHealthPercent' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, DamageReduceRate) == 0x000080, "Member 'UURoleAttributeDefensiveInfo::DamageReduceRate' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, DamageVulnerRate) == 0x000084, "Member 'UURoleAttributeDefensiveInfo::DamageVulnerRate' has a wrong offset!");
static_assert(offsetof(UURoleAttributeDefensiveInfo, HealWoundRate) == 0x000088, "Member 'UURoleAttributeDefensiveInfo::HealWoundRate' has a wrong offset!");

// Class TGFGame.TGFUpdateUserInfoEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFUpdateUserInfoEvent final : public UTGFEventArgs
{
public:
	class UUserInfo*                              UserInfo;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFUpdateUserInfoEvent">();
	}
	static class UTGFUpdateUserInfoEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFUpdateUserInfoEvent>();
	}
};
static_assert(alignof(UTGFUpdateUserInfoEvent) == 0x000008, "Wrong alignment on UTGFUpdateUserInfoEvent");
static_assert(sizeof(UTGFUpdateUserInfoEvent) == 0x000030, "Wrong size on UTGFUpdateUserInfoEvent");
static_assert(offsetof(UTGFUpdateUserInfoEvent, UserInfo) == 0x000028, "Member 'UTGFUpdateUserInfoEvent::UserInfo' has a wrong offset!");

// Class TGFGame.TGFUpdateGlobalUserInfoEvent
// 0x0008 (0x0030 - 0x0028)
class UTGFUpdateGlobalUserInfoEvent final : public UTGFEventArgs
{
public:
	class UGlobalUserInfo*                        GlobalUserInfo;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFUpdateGlobalUserInfoEvent">();
	}
	static class UTGFUpdateGlobalUserInfoEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFUpdateGlobalUserInfoEvent>();
	}
};
static_assert(alignof(UTGFUpdateGlobalUserInfoEvent) == 0x000008, "Wrong alignment on UTGFUpdateGlobalUserInfoEvent");
static_assert(sizeof(UTGFUpdateGlobalUserInfoEvent) == 0x000030, "Wrong size on UTGFUpdateGlobalUserInfoEvent");
static_assert(offsetof(UTGFUpdateGlobalUserInfoEvent, GlobalUserInfo) == 0x000028, "Member 'UTGFUpdateGlobalUserInfoEvent::GlobalUserInfo' has a wrong offset!");

// Class TGFGame.TGFCdnResponseSuccess
// 0x0098 (0x00C0 - 0x0028)
class UTGFCdnResponseSuccess final : public UTGFEventArgs
{
public:
	struct FTGFRegionDetailData                   Content;                                           // 0x0028(0x0098)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFCdnResponseSuccess">();
	}
	static class UTGFCdnResponseSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFCdnResponseSuccess>();
	}
};
static_assert(alignof(UTGFCdnResponseSuccess) == 0x000008, "Wrong alignment on UTGFCdnResponseSuccess");
static_assert(sizeof(UTGFCdnResponseSuccess) == 0x0000C0, "Wrong size on UTGFCdnResponseSuccess");
static_assert(offsetof(UTGFCdnResponseSuccess, Content) == 0x000028, "Member 'UTGFCdnResponseSuccess::Content' has a wrong offset!");

// Class TGFGame.TGFGameSettingKeyBinding
// 0x0068 (0x01D0 - 0x0168)
class UTGFGameSettingKeyBinding final : public UGameSettingValue
{
public:
	uint8                                         Pad_168[0x68];                                     // 0x0168(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFGameSettingKeyBinding">();
	}
	static class UTGFGameSettingKeyBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFGameSettingKeyBinding>();
	}
};
static_assert(alignof(UTGFGameSettingKeyBinding) == 0x000008, "Wrong alignment on UTGFGameSettingKeyBinding");
static_assert(sizeof(UTGFGameSettingKeyBinding) == 0x0001D0, "Wrong size on UTGFGameSettingKeyBinding");

// Class TGFGame.TGFSettingScreen
// 0x0068 (0x04C8 - 0x0460)
class UTGFSettingScreen final : public UGameSettingScreen
{
public:
	class ULyraTabListWidgetBase*                 TopSettingsTabs;                                   // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ButtonReset;                                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           SettingSubwin;                                     // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            SettingBottomHint;                                 // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    BackInputActionData;                               // 0x0480(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ApplyInputActionData;                              // 0x0490(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    CancelChangesInputActionData;                      // 0x04A0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnResetButtonClicked();
	void HandleSettingKeyBindingActivate(class UTGFEventArgs* Args);
	void HandleSettingKeyBindingDeactivate(class UTGFEventArgs* Args);
	void HandleToggleFullScreenCommand(bool bValue);
	void NavigateToSettingTab(class FName SettingDevName);

	class FString GetMapName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TGFSettingScreen">();
	}
	static class UTGFSettingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTGFSettingScreen>();
	}
};
static_assert(alignof(UTGFSettingScreen) == 0x000008, "Wrong alignment on UTGFSettingScreen");
static_assert(sizeof(UTGFSettingScreen) == 0x0004C8, "Wrong size on UTGFSettingScreen");
static_assert(offsetof(UTGFSettingScreen, TopSettingsTabs) == 0x000460, "Member 'UTGFSettingScreen::TopSettingsTabs' has a wrong offset!");
static_assert(offsetof(UTGFSettingScreen, ButtonReset) == 0x000468, "Member 'UTGFSettingScreen::ButtonReset' has a wrong offset!");
static_assert(offsetof(UTGFSettingScreen, SettingSubwin) == 0x000470, "Member 'UTGFSettingScreen::SettingSubwin' has a wrong offset!");
static_assert(offsetof(UTGFSettingScreen, SettingBottomHint) == 0x000478, "Member 'UTGFSettingScreen::SettingBottomHint' has a wrong offset!");
static_assert(offsetof(UTGFSettingScreen, BackInputActionData) == 0x000480, "Member 'UTGFSettingScreen::BackInputActionData' has a wrong offset!");
static_assert(offsetof(UTGFSettingScreen, ApplyInputActionData) == 0x000490, "Member 'UTGFSettingScreen::ApplyInputActionData' has a wrong offset!");
static_assert(offsetof(UTGFSettingScreen, CancelChangesInputActionData) == 0x0004A0, "Member 'UTGFSettingScreen::CancelChangesInputActionData' has a wrong offset!");

}

