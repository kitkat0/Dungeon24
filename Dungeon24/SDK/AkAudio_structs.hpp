#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AkAudio

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "MovieScene_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum AkAudio.EAkResult
// NumValues: 0x003B
enum class EAkResult : uint8
{
	NotImplemented                           = 0,
	Success                                  = 1,
	Fail                                     = 2,
	PartialSuccess                           = 3,
	NotCompatible                            = 4,
	AlreadyConnected                         = 5,
	InvalidFile                              = 7,
	AudioFileHeaderTooLarge                  = 8,
	MaxReached                               = 9,
	InvalidID                                = 14,
	IDNotFound                               = 15,
	InvalidInstanceID                        = 16,
	NoMoreData                               = 17,
	InvalidStateGroup                        = 20,
	ChildAlreadyHasAParent                   = 21,
	InvalidLanguage                          = 22,
	CannotAddItseflAsAChild                  = 23,
	InvalidParameter                         = 31,
	ElementAlreadyInList                     = 35,
	PathNotFound                             = 36,
	PathNoVertices                           = 37,
	PathNotRunning                           = 38,
	PathNotPaused                            = 39,
	PathNodeAlreadyInList                    = 40,
	PathNodeNotInList                        = 41,
	DataNeeded                               = 43,
	NoDataNeeded                             = 44,
	DataReady                                = 45,
	NoDataReady                              = 46,
	InsufficientMemory                       = 52,
	Cancelled                                = 53,
	UnknownBankID                            = 54,
	BankReadError                            = 56,
	InvalidSwitchType                        = 57,
	FormatNotReady                           = 63,
	WrongBankVersion                         = 64,
	FileNotFound                             = 66,
	DeviceNotReady                           = 67,
	BankAlreadyLoaded                        = 69,
	RenderedFX                               = 71,
	ProcessNeeded                            = 72,
	ProcessDone                              = 73,
	MemManagerNotInitialized                 = 74,
	StreamMgrNotInitialized                  = 75,
	SSEInstructionsNotSupported              = 76,
	Busy                                     = 77,
	UnsupportedChannelConfig                 = 78,
	PluginMediaNotAvailable                  = 79,
	MustBeVirtualized                        = 80,
	CommandTooLarge                          = 81,
	RejectedByFilter                         = 82,
	InvalidCustomPlatformName                = 83,
	DLLCannotLoad                            = 84,
	DLLPathNotFound                          = 85,
	NoJavaVM                                 = 86,
	OpenSLError                              = 87,
	PluginNotRegistered                      = 88,
	DataAlignmentError                       = 89,
	EAkResult_MAX                            = 90,
};

// Enum AkAudio.EAkCallbackType
// NumValues: 0x000E
enum class EAkCallbackType : uint8
{
	EndOfEvent                               = 0,
	Marker                                   = 2,
	Duration                                 = 3,
	Starvation                               = 5,
	MusicPlayStarted                         = 7,
	MusicSyncBeat                            = 8,
	MusicSyncBar                             = 9,
	MusicSyncEntry                           = 10,
	MusicSyncExit                            = 11,
	MusicSyncGrid                            = 12,
	MusicSyncUserCue                         = 13,
	MusicSyncPoint                           = 14,
	MIDIEvent                                = 16,
	EAkCallbackType_MAX                      = 17,
};

// Enum AkAudio.EAkAndroidAudioAPI
// NumValues: 0x0003
enum class EAkAndroidAudioAPI : uint8
{
	AAudio                                   = 0,
	OpenSL_ES                                = 1,
	EAkAndroidAudioAPI_MAX                   = 2,
};

// Enum AkAudio.EAkAudioSessionCategory
// NumValues: 0x0004
enum class EAkAudioSessionCategory : uint32
{
	Ambient                                  = 0,
	SoloAmbient                              = 1,
	PlayAndRecord                            = 2,
	EAkAudioSessionCategory_MAX              = 3,
};

// Enum AkAudio.EAkAudioSessionCategoryOptions
// NumValues: 0x0005
enum class EAkAudioSessionCategoryOptions : uint8
{
	MixWithOthers                            = 0,
	DuckOthers                               = 1,
	AllowBluetooth                           = 2,
	DefaultToSpeaker                         = 3,
	EAkAudioSessionCategoryOptions_MAX       = 4,
};

// Enum AkAudio.EAkAudioSessionMode
// NumValues: 0x0008
enum class EAkAudioSessionMode : uint32
{
	Default                                  = 0,
	VoiceChat                                = 1,
	GameChat                                 = 2,
	VideoRecording                           = 3,
	Measurement                              = 4,
	MoviePlayback                            = 5,
	VideoChat                                = 6,
	EAkAudioSessionMode_MAX                  = 7,
};

// Enum AkAudio.EReflectionFilterBits
// NumValues: 0x0004
enum class EReflectionFilterBits : uint8
{
	Wall                                     = 0,
	Ceiling                                  = 1,
	Floor                                    = 2,
	EReflectionFilterBits_MAX                = 3,
};

// Enum AkAudio.EAkAudioContext
// NumValues: 0x0005
enum class EAkAudioContext : uint8
{
	Foreign                                  = 0,
	GameplayAudio                            = 1,
	EditorAudio                              = 2,
	AlwaysActive                             = 3,
	EAkAudioContext_MAX                      = 4,
};

// Enum AkAudio.PanningRule
// NumValues: 0x0003
enum class EPanningRule : uint8
{
	PanningRule_Speakers                     = 0,
	PanningRule_Headphones                   = 1,
	PanningRule_MAX                          = 2,
};

// Enum AkAudio.AkAcousticPortalState
// NumValues: 0x0003
enum class EAkAcousticPortalState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	AkAcousticPortalState_MAX                = 2,
};

// Enum AkAudio.AkChannelConfiguration
// NumValues: 0x001C
enum class EAkChannelConfiguration : uint8
{
	Ak_Parent                                = 0,
	Ak_MainMix                               = 1,
	Ak_Passthrough                           = 2,
	Ak_LFE                                   = 3,
	AK_Audio_Objects                         = 4,
	Ak_1_0                                   = 5,
	Ak_2_0                                   = 6,
	Ak_2_1                                   = 7,
	Ak_3_0                                   = 8,
	Ak_3_1                                   = 9,
	Ak_4_0                                   = 10,
	Ak_4_1                                   = 11,
	Ak_5_0                                   = 12,
	Ak_5_1                                   = 13,
	Ak_7_1                                   = 14,
	Ak_5_1_2                                 = 15,
	Ak_7_1_2                                 = 16,
	Ak_7_1_4                                 = 17,
	Ak_Auro_9_1                              = 18,
	Ak_Auro_10_1                             = 19,
	Ak_Auro_11_1                             = 20,
	Ak_Auro_13_1                             = 21,
	Ak_Ambisonics_1st_order                  = 22,
	Ak_Ambisonics_2nd_order                  = 23,
	Ak_Ambisonics_3rd_order                  = 24,
	Ak_Ambisonics_4th_order                  = 25,
	Ak_Ambisonics_5th_order                  = 26,
	AkChannelConfiguration_MAX               = 27,
};

// Enum AkAudio.AkSpeakerConfiguration
// NumValues: 0x0011
enum class EAkSpeakerConfiguration : uint32
{
	Ak_Speaker_Front_Left                    = 1,
	Ak_Speaker_Front_Right                   = 2,
	Ak_Speaker_Front_Center                  = 4,
	Ak_Speaker_Low_Frequency                 = 8,
	Ak_Speaker_Back_Left                     = 16,
	Ak_Speaker_Back_Right                    = 32,
	Ak_Speaker_Back_Center                   = 256,
	Ak_Speaker_Side_Left                     = 512,
	Ak_Speaker_Side_Right                    = 1024,
	Ak_Speaker_Top                           = 2048,
	Ak_Speaker_Height_Front_Left             = 4096,
	Ak_Speaker_Height_Front_Center           = 8192,
	Ak_Speaker_Height_Front_Right            = 16384,
	Ak_Speaker_Height_Back_Left              = 32768,
	Ak_Speaker_Height_Back_Center            = 65536,
	Ak_Speaker_Height_Back_Right             = 131072,
	Ak_Speaker_MAX                           = 131073,
};

// Enum AkAudio.AkMultiPositionType
// NumValues: 0x0004
enum class EAkMultiPositionType : uint8
{
	SingleSource                             = 0,
	MultiSources                             = 1,
	MultiDirections                          = 2,
	AkMultiPositionType_MAX                  = 3,
};

// Enum AkAudio.AkActionOnEventType
// NumValues: 0x0006
enum class EAkActionOnEventType : uint8
{
	Stop                                     = 0,
	Pause                                    = 1,
	Resume                                   = 2,
	Break                                    = 3,
	ReleaseEnvelope                          = 4,
	AkActionOnEventType_MAX                  = 5,
};

// Enum AkAudio.EAkCurveInterpolation
// NumValues: 0x000C
enum class EAkCurveInterpolation : uint8
{
	Log3                                     = 0,
	Sine                                     = 1,
	Log1                                     = 2,
	InvSCurve                                = 3,
	Linear                                   = 4,
	SCurve                                   = 5,
	Exp1                                     = 6,
	SineRecip                                = 7,
	Exp3                                     = 8,
	LastFadeCurve                            = 8,
	Constant                                 = 9,
	EAkCurveInterpolation_MAX                = 10,
};

// Enum AkAudio.ERTPCValueType
// NumValues: 0x0006
enum class ERTPCValueType : uint8
{
	Default                                  = 0,
	Global                                   = 1,
	GameObject                               = 2,
	PlayingID                                = 3,
	Unavailable                              = 4,
	ERTPCValueType_MAX                       = 5,
};

// Enum AkAudio.EAkMidiEventType
// NumValues: 0x000C
enum class EAkMidiEventType : uint8
{
	AkMidiEventTypeInvalid                   = 0,
	AkMidiEventTypeNoteOff                   = 128,
	AkMidiEventTypeNoteOn                    = 144,
	AkMidiEventTypeNoteAftertouch            = 160,
	AkMidiEventTypeController                = 176,
	AkMidiEventTypeProgramChange             = 192,
	AkMidiEventTypeChannelAftertouch         = 208,
	AkMidiEventTypePitchBend                 = 224,
	AkMidiEventTypeSysex                     = 240,
	AkMidiEventTypeEscape                    = 247,
	AkMidiEventTypeMeta                      = 255,
	EAkMidiEventType_MAX                     = 256,
};

// Enum AkAudio.EAkMidiCcValues
// NumValues: 0x0062
enum class EAkMidiCcValues : uint8
{
	AkMidiCcBankSelectCoarse                 = 0,
	AkMidiCcModWheelCoarse                   = 1,
	AkMidiCcBreathCtrlCoarse                 = 2,
	AkMidiCcCtrl3Coarse                      = 3,
	AkMidiCcFootPedalCoarse                  = 4,
	AkMidiCcPortamentoCoarse                 = 5,
	AkMidiCcDataEntryCoarse                  = 6,
	AkMidiCcVolumeCoarse                     = 7,
	AkMidiCcBalanceCoarse                    = 8,
	AkMidiCcCtrl9Coarse                      = 9,
	AkMidiCcPanPositionCoarse                = 10,
	AkMidiCcExpressionCoarse                 = 11,
	AkMidiCcEffectCtrl1Coarse                = 12,
	AkMidiCcEffectCtrl2Coarse                = 13,
	AkMidiCcCtrl14Coarse                     = 14,
	AkMidiCcCtrl15Coarse                     = 15,
	AkMidiCcGenSlider1                       = 16,
	AkMidiCcGenSlider2                       = 17,
	AkMidiCcGenSlider3                       = 18,
	AkMidiCcGenSlider4                       = 19,
	AkMidiCcCtrl20Coarse                     = 20,
	AkMidiCcCtrl21Coarse                     = 21,
	AkMidiCcCtrl22Coarse                     = 22,
	AkMidiCcCtrl23Coarse                     = 23,
	AkMidiCcCtrl24Coarse                     = 24,
	AkMidiCcCtrl25Coarse                     = 25,
	AkMidiCcCtrl26Coarse                     = 26,
	AkMidiCcCtrl27Coarse                     = 27,
	AkMidiCcCtrl28Coarse                     = 28,
	AkMidiCcCtrl29Coarse                     = 29,
	AkMidiCcCtrl30Coarse                     = 30,
	AkMidiCcCtrl31Coarse                     = 31,
	AkMidiCcBankSelectFine                   = 32,
	AkMidiCcModWheelFine                     = 33,
	AkMidiCcBreathCtrlFine                   = 34,
	AkMidiCcCtrl3Fine                        = 35,
	AkMidiCcFootPedalFine                    = 36,
	AkMidiCcPortamentoFine                   = 37,
	AkMidiCcDataEntryFine                    = 38,
	AkMidiCcVolumeFine                       = 39,
	AkMidiCcBalanceFine                      = 40,
	AkMidiCcCtrl9Fine                        = 41,
	AkMidiCcPanPositionFine                  = 42,
	AkMidiCcExpressionFine                   = 43,
	AkMidiCcEffectCtrl1Fine                  = 44,
	AkMidiCcEffectCtrl2Fine                  = 45,
	AkMidiCcCtrl14Fine                       = 46,
	AkMidiCcCtrl15Fine                       = 47,
	AkMidiCcCtrl20Fine                       = 52,
	AkMidiCcCtrl21Fine                       = 53,
	AkMidiCcCtrl22Fine                       = 54,
	AkMidiCcCtrl23Fine                       = 55,
	AkMidiCcCtrl24Fine                       = 56,
	AkMidiCcCtrl25Fine                       = 57,
	AkMidiCcCtrl26Fine                       = 58,
	AkMidiCcCtrl27Fine                       = 59,
	AkMidiCcCtrl28Fine                       = 60,
	AkMidiCcCtrl29Fine                       = 61,
	AkMidiCcCtrl30Fine                       = 62,
	AkMidiCcCtrl31Fine                       = 63,
	AkMidiCcHoldPedal                        = 64,
	AkMidiCcPortamentoOnOff                  = 65,
	AkMidiCcSustenutoPedal                   = 66,
	AkMidiCcSoftPedal                        = 67,
	AkMidiCcLegatoPedal                      = 68,
	AkMidiCcHoldPedal2                       = 69,
	AkMidiCcSoundVariation                   = 70,
	AkMidiCcSoundTimbre                      = 71,
	AkMidiCcSoundReleaseTime                 = 72,
	AkMidiCcSoundAttackTime                  = 73,
	AkMidiCcSoundBrightness                  = 74,
	AkMidiCcSoundCtrl6                       = 75,
	AkMidiCcSoundCtrl7                       = 76,
	AkMidiCcSoundCtrl8                       = 77,
	AkMidiCcSoundCtrl9                       = 78,
	AkMidiCcSoundCtrl10                      = 79,
	AkMidiCcGeneralButton1                   = 80,
	AkMidiCcGeneralButton2                   = 81,
	AkMidiCcGeneralButton3                   = 82,
	AkMidiCcGeneralButton4                   = 83,
	AkMidiCcReverbLevel                      = 91,
	AkMidiCcTremoloLevel                     = 92,
	AkMidiCcChorusLevel                      = 93,
	AkMidiCcCelesteLevel                     = 94,
	AkMidiCcPhaserLevel                      = 95,
	AkMidiCcDataButtonP1                     = 96,
	AkMidiCcDataButtonM1                     = 97,
	AkMidiCcNonRegisterCoarse                = 98,
	AkMidiCcNonRegisterFine                  = 99,
	AkMidiCcAllSoundOff                      = 120,
	AkMidiCcAllControllersOff                = 121,
	AkMidiCcLocalKeyboard                    = 122,
	AkMidiCcAllNotesOff                      = 123,
	AkMidiCcOmniModeOff                      = 124,
	AkMidiCcOmniModeOn                       = 125,
	AkMidiCcOmniMonophonicOn                 = 126,
	AkMidiCcOmniPolyphonicOn                 = 127,
	EAkMidiCcValues_MAX                      = 128,
};

// Enum AkAudio.AkCodecId
// NumValues: 0x000A
enum class EAkCodecId : uint8
{
	None                                     = 0,
	PCM                                      = 1,
	ADPCM                                    = 2,
	XMA                                      = 3,
	Vorbis                                   = 4,
	ATRAC9                                   = 12,
	OpusNX                                   = 17,
	AkOpus                                   = 19,
	AkOpusWEM                                = 20,
	AkCodecId_MAX                            = 21,
};

// Enum AkAudio.AkMeshType
// NumValues: 0x0003
enum class EAkMeshType : uint8
{
	StaticMesh                               = 0,
	CollisionMesh                            = 1,
	AkMeshType_MAX                           = 2,
};

// Enum AkAudio.EAkPanningRule
// NumValues: 0x0003
enum class EAkPanningRule : uint32
{
	Speakers                                 = 0,
	Headphones                               = 1,
	EAkPanningRule_MAX                       = 2,
};

// Enum AkAudio.EAkChannelConfigType
// NumValues: 0x0004
enum class EAkChannelConfigType : uint32
{
	Anonymous                                = 0,
	Standard                                 = 1,
	Ambisonic                                = 2,
	EAkChannelConfigType_MAX                 = 3,
};

// Enum AkAudio.EAkChannelMask
// NumValues: 0x0011
enum class EAkChannelMask : uint8
{
	FrontLeft                                = 0,
	FrontRight                               = 1,
	FrontCenter                              = 2,
	LowFrequency                             = 3,
	BackLeft                                 = 4,
	BackRight                                = 5,
	BackCenter                               = 8,
	SideLeft                                 = 9,
	SideRight                                = 10,
	Top                                      = 11,
	HeightFrontLeft                          = 12,
	HeightFrontCenter                        = 13,
	HeightFrontRight                         = 14,
	HeightBackLeft                           = 15,
	HeightBackCenter                         = 16,
	HeightBackRight                          = 17,
	EAkChannelMask_MAX                       = 18,
};

// Enum AkAudio.EAkCommSystem
// NumValues: 0x0003
enum class EAkCommSystem : uint32
{
	Socket                                   = 0,
	HTCS                                     = 1,
	EAkCommSystem_MAX                        = 2,
};

// Enum AkAudio.EAkCollisionChannel
// NumValues: 0x000A
enum class EAkCollisionChannel : uint8
{
	EAKCC_WorldStatic                        = 0,
	EAKCC_WorldDynamic                       = 1,
	EAKCC_Pawn                               = 2,
	EAKCC_Visibility                         = 3,
	EAKCC_Camera                             = 4,
	EAKCC_PhysicsBody                        = 5,
	EAKCC_Vehicle                            = 6,
	EAKCC_Destructible                       = 7,
	EAKCC_UseIntegrationSettingsDefault      = 8,
	EAKCC_MAX                                = 9,
};

// Enum AkAudio.EAkUnrealAudioRouting
// NumValues: 0x0007
enum class EAkUnrealAudioRouting : uint32
{
	Custom                                   = 0,
	Separate                                 = 1,
	AudioLink                                = 2,
	AudioMixer                               = 3,
	EnableWwiseOnly                          = 4,
	EnableUnrealOnly                         = 5,
	EAkUnrealAudioRouting_MAX                = 6,
};

// Enum AkAudio.EAkFitToGeometryMode
// NumValues: 0x0004
enum class EAkFitToGeometryMode : uint8
{
	OrientedBox                              = 0,
	AlignedBox                               = 1,
	ConvexPolyhedron                         = 2,
	EAkFitToGeometryMode_MAX                 = 3,
};

// ScriptStruct AkAudio.AKWaapiJsonObject
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAKWaapiJsonObject final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAKWaapiJsonObject) == 0x000008, "Wrong alignment on FAKWaapiJsonObject");
static_assert(sizeof(FAKWaapiJsonObject) == 0x000010, "Wrong size on FAKWaapiJsonObject");

// ScriptStruct AkAudio.AkOutputSettings
// 0x0018 (0x0018 - 0x0000)
struct FAkOutputSettings final
{
public:
	class FString                                 AudioDeviceShareSetName;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdDevice;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPanningRule                                  PanRule;                                           // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkChannelConfiguration                       ChannelConfig;                                     // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkOutputSettings) == 0x000008, "Wrong alignment on FAkOutputSettings");
static_assert(sizeof(FAkOutputSettings) == 0x000018, "Wrong size on FAkOutputSettings");
static_assert(offsetof(FAkOutputSettings, AudioDeviceShareSetName) == 0x000000, "Member 'FAkOutputSettings::AudioDeviceShareSetName' has a wrong offset!");
static_assert(offsetof(FAkOutputSettings, IdDevice) == 0x000010, "Member 'FAkOutputSettings::IdDevice' has a wrong offset!");
static_assert(offsetof(FAkOutputSettings, PanRule) == 0x000014, "Member 'FAkOutputSettings::PanRule' has a wrong offset!");
static_assert(offsetof(FAkOutputSettings, ChannelConfig) == 0x000015, "Member 'FAkOutputSettings::ChannelConfig' has a wrong offset!");

// ScriptStruct AkAudio.AkChannelMask
// 0x0004 (0x0004 - 0x0000)
struct FAkChannelMask final
{
public:
	int32                                         ChannelMask;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkChannelMask) == 0x000004, "Wrong alignment on FAkChannelMask");
static_assert(sizeof(FAkChannelMask) == 0x000004, "Wrong size on FAkChannelMask");
static_assert(offsetof(FAkChannelMask, ChannelMask) == 0x000000, "Member 'FAkChannelMask::ChannelMask' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiEventBase
// 0x0002 (0x0002 - 0x0000)
struct FAkMidiEventBase
{
public:
	EAkMidiEventType                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Chan;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiEventBase) == 0x000001, "Wrong alignment on FAkMidiEventBase");
static_assert(sizeof(FAkMidiEventBase) == 0x000002, "Wrong size on FAkMidiEventBase");
static_assert(offsetof(FAkMidiEventBase, Type) == 0x000000, "Member 'FAkMidiEventBase::Type' has a wrong offset!");
static_assert(offsetof(FAkMidiEventBase, Chan) == 0x000001, "Member 'FAkMidiEventBase::Chan' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiChannelAftertouch
// 0x0001 (0x0003 - 0x0002)
struct FAkMidiChannelAftertouch final : public FAkMidiEventBase
{
public:
	uint8                                         Value;                                             // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiChannelAftertouch) == 0x000001, "Wrong alignment on FAkMidiChannelAftertouch");
static_assert(sizeof(FAkMidiChannelAftertouch) == 0x000003, "Wrong size on FAkMidiChannelAftertouch");
static_assert(offsetof(FAkMidiChannelAftertouch, Value) == 0x000002, "Member 'FAkMidiChannelAftertouch::Value' has a wrong offset!");

// ScriptStruct AkAudio.AkWaapiSubscriptionId
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FAkWaapiSubscriptionId final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkWaapiSubscriptionId) == 0x000008, "Wrong alignment on FAkWaapiSubscriptionId");
static_assert(sizeof(FAkWaapiSubscriptionId) == 0x000008, "Wrong size on FAkWaapiSubscriptionId");

// ScriptStruct AkAudio.AkAdvancedInitializationSettings
// 0x002C (0x002C - 0x0000)
struct FAkAdvancedInitializationSettings
{
public:
	uint32                                        IO_MemorySize;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        IO_Granularity;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAutoStreamBufferLength;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStreamCache;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaximumPinnedBytesInCache;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGameSyncPreparation;                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ContinuousPlaybackLookAhead;                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MonitorQueuePoolSize;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaximumHardwareTimeoutMs;                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugOutOfRangeCheckEnabled;                       // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugOutOfRangeLimit;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkAdvancedInitializationSettings) == 0x000004, "Wrong alignment on FAkAdvancedInitializationSettings");
static_assert(sizeof(FAkAdvancedInitializationSettings) == 0x00002C, "Wrong size on FAkAdvancedInitializationSettings");
static_assert(offsetof(FAkAdvancedInitializationSettings, IO_MemorySize) == 0x000000, "Member 'FAkAdvancedInitializationSettings::IO_MemorySize' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, IO_Granularity) == 0x000004, "Member 'FAkAdvancedInitializationSettings::IO_Granularity' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, TargetAutoStreamBufferLength) == 0x000008, "Member 'FAkAdvancedInitializationSettings::TargetAutoStreamBufferLength' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, UseStreamCache) == 0x00000C, "Member 'FAkAdvancedInitializationSettings::UseStreamCache' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, MaximumPinnedBytesInCache) == 0x000010, "Member 'FAkAdvancedInitializationSettings::MaximumPinnedBytesInCache' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, EnableGameSyncPreparation) == 0x000014, "Member 'FAkAdvancedInitializationSettings::EnableGameSyncPreparation' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, ContinuousPlaybackLookAhead) == 0x000018, "Member 'FAkAdvancedInitializationSettings::ContinuousPlaybackLookAhead' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, MonitorQueuePoolSize) == 0x00001C, "Member 'FAkAdvancedInitializationSettings::MonitorQueuePoolSize' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, MaximumHardwareTimeoutMs) == 0x000020, "Member 'FAkAdvancedInitializationSettings::MaximumHardwareTimeoutMs' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, DebugOutOfRangeCheckEnabled) == 0x000024, "Member 'FAkAdvancedInitializationSettings::DebugOutOfRangeCheckEnabled' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettings, DebugOutOfRangeLimit) == 0x000028, "Member 'FAkAdvancedInitializationSettings::DebugOutOfRangeLimit' has a wrong offset!");

// ScriptStruct AkAudio.AkAdvancedInitializationSettingsWithMultiCoreRendering
// 0x000C (0x0038 - 0x002C)
struct FAkAdvancedInitializationSettingsWithMultiCoreRendering : public FAkAdvancedInitializationSettings
{
public:
	bool                                          EnableMultiCoreRendering;                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxNumJobWorkers;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        JobWorkerMaxExecutionTimeUSec;                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkAdvancedInitializationSettingsWithMultiCoreRendering) == 0x000004, "Wrong alignment on FAkAdvancedInitializationSettingsWithMultiCoreRendering");
static_assert(sizeof(FAkAdvancedInitializationSettingsWithMultiCoreRendering) == 0x000038, "Wrong size on FAkAdvancedInitializationSettingsWithMultiCoreRendering");
static_assert(offsetof(FAkAdvancedInitializationSettingsWithMultiCoreRendering, EnableMultiCoreRendering) == 0x00002C, "Member 'FAkAdvancedInitializationSettingsWithMultiCoreRendering::EnableMultiCoreRendering' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettingsWithMultiCoreRendering, MaxNumJobWorkers) == 0x000030, "Member 'FAkAdvancedInitializationSettingsWithMultiCoreRendering::MaxNumJobWorkers' has a wrong offset!");
static_assert(offsetof(FAkAdvancedInitializationSettingsWithMultiCoreRendering, JobWorkerMaxExecutionTimeUSec) == 0x000034, "Member 'FAkAdvancedInitializationSettingsWithMultiCoreRendering::JobWorkerMaxExecutionTimeUSec' has a wrong offset!");

// ScriptStruct AkAudio.AkAndroidAdvancedInitializationSettings
// 0x0008 (0x0040 - 0x0038)
struct FAkAndroidAdvancedInitializationSettings final : public FAkAdvancedInitializationSettingsWithMultiCoreRendering
{
public:
	uint32                                        AudioAPI;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RoundFrameSizeToHardwareSize;                      // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkAndroidAdvancedInitializationSettings) == 0x000004, "Wrong alignment on FAkAndroidAdvancedInitializationSettings");
static_assert(sizeof(FAkAndroidAdvancedInitializationSettings) == 0x000040, "Wrong size on FAkAndroidAdvancedInitializationSettings");
static_assert(offsetof(FAkAndroidAdvancedInitializationSettings, AudioAPI) == 0x000038, "Member 'FAkAndroidAdvancedInitializationSettings::AudioAPI' has a wrong offset!");
static_assert(offsetof(FAkAndroidAdvancedInitializationSettings, RoundFrameSizeToHardwareSize) == 0x00003C, "Member 'FAkAndroidAdvancedInitializationSettings::RoundFrameSizeToHardwareSize' has a wrong offset!");

// ScriptStruct AkAudio.AkAudioSession
// 0x000C (0x000C - 0x0000)
struct FAkAudioSession final
{
public:
	EAkAudioSessionCategory                       AudioSessionCategory;                              // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AudioSessionCategoryOptions;                       // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkAudioSessionMode                           AudioSessionMode;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkAudioSession) == 0x000004, "Wrong alignment on FAkAudioSession");
static_assert(sizeof(FAkAudioSession) == 0x00000C, "Wrong size on FAkAudioSession");
static_assert(offsetof(FAkAudioSession, AudioSessionCategory) == 0x000000, "Member 'FAkAudioSession::AudioSessionCategory' has a wrong offset!");
static_assert(offsetof(FAkAudioSession, AudioSessionCategoryOptions) == 0x000004, "Member 'FAkAudioSession::AudioSessionCategoryOptions' has a wrong offset!");
static_assert(offsetof(FAkAudioSession, AudioSessionMode) == 0x000008, "Member 'FAkAudioSession::AudioSessionMode' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiGeneric
// 0x0002 (0x0004 - 0x0002)
struct FAkMidiGeneric final : public FAkMidiEventBase
{
public:
	uint8                                         Param1;                                            // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Param2;                                            // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiGeneric) == 0x000001, "Wrong alignment on FAkMidiGeneric");
static_assert(sizeof(FAkMidiGeneric) == 0x000004, "Wrong size on FAkMidiGeneric");
static_assert(offsetof(FAkMidiGeneric, Param1) == 0x000002, "Member 'FAkMidiGeneric::Param1' has a wrong offset!");
static_assert(offsetof(FAkMidiGeneric, Param2) == 0x000003, "Member 'FAkMidiGeneric::Param2' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiNoteOnOff
// 0x0002 (0x0004 - 0x0002)
struct FAkMidiNoteOnOff final : public FAkMidiEventBase
{
public:
	uint8                                         Note;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Velocity;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiNoteOnOff) == 0x000001, "Wrong alignment on FAkMidiNoteOnOff");
static_assert(sizeof(FAkMidiNoteOnOff) == 0x000004, "Wrong size on FAkMidiNoteOnOff");
static_assert(offsetof(FAkMidiNoteOnOff, Note) == 0x000002, "Member 'FAkMidiNoteOnOff::Note' has a wrong offset!");
static_assert(offsetof(FAkMidiNoteOnOff, Velocity) == 0x000003, "Member 'FAkMidiNoteOnOff::Velocity' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiCc
// 0x0002 (0x0004 - 0x0002)
struct FAkMidiCc final : public FAkMidiEventBase
{
public:
	EAkMidiCcValues                               Cc;                                                // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value;                                             // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiCc) == 0x000001, "Wrong alignment on FAkMidiCc");
static_assert(sizeof(FAkMidiCc) == 0x000004, "Wrong size on FAkMidiCc");
static_assert(offsetof(FAkMidiCc, Cc) == 0x000002, "Member 'FAkMidiCc::Cc' has a wrong offset!");
static_assert(offsetof(FAkMidiCc, Value) == 0x000003, "Member 'FAkMidiCc::Value' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiPitchBend
// 0x0006 (0x0008 - 0x0002)
struct FAkMidiPitchBend final : public FAkMidiEventBase
{
public:
	uint8                                         ValueLsb;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ValueMsb;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullValue;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiPitchBend) == 0x000004, "Wrong alignment on FAkMidiPitchBend");
static_assert(sizeof(FAkMidiPitchBend) == 0x000008, "Wrong size on FAkMidiPitchBend");
static_assert(offsetof(FAkMidiPitchBend, ValueLsb) == 0x000002, "Member 'FAkMidiPitchBend::ValueLsb' has a wrong offset!");
static_assert(offsetof(FAkMidiPitchBend, ValueMsb) == 0x000003, "Member 'FAkMidiPitchBend::ValueMsb' has a wrong offset!");
static_assert(offsetof(FAkMidiPitchBend, FullValue) == 0x000004, "Member 'FAkMidiPitchBend::FullValue' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiNoteAftertouch
// 0x0002 (0x0004 - 0x0002)
struct FAkMidiNoteAftertouch final : public FAkMidiEventBase
{
public:
	uint8                                         Note;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value;                                             // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiNoteAftertouch) == 0x000001, "Wrong alignment on FAkMidiNoteAftertouch");
static_assert(sizeof(FAkMidiNoteAftertouch) == 0x000004, "Wrong size on FAkMidiNoteAftertouch");
static_assert(offsetof(FAkMidiNoteAftertouch, Note) == 0x000002, "Member 'FAkMidiNoteAftertouch::Note' has a wrong offset!");
static_assert(offsetof(FAkMidiNoteAftertouch, Value) == 0x000003, "Member 'FAkMidiNoteAftertouch::Value' has a wrong offset!");

// ScriptStruct AkAudio.AkMidiProgramChange
// 0x0001 (0x0003 - 0x0002)
struct FAkMidiProgramChange final : public FAkMidiEventBase
{
public:
	uint8                                         ProgramNum;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkMidiProgramChange) == 0x000001, "Wrong alignment on FAkMidiProgramChange");
static_assert(sizeof(FAkMidiProgramChange) == 0x000003, "Wrong size on FAkMidiProgramChange");
static_assert(offsetof(FAkMidiProgramChange, ProgramNum) == 0x000002, "Member 'FAkMidiProgramChange::ProgramNum' has a wrong offset!");

// ScriptStruct AkAudio.AkSegmentInfo
// 0x0024 (0x0024 - 0x0000)
struct FAkSegmentInfo final
{
public:
	int32                                         CurrentPosition;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreEntryDuration;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveDuration;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostExitDuration;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainingLookAheadTime;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeatDuration;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarDuration;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridDuration;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridOffset;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkSegmentInfo) == 0x000004, "Wrong alignment on FAkSegmentInfo");
static_assert(sizeof(FAkSegmentInfo) == 0x000024, "Wrong size on FAkSegmentInfo");
static_assert(offsetof(FAkSegmentInfo, CurrentPosition) == 0x000000, "Member 'FAkSegmentInfo::CurrentPosition' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, PreEntryDuration) == 0x000004, "Member 'FAkSegmentInfo::PreEntryDuration' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, ActiveDuration) == 0x000008, "Member 'FAkSegmentInfo::ActiveDuration' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, PostExitDuration) == 0x00000C, "Member 'FAkSegmentInfo::PostExitDuration' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, RemainingLookAheadTime) == 0x000010, "Member 'FAkSegmentInfo::RemainingLookAheadTime' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, BeatDuration) == 0x000014, "Member 'FAkSegmentInfo::BeatDuration' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, BarDuration) == 0x000018, "Member 'FAkSegmentInfo::BarDuration' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, GridDuration) == 0x00001C, "Member 'FAkSegmentInfo::GridDuration' has a wrong offset!");
static_assert(offsetof(FAkSegmentInfo, GridOffset) == 0x000020, "Member 'FAkSegmentInfo::GridOffset' has a wrong offset!");

// ScriptStruct AkAudio.AkExternalSourceInfo
// 0x0038 (0x0038 - 0x0000)
struct FAkExternalSourceInfo final
{
public:
	class FString                                 ExternalSrcName;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkCodecId                                    CodecID;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Filename;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkExternalMediaAsset*                  ExternalSourceAsset;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStreamed;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkExternalSourceInfo) == 0x000008, "Wrong alignment on FAkExternalSourceInfo");
static_assert(sizeof(FAkExternalSourceInfo) == 0x000038, "Wrong size on FAkExternalSourceInfo");
static_assert(offsetof(FAkExternalSourceInfo, ExternalSrcName) == 0x000000, "Member 'FAkExternalSourceInfo::ExternalSrcName' has a wrong offset!");
static_assert(offsetof(FAkExternalSourceInfo, CodecID) == 0x000010, "Member 'FAkExternalSourceInfo::CodecID' has a wrong offset!");
static_assert(offsetof(FAkExternalSourceInfo, Filename) == 0x000018, "Member 'FAkExternalSourceInfo::Filename' has a wrong offset!");
static_assert(offsetof(FAkExternalSourceInfo, ExternalSourceAsset) == 0x000028, "Member 'FAkExternalSourceInfo::ExternalSourceAsset' has a wrong offset!");
static_assert(offsetof(FAkExternalSourceInfo, IsStreamed) == 0x000030, "Member 'FAkExternalSourceInfo::IsStreamed' has a wrong offset!");

// ScriptStruct AkAudio.AkGeometrySurfaceOverride
// 0x0018 (0x0018 - 0x0000)
struct FAkGeometrySurfaceOverride final
{
public:
	class UAkAcousticTexture*                     AcousticTexture;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOcclusionOverride;                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OcclusionValue;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceArea;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkGeometrySurfaceOverride) == 0x000008, "Wrong alignment on FAkGeometrySurfaceOverride");
static_assert(sizeof(FAkGeometrySurfaceOverride) == 0x000018, "Wrong size on FAkGeometrySurfaceOverride");
static_assert(offsetof(FAkGeometrySurfaceOverride, AcousticTexture) == 0x000000, "Member 'FAkGeometrySurfaceOverride::AcousticTexture' has a wrong offset!");
static_assert(offsetof(FAkGeometrySurfaceOverride, bEnableOcclusionOverride) == 0x000008, "Member 'FAkGeometrySurfaceOverride::bEnableOcclusionOverride' has a wrong offset!");
static_assert(offsetof(FAkGeometrySurfaceOverride, OcclusionValue) == 0x00000C, "Member 'FAkGeometrySurfaceOverride::OcclusionValue' has a wrong offset!");
static_assert(offsetof(FAkGeometrySurfaceOverride, SurfaceArea) == 0x000010, "Member 'FAkGeometrySurfaceOverride::SurfaceArea' has a wrong offset!");

// ScriptStruct AkAudio.AkAcousticSurface
// 0x0018 (0x0018 - 0x0000)
struct FAkAcousticSurface final
{
public:
	uint32                                        Texture;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Occlusion;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkAcousticSurface) == 0x000008, "Wrong alignment on FAkAcousticSurface");
static_assert(sizeof(FAkAcousticSurface) == 0x000018, "Wrong size on FAkAcousticSurface");
static_assert(offsetof(FAkAcousticSurface, Texture) == 0x000000, "Member 'FAkAcousticSurface::Texture' has a wrong offset!");
static_assert(offsetof(FAkAcousticSurface, Occlusion) == 0x000004, "Member 'FAkAcousticSurface::Occlusion' has a wrong offset!");
static_assert(offsetof(FAkAcousticSurface, Name) == 0x000008, "Member 'FAkAcousticSurface::Name' has a wrong offset!");

// ScriptStruct AkAudio.AkTriangle
// 0x0008 (0x0008 - 0x0000)
struct FAkTriangle final
{
public:
	uint16                                        Point0;                                            // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Point1;                                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Point2;                                            // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Surface;                                           // 0x0006(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkTriangle) == 0x000002, "Wrong alignment on FAkTriangle");
static_assert(sizeof(FAkTriangle) == 0x000008, "Wrong size on FAkTriangle");
static_assert(offsetof(FAkTriangle, Point0) == 0x000000, "Member 'FAkTriangle::Point0' has a wrong offset!");
static_assert(offsetof(FAkTriangle, Point1) == 0x000002, "Member 'FAkTriangle::Point1' has a wrong offset!");
static_assert(offsetof(FAkTriangle, Point2) == 0x000004, "Member 'FAkTriangle::Point2' has a wrong offset!");
static_assert(offsetof(FAkTriangle, Surface) == 0x000006, "Member 'FAkTriangle::Surface' has a wrong offset!");

// ScriptStruct AkAudio.AkGeometryData
// 0x0050 (0x0050 - 0x0000)
struct FAkGeometryData final
{
public:
	TArray<struct FVector>                        Vertices;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAkAcousticSurface>             Surfaces;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAkTriangle>                    Triangles;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPhysicalMaterial*>              ToOverrideAcousticTexture;                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPhysicalMaterial*>              ToOverrideOcclusion;                               // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkGeometryData) == 0x000008, "Wrong alignment on FAkGeometryData");
static_assert(sizeof(FAkGeometryData) == 0x000050, "Wrong size on FAkGeometryData");
static_assert(offsetof(FAkGeometryData, Vertices) == 0x000000, "Member 'FAkGeometryData::Vertices' has a wrong offset!");
static_assert(offsetof(FAkGeometryData, Surfaces) == 0x000010, "Member 'FAkGeometryData::Surfaces' has a wrong offset!");
static_assert(offsetof(FAkGeometryData, Triangles) == 0x000020, "Member 'FAkGeometryData::Triangles' has a wrong offset!");
static_assert(offsetof(FAkGeometryData, ToOverrideAcousticTexture) == 0x000030, "Member 'FAkGeometryData::ToOverrideAcousticTexture' has a wrong offset!");
static_assert(offsetof(FAkGeometryData, ToOverrideOcclusion) == 0x000040, "Member 'FAkGeometryData::ToOverrideOcclusion' has a wrong offset!");

// ScriptStruct AkAudio.AkHololensAdvancedInitializationSettings
// 0x0004 (0x003C - 0x0038)
struct FAkHololensAdvancedInitializationSettings final : public FAkAdvancedInitializationSettingsWithMultiCoreRendering
{
public:
	bool                                          UseHeadMountedDisplayAudioDevice;                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkHololensAdvancedInitializationSettings) == 0x000004, "Wrong alignment on FAkHololensAdvancedInitializationSettings");
static_assert(sizeof(FAkHololensAdvancedInitializationSettings) == 0x00003C, "Wrong size on FAkHololensAdvancedInitializationSettings");
static_assert(offsetof(FAkHololensAdvancedInitializationSettings, UseHeadMountedDisplayAudioDevice) == 0x000038, "Member 'FAkHololensAdvancedInitializationSettings::UseHeadMountedDisplayAudioDevice' has a wrong offset!");

// ScriptStruct AkAudio.AkMainOutputSettings
// 0x0028 (0x0028 - 0x0000)
struct FAkMainOutputSettings final
{
public:
	class FString                                 AudioDeviceShareSet;                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DeviceID;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkPanningRule                                PanningRule;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkChannelConfigType                          ChannelConfigType;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ChannelMask;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NumberOfChannels;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkMainOutputSettings) == 0x000008, "Wrong alignment on FAkMainOutputSettings");
static_assert(sizeof(FAkMainOutputSettings) == 0x000028, "Wrong size on FAkMainOutputSettings");
static_assert(offsetof(FAkMainOutputSettings, AudioDeviceShareSet) == 0x000000, "Member 'FAkMainOutputSettings::AudioDeviceShareSet' has a wrong offset!");
static_assert(offsetof(FAkMainOutputSettings, DeviceID) == 0x000010, "Member 'FAkMainOutputSettings::DeviceID' has a wrong offset!");
static_assert(offsetof(FAkMainOutputSettings, PanningRule) == 0x000014, "Member 'FAkMainOutputSettings::PanningRule' has a wrong offset!");
static_assert(offsetof(FAkMainOutputSettings, ChannelConfigType) == 0x000018, "Member 'FAkMainOutputSettings::ChannelConfigType' has a wrong offset!");
static_assert(offsetof(FAkMainOutputSettings, ChannelMask) == 0x00001C, "Member 'FAkMainOutputSettings::ChannelMask' has a wrong offset!");
static_assert(offsetof(FAkMainOutputSettings, NumberOfChannels) == 0x000020, "Member 'FAkMainOutputSettings::NumberOfChannels' has a wrong offset!");

// ScriptStruct AkAudio.AkSpatialAudioSettings
// 0x0028 (0x0028 - 0x0000)
struct FAkSpatialAudioSettings final
{
public:
	uint32                                        MaxSoundPropagationDepth;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementThreshold;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NumberOfPrimaryRays;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ReflectionOrder;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DiffractionOrder;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DiffractionOnReflectionsOrder;                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumPathLength;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CPULimitPercentage;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LoadBalancingSpread;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGeometricDiffractionAndTransmission;         // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CalcEmitterVirtualPosition;                        // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkSpatialAudioSettings) == 0x000004, "Wrong alignment on FAkSpatialAudioSettings");
static_assert(sizeof(FAkSpatialAudioSettings) == 0x000028, "Wrong size on FAkSpatialAudioSettings");
static_assert(offsetof(FAkSpatialAudioSettings, MaxSoundPropagationDepth) == 0x000000, "Member 'FAkSpatialAudioSettings::MaxSoundPropagationDepth' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, MovementThreshold) == 0x000004, "Member 'FAkSpatialAudioSettings::MovementThreshold' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, NumberOfPrimaryRays) == 0x000008, "Member 'FAkSpatialAudioSettings::NumberOfPrimaryRays' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, ReflectionOrder) == 0x00000C, "Member 'FAkSpatialAudioSettings::ReflectionOrder' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, DiffractionOrder) == 0x000010, "Member 'FAkSpatialAudioSettings::DiffractionOrder' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, DiffractionOnReflectionsOrder) == 0x000014, "Member 'FAkSpatialAudioSettings::DiffractionOnReflectionsOrder' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, MaximumPathLength) == 0x000018, "Member 'FAkSpatialAudioSettings::MaximumPathLength' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, CPULimitPercentage) == 0x00001C, "Member 'FAkSpatialAudioSettings::CPULimitPercentage' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, LoadBalancingSpread) == 0x000020, "Member 'FAkSpatialAudioSettings::LoadBalancingSpread' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, EnableGeometricDiffractionAndTransmission) == 0x000024, "Member 'FAkSpatialAudioSettings::EnableGeometricDiffractionAndTransmission' has a wrong offset!");
static_assert(offsetof(FAkSpatialAudioSettings, CalcEmitterVirtualPosition) == 0x000025, "Member 'FAkSpatialAudioSettings::CalcEmitterVirtualPosition' has a wrong offset!");

// ScriptStruct AkAudio.AkCommunicationSettings
// 0x0018 (0x0018 - 0x0000)
struct FAkCommunicationSettings
{
public:
	uint32                                        PoolSize;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        DiscoveryBroadcastPort;                            // 0x0004(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        CommandPort;                                       // 0x0006(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetworkName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkCommunicationSettings) == 0x000008, "Wrong alignment on FAkCommunicationSettings");
static_assert(sizeof(FAkCommunicationSettings) == 0x000018, "Wrong size on FAkCommunicationSettings");
static_assert(offsetof(FAkCommunicationSettings, PoolSize) == 0x000000, "Member 'FAkCommunicationSettings::PoolSize' has a wrong offset!");
static_assert(offsetof(FAkCommunicationSettings, DiscoveryBroadcastPort) == 0x000004, "Member 'FAkCommunicationSettings::DiscoveryBroadcastPort' has a wrong offset!");
static_assert(offsetof(FAkCommunicationSettings, CommandPort) == 0x000006, "Member 'FAkCommunicationSettings::CommandPort' has a wrong offset!");
static_assert(offsetof(FAkCommunicationSettings, NetworkName) == 0x000008, "Member 'FAkCommunicationSettings::NetworkName' has a wrong offset!");

// ScriptStruct AkAudio.AkCommunicationSettingsWithSystemInitialization
// 0x0008 (0x0020 - 0x0018)
struct FAkCommunicationSettingsWithSystemInitialization final : public FAkCommunicationSettings
{
public:
	bool                                          InitializeSystemComms;                             // 0x0018(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkCommunicationSettingsWithSystemInitialization) == 0x000008, "Wrong alignment on FAkCommunicationSettingsWithSystemInitialization");
static_assert(sizeof(FAkCommunicationSettingsWithSystemInitialization) == 0x000020, "Wrong size on FAkCommunicationSettingsWithSystemInitialization");
static_assert(offsetof(FAkCommunicationSettingsWithSystemInitialization, InitializeSystemComms) == 0x000018, "Member 'FAkCommunicationSettingsWithSystemInitialization::InitializeSystemComms' has a wrong offset!");

// ScriptStruct AkAudio.AkCommunicationSettingsWithCommSelection
// 0x0008 (0x0020 - 0x0018)
struct FAkCommunicationSettingsWithCommSelection final : public FAkCommunicationSettings
{
public:
	EAkCommSystem                                 CommunicationSystem;                               // 0x0018(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkCommunicationSettingsWithCommSelection) == 0x000008, "Wrong alignment on FAkCommunicationSettingsWithCommSelection");
static_assert(sizeof(FAkCommunicationSettingsWithCommSelection) == 0x000020, "Wrong size on FAkCommunicationSettingsWithCommSelection");
static_assert(offsetof(FAkCommunicationSettingsWithCommSelection, CommunicationSystem) == 0x000018, "Member 'FAkCommunicationSettingsWithCommSelection::CommunicationSystem' has a wrong offset!");

// ScriptStruct AkAudio.AkCommonInitializationSettings
// 0x0068 (0x0068 - 0x0000)
struct FAkCommonInitializationSettings
{
public:
	uint32                                        MaximumNumberOfMemoryPools;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaximumNumberOfPositioningPaths;                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CommandQueueSize;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SamplesPerFrame;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkMainOutputSettings                  MainOutputSettings;                                // 0x0010(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         StreamingLookAheadRatio;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NumberOfRefillsInVoice;                            // 0x003C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkSpatialAudioSettings                SpatialAudioSettings;                              // 0x0040(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkCommonInitializationSettings) == 0x000008, "Wrong alignment on FAkCommonInitializationSettings");
static_assert(sizeof(FAkCommonInitializationSettings) == 0x000068, "Wrong size on FAkCommonInitializationSettings");
static_assert(offsetof(FAkCommonInitializationSettings, MaximumNumberOfMemoryPools) == 0x000000, "Member 'FAkCommonInitializationSettings::MaximumNumberOfMemoryPools' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, MaximumNumberOfPositioningPaths) == 0x000004, "Member 'FAkCommonInitializationSettings::MaximumNumberOfPositioningPaths' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, CommandQueueSize) == 0x000008, "Member 'FAkCommonInitializationSettings::CommandQueueSize' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, SamplesPerFrame) == 0x00000C, "Member 'FAkCommonInitializationSettings::SamplesPerFrame' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, MainOutputSettings) == 0x000010, "Member 'FAkCommonInitializationSettings::MainOutputSettings' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, StreamingLookAheadRatio) == 0x000038, "Member 'FAkCommonInitializationSettings::StreamingLookAheadRatio' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, NumberOfRefillsInVoice) == 0x00003C, "Member 'FAkCommonInitializationSettings::NumberOfRefillsInVoice' has a wrong offset!");
static_assert(offsetof(FAkCommonInitializationSettings, SpatialAudioSettings) == 0x000040, "Member 'FAkCommonInitializationSettings::SpatialAudioSettings' has a wrong offset!");

// ScriptStruct AkAudio.AkCommonInitializationSettingsWithSampleRate
// 0x0008 (0x0070 - 0x0068)
struct FAkCommonInitializationSettingsWithSampleRate final : public FAkCommonInitializationSettings
{
public:
	uint32                                        SampleRate;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkCommonInitializationSettingsWithSampleRate) == 0x000008, "Wrong alignment on FAkCommonInitializationSettingsWithSampleRate");
static_assert(sizeof(FAkCommonInitializationSettingsWithSampleRate) == 0x000070, "Wrong size on FAkCommonInitializationSettingsWithSampleRate");
static_assert(offsetof(FAkCommonInitializationSettingsWithSampleRate, SampleRate) == 0x000068, "Member 'FAkCommonInitializationSettingsWithSampleRate::SampleRate' has a wrong offset!");

// ScriptStruct AkAudio.AkBoolPropertyToControl
// 0x0010 (0x0010 - 0x0000)
struct FAkBoolPropertyToControl final
{
public:
	class FString                                 ItemProperty;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkBoolPropertyToControl) == 0x000008, "Wrong alignment on FAkBoolPropertyToControl");
static_assert(sizeof(FAkBoolPropertyToControl) == 0x000010, "Wrong size on FAkBoolPropertyToControl");
static_assert(offsetof(FAkBoolPropertyToControl, ItemProperty) == 0x000000, "Member 'FAkBoolPropertyToControl::ItemProperty' has a wrong offset!");

// ScriptStruct AkAudio.AkPropertyToControl
// 0x0010 (0x0010 - 0x0000)
struct FAkPropertyToControl final
{
public:
	class FString                                 ItemProperty;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkPropertyToControl) == 0x000008, "Wrong alignment on FAkPropertyToControl");
static_assert(sizeof(FAkPropertyToControl) == 0x000010, "Wrong size on FAkPropertyToControl");
static_assert(offsetof(FAkPropertyToControl, ItemProperty) == 0x000000, "Member 'FAkPropertyToControl::ItemProperty' has a wrong offset!");

// ScriptStruct AkAudio.AkReverbDescriptor
// 0x0028 (0x0028 - 0x0000)
struct FAkReverbDescriptor final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    Primitive;                                         // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkReverbDescriptor) == 0x000008, "Wrong alignment on FAkReverbDescriptor");
static_assert(sizeof(FAkReverbDescriptor) == 0x000028, "Wrong size on FAkReverbDescriptor");
static_assert(offsetof(FAkReverbDescriptor, Primitive) == 0x000018, "Member 'FAkReverbDescriptor::Primitive' has a wrong offset!");

// ScriptStruct AkAudio.AkGeometrySurfacePropertiesToMap
// 0x0038 (0x0038 - 0x0000)
struct FAkGeometrySurfacePropertiesToMap final
{
public:
	TSoftObjectPtr<class UAkAcousticTexture>      AcousticTexture;                                   // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionValue;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkGeometrySurfacePropertiesToMap) == 0x000008, "Wrong alignment on FAkGeometrySurfacePropertiesToMap");
static_assert(sizeof(FAkGeometrySurfacePropertiesToMap) == 0x000038, "Wrong size on FAkGeometrySurfacePropertiesToMap");
static_assert(offsetof(FAkGeometrySurfacePropertiesToMap, AcousticTexture) == 0x000000, "Member 'FAkGeometrySurfacePropertiesToMap::AcousticTexture' has a wrong offset!");
static_assert(offsetof(FAkGeometrySurfacePropertiesToMap, OcclusionValue) == 0x000030, "Member 'FAkGeometrySurfacePropertiesToMap::OcclusionValue' has a wrong offset!");

// ScriptStruct AkAudio.AkAcousticTextureParams
// 0x0030 (0x0030 - 0x0000)
struct FAkAcousticTextureParams final
{
public:
	struct FVector4                               AbsorptionValues;                                  // 0x0000(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkAcousticTextureParams) == 0x000010, "Wrong alignment on FAkAcousticTextureParams");
static_assert(sizeof(FAkAcousticTextureParams) == 0x000030, "Wrong size on FAkAcousticTextureParams");
static_assert(offsetof(FAkAcousticTextureParams, AbsorptionValues) == 0x000000, "Member 'FAkAcousticTextureParams::AbsorptionValues' has a wrong offset!");

// ScriptStruct AkAudio.AkWwiseObjectDetails
// 0x0030 (0x0030 - 0x0000)
struct FAkWwiseObjectDetails final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemPath;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkWwiseObjectDetails) == 0x000008, "Wrong alignment on FAkWwiseObjectDetails");
static_assert(sizeof(FAkWwiseObjectDetails) == 0x000030, "Wrong size on FAkWwiseObjectDetails");
static_assert(offsetof(FAkWwiseObjectDetails, ItemName) == 0x000000, "Member 'FAkWwiseObjectDetails::ItemName' has a wrong offset!");
static_assert(offsetof(FAkWwiseObjectDetails, ItemPath) == 0x000010, "Member 'FAkWwiseObjectDetails::ItemPath' has a wrong offset!");
static_assert(offsetof(FAkWwiseObjectDetails, ItemId) == 0x000020, "Member 'FAkWwiseObjectDetails::ItemId' has a wrong offset!");

// ScriptStruct AkAudio.AkWwiseItemToControl
// 0x0040 (0x0040 - 0x0000)
struct FAkWwiseItemToControl final
{
public:
	struct FAkWwiseObjectDetails                  ItemPicked;                                        // 0x0000(0x0030)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FString                                 ItemPath;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkWwiseItemToControl) == 0x000008, "Wrong alignment on FAkWwiseItemToControl");
static_assert(sizeof(FAkWwiseItemToControl) == 0x000040, "Wrong size on FAkWwiseItemToControl");
static_assert(offsetof(FAkWwiseItemToControl, ItemPicked) == 0x000000, "Member 'FAkWwiseItemToControl::ItemPicked' has a wrong offset!");
static_assert(offsetof(FAkWwiseItemToControl, ItemPath) == 0x000030, "Member 'FAkWwiseItemToControl::ItemPath' has a wrong offset!");

// ScriptStruct AkAudio.AkSurfaceEdgeVerts
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FAkSurfaceEdgeVerts final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkSurfaceEdgeVerts) == 0x000008, "Wrong alignment on FAkSurfaceEdgeVerts");
static_assert(sizeof(FAkSurfaceEdgeVerts) == 0x000030, "Wrong size on FAkSurfaceEdgeVerts");

// ScriptStruct AkAudio.AkSurfaceEdgeInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FAkSurfaceEdgeInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkSurfaceEdgeInfo) == 0x000008, "Wrong alignment on FAkSurfaceEdgeInfo");
static_assert(sizeof(FAkSurfaceEdgeInfo) == 0x000050, "Wrong size on FAkSurfaceEdgeInfo");

// ScriptStruct AkAudio.AkSurfacePoly
// 0x0018 (0x0018 - 0x0000)
struct FAkSurfacePoly final
{
public:
	class UAkAcousticTexture*                     Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Occlusion;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableSurface;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurfaceArea;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkSurfacePoly) == 0x000008, "Wrong alignment on FAkSurfacePoly");
static_assert(sizeof(FAkSurfacePoly) == 0x000018, "Wrong size on FAkSurfacePoly");
static_assert(offsetof(FAkSurfacePoly, Texture) == 0x000000, "Member 'FAkSurfacePoly::Texture' has a wrong offset!");
static_assert(offsetof(FAkSurfacePoly, Occlusion) == 0x000008, "Member 'FAkSurfacePoly::Occlusion' has a wrong offset!");
static_assert(offsetof(FAkSurfacePoly, EnableSurface) == 0x00000C, "Member 'FAkSurfacePoly::EnableSurface' has a wrong offset!");
static_assert(offsetof(FAkSurfacePoly, SurfaceArea) == 0x000010, "Member 'FAkSurfacePoly::SurfaceArea' has a wrong offset!");

// ScriptStruct AkAudio.AkWaapiFieldNames
// 0x0010 (0x0010 - 0x0000)
struct FAkWaapiFieldNames final
{
public:
	class FString                                 FieldName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkWaapiFieldNames) == 0x000008, "Wrong alignment on FAkWaapiFieldNames");
static_assert(sizeof(FAkWaapiFieldNames) == 0x000010, "Wrong size on FAkWaapiFieldNames");
static_assert(offsetof(FAkWaapiFieldNames, FieldName) == 0x000000, "Member 'FAkWaapiFieldNames::FieldName' has a wrong offset!");

// ScriptStruct AkAudio.AkWaapiUri
// 0x0010 (0x0010 - 0x0000)
struct FAkWaapiUri final
{
public:
	class FString                                 Uri;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkWaapiUri) == 0x000008, "Wrong alignment on FAkWaapiUri");
static_assert(sizeof(FAkWaapiUri) == 0x000010, "Wrong size on FAkWaapiUri");
static_assert(offsetof(FAkWaapiUri, Uri) == 0x000000, "Member 'FAkWaapiUri::Uri' has a wrong offset!");

// ScriptStruct AkAudio.AkWindowsAdvancedInitializationSettings
// 0x0008 (0x0040 - 0x0038)
struct FAkWindowsAdvancedInitializationSettings final : public FAkAdvancedInitializationSettingsWithMultiCoreRendering
{
public:
	bool                                          UseHeadMountedDisplayAudioDevice;                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxSystemAudioObjects;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkWindowsAdvancedInitializationSettings) == 0x000004, "Wrong alignment on FAkWindowsAdvancedInitializationSettings");
static_assert(sizeof(FAkWindowsAdvancedInitializationSettings) == 0x000040, "Wrong size on FAkWindowsAdvancedInitializationSettings");
static_assert(offsetof(FAkWindowsAdvancedInitializationSettings, UseHeadMountedDisplayAudioDevice) == 0x000038, "Member 'FAkWindowsAdvancedInitializationSettings::UseHeadMountedDisplayAudioDevice' has a wrong offset!");
static_assert(offsetof(FAkWindowsAdvancedInitializationSettings, MaxSystemAudioObjects) == 0x00003C, "Member 'FAkWindowsAdvancedInitializationSettings::MaxSystemAudioObjects' has a wrong offset!");

// ScriptStruct AkAudio.AkWinGDKAdvancedInitializationSettings
// 0x0008 (0x0040 - 0x0038)
struct FAkWinGDKAdvancedInitializationSettings final : public FAkAdvancedInitializationSettingsWithMultiCoreRendering
{
public:
	bool                                          UseHeadMountedDisplayAudioDevice;                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        UMaxSystemAudioObjects;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkWinGDKAdvancedInitializationSettings) == 0x000004, "Wrong alignment on FAkWinGDKAdvancedInitializationSettings");
static_assert(sizeof(FAkWinGDKAdvancedInitializationSettings) == 0x000040, "Wrong size on FAkWinGDKAdvancedInitializationSettings");
static_assert(offsetof(FAkWinGDKAdvancedInitializationSettings, UseHeadMountedDisplayAudioDevice) == 0x000038, "Member 'FAkWinGDKAdvancedInitializationSettings::UseHeadMountedDisplayAudioDevice' has a wrong offset!");
static_assert(offsetof(FAkWinGDKAdvancedInitializationSettings, UMaxSystemAudioObjects) == 0x00003C, "Member 'FAkWinGDKAdvancedInitializationSettings::UMaxSystemAudioObjects' has a wrong offset!");

// ScriptStruct AkAudio.MovieSceneAkAudioEventTemplate
// 0x0008 (0x0028 - 0x0020)
struct FMovieSceneAkAudioEventTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UMovieSceneAkAudioEventSection*         Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneAkAudioEventTemplate) == 0x000008, "Wrong alignment on FMovieSceneAkAudioEventTemplate");
static_assert(sizeof(FMovieSceneAkAudioEventTemplate) == 0x000028, "Wrong size on FMovieSceneAkAudioEventTemplate");
static_assert(offsetof(FMovieSceneAkAudioEventTemplate, Section) == 0x000020, "Member 'FMovieSceneAkAudioEventTemplate::Section' has a wrong offset!");

// ScriptStruct AkAudio.MovieSceneAkAudioRTPCTemplate
// 0x0008 (0x0028 - 0x0020)
struct FMovieSceneAkAudioRTPCTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UMovieSceneAkAudioRTPCSection*          Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneAkAudioRTPCTemplate) == 0x000008, "Wrong alignment on FMovieSceneAkAudioRTPCTemplate");
static_assert(sizeof(FMovieSceneAkAudioRTPCTemplate) == 0x000028, "Wrong size on FMovieSceneAkAudioRTPCTemplate");
static_assert(offsetof(FMovieSceneAkAudioRTPCTemplate, Section) == 0x000020, "Member 'FMovieSceneAkAudioRTPCTemplate::Section' has a wrong offset!");

// ScriptStruct AkAudio.MovieSceneTangentDataSerializationHelper
// 0x0014 (0x0014 - 0x0000)
struct FMovieSceneTangentDataSerializationHelper final
{
public:
	float                                         ArriveTangent;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangent;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentWeightMode                   TangentWeightMode;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArriveTangentWeight;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangentWeight;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneTangentDataSerializationHelper) == 0x000004, "Wrong alignment on FMovieSceneTangentDataSerializationHelper");
static_assert(sizeof(FMovieSceneTangentDataSerializationHelper) == 0x000014, "Wrong size on FMovieSceneTangentDataSerializationHelper");
static_assert(offsetof(FMovieSceneTangentDataSerializationHelper, ArriveTangent) == 0x000000, "Member 'FMovieSceneTangentDataSerializationHelper::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FMovieSceneTangentDataSerializationHelper, LeaveTangent) == 0x000004, "Member 'FMovieSceneTangentDataSerializationHelper::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FMovieSceneTangentDataSerializationHelper, TangentWeightMode) == 0x000008, "Member 'FMovieSceneTangentDataSerializationHelper::TangentWeightMode' has a wrong offset!");
static_assert(offsetof(FMovieSceneTangentDataSerializationHelper, ArriveTangentWeight) == 0x00000C, "Member 'FMovieSceneTangentDataSerializationHelper::ArriveTangentWeight' has a wrong offset!");
static_assert(offsetof(FMovieSceneTangentDataSerializationHelper, LeaveTangentWeight) == 0x000010, "Member 'FMovieSceneTangentDataSerializationHelper::LeaveTangentWeight' has a wrong offset!");

// ScriptStruct AkAudio.MovieSceneFloatValueSerializationHelper
// 0x001C (0x001C - 0x0000)
struct FMovieSceneFloatValueSerializationHelper final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveInterpMode                          InterpMode;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentMode                         TangentMode;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneTangentDataSerializationHelper Tangent;                                           // 0x0008(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneFloatValueSerializationHelper) == 0x000004, "Wrong alignment on FMovieSceneFloatValueSerializationHelper");
static_assert(sizeof(FMovieSceneFloatValueSerializationHelper) == 0x00001C, "Wrong size on FMovieSceneFloatValueSerializationHelper");
static_assert(offsetof(FMovieSceneFloatValueSerializationHelper, Value) == 0x000000, "Member 'FMovieSceneFloatValueSerializationHelper::Value' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatValueSerializationHelper, InterpMode) == 0x000004, "Member 'FMovieSceneFloatValueSerializationHelper::InterpMode' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatValueSerializationHelper, TangentMode) == 0x000005, "Member 'FMovieSceneFloatValueSerializationHelper::TangentMode' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatValueSerializationHelper, Tangent) == 0x000008, "Member 'FMovieSceneFloatValueSerializationHelper::Tangent' has a wrong offset!");

// ScriptStruct AkAudio.MovieSceneFloatChannelSerializationHelper
// 0x0030 (0x0030 - 0x0000)
struct FMovieSceneFloatChannelSerializationHelper final
{
public:
	ERichCurveExtrapolation                       PreInfinityExtrap;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveExtrapolation                       PostInfinityExtrap;                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Times;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMovieSceneFloatValueSerializationHelper> Values;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDefaultValue;                                  // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneFloatChannelSerializationHelper) == 0x000008, "Wrong alignment on FMovieSceneFloatChannelSerializationHelper");
static_assert(sizeof(FMovieSceneFloatChannelSerializationHelper) == 0x000030, "Wrong size on FMovieSceneFloatChannelSerializationHelper");
static_assert(offsetof(FMovieSceneFloatChannelSerializationHelper, PreInfinityExtrap) == 0x000000, "Member 'FMovieSceneFloatChannelSerializationHelper::PreInfinityExtrap' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatChannelSerializationHelper, PostInfinityExtrap) == 0x000001, "Member 'FMovieSceneFloatChannelSerializationHelper::PostInfinityExtrap' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatChannelSerializationHelper, Times) == 0x000008, "Member 'FMovieSceneFloatChannelSerializationHelper::Times' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatChannelSerializationHelper, Values) == 0x000018, "Member 'FMovieSceneFloatChannelSerializationHelper::Values' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatChannelSerializationHelper, DefaultValue) == 0x000028, "Member 'FMovieSceneFloatChannelSerializationHelper::DefaultValue' has a wrong offset!");
static_assert(offsetof(FMovieSceneFloatChannelSerializationHelper, bHasDefaultValue) == 0x00002C, "Member 'FMovieSceneFloatChannelSerializationHelper::bHasDefaultValue' has a wrong offset!");

}

