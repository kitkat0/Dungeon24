#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_TGF_Base

#include "Basic.hpp"

#include "GA_TGF_Base_classes.hpp"
#include "GA_TGF_Base_parameters.hpp"


namespace SDK
{

// Function GA_TGF_Base.GA_TGF_Base_C.AddWeaponElement
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::AddWeaponElement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "AddWeaponElement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.Apply Counter
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::Apply_Counter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "Apply Counter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ApplyAbilityHurtType
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ApplyAbilityHurtType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ApplyAbilityHurtType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ApplyGuarded
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::ApplyGuarded(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ApplyGuarded");

	Params::GA_TGF_Base_C_ApplyGuarded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_Base.GA_TGF_Base_C.ApplyHitPartTag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ApplyHitPartTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ApplyHitPartTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ApplyMeleeWeaponEffect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               MeleeWeaponEffectInputData                             (BlueprintVisible, BlueprintReadOnly, Parm)

void UGA_TGF_Base_C::ApplyMeleeWeaponEffect(const struct FGameplayEventData& MeleeWeaponEffectInputData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ApplyMeleeWeaponEffect");

	Params::GA_TGF_Base_C_ApplyMeleeWeaponEffect Parms{};

	Parms.MeleeWeaponEffectInputData = std::move(MeleeWeaponEffectInputData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ApplyMoveSpeedDebuff
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ApplyMoveSpeedDebuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ApplyMoveSpeedDebuff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ApplyPerfectGuarded
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ApplyPerfectGuarded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ApplyPerfectGuarded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckAttrBoostTags
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::CheckAttrBoostTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckAttrBoostTags");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckCritical
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::CheckCritical()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckCritical");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckGEAttributeTag
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::CheckGEAttributeTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckGEAttributeTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckGuarded
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::CheckGuarded(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckGuarded");

	Params::GA_TGF_Base_C_CheckGuarded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckHeavyHitAndInterrupt
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::CheckHeavyHitAndInterrupt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckHeavyHitAndInterrupt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckHitIneractorEnviorment
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::CheckHitIneractorEnviorment(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckHitIneractorEnviorment");

	Params::GA_TGF_Base_C_CheckHitIneractorEnviorment Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckHitInteractorBattle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::CheckHitInteractorBattle(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckHitInteractorBattle");

	Params::GA_TGF_Base_C_CheckHitInteractorBattle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckProjectileSecurity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       BornTrans                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           SrcActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    CheckResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::CheckProjectileSecurity(const struct FTransform& BornTrans, class AActor* SrcActor, bool* CheckResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckProjectileSecurity");

	Params::GA_TGF_Base_C_CheckProjectileSecurity Parms{};

	Parms.BornTrans = std::move(BornTrans);
	Parms.SrcActor = SrcActor;

	UObject::ProcessEvent(Func, &Parms);

	if (CheckResult != nullptr)
		*CheckResult = Parms.CheckResult;
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckReboundFromTargetTag
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::CheckReboundFromTargetTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckReboundFromTargetTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.CheckTeamTag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bAddFriendly                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::CheckTeamTag(bool bAddFriendly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "CheckTeamTag");

	Params::GA_TGF_Base_C_CheckTeamTag Parms{};

	Parms.bAddFriendly = bAddFriendly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DecideGEsToUse
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   DecideType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UClass*>                   ResultGEs                                              (Parm, OutParm)

void UGA_TGF_Base_C::DecideGEsToUse(int32 DecideType, TArray<class UClass*>* ResultGEs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DecideGEsToUse");

	Params::GA_TGF_Base_C_DecideGEsToUse Parms{};

	Parms.DecideType = DecideType;

	UObject::ProcessEvent(Func, &Parms);

	if (ResultGEs != nullptr)
		*ResultGEs = std::move(Parms.ResultGEs);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DecideInstigatorASCWeaponAttack
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InputActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::DecideInstigatorASCWeaponAttack(class AActor* InputActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DecideInstigatorASCWeaponAttack");

	Params::GA_TGF_Base_C_DecideInstigatorASCWeaponAttack Parms{};

	Parms.InputActor = InputActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DeInitParams
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::DeInitParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DeInitParams");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DeInitShieldConfig
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::DeInitShieldConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DeInitShieldConfig");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DeInitWeaponMesh
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::DeInitWeaponMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DeInitWeaponMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DisperseBuffDispatcher__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveGameplayEffectHandle                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::DisperseBuffDispatcher__DelegateSignature(const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DisperseBuffDispatcher__DelegateSignature");

	Params::GA_TGF_Base_C_DisperseBuffDispatcher__DelegateSignature Parms{};

	Parms.ActiveGameplayEffectHandle = std::move(ActiveGameplayEffectHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DisperseBuffWithHandler
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Targets                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     BuffTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            HighPriorityTags                                       (BlueprintVisible, BlueprintReadOnly, Parm)
// int32                                   Num                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisperseSucceed                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::DisperseBuffWithHandler(TArray<class AActor*>& Targets, const struct FGameplayTag& BuffTag, const struct FGameplayTagContainer& HighPriorityTags, int32 Num, bool* bDisperseSucceed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DisperseBuffWithHandler");

	Params::GA_TGF_Base_C_DisperseBuffWithHandler Parms{};

	Parms.Targets = std::move(Targets);
	Parms.BuffTag = std::move(BuffTag);
	Parms.HighPriorityTags = std::move(HighPriorityTags);
	Parms.Num = Num;

	UObject::ProcessEvent(Func, &Parms);

	Targets = std::move(Parms.Targets);

	if (bDisperseSucceed != nullptr)
		*bDisperseSucceed = Parms.bDisperseSucceed;
}


// Function GA_TGF_Base.GA_TGF_Base_C.DoInteractorBattleGE
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::DoInteractorBattleGE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DoInteractorBattleGE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.DoInteractorEnvironment
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::DoInteractorEnvironment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "DoInteractorEnvironment");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.EnableProjectileBlocker
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::EnableProjectileBlocker(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "EnableProjectileBlocker");

	Params::GA_TGF_Base_C_EnableProjectileBlocker Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.GatherNearbyActors
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm)
// bool                                    Res                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::GatherNearbyActors(const struct FVector& Location, double Radius, TArray<class AActor*>* Actors, bool* Res)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GatherNearbyActors");

	Params::GA_TGF_Base_C_GatherNearbyActors Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);

	if (Actors != nullptr)
		*Actors = std::move(Parms.Actors);

	if (Res != nullptr)
		*Res = Parms.Res;
}


// Function GA_TGF_Base.GA_TGF_Base_C.GetHandMeleeWeaponActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LeftHand                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AB_TGF_MeleeWeaponBase_C*         ResultActor                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::GetHandMeleeWeaponActor(bool LeftHand, class AB_TGF_MeleeWeaponBase_C** ResultActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GetHandMeleeWeaponActor");

	Params::GA_TGF_Base_C_GetHandMeleeWeaponActor Parms{};

	Parms.LeftHand = LeftHand;

	UObject::ProcessEvent(Func, &Parms);

	if (ResultActor != nullptr)
		*ResultActor = Parms.ResultActor;
}


// Function GA_TGF_Base.GA_TGF_Base_C.GetLeftHandMeleeWeaponActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_TGF_MeleeWeaponBase_C*         ResultActor                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::GetLeftHandMeleeWeaponActor(class AB_TGF_MeleeWeaponBase_C** ResultActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GetLeftHandMeleeWeaponActor");

	Params::GA_TGF_Base_C_GetLeftHandMeleeWeaponActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ResultActor != nullptr)
		*ResultActor = Parms.ResultActor;
}


// Function GA_TGF_Base.GA_TGF_Base_C.GetMonsterBodyMeleeWeaponActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Tgf_Monster_C*                ResultActor                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::GetMonsterBodyMeleeWeaponActor(class ABP_Tgf_Monster_C** ResultActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GetMonsterBodyMeleeWeaponActor");

	Params::GA_TGF_Base_C_GetMonsterBodyMeleeWeaponActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ResultActor != nullptr)
		*ResultActor = Parms.ResultActor;
}


// Function GA_TGF_Base.GA_TGF_Base_C.GetPlayerBodyMeleeWeaponActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Fighter_HeroSample_C*         Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::GetPlayerBodyMeleeWeaponActor(class ABP_Fighter_HeroSample_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GetPlayerBodyMeleeWeaponActor");

	Params::GA_TGF_Base_C_GetPlayerBodyMeleeWeaponActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GA_TGF_Base.GA_TGF_Base_C.GetRightHandMeleeWeaponActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_TGF_MeleeWeaponBase_C*         ResultActor                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::GetRightHandMeleeWeaponActor(class AB_TGF_MeleeWeaponBase_C** ResultActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GetRightHandMeleeWeaponActor");

	Params::GA_TGF_Base_C_GetRightHandMeleeWeaponActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ResultActor != nullptr)
		*ResultActor = Parms.ResultActor;
}


// Function GA_TGF_Base.GA_TGF_Base_C.GetSourceTags
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            InstigatorTags                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FGameplayTagContainer            Tags                                                   (Parm, OutParm)

void UGA_TGF_Base_C::GetSourceTags(const struct FGameplayTagContainer& InstigatorTags, struct FGameplayTagContainer* Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "GetSourceTags");

	Params::GA_TGF_Base_C_GetSourceTags Parms{};

	Parms.InstigatorTags = std::move(InstigatorTags);

	UObject::ProcessEvent(Func, &Parms);

	if (Tags != nullptr)
		*Tags = std::move(Parms.Tags);
}


// Function GA_TGF_Base.GA_TGF_Base_C.InitParams
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::InitParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "InitParams");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.InitShieldConfig
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::InitShieldConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "InitShieldConfig");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.InitWeaponMesh
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::InitWeaponMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "InitWeaponMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.InterruptAbility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               InterruptData                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void UGA_TGF_Base_C::InterruptAbility(const struct FGameplayEventData& InterruptData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "InterruptAbility");

	Params::GA_TGF_Base_C_InterruptAbility Parms{};

	Parms.InterruptData = std::move(InterruptData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.NotifyRebound
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::NotifyRebound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "NotifyRebound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ProcessNormalIgnoreStaticCollision
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_TGF_Normal_ProjectileBase_C*   SpawnedProjectile                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTrans                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::ProcessNormalIgnoreStaticCollision(class AB_TGF_Normal_ProjectileBase_C* SpawnedProjectile, const struct FTransform& SpawnTrans, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ProcessNormalIgnoreStaticCollision");

	Params::GA_TGF_Base_C_ProcessNormalIgnoreStaticCollision Parms{};

	Parms.SpawnedProjectile = SpawnedProjectile;
	Parms.SpawnTrans = std::move(SpawnTrans);
	Parms.Instigator = Instigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ProcessTrackIgnoreStaticCollistion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_TGF_Track_ProjectileBase_C*    SpawnedProjectile                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTrans                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TrackActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::ProcessTrackIgnoreStaticCollistion(class AB_TGF_Track_ProjectileBase_C* SpawnedProjectile, const struct FTransform& SpawnTrans, class AActor* Instigator, class AActor* TrackActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ProcessTrackIgnoreStaticCollistion");

	Params::GA_TGF_Base_C_ProcessTrackIgnoreStaticCollistion Parms{};

	Parms.SpawnedProjectile = SpawnedProjectile;
	Parms.SpawnTrans = std::move(SpawnTrans);
	Parms.Instigator = Instigator;
	Parms.TrackActor = TrackActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.RefreshActorHitInfo
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::RefreshActorHitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "RefreshActorHitInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.RemoveMoveSpeedDebuff
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::RemoveMoveSpeedDebuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "RemoveMoveSpeedDebuff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetAbilityHurtType
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetAbilityHurtType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetAbilityHurtType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetAttrBoostTags
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetAttrBoostTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetAttrBoostTags");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetCanWalkOffLedges
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetCanWalkOffLedges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetCanWalkOffLedges");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetCritical
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetCritical()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetCritical");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetGEAttributeTag
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetGEAttributeTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetGEAttributeTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetGuarded
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetGuarded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetGuarded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetHitPartTag
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetHitPartTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetHitPartTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetInterrupt
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetInterrupt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetInterrupt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetNormalProjectile
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Projectile                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::ResetNormalProjectile(class AActor* Projectile, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetNormalProjectile");

	Params::GA_TGF_Base_C_ResetNormalProjectile Parms{};

	Parms.Projectile = Projectile;
	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetPerfectGuarded
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetPerfectGuarded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetPerfectGuarded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetTeamTag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetTeamTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetTeamTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetTrackProjectile
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Projectile                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TrackTarget                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             TrackSocketName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetPos                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::ResetTrackProjectile(class AActor* Projectile, const struct FTransform& Transform, class AActor* TrackTarget, class FName TrackSocketName, const struct FVector& TargetPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetTrackProjectile");

	Params::GA_TGF_Base_C_ResetTrackProjectile Parms{};

	Parms.Projectile = Projectile;
	Parms.Transform = std::move(Transform);
	Parms.TrackTarget = TrackTarget;
	Parms.TrackSocketName = TrackSocketName;
	Parms.TargetPos = std::move(TargetPos);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.ResetWeaponElement
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_TGF_Base_C::ResetWeaponElement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "ResetWeaponElement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_TGF_Base.GA_TGF_Base_C.SetCanWalkOffLedges
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::SetCanWalkOffLedges(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "SetCanWalkOffLedges");

	Params::GA_TGF_Base_C_SetCanWalkOffLedges Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_TGF_Base.GA_TGF_Base_C.SpawnNormalProjectile
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           SpawnActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESpawnActorCollisionHandlingMethod      CollisionHandling                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Owner                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ETgfUseAttackType                       UseAttackType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETgfEquipSlot                           ConsumeItemSlotType                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ConsumeItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NeedChangeMesh                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCurveFloat*                      DamageRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AB_TGF_Normal_ProjectileBase_C*   Projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::SpawnNormalProjectile(class UClass* SpawnActor, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandling, class AActor* Owner, class APawn* Instigator, ETgfUseAttackType UseAttackType, ETgfEquipSlot ConsumeItemSlotType, bool ConsumeItem, bool NeedChangeMesh, class UCurveFloat* DamageRate, class AB_TGF_Normal_ProjectileBase_C** Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "SpawnNormalProjectile");

	Params::GA_TGF_Base_C_SpawnNormalProjectile Parms{};

	Parms.SpawnActor = SpawnActor;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandling = CollisionHandling;
	Parms.Owner = Owner;
	Parms.Instigator = Instigator;
	Parms.UseAttackType = UseAttackType;
	Parms.ConsumeItemSlotType = ConsumeItemSlotType;
	Parms.ConsumeItem = ConsumeItem;
	Parms.NeedChangeMesh = NeedChangeMesh;
	Parms.DamageRate = DamageRate;

	UObject::ProcessEvent(Func, &Parms);

	if (Projectile != nullptr)
		*Projectile = Parms.Projectile;
}


// Function GA_TGF_Base.GA_TGF_Base_C.SpawnStaticOverlapProjectile
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           SpawnActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESpawnActorCollisionHandlingMethod      CollisionHandling                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Owner                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ETgfUseAttackType                       UseAttackType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETgfEquipSlot                           ConsumeItemSlotType                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ConsumeItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCurveFloat*                      DamageRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AB_TGF_Static_OverlapCheck_ProjectileBase_C*Projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::SpawnStaticOverlapProjectile(class UClass* SpawnActor, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandling, class AActor* Owner, class APawn* Instigator, ETgfUseAttackType UseAttackType, ETgfEquipSlot ConsumeItemSlotType, bool ConsumeItem, class UCurveFloat* DamageRate, class AB_TGF_Static_OverlapCheck_ProjectileBase_C** Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "SpawnStaticOverlapProjectile");

	Params::GA_TGF_Base_C_SpawnStaticOverlapProjectile Parms{};

	Parms.SpawnActor = SpawnActor;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandling = CollisionHandling;
	Parms.Owner = Owner;
	Parms.Instigator = Instigator;
	Parms.UseAttackType = UseAttackType;
	Parms.ConsumeItemSlotType = ConsumeItemSlotType;
	Parms.ConsumeItem = ConsumeItem;
	Parms.DamageRate = DamageRate;

	UObject::ProcessEvent(Func, &Parms);

	if (Projectile != nullptr)
		*Projectile = Parms.Projectile;
}


// Function GA_TGF_Base.GA_TGF_Base_C.SpawnTrackProjectile
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           SpawnActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESpawnActorCollisionHandlingMethod      CollisionHandling                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Owner                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ETgfUseAttackType                       UseAttackType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETgfEquipSlot                           ConsumeItemSlotType                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TrackTarget                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ConsumeItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NeedChangeMesh                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCurveFloat*                      DamageRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             TrackSocketName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AB_TGF_Track_ProjectileBase_C*    Projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_TGF_Base_C::SpawnTrackProjectile(class UClass* SpawnActor, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandling, class AActor* Owner, class APawn* Instigator, ETgfUseAttackType UseAttackType, ETgfEquipSlot ConsumeItemSlotType, class AActor* TrackTarget, bool ConsumeItem, bool NeedChangeMesh, class UCurveFloat* DamageRate, class FName TrackSocketName, class AB_TGF_Track_ProjectileBase_C** Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_TGF_Base_C", "SpawnTrackProjectile");

	Params::GA_TGF_Base_C_SpawnTrackProjectile Parms{};

	Parms.SpawnActor = SpawnActor;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandling = CollisionHandling;
	Parms.Owner = Owner;
	Parms.Instigator = Instigator;
	Parms.UseAttackType = UseAttackType;
	Parms.ConsumeItemSlotType = ConsumeItemSlotType;
	Parms.TrackTarget = TrackTarget;
	Parms.ConsumeItem = ConsumeItem;
	Parms.NeedChangeMesh = NeedChangeMesh;
	Parms.DamageRate = DamageRate;
	Parms.TrackSocketName = TrackSocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (Projectile != nullptr)
		*Projectile = Parms.Projectile;
}

}

